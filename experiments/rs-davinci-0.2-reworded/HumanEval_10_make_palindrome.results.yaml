name: HumanEval_10_make_palindrome
language: rs
results:
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix = String::new();\n \
    \   let mut prefix = String::new();\n    let mut i = 0;\n    while i < string.len()\
    \ {\n        suffix.push(string.chars().nth(i).unwrap());\n        prefix.push(string.chars().nth(string.len()\
    \ - i - 1).unwrap());\n        if suffix == prefix {\n            break;\n   \
    \     }\n        i += 1;\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmp06np69yc.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix = String::new();\n \
    \   let mut prefix = String::new();\n    let mut is_palindrome = false;\n    for\
    \ c in string.chars().rev() {\n        suffix.push(c);\n        if is_palindrome(&suffix)\
    \ {\n            is_palindrome = true;\n            break;\n        }\n    }\n\
    \    if is_palindrome {\n        for c in string.chars() {\n            prefix.push(c);\n\
    \            if is_palindrome(&prefix) {\n                break;\n           \
    \ }\n        }\n        result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0618]: expected function, found `bool`\n  --> /tmp/tmpo0_ehf_f.rs:18:12\n\
    \   |\n15 |     let mut is_palindrome = false;\n   |         -----------------\
    \ `is_palindrome` has type `bool`\n...\n18 |         if is_palindrome(&suffix)\
    \ {\n   |            ^^^^^^^^^^^^^---------\n   |            |\n   |         \
    \   call expression requires function\n\nerror[E0618]: expected function, found\
    \ `bool`\n  --> /tmp/tmpo0_ehf_f.rs:26:16\n   |\n15 |     let mut is_palindrome\
    \ = false;\n   |         ----------------- `is_palindrome` has type `bool`\n...\n\
    26 |             if is_palindrome(&prefix) {\n   |                ^^^^^^^^^^^^^---------\n\
    \   |                |\n   |                call expression requires function\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0618`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut prefix = String::new();\n \
    \   let mut suffix = String::new();\n    let mut i = 0;\n    let mut j = string.len()\
    \ - 1;\n    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            prefix.push(string.chars().nth(i).unwrap());\n            suffix.push(string.chars().nth(j).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            break;\n\
    \        }\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp4y7tj8tc.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut i = 0;\n    let mut j = string.len() -\
    \ 1;\n    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            suffix.push(string.chars().nth(i).unwrap());\n            prefix.push(string.chars().nth(j).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            i = 0;\n\
    \            j -= 1;\n            suffix.clear();\n            prefix.clear();\n\
    \        }\n    }\n    string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp9o3lmlfk.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = String::new();\n\
    \    let mut palindrome_prefix = String::new();\n    let mut palindrome_suffix_length\
    \ = 0;\n    let mut palindrome_prefix_length = 0;\n    let mut string_length =\
    \ string.len();\n    let mut string_chars = string.chars();\n    let mut string_chars_rev\
    \ = string.chars().rev();\n    let mut string_chars_rev_clone = string.chars().rev();\n\
    \    let mut string_chars_clone = string.chars();\n    let mut string_chars_clone_rev\
    \ = string.chars().rev();\n    let mut string_chars_clone_rev_clone = string.chars().rev();\n\
    \    let mut string_chars_clone_clone = string.chars();\n    let mut string_chars_clone_clone_rev\
    \ = string.chars().rev();\n    let mut string_chars_clone_clone_rev_clone = string.chars().rev();\n\
    \    let mut string_chars_clone_clone_clone = string.chars();\n    let mut string_chars_clone_clone_clone_rev\
    \ = string.chars().rev();\n    let mut string_chars_clone_clone_clone_rev_clone\
    \ = string.chars().rev();\n    let mut string_chars_clone_clone_clone_clone =\
    \ string.chars();\n    let mut string_chars_clone_clone_clone_clone_rev = string.chars().rev();\n\
    \    let mut string_chars_clone_clone_clone_clone_rev_clone = string.chars().rev();\n\
    \    let mut string_chars_clone_clone_clone_clone_clone = string.chars();\n  \
    \  let mut string_chars_clone_clone_clone_clone_clone_rev = string.chars().rev();\n\
    \    let mut string_chars_clone_clone_clone_clone_clone_rev_clone = string.chars().rev();\n\
    \    let mut string_chars_clone_clone_clone_clone_clone_clone = string.chars();\n\
    \    let mut string_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsffdf3nw.rs:37:20\n   |\n\
    37 |     let mut string_\n   |                    ^ help: add `;` here\n38 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsffdf3nw.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    for i in 0..string.len() {\n        let suffix = string.chars().skip(i).collect::<String>();\n\
    \        if is_palindrome(&suffix) {\n            longest_palindrome_suffix =\
    \ suffix;\n        }\n    }\n    let prefix = string.chars().take(string.len()\
    \ - longest_palindrome_suffix.len()).collect::<String>();\n    string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpwzgsxwlc.rs:16:12\n   |\n16 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    for i in 0..string.len() {\n        let suffix = string.split_off(string.len()\
    \ - i);\n        if is_palindrome(&suffix) {\n            longest_palindrome_suffix\
    \ = suffix;\n            break;\n        }\n    }\n    string.push_str(&longest_palindrome_suffix);\n\
    \    string.push_str(&string[..string.len() - longest_palindrome_suffix.len()].chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpgaa5zqeb.rs:16:12\n   |\n16 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_len = 0;\n    for i in 0..string.len()\
    \ {\n        let suffix = &string[i..];\n        if is_palindrome(suffix) {\n\
    \            if suffix.len() > longest_palindrome_suffix_len {\n             \
    \   longest_palindrome_suffix = suffix.to_string();\n                longest_palindrome_suffix_len\
    \ = suffix.len();\n            }\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix_len];\n    let prefix_reversed = reverse(prefix);\n\
    \    string.push_str(&prefix_reversed);\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp9eqypw0b.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `reverse` in this scope\n  --> /tmp/tmp9eqypw0b.rs:25:27\n   |\n\
    25 |     let prefix_reversed = reverse(prefix);\n   |                        \
    \   ^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    for i in 0..string.len() {\n        let suffix = &string[i..];\n        if\
    \ is_palindrome(suffix) {\n            longest_palindrome_suffix = suffix.to_string();\n\
    \            break;\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix.len()];\n    string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpf72klqib.rs:16:12\n   |\n16 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut prefix = String::new();\n \
    \   let mut suffix = String::new();\n    for (i, c) in string.chars().enumerate()\
    \ {\n        prefix.push(c);\n        suffix.insert(0, c);\n        if prefix\
    \ == suffix {\n            result.push_str(&suffix[i + 1..]);\n            break;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyz\"`,\n right: `\"xyzyx\"`', /tmp/tmpdbzqvkd6.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut prefix = String::new();\n    let mut\
    \ suffix = String::new();\n    let mut i = 0;\n    let mut j = string.len() -\
    \ 1;\n    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            prefix.push(string.chars().nth(i).unwrap());\n            suffix.push(string.chars().nth(j).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            i = 0;\n\
    \            j -= 1;\n            prefix.clear();\n            suffix.clear();\n\
    \        }\n    }\n    string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp9ydieipa.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut prefix = String::new();\n    let mut\
    \ suffix = String::new();\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_len = 0;\n    let mut i = 0;\n    let mut\
    \ j = string.len() - 1;\n    while i < j {\n        if string.chars().nth(i) ==\
    \ string.chars().nth(j) {\n            suffix.push(string.chars().nth(i).unwrap());\n\
    \            prefix.push(string.chars().nth(j).unwrap());\n            i += 1;\n\
    \            j -= 1;\n        } else {\n            if suffix.len() > longest_palindrome_suffix_len\
    \ {\n                longest_palindrome_suffix = suffix.clone();\n           \
    \     longest_palindrome_suffix_len = suffix.len();\n            }\n         \
    \   suffix = String::new();\n            prefix = String::new();\n           \
    \ i = 0;\n            j -= 1;\n        }\n    }\n    if suffix.len() > longest_palindrome_suffix_len\
    \ {\n        longest_palindrome_suffix = suffix.clone();\n        longest_palindrome_suffix_len\
    \ = suffix.len();\n    }\n    string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp4neoq7rl.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut longest_palindrome_suffix_length = 0;\n\
    \    let mut longest_palindrome_suffix_index = 0;\n    let mut current_palindrome_suffix_length\
    \ = 0;\n    let mut current_palindrome_suffix_index = 0;\n    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n\
    \    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n\
    \    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n\
    \    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n\
    \    let mut z = 0;\n    let mut aa = 0;\n    let mut ab = 0;\n    let mut ac\
    \ = 0;\n    let mut ad = 0;\n    let mut ae = 0;\n    let mut af = 0;\n    let\
    \ mut ag = 0;\n    let mut ah = 0;\n    let mut ai = 0;\n    let mut aj = 0;\n\
    \    let mut ak = 0;\n    let mut al = 0;\n    let mut am = 0;\n    let mut an\
    \ = 0;\n    let mut ao = 0;\n    let mut ap = 0;\n    let mut aq = 0;\n    let\
    \ mut ar = 0;\n    let mut as_ = 0;\n    let mut at = 0;\n    let mut au = 0;\n\
    \    let mut av = 0;\n    let mut aw = 0;\n    let mut ax = 0;\n    let mut ay\
    \ = 0;\n    let mut az = 0;\n    let mut ba = 0;\n    let mut bb = 0;\n    let\
    \ mut bc = 0;\n    let mut bd = 0;\n    let mut be = 0;\n    let mut bf = 0;\n\
    \    let mut bg\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxphn0b35.rs:69:15\n   |\n\
    69 |     let mut bg\n   |               ^ help: add `;` here\n70 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxphn0b35.rs:11:39\n \
    \  |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = String::new();\n\
    \    let mut palindrome_prefix = String::new();\n    let mut palindrome_suffix_length\
    \ = 0;\n    let mut palindrome_prefix_length = 0;\n    let mut palindrome_length\
    \ = 0;\n    let mut palindrome_start = 0;\n    let mut palindrome_end = 0;\n \
    \   let mut i = 0;\n    let mut j = string.len() - 1;\n    let mut k = 0;\n  \
    \  let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n\
    \    let mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n\
    \    let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n\
    \    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n    let mut aa =\
    \ 0;\n    let mut ab = 0;\n    let mut ac = 0;\n    let mut ad = 0;\n    let mut\
    \ ae = 0;\n    let mut af = 0;\n    let mut ag = 0;\n    let mut ah = 0;\n   \
    \ let mut ai = 0;\n    let mut aj = 0;\n    let mut ak = 0;\n    let mut al =\
    \ 0;\n    let mut am = 0;\n    let mut an = 0;\n    let mut ao = 0;\n    let mut\
    \ ap = 0;\n    let mut aq = 0;\n    let mut ar = 0;\n    let mut as_ = 0;\n  \
    \  let mut at = 0;\n    let mut au = 0;\n    let mut av = 0;\n    let mut aw =\
    \ 0;\n    let mut ax = 0;\n    let mut ay = 0;\n    let mut az = 0;\n    let mut\
    \ ba = 0;\n    let mut bb = 0;\n    let mut bc = 0;\n    let mut bd = 0;\n   \
    \ let mut be = 0;\n    let mut\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp2b3yar_p.rs:70:1\n\
    \   |\n70 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_length = 0;\n    let mut longest_palindrome_suffix_index\
    \ = 0;\n    for i in 0..string.len() {\n        let suffix = &string[i..];\n \
    \       let suffix_length = suffix.len();\n        if suffix_length > longest_palindrome_suffix_length\
    \ && is_palindrome(suffix) {\n            longest_palindrome_suffix = suffix.to_string();\n\
    \            longest_palindrome_suffix_length = suffix_length;\n            longest_palindrome_suffix_index\
    \ = i;\n        }\n    }\n    if longest_palindrome_suffix_length > 0 {\n    \
    \    let prefix = &string[..longest_palindrome_suffix_index];\n        let reverse_prefix\
    \ = reverse(prefix);\n        string.push_str(&reverse_prefix);\n    }\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp6zkg1xj0.rs:19:64\n   |\n19 |         if suffix_length > longest_palindrome_suffix_length\
    \ && is_palindrome(suffix) {\n   |                                           \
    \                     ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `reverse` in this scope\n  --> /tmp/tmp6zkg1xj0.rs:27:30\n   |\n\
    27 |         let reverse_prefix = reverse(prefix);\n   |                     \
    \         ^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut prefix = String::new();\n \
    \   let mut suffix = String::new();\n    let mut i = 0;\n    let mut j = string.len()\
    \ - 1;\n    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            prefix.push(string.chars().nth(i).unwrap());\n            suffix.push(string.chars().nth(j).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            break;\n\
    \        }\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpqc0smibt.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix = string.clone();\n\
    \    let mut prefix = String::new();\n    while !is_palindrome(&suffix) {\n  \
    \      prefix.push(suffix.pop().unwrap());\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpndqb04lq.rs:15:12\n   |\n15 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut reversed = string.chars().rev().collect::<String>();\n\
    \    let mut suffix_len = 0;\n    for i in 0..string.len() {\n        if string[i..]\
    \ == reversed[..string.len() - i] {\n            suffix_len = string.len() - i;\n\
    \            break;\n        }\n    }\n    result.push_str(&reversed[..string.len()\
    \ - suffix_len]);\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyzzy\"`,\n right: `\"xyzyx\"`', /tmp/tmpy4vg3i0k.rs:29:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_length = 0;\n    for i in 0..string.len()\
    \ {\n        let suffix = &string[i..];\n        if is_palindrome(suffix) {\n\
    \            if suffix.len() > longest_palindrome_suffix_length {\n          \
    \      longest_palindrome_suffix = suffix.to_string();\n                longest_palindrome_suffix_length\
    \ = suffix.len();\n            }\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix_length];\n    string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpmxjmzj1l.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut prefix = String::new();\n \
    \   let mut suffix = String::new();\n    let mut longest_palindrome_length = 0;\n\
    \    let mut longest_palindrome_index = 0;\n    for i in 0..string.len() {\n \
    \       let (prefix_len, suffix_len) = (i, string.len() - i - 1);\n        let\
    \ (prefix_slice, suffix_slice) = (\n            &string[0..prefix_len],\n    \
    \        &string[suffix_len..string.len()],\n        );\n        if prefix_slice\
    \ == suffix_slice {\n            if prefix_len > longest_palindrome_length {\n\
    \                longest_palindrome_length = prefix_len;\n                longest_palindrome_index\
    \ = i;\n            }\n        }\n    }\n    let (prefix_len, suffix_len) = (longest_palindrome_index,\
    \ string.len() - longest_palindrome_index);\n    let (prefix_slice, suffix_slice)\
    \ = (\n        &string[0..prefix_len],\n        &string[suffix_len..string.len()],\n\
    \    );\n    prefix.push_str(prefix_slice);\n    suffix.push_str(suffix_slice);\n\
    \    result.push_str(&suffix.chars().rev().collect::<String>());\n    result\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyz\"`,\n right: `\"xyzyx\"`', /tmp/tmp9kv0gj78.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix = String::new();\n \
    \   let mut prefix = String::new();\n    let mut longest_palindrome_length = 0;\n\
    \    for i in 0..string.len() {\n        let (mut suffix_length, mut prefix_length)\
    \ = (0, 0);\n        for j in 0..i + 1 {\n            if string.chars().nth(i\
    \ - j) == string.chars().nth(i + j) {\n                suffix_length += 1;\n \
    \           } else {\n                break;\n            }\n        }\n     \
    \   for j in 0..i + 1 {\n            if string.chars().nth(i - j) == string.chars().nth(i\
    \ + j + 1) {\n                prefix_length += 1;\n            } else {\n    \
    \            break;\n            }\n        }\n        if suffix_length > longest_palindrome_length\
    \ {\n            longest_palindrome_length = suffix_length;\n            suffix\
    \ = string[i - suffix_length + 1..i + 1].to_string();\n        }\n        if prefix_length\
    \ > longest_palindrome_length {\n            longest_palindrome_length = prefix_length;\n\
    \            prefix = string[i - prefix_length + 1..i + 1].to_string();\n    \
    \    }\n    }\n    if longest_palindrome_length > 0 {\n        result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpleg5an2t.rs:34:29\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    for (i, c) in string.chars().enumerate() {\n  \
    \      suffix.push(c);\n        if is_palindrome(&suffix) {\n            prefix\
    \ = string.chars().take(i + 1).collect();\n        }\n    }\n    string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpsxbky8is.rs:17:12\n   |\n17 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    for i in 0..string.len() {\n        let suffix = &string[i..];\n        if\
    \ is_palindrome(suffix) {\n            longest_palindrome_suffix = suffix.to_string();\n\
    \            break;\n        }\n    }\n    string.push_str(&string[..string.len()\
    \ - longest_palindrome_suffix.len()].chars().rev().collect::<String>());\n   \
    \ string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpi3m_6961.rs:16:12\n   |\n16 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut i = 0;\n    let mut j = string.len()\
    \ - 1;\n    while i < j {\n        if string.chars().nth(i) != string.chars().nth(j)\
    \ {\n            break;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    let mut prefix = String::new();\n    for k in (0..i).rev() {\n        prefix.push(string.chars().nth(k).unwrap());\n\
    \    }\n    string.push_str(&prefix);\n    string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpu1qace0d.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string.clone();\n\
    \    reversed_string.reverse();\n    let mut suffix = String::new();\n    let\
    \ mut prefix = String::new();\n    let mut i = 0;\n    while i < string.len()\
    \ {\n        if string[i..] == reversed_string[..string.len() - i] {\n       \
    \     suffix = string[i..].to_string();\n            prefix = string[..i].to_string();\n\
    \            break;\n        }\n        i += 1;\n    }\n    prefix.reverse();\n\
    \    string.push_str(&prefix);\n    string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpreqe8lkh.rs:14:21\n   |\n14 |     reversed_string.reverse();\n\
    \   |                     ^^^^^^^ help: there is an associated function with a\
    \ similar name: `reserve`\n\nerror[E0599]: no method named `reverse` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpreqe8lkh.rs:26:12\n   |\n\
    26 |     prefix.reverse();\n   |            ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reserve`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut longest_palindrome_len = 0;\n    let mut\
    \ longest_palindrome_start = 0;\n    let mut longest_palindrome_end = 0;\n   \
    \ let mut longest_palindrome_start_index = 0;\n    let mut longest_palindrome_end_index\
    \ = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut\
    \ l = 0;\n    let mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n    let\
    \ mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n   \
    \ let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n\
    \    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n    let mut a = 0;\n\
    \    let mut b = 0;\n    let mut c = 0;\n    let mut d = 0;\n    let mut e = 0;\n\
    \    let mut f = 0;\n    let mut g = 0;\n    let mut h = 0;\n    let mut ii =\
    \ 0;\n    let mut jj = 0;\n    let mut kk = 0;\n    let mut ll = 0;\n    let mut\
    \ mm = 0;\n    let mut nn = 0;\n    let mut oo = 0;\n    let mut pp = 0;\n   \
    \ let mut qq = 0;\n    let mut rr = 0;\n    let mut ss = 0;\n    let mut tt =\
    \ 0;\n    let mut uu = 0;\n    let mut vv = 0;\n    let mut ww = 0;\n    let mut\
    \ xx = 0;\n    let mut yy = 0;\n    let mut zz = 0;\n    let mut aa = 0;\n   \
    \ let mut bb = 0;\n    let mut cc = 0;\n    let mut dd = 0;\n    let mut ee =\
    \ 0;\n    let\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpy4rc64yh.rs:70:1\n  \
    \ |\n70 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_length = 0;\n    let mut longest_palindrome_suffix_index\
    \ = 0;\n    let mut i = 0;\n    while i < string.len() {\n        let mut j =\
    \ 0;\n        while j < string.len() - i {\n            if string.chars().nth(i\
    \ + j) != string.chars().nth(string.len() - 1 - j) {\n                break;\n\
    \            }\n            j += 1;\n        }\n        if j > longest_palindrome_suffix_length\
    \ {\n            longest_palindrome_suffix_length = j;\n            longest_palindrome_suffix_index\
    \ = i;\n        }\n        i += 1;\n    }\n    if longest_palindrome_suffix_length\
    \ > 0 {\n        longest_palindrome_suffix = string.chars().skip(longest_palindrome_suffix_index).take(longest_palindrome_suffix_length).collect();\n\
    \        string.push_str(&longest_palindrome_suffix.chars().rev().collect::<String>());\n\
    \    }\n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmp32bpmgxz.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut palindrome = String::new();\n    let mut\
    \ longest_palindrome = String::new();\n    let mut longest_palindrome_length =\
    \ 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut\
    \ l = 0;\n    let mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n    let\
    \ mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n   \
    \ let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n\
    \    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n    let mut aa =\
    \ 0;\n    let mut ab = 0;\n    let mut ac = 0;\n    let mut ad = 0;\n    let mut\
    \ ae = 0;\n    let mut af = 0;\n    let mut ag = 0;\n    let mut ah = 0;\n   \
    \ let mut ai = 0;\n    let mut aj = 0;\n    let mut ak = 0;\n    let mut al =\
    \ 0;\n    let mut am = 0;\n    let mut an = 0;\n    let mut ao = 0;\n    let mut\
    \ ap = 0;\n    let mut aq = 0;\n    let mut ar = 0;\n    let mut as_ = 0;\n  \
    \  let mut at = 0;\n    let mut au = 0;\n    let mut av = 0;\n    let mut aw =\
    \ 0;\n    let mut ax = 0;\n    let mut ay = 0;\n    let mut az = 0;\n    let mut\
    \ ba = 0;\n    let mut bb = 0;\n    let mut bc = 0;\n    let mut bd = 0;\n   \
    \ let mut be = 0;\n    let mut bf = 0;\n    let mut bg = 0;\n    let mut bh =\
    \ 0;\n    let mut bi = 0;\n    let mut bj = 0\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpcnqr268c.rs:71:19\n   |\n\
    71 |     let mut bj = 0\n   |                   ^ help: add `;` here\n72 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcnqr268c.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut longest_palindrome_length = 0;\n    let\
    \ mut longest_palindrome_index = 0;\n    for i in 0..string.len() {\n        let\
    \ (mut j, mut k) = (i, i);\n        while j >= 0 && k < string.len() && string.chars().nth(j)\
    \ == string.chars().nth(k) {\n            j -= 1;\n            k += 1;\n     \
    \   }\n        if k - j - 1 > longest_palindrome_length {\n            longest_palindrome_length\
    \ = k - j - 1;\n            longest_palindrome_index = j + 1;\n        }\n   \
    \     j = i;\n        k = i + 1;\n        while j >= 0 && k < string.len() &&\
    \ string.chars().nth(j) == string.chars().nth(k) {\n            j -= 1;\n    \
    \        k += 1;\n        }\n        if k - j - 1 > longest_palindrome_length\
    \ {\n            longest_palindrome_length = k - j - 1;\n            longest_palindrome_index\
    \ = j + 1;\n        }\n    }\n    suffix = string.chars().skip(longest_palindrome_index).take(longest_palindrome_length).collect();\n\
    \    prefix = string.chars().take(longest_palindrome_index).collect();\n    string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpyb426zmq.rs:20:13\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix = String::new();\n \
    \   let mut prefix = String::new();\n    let mut i = 0;\n    let mut j = string.len()\
    \ - 1;\n    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            suffix.push(string.chars().nth(i).unwrap());\n            prefix.push(string.chars().nth(j).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            i = 0;\n\
    \            j -= 1;\n            suffix.clear();\n            prefix.clear();\n\
    \        }\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpv369pihc.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = 0;\n  \
    \  for i in 0..string.len() {\n        if is_palindrome(&string[i..]) {\n    \
    \        longest_palindrome_suffix = i;\n            break;\n        }\n    }\n\
    \    let prefix = &string[..string.len() - longest_palindrome_suffix];\n    string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp02a3ox5r.rs:15:12\n   |\n15 |         if is_palindrome(&string[i..])\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut prefix = String::new();\n    let mut\
    \ suffix = String::new();\n    let mut suffix_len = 0;\n    let mut prefix_len\
    \ = 0;\n    let mut max_len = 0;\n    let mut max_len_idx = 0;\n    let mut max_len_idx_rev\
    \ = 0;\n    let mut max_len_rev = 0;\n    let mut max_len_idx_rev_rev = 0;\n \
    \   let mut max_len_rev_rev = 0;\n    let mut max_len_rev_rev_idx = 0;\n    let\
    \ mut max_len_rev_rev_idx_rev = 0;\n    let mut max_len_rev_rev_rev = 0;\n   \
    \ let mut max_len_rev_rev_rev_idx = 0;\n    let mut max_len_rev_rev_rev_idx_rev\
    \ = 0;\n    let mut max_len_rev_rev_rev_rev = 0;\n    let mut max_len_rev_rev_rev_rev_idx\
    \ = 0;\n    let mut max_len_rev_rev_rev_rev_idx_rev = 0;\n    let mut max_len_rev_rev_rev_rev_rev\
    \ = 0;\n    let mut max_len_rev_rev_rev_rev_rev_idx = 0;\n    let mut max_len_rev_rev_rev_rev_rev_idx_rev\
    \ = 0;\n    let mut max_len_rev_rev_rev_rev_rev_rev = 0;\n    let mut max_len_rev_rev_rev_rev_rev_rev_idx\
    \ = 0;\n    let mut max_len_rev_rev_rev_rev_rev_rev_idx_rev = 0;\n    let mut\
    \ max_len_rev_rev_rev_rev_rev_rev_rev = 0;\n    let mut max_len_rev_rev_rev_rev_rev_rev_rev_idx\
    \ = 0;\n    let mut max_len_rev_rev_rev_rev_rev_rev_rev_idx_rev = 0;\n    let\
    \ mut max_len\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpi21rgf7k.rs:40:20\n   |\n\
    40 |     let mut max_len\n   |                    ^ help: add `;` here\n41 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi21rgf7k.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut i = 0;\n    let mut j = string.len() -\
    \ 1;\n    let mut is_palindrome = false;\n    while i < j {\n        if string.chars().nth(i)\
    \ == string.chars().nth(j) {\n            i += 1;\n            j -= 1;\n     \
    \       is_palindrome = true;\n        } else {\n            if is_palindrome\
    \ {\n                suffix.push(string.chars().nth(i).unwrap());\n          \
    \      prefix.push(string.chars().nth(j).unwrap());\n                i += 1;\n\
    \                j -= 1;\n            } else {\n                suffix.push(string.chars().nth(i).unwrap());\n\
    \                prefix.push(string.chars().nth(j).unwrap());\n              \
    \  i += 1;\n                j -= 1;\n            }\n        }\n    }\n    if is_palindrome\
    \ {\n        string.push_str(&suffix);\n        string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    } else {\n        string.push_str(&suffix);\n        string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    }\n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp1f0qw6ec.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut longest_palindrome_length = 0;\n    let\
    \ mut longest_palindrome_index = 0;\n    for i in 0..string.len() {\n        let\
    \ (palindrome_length, palindrome_index) = find_longest_palindrome_suffix(&string,\
    \ i);\n        if palindrome_length > longest_palindrome_length {\n          \
    \  longest_palindrome_length = palindrome_length;\n            longest_palindrome_index\
    \ = palindrome_index;\n        }\n    }\n    suffix = string.chars().skip(longest_palindrome_index).take(longest_palindrome_length).collect();\n\
    \    prefix = string.chars().take(longest_palindrome_index).collect();\n    string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_longest_palindrome_suffix` in\
    \ this scope\n  --> /tmp/tmpmr5cegil.rs:18:53\n   |\n18 |         let (palindrome_length,\
    \ palindrome_index) = find_longest_palindrome_suffix(&string, i);\n   |      \
    \                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `longest_palindrome_index`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    for i in 0..string.len() {\n        let suffix = string.get(i..).unwrap();\n\
    \        if is_palindrome(suffix) {\n            longest_palindrome_suffix = suffix.to_string();\n\
    \            break;\n        }\n    }\n    let prefix = string.get(0..string.len()\
    \ - longest_palindrome_suffix.len()).unwrap();\n    string.push_str(&reverse(prefix));\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpsfrbcke2.rs:16:12\n   |\n16 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `reverse` in this scope\n  --> /tmp/tmpsfrbcke2.rs:22:22\n   |\n\
    22 |     string.push_str(&reverse(prefix));\n   |                      ^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string.clone();\n    let mut prefix = String::new();\n\
    \    let mut suffix = String::new();\n    let mut is_palindrome = false;\n   \
    \ let mut i = 0;\n    while !is_palindrome {\n        prefix.push(string.chars().nth(i).unwrap());\n\
    \        suffix.push(string.chars().nth(string.len() - i - 1).unwrap());\n   \
    \     if prefix == suffix {\n            is_palindrome = true;\n        }\n  \
    \      i += 1;\n    }\n    palindrome.push_str(&prefix);\n    palindrome\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpxysnbrne.rs:18:43\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut longest_palindrome_length = 0;\n    let\
    \ mut longest_palindrome_start = 0;\n    let mut longest_palindrome_end = 0;\n\
    \    let mut current_palindrome_length = 0;\n    let mut current_palindrome_start\
    \ = 0;\n    let mut current_palindrome_end = 0;\n    let mut string_length = string.len();\n\
    \    let mut string_chars = string.chars();\n    let mut string_chars_rev = string.chars().rev();\n\
    \    let mut string_chars_rev_peekable = string.chars().rev().peekable();\n  \
    \  let mut string_chars_peekable = string.chars().peekable();\n    let mut string_chars_peekable_rev\
    \ = string.chars().rev().peekable();\n    let mut string_chars_peekable_rev_peekable\
    \ = string.chars().rev().peekable();\n    let mut string_chars_peekable_rev_peekable_rev\
    \ = string.chars().rev().peekable();\n    let mut string_chars_peekable_rev_peekable_rev_peekable\
    \ = string.chars().rev().peekable();\n    let mut string_chars_peekable_rev_peekable_rev_peekable_rev\
    \ = string.chars().rev().peekable();\n    let mut string_chars_peekable_rev_peekable_rev_peekable_rev_peekable\
    \ = string.chars().rev().peekable();\n    let mut string_chars_peekable_rev_peekable_rev_peekable_rev_peekable_rev\
    \ = string.chars().rev().peekable();\n    let mut string_chars_peekable_rev_peekable_rev_peekable_rev_peekable_rev_peekable\
    \ = string.chars().rev().peekable();\n    let mut string_chars_peekable\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4zwgh3ib.rs:34:34\n   |\n\
    34 |     let mut string_chars_peekable\n   |                                 \
    \ ^ help: add `;` here\n35 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4zwgh3ib.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_len = 0;\n    let mut longest_palindrome_suffix_index\
    \ = 0;\n    let mut longest_palindrome_suffix_index_end = 0;\n    let mut longest_palindrome_suffix_index_start\
    \ = 0;\n    let mut longest_palindrome_suffix_index_start_end = 0;\n    let mut\
    \ longest_palindrome_suffix_index_start_start = 0;\n    let mut longest_palindrome_suffix_index_start_start_end\
    \ = 0;\n    let mut longest_palindrome_suffix_index_start_start_start = 0;\n \
    \   let mut longest_palindrome_suffix_index_start_start_start_end = 0;\n    let\
    \ mut longest_palindrome_suffix_index_start_start_start_start = 0;\n    let mut\
    \ longest_palindrome_suffix_index_start_start_start_start_end = 0;\n    let mut\
    \ longest_palindrome_suffix_index_start_start_start_start_start = 0;\n    let\
    \ mut longest_palindrome_suffix_index_start_start_start_start_start_end = 0;\n\
    \    let mut longest_palindrome_suffix_index_start_start_start_start_start_start\
    \ = 0;\n    let mut longest_palindrome_suffix_index_start_start_start_start_start_start_end\
    \ = 0;\n    let mut longest_palindrome_suffix_index_start_start_start_start_start_start_start\
    \ = 0;\n    let mut longest_palindrome_suffix_index_start_start_start_start_start_start_start_end\
    \ = 0;\n    let mut longest_palindrome_suffix_index_start_start_start_start_start_start_start_start\
    \ = 0;\n    let mut longest_palindrome_suffix_index_start_start_start_start_start_start_start_start_end\
    \ = 0;\n   \n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6kg0p7xa.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = String::new();\n\
    \    let mut palindrome_prefix = String::new();\n    let mut longest_palindrome_suffix_length\
    \ = 0;\n    for i in 0..string.len() {\n        let suffix = &string[i..];\n \
    \       let prefix = &string[..string.len() - i];\n        if is_palindrome(suffix)\
    \ && suffix.len() > longest_palindrome_suffix_length {\n            palindrome_suffix\
    \ = suffix.to_string();\n            palindrome_prefix = prefix.to_string();\n\
    \            longest_palindrome_suffix_length = suffix.len();\n        }\n   \
    \ }\n    let mut palindrome = String::new();\n    palindrome.push_str(&palindrome_prefix);\n\
    \    palindrome.push_str(&palindrome_suffix);\n    palindrome.push_str(&palindrome_prefix.chars().rev().collect::<String>());\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp2672litu.rs:19:12\n   |\n19 |         if is_palindrome(suffix) && suffix.len()\
    \ > longest_palindrome_suffix_length {\n   |            ^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut prefix = String::new();\n    let mut\
    \ suffix = String::new();\n    let mut i = 0;\n    let mut j = string.len() -\
    \ 1;\n    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            prefix.push(string.chars().nth(i).unwrap());\n            suffix.push(string.chars().nth(j).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            i = 0;\n\
    \            j -= 1;\n            prefix.clear();\n            suffix.clear();\n\
    \        }\n    }\n    string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpt0rzahd2.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    for i in 0..string.len() {\n        let suffix = &string[i..];\n        if\
    \ is_palindrome(suffix) {\n            longest_palindrome_suffix = suffix.to_string();\n\
    \            break;\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix.len()];\n    string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpnno5blbf.rs:16:12\n   |\n16 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut prefix = String::new();\n \
    \   let mut suffix = String::new();\n    let mut i = 0;\n    while i < string.len()\
    \ {\n        if is_palindrome(&string[i..]) {\n            suffix = string[i..].to_string();\n\
    \            break;\n        }\n        i += 1;\n    }\n    prefix = string[..string.len()\
    \ - suffix.len()].to_string();\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmptlu4e57l.rs:17:12\n   |\n17 |         if is_palindrome(&string[i..])\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = String::new();\n\
    \    let mut palindrome_prefix = String::new();\n    let mut palindrome_suffix_length\
    \ = 0;\n    let mut palindrome_prefix_length = 0;\n    let mut i = 0;\n    let\
    \ mut j = string.len() - 1;\n    while i < j {\n        if string.chars().nth(i)\
    \ == string.chars().nth(j) {\n            palindrome_suffix.push(string.chars().nth(i).unwrap());\n\
    \            palindrome_prefix.push(string.chars().nth(j).unwrap());\n       \
    \     palindrome_suffix_length += 1;\n            palindrome_prefix_length +=\
    \ 1;\n            i += 1;\n            j -= 1;\n        } else {\n           \
    \ palindrome_suffix.clear();\n            palindrome_prefix.clear();\n       \
    \     palindrome_suffix_length = 0;\n            palindrome_prefix_length = 0;\n\
    \            i = 0;\n            j -= 1;\n        }\n    }\n    string.push_str(&palindrome_prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpd45r2ie5.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_length = 0;\n    let mut longest_palindrome_suffix_index\
    \ = 0;\n    let mut string_length = string.len();\n    for i in 0..string_length\
    \ {\n        let mut palindrome_suffix = String::new();\n        let mut palindrome_suffix_length\
    \ = 0;\n        let mut j = i;\n        while j < string_length {\n          \
    \  palindrome_suffix.push(string.chars().nth(j).unwrap());\n            if is_palindrome(&palindrome_suffix)\
    \ {\n                palindrome_suffix_length = palindrome_suffix.len();\n   \
    \             if palindrome_suffix_length > longest_palindrome_suffix_length {\n\
    \                    longest_palindrome_suffix = palindrome_suffix.clone();\n\
    \                    longest_palindrome_suffix_length = palindrome_suffix_length;\n\
    \                    longest_palindrome_suffix_index = j;\n                }\n\
    \            }\n            j += 1;\n        }\n    }\n    let mut string_prefix\
    \ = String::new();\n    for i in 0..longest_palindrome_suffix_index {\n      \
    \  string_prefix.push(string.chars().nth(i).unwrap());\n    }\n    string.push_str(&string_prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmplm39o5y2.rs:23:16\n   |\n23 |             if is_palindrome(&palindrome_suffix)\
    \ {\n   |                ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = String::new();\n\
    \    for i in (0..string.len()).rev() {\n        if is_palindrome(&string[i..])\
    \ {\n            palindrome_suffix = string[i..].to_string();\n            break;\n\
    \        }\n    }\n    string.push_str(&reverse(&string[..string.len() - palindrome_suffix.len()]));\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpjr9d5gr4.rs:15:12\n   |\n15 |         if is_palindrome(&string[i..])\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `reverse` in this scope\n  --> /tmp/tmpjr9d5gr4.rs:20:22\n   |\n\
    20 |     string.push_str(&reverse(&string[..string.len() - palindrome_suffix.len()]));\n\
    \   |                      ^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string.clone();\n    let mut prefix = String::new();\n\
    \    let mut suffix = String::new();\n    let mut suffix_len = 0;\n    let mut\
    \ prefix_len = 0;\n    let mut i = 0;\n    let mut j = string.len() - 1;\n   \
    \ while i < j {\n        if string.chars().nth(i) == string.chars().nth(j) {\n\
    \            suffix.push(string.chars().nth(i).unwrap());\n            suffix_len\
    \ += 1;\n            prefix.push(string.chars().nth(j).unwrap());\n          \
    \  prefix_len += 1;\n            i += 1;\n            j -= 1;\n        } else\
    \ {\n            suffix.clear();\n            suffix_len = 0;\n            prefix.clear();\n\
    \            prefix_len = 0;\n            i = 0;\n            j -= 1;\n      \
    \  }\n    }\n    if suffix_len == 0 {\n        palindrome.push(string.chars().nth(0).unwrap());\n\
    \    } else {\n        palindrome.push_str(&prefix);\n    }\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpxtc03mhk.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string.clone();\n\
    \    reversed_string.reverse();\n    let mut suffix = String::new();\n    let\
    \ mut prefix = String::new();\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_prefix = String::new();\n    let mut longest_palindrome_suffix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_length = 0;\n    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n\
    \    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n\
    \    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n\
    \    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n\
    \    let mut z = 0;\n    let mut aa = 0;\n    let mut ab = 0;\n    let mut ac\
    \ = 0;\n    let mut ad = 0;\n    let mut ae = 0;\n    let mut af = 0;\n    let\
    \ mut ag = 0;\n    let mut ah = 0;\n    let mut ai = 0;\n    let mut aj = 0;\n\
    \    let mut ak = 0;\n    let mut al = 0;\n    let mut am = 0;\n    let mut an\
    \ = 0;\n    let mut ao = 0;\n    let mut ap = 0;\n    let mut aq = 0;\n    let\
    \ mut ar = 0;\n    let mut as_ = 0;\n    let mut at = 0;\n    let mut au = 0;\n\
    \    let mut av = 0;\n    let mut aw = 0;\n    let mut ax = 0;\n    let mut ay\
    \ = 0;\n    let mut az = 0;\n    let mut ba = 0;\n    let mut bb = 0;\n    let\
    \ mut bc = 0;\n    let mut bd = 0;\n    let mut be\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvmn9lr8u.rs:69:15\n   |\n\
    69 |     let mut be\n   |               ^ help: add `;` here\n70 | }\n   | - unexpected\
    \ token\n\nerror[E0599]: no method named `reverse` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpvmn9lr8u.rs:14:21\n   |\n14 |     reversed_string.reverse();\n\
    \   |                     ^^^^^^^ help: there is an associated function with a\
    \ similar name: `reserve`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvmn9lr8u.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut prefix = String::new();\n    let mut\
    \ suffix = String::new();\n    let mut suffix_length = 0;\n    let mut prefix_length\
    \ = 0;\n    let mut i = 0;\n    let mut j = string.len() - 1;\n    while i < j\
    \ {\n        if string.chars().nth(i) == string.chars().nth(j) {\n           \
    \ suffix.push(string.chars().nth(i).unwrap());\n            suffix_length += 1;\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            if suffix_length\
    \ > prefix_length {\n                prefix = suffix.clone();\n              \
    \  prefix_length = suffix_length;\n            }\n            suffix = String::new();\n\
    \            suffix_length = 0;\n            i = 0;\n            j -= 1;\n   \
    \     }\n    }\n    if suffix_length > prefix_length {\n        prefix = suffix.clone();\n\
    \        prefix_length = suffix_length;\n    }\n    string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp_brmwjty.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut prefix = String::new();\n \
    \   for c in string.chars().rev() {\n        prefix.push(c);\n        if string.ends_with(&prefix)\
    \ {\n            result.push_str(&prefix);\n            break;\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n   \
    \ assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmpwwmx383h.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix = String::new();\n \
    \   let mut prefix = String::new();\n    let mut longest_palindrome_suffix_len\
    \ = 0;\n    for i in 0..string.len() {\n        let (suffix_len, prefix_len) =\
    \ is_palindrome(&string, i);\n        if suffix_len > longest_palindrome_suffix_len\
    \ {\n            longest_palindrome_suffix_len = suffix_len;\n            suffix\
    \ = string[i..i + suffix_len].to_string();\n            prefix = string[i - prefix_len..i].to_string();\n\
    \        }\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpawp20gah.rs:17:40\n   |\n17 |         let (suffix_len, prefix_len) =\
    \ is_palindrome(&string, i);\n   |                                        ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string.clone();\n    let mut prefix = String::new();\n\
    \    let mut suffix = String::new();\n    let mut reversed_prefix = String::new();\n\
    \    let mut reversed_suffix = String::new();\n    let mut is_palindrome = false;\n\
    \    let mut is_prefix_palindrome = false;\n    let mut is_suffix_palindrome =\
    \ false;\n    let mut is_reversed_prefix_palindrome = false;\n    let mut is_reversed_suffix_palindrome\
    \ = false;\n    let mut is_reversed_prefix_longer = false;\n    let mut is_reversed_suffix_longer\
    \ = false;\n    let mut i = 0;\n    let mut j = string.len() - 1;\n    let mut\
    \ k = 0;\n    let mut l = string.len() - 1;\n    let mut m = 0;\n    let mut n\
    \ = string.len() - 1;\n    let mut o = 0;\n    let mut p = string.len() - 1;\n\
    \    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            prefix.push(string.chars().nth(i).unwrap());\n            suffix.push(string.chars().nth(j).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            break;\n\
    \        }\n    }\n    if prefix.len() == string.len() {\n        is_palindrome\
    \ = true;\n    }\n    while k < l {\n        if string.chars().nth(k) == string.chars().nth(l)\
    \ {\n            reversed_prefix.push(string.chars().nth(l).unwrap());\n     \
    \       reversed_suffix.push(string.chars().nth(k).unwrap());\n            k +=\
    \ 1;\n            l -= 1;\n        } else {\n            break;\n        }\n \
    \   }\n    if reversed_prefix.len() == string.len() {\n        is_palindrome =\
    \ true;\n    }\n    if prefix.\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmp9m3inr67.rs:59:1\n   |\n59\
    \ | }\n   | ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmp9m3inr67.rs:59:1\n\
    \   |\n58 |     if prefix.\n   |     -- this `if` expression has a condition,\
    \ but no block\n59 | }\n   | ^ expected `{`\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = String::new();\n\
    \    let mut palindrome_suffix_len = 0;\n    let mut i = string.len();\n    while\
    \ i > 0 {\n        let (prefix, suffix) = string.split_at(i);\n        if is_palindrome(suffix)\
    \ {\n            palindrome_suffix = suffix.to_string();\n            palindrome_suffix_len\
    \ = palindrome_suffix.len();\n            break;\n        }\n        i -= 1;\n\
    \    }\n    string.push_str(&palindrome_suffix[..palindrome_suffix_len - 1].chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpk1fgt8qu.rs:18:12\n   |\n18 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut prefix = String::new();\n \
    \   let mut suffix = String::new();\n    let mut max_palindrome_length = 0;\n\
    \    let mut max_palindrome_index = 0;\n    let mut max_palindrome_index_end =\
    \ 0;\n    let mut max_palindrome_index_start = 0;\n    let mut max_palindrome_index_start_end\
    \ = 0;\n    let mut max_palindrome_index_end_start = 0;\n    let mut max_palindrome_index_start_end_start\
    \ = 0;\n    let mut max_palindrome_index_end_start_end = 0;\n    let mut max_palindrome_index_start_end_start_end\
    \ = 0;\n    let mut max_palindrome_index_end_start_end_start = 0;\n    let mut\
    \ max_palindrome_index_start_end_start_end_start = 0;\n    let mut max_palindrome_index_end_start_end_start_end\
    \ = 0;\n    let mut max_palindrome_index_start_end_start_end_start_end = 0;\n\
    \    let mut max_palindrome_index_end_start_end_start_end_start = 0;\n    let\
    \ mut max_palindrome_index_start_end_start_end_start_end_start = 0;\n    let mut\
    \ max_palindrome_index_end_start_end_start_end_start_end = 0;\n    let mut max_palindrome_index_start_end_start_end_start_end_start_end\
    \ = 0;\n    let mut max_palindrome_index_end_start_end_start_end_start_end_start\
    \ = 0;\n    let mut max_palindrome_index_start_end_start_end_start_end_start_end_start\
    \ = 0;\n    let mut max_palindrome_index_end_start_end_start_end_start_end_start_end\
    \ = 0;\n    let mut max_palindrome_index_start_end_start_end_start_\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6p1we1td.rs:35:60\n   |\n\
    35 |     let mut max_palindrome_index_start_end_start_end_start_\n   |       \
    \                                                     ^ help: add `;` here\n36\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6p1we1td.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = String::new();\n\
    \    let mut palindrome_prefix = String::new();\n    let mut palindrome_suffix_length\
    \ = 0;\n    let mut palindrome_prefix_length = 0;\n    let mut i = 0;\n    let\
    \ mut j = string.len() - 1;\n    while i < j {\n        if string.chars().nth(i)\
    \ == string.chars().nth(j) {\n            palindrome_suffix.push(string.chars().nth(i).unwrap());\n\
    \            palindrome_prefix.push(string.chars().nth(j).unwrap());\n       \
    \     palindrome_suffix_length += 1;\n            palindrome_prefix_length +=\
    \ 1;\n            i += 1;\n            j -= 1;\n        } else {\n           \
    \ palindrome_suffix.clear();\n            palindrome_prefix.clear();\n       \
    \     palindrome_suffix_length = 0;\n            palindrome_prefix_length = 0;\n\
    \            i = 0;\n            j -= 1;\n        }\n    }\n    string.drain(..palindrome_suffix_length);\n\
    \    string.push_str(&palindrome_prefix);\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmppztbfubq.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    for i in 0..string.len() {\n        let suffix = &string[i..];\n        if\
    \ is_palindrome(suffix) {\n            longest_palindrome_suffix = suffix.to_string();\n\
    \            break;\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix.len()];\n    let mut reversed_prefix = prefix.chars().rev().collect::<String>();\n\
    \    string.push_str(&reversed_prefix);\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpyoq4fwtu.rs:16:12\n   |\n16 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut prefix = String::new();\n \
    \   let mut suffix = String::new();\n    let mut is_palindrome = false;\n    for\
    \ i in 0..string.len() {\n        prefix.push(string.chars().nth(i).unwrap());\n\
    \        suffix.push(string.chars().nth(string.len() - i - 1).unwrap());\n   \
    \     if prefix == suffix {\n            is_palindrome = true;\n            break;\n\
    \        }\n    }\n    if !is_palindrome {\n        result.push_str(&prefix[0..prefix.len()\
    \ - 1].chars().rev().collect::<String>());\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp3e6smq65.rs:25:36\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix = String::new();\n \
    \   let mut prefix = String::new();\n    let mut i = 0;\n    let mut j = string.len()\
    \ - 1;\n    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            suffix.push(string.chars().nth(i).unwrap());\n            prefix.push(string.chars().nth(j).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            break;\n\
    \        }\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpz0zm_2ho.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string.clone();\n    let mut prefix = String::new();\n\
    \    let mut suffix = String::new();\n    let mut longest_palindrome_length =\
    \ 0;\n    let mut longest_palindrome_index = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n    let\
    \ mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n   \
    \ let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n\
    \    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n\
    \    let mut z = 0;\n    let mut aa = 0;\n    let mut bb = 0;\n    let mut cc\
    \ = 0;\n    let mut dd = 0;\n    let mut ee = 0;\n    let mut ff = 0;\n    let\
    \ mut gg = 0;\n    let mut hh = 0;\n    let mut ii = 0;\n    let mut jj = 0;\n\
    \    let mut kk = 0;\n    let mut ll = 0;\n    let mut mm = 0;\n    let mut nn\
    \ = 0;\n    let mut oo = 0;\n    let mut pp = 0;\n    let mut qq = 0;\n    let\
    \ mut rr = 0;\n    let mut ss = 0;\n    let mut tt = 0;\n    let mut uu = 0;\n\
    \    let mut vv = 0;\n    let mut ww = 0;\n    let mut xx = 0;\n    let mut yy\
    \ = 0;\n    let mut zz = 0;\n    let mut aaa = 0;\n    let mut bbb = 0;\n    let\
    \ mut ccc = 0;\n    let mut ddd = 0;\n    let mut eee = 0;\n    let mut fff =\
    \ 0;\n    let mut ggg = 0;\n    let mut hhh = 0;\n    let mut iii = 0;\n    let\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpmj1dnexj.rs:71:1\n  \
    \ |\n71 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_len = 0;\n    let mut longest_palindrome_suffix_idx\
    \ = 0;\n    for i in 0..string.len() {\n        let (suffix, prefix) = string.split_at(i);\n\
    \        if is_palindrome(suffix) {\n            if suffix.len() > longest_palindrome_suffix_len\
    \ {\n                longest_palindrome_suffix = suffix.to_string();\n       \
    \         longest_palindrome_suffix_len = suffix.len();\n                longest_palindrome_suffix_idx\
    \ = i;\n            }\n        }\n    }\n    let prefix = string.split_at(longest_palindrome_suffix_idx).0;\n\
    \    string.push_str(&prefix.chars().rev().collect::<String>());\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpugtc9zph.rs:18:12\n   |\n18 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut prefix = String::new();\n \
    \   let mut suffix = String::new();\n    let mut is_palindrome = false;\n    let\
    \ mut i = 0;\n    while !is_palindrome {\n        prefix.push(string.chars().nth(i).unwrap());\n\
    \        suffix.push(string.chars().nth(string.len() - i - 1).unwrap());\n   \
    \     if prefix == suffix {\n            is_palindrome = true;\n        }\n  \
    \      i += 1;\n    }\n    result.push_str(&prefix);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpr2shqypu.rs:18:43\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = String::new();\n\
    \    let mut palindrome_prefix = String::new();\n    let mut is_palindrome = false;\n\
    \    let mut i = 0;\n    while !is_palindrome {\n        let (prefix, suffix)\
    \ = string.split_at(i);\n        palindrome_suffix = suffix.to_string();\n   \
    \     palindrome_prefix = prefix.to_string();\n        is_palindrome = is_palindrome(palindrome_suffix.clone());\n\
    \        i += 1;\n    }\n    let mut palindrome_prefix = palindrome_prefix.chars().rev().collect::<String>();\n\
    \    palindrome_prefix.push_str(&palindrome_suffix);\n    palindrome_prefix\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0618]: expected function, found `bool`\n  --> /tmp/tmp281rro72.rs:21:25\n\
    \   |\n15 |     let mut is_palindrome = false;\n   |         -----------------\
    \ `is_palindrome` has type `bool`\n...\n21 |         is_palindrome = is_palindrome(palindrome_suffix.clone());\n\
    \   |                         ^^^^^^^^^^^^^---------------------------\n   | \
    \                        |\n   |                         call expression requires\
    \ function\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0618`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut palindrome = String::new();\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let\
    \ mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n   \
    \ let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n\
    \    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n\
    \    let mut y = 0;\n    let mut z = 0;\n    let mut aa = 0;\n    let mut ab =\
    \ 0;\n    let mut ac = 0;\n    let mut ad = 0;\n    let mut ae = 0;\n    let mut\
    \ af = 0;\n    let mut ag = 0;\n    let mut ah = 0;\n    let mut ai = 0;\n   \
    \ let mut aj = 0;\n    let mut ak = 0;\n    let mut al = 0;\n    let mut am =\
    \ 0;\n    let mut an = 0;\n    let mut ao = 0;\n    let mut ap = 0;\n    let mut\
    \ aq = 0;\n    let mut ar = 0;\n    let mut as_ = 0;\n    let mut at = 0;\n  \
    \  let mut au = 0;\n    let mut av = 0;\n    let mut aw = 0;\n    let mut ax =\
    \ 0;\n    let mut ay = 0;\n    let mut az = 0;\n    let mut ba = 0;\n    let mut\
    \ bb = 0;\n    let mut bc = 0;\n    let mut bd = 0;\n    let mut be = 0;\n   \
    \ let mut bf = 0;\n    let mut bg = 0;\n    let mut bh = 0;\n    let mut bi =\
    \ 0;\n    let mut bj = 0;\n    let mut bk = 0;\n    let mut bl = 0;\n    let mut\
    \ bm = 0;\n\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5bxbge83.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed = string.clone();\n    reversed.reverse();\n\
    \    let mut longest_palindrome = String::new();\n    for i in 0..string.len()\
    \ {\n        if string.ends_with(&reversed[i..]) {\n            longest_palindrome\
    \ = reversed[i..].to_string();\n            break;\n        }\n    }\n    string.push_str(&longest_palindrome);\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpuu2lk6zj.rs:14:14\n   |\n14 |     reversed.reverse();\n\
    \   |              ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix = String::new();\n \
    \   let mut prefix = String::new();\n    for (i, c) in string.chars().enumerate()\
    \ {\n        suffix.push(c);\n        if is_palindrome(&suffix) {\n          \
    \  prefix = string[..i + 1].to_string();\n        }\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpkn2hm8ct.rs:17:12\n   |\n17 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_len = 0;\n    let mut longest_palindrome_suffix_idx\
    \ = 0;\n    let mut i = 0;\n    while i < string.len() {\n        let mut j =\
    \ i;\n        let mut k = i;\n        while k < string.len() && string.chars().nth(k)\
    \ == string.chars().nth(j) {\n            k += 1;\n            j -= 1;\n     \
    \   }\n        if k - i > longest_palindrome_suffix_len && j < 0 {\n         \
    \   longest_palindrome_suffix_len = k - i;\n            longest_palindrome_suffix_idx\
    \ = i;\n        }\n        i += 1;\n    }\n    if longest_palindrome_suffix_len\
    \ > 0 {\n        longest_palindrome_suffix = string.chars().skip(longest_palindrome_suffix_idx).take(longest_palindrome_suffix_len).collect();\n\
    \        string.push_str(&longest_palindrome_suffix.chars().rev().collect::<String>());\n\
    \    }\n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpop6msbxn.rs:22:13\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut i = 0;\n    let mut j = string.len()\
    \ - 1;\n    while i < j {\n        if string.chars().nth(i) != string.chars().nth(j)\
    \ {\n            break;\n        }\n        i += 1;\n        j -= 1;\n    }\n\
    \    let mut prefix = String::new();\n    for k in (i..string.len()).rev() {\n\
    \        prefix.push(string.chars().nth(k).unwrap());\n    }\n    string.push_str(&prefix);\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp7q995uh0.rs:14:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut prefix = String::new();\n \
    \   let mut suffix = String::new();\n    let mut i = 0;\n    let mut j = string.len()\
    \ - 1;\n    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            prefix.push(string.chars().nth(i).unwrap());\n            suffix.push(string.chars().nth(j).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            break;\n\
    \        }\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpwacwm_8b.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut palindrome = String::new();\n    let mut\
    \ palindrome_length = 0;\n    let mut i = 0;\n    let mut j = string.len() - 1;\n\
    \    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            palindrome.push(string.chars().nth(i).unwrap());\n          \
    \  palindrome_length += 1;\n        } else {\n            palindrome = String::new();\n\
    \            palindrome_length = 0;\n        }\n        i += 1;\n        j -=\
    \ 1;\n    }\n    if palindrome_length > 0 {\n        suffix = palindrome.clone();\n\
    \        prefix = string.chars().take(string.len() - palindrome_length).collect();\n\
    \    } else {\n        suffix = string.chars().take(string.len() - 1).collect();\n\
    \        prefix = string.chars().skip(1).collect();\n    }\n    suffix.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    suffix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpj90e1jmm.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut prefix = String::new();\n \
    \   let mut suffix = String::new();\n    for i in 0..string.len() {\n        prefix.push(string.chars().nth(i).unwrap());\n\
    \        suffix.push(string.chars().nth(string.len() - i - 1).unwrap());\n   \
    \     if prefix == suffix {\n            result.push_str(&prefix[0..prefix.len()\
    \ - 1].chars().rev().collect::<String>());\n            break;\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n   \
    \ assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyz\"`,\n right: `\"xyzyx\"`', /tmp/tmp1adp8jfw.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = String::new();\n\
    \    let mut palindrome_prefix = String::new();\n    let mut i = string.len();\n\
    \    while i > 0 {\n        let (prefix, suffix) = string.split_at(i);\n     \
    \   if is_palindrome(suffix) {\n            palindrome_suffix = suffix.to_string();\n\
    \            palindrome_prefix = prefix.chars().rev().collect();\n           \
    \ break;\n        }\n        i -= 1;\n    }\n    string.push_str(&palindrome_prefix);\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp5skba8gm.rs:18:12\n   |\n18 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    for i in 0..string.len() {\n        let suffix = string.split_off(string.len()\
    \ - i);\n        if is_palindrome(&suffix) {\n            longest_palindrome_suffix\
    \ = suffix;\n            break;\n        }\n    }\n    string.push_str(&longest_palindrome_suffix);\n\
    \    string.push_str(&string[..string.len() - longest_palindrome_suffix.len()].chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp4bnnfokd.rs:16:12\n   |\n16 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut reversed = string.chars().rev().collect::<String>();\n\
    \    let mut suffix_length = 0;\n    let mut prefix_length = 0;\n    for (i, (c1,\
    \ c2)) in string.chars().zip(reversed.chars()).enumerate() {\n        if c1 ==\
    \ c2 {\n            suffix_length = i + 1;\n        } else {\n            prefix_length\
    \ = i;\n        }\n    }\n    result.push_str(&reversed[..prefix_length]);\n \
    \   result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyzzy\"`,\n right: `\"xyzyx\"`', /tmp/tmpd5uflll_.rs:31:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = String::new();\n\
    \    let mut palindrome_prefix = String::new();\n    let mut palindrome_suffix_length\
    \ = 0;\n    let mut palindrome_prefix_length = 0;\n    let mut i = 0;\n    let\
    \ mut j = string.len() - 1;\n    while i < j {\n        if string.chars().nth(i)\
    \ == string.chars().nth(j) {\n            palindrome_suffix.push(string.chars().nth(i).unwrap());\n\
    \            palindrome_prefix.push(string.chars().nth(j).unwrap());\n       \
    \     palindrome_suffix_length += 1;\n            palindrome_prefix_length +=\
    \ 1;\n            i += 1;\n            j -= 1;\n        } else {\n           \
    \ palindrome_suffix.clear();\n            palindrome_prefix.clear();\n       \
    \     palindrome_suffix_length = 0;\n            palindrome_prefix_length = 0;\n\
    \            i = 0;\n            j -= 1;\n        }\n    }\n    string.push_str(&palindrome_prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpkz69ggbm.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome = String::new();\n\
    \    let mut longest_palindrome_length = 0;\n    let mut longest_palindrome_start\
    \ = 0;\n    let mut longest_palindrome_end = 0;\n    let mut string_length = string.len();\n\
    \    let mut string_chars = string.chars();\n    let mut string_chars_rev = string.chars().rev();\n\
    \    let mut string_chars_rev_vec = string.chars().rev().collect::<Vec<char>>();\n\
    \    let mut string_chars_rev_vec_iter = string_chars_rev_vec.iter();\n    let\
    \ mut string_chars_rev_vec_iter_rev = string_chars_rev_vec.iter().rev();\n   \
    \ let mut string_chars_rev_vec_iter_rev_clone = string_chars_rev_vec.iter().rev().clone();\n\
    \    let mut string_chars_rev_vec_iter_rev_clone_clone = string_chars_rev_vec.iter().rev().clone();\n\
    \    let mut string_chars_rev_vec_iter_rev_clone_clone_clone = string_chars_rev_vec.iter().rev().clone();\n\
    \    let mut string_chars_rev_vec_iter_rev_clone_clone_clone_clone = string_chars_rev_vec.iter().rev().clone();\n\
    \    let mut string_chars_rev_vec_iter_rev_clone_clone_clone_clone_clone = string_chars_rev_vec.iter().rev().clone();\n\
    \    let mut string_chars_rev_vec_iter_rev_clone_clone_clone_clone_clone_clone\
    \ = string_chars_rev_vec.iter().rev().clone();\n    let mut string_chars_rev_vec_iter_rev_clone_clone_clone_clone_clone_clone_clone\
    \ = string_chars_rev_vec.iter().rev().clone();\n    let mut string_chars_rev_vec_iter_rev_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = string_chars_rev\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpw5oy6fv_.rs:30:109\n   |\n\
    30 |     let mut string_chars_rev_vec_iter_rev_clone_clone_clone_clone_clone_clone_clone_clone\
    \ = string_chars_rev\n   |                                                   \
    \                                                          ^ help: add `;` here\n\
    31 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw5oy6fv_.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut palindrome = String::new();\n    let mut\
    \ longest_palindrome = String::new();\n    let mut longest_palindrome_length =\
    \ 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut\
    \ l = 0;\n    let mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n    let\
    \ mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n   \
    \ let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n\
    \    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n    let mut aa =\
    \ 0;\n    let mut ab = 0;\n    let mut ac = 0;\n    let mut ad = 0;\n    let mut\
    \ ae = 0;\n    let mut af = 0;\n    let mut ag = 0;\n    let mut ah = 0;\n   \
    \ let mut ai = 0;\n    let mut aj = 0;\n    let mut ak = 0;\n    let mut al =\
    \ 0;\n    let mut am = 0;\n    let mut an = 0;\n    let mut ao = 0;\n    let mut\
    \ ap = 0;\n    let mut aq = 0;\n    let mut ar = 0;\n    let mut as_ = 0;\n  \
    \  let mut at = 0;\n    let mut au = 0;\n    let mut av = 0;\n    let mut aw =\
    \ 0;\n    let mut ax = 0;\n    let mut ay = 0;\n    let mut az = 0;\n    let mut\
    \ ba = 0;\n    let mut bb = 0;\n    let mut bc = 0;\n    let mut bd = 0;\n   \
    \ let mut be = 0;\n    let mut bf = 0;\n    let mut bg = 0;\n    let mut bh =\
    \ 0;\n    let mut bi = 0;\n    let mut bj = 0\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmph9jggtjv.rs:71:19\n   |\n\
    71 |     let mut bj = 0\n   |                   ^ help: add `;` here\n72 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph9jggtjv.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix = String::new();\n \
    \   for c in string.chars().rev() {\n        suffix.push(c);\n        if is_palindrome(&string,\
    \ &suffix) {\n            result.push_str(&suffix);\n            break;\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmppztg5c_d.rs:16:12\n   |\n16 |         if is_palindrome(&string, &suffix)\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut palindrome = String::new();\n    let mut\
    \ i = 0;\n    let mut j = string.len() - 1;\n    let mut is_palindrome = false;\n\
    \    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            suffix.push(string.chars().nth(i).unwrap());\n            prefix.push(string.chars().nth(j).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            suffix.clear();\n\
    \            prefix.clear();\n            i = 0;\n            j -= 1;\n      \
    \  }\n        if i == j {\n            is_palindrome = true;\n        }\n    }\n\
    \    if is_palindrome {\n        palindrome.push_str(&string);\n        palindrome.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    } else {\n        palindrome.push_str(&string);\n        palindrome.push_str(&suffix.chars().rev().collect::<String>());\n\
    \    }\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp7y8ler7l.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut prefix = String::new();\n \
    \   let mut suffix = String::new();\n    let mut suffix_length = 0;\n    let mut\
    \ prefix_length = 0;\n    let mut i = 0;\n    let mut j = string.len() - 1;\n\
    \    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            suffix.push(string.chars().nth(i).unwrap());\n            suffix_length\
    \ += 1;\n            i += 1;\n            j -= 1;\n        } else {\n        \
    \    prefix.push(string.chars().nth(i).unwrap());\n            prefix_length +=\
    \ 1;\n            i += 1;\n        }\n    }\n    if suffix_length == 0 {\n   \
    \     prefix.push(string.chars().nth(i).unwrap());\n        prefix_length += 1;\n\
    \    }\n    result.push_str(&prefix[prefix_length..].chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp0439s4v7.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome = String::new();\n\
    \    for i in 0..string.len() {\n        let prefix = &string[0..i];\n       \
    \ let postfix = &string[i..];\n        if is_palindrome(postfix) && postfix.len()\
    \ > longest_palindrome.len() {\n            longest_palindrome = postfix.to_string();\n\
    \        }\n    }\n    string.push_str(&reverse(string[0..string.len() - longest_palindrome.len()].to_string()));\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp4suldl7c.rs:17:12\n   |\n17 |         if is_palindrome(postfix) && postfix.len()\
    \ > longest_palindrome.len() {\n   |            ^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `reverse` in this scope\n  --> /tmp/tmp4suldl7c.rs:21:22\n\
    \   |\n21 |     string.push_str(&reverse(string[0..string.len() - longest_palindrome.len()].to_string()));\n\
    \   |                      ^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_len = 0;\n    for i in 0..string.len()\
    \ {\n        let suffix = &string[i..];\n        if is_palindrome(suffix) {\n\
    \            if suffix.len() > longest_palindrome_suffix_len {\n             \
    \   longest_palindrome_suffix = suffix.to_string();\n                longest_palindrome_suffix_len\
    \ = suffix.len();\n            }\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix_len];\n    let reversed_prefix = reverse(prefix);\n\
    \    string.push_str(&reversed_prefix);\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpgq6fhdjx.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `reverse` in this scope\n  --> /tmp/tmpgq6fhdjx.rs:25:27\n   |\n\
    25 |     let reversed_prefix = reverse(prefix);\n   |                        \
    \   ^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_length = 0;\n    let mut longest_palindrome_suffix_index\
    \ = 0;\n    for i in 0..string.len() {\n        let suffix = &string[i..];\n \
    \       if is_palindrome(suffix) {\n            if suffix.len() > longest_palindrome_suffix_length\
    \ {\n                longest_palindrome_suffix = suffix.to_string();\n       \
    \         longest_palindrome_suffix_length = suffix.len();\n                longest_palindrome_suffix_index\
    \ = i;\n            }\n        }\n    }\n    let prefix = &string[..longest_palindrome_suffix_index];\n\
    \    let prefix_reversed = reverse(prefix);\n    string.push_str(&prefix_reversed);\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpthiude87.rs:18:12\n   |\n18 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `reverse` in this scope\n  --> /tmp/tmpthiude87.rs:27:27\n   |\n\
    27 |     let prefix_reversed = reverse(prefix);\n   |                        \
    \   ^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_length = 0;\n    let mut longest_palindrome_suffix_start\
    \ = 0;\n    let mut longest_palindrome_suffix_end = 0;\n    let mut i = 0;\n \
    \   let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n\
    \    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n\
    \    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n\
    \    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n\
    \    let mut z = 0;\n    let mut aa = 0;\n    let mut ab = 0;\n    let mut ac\
    \ = 0;\n    let mut ad = 0;\n    let mut ae = 0;\n    let mut af = 0;\n    let\
    \ mut ag = 0;\n    let mut ah = 0;\n    let mut ai = 0;\n    let mut aj = 0;\n\
    \    let mut ak = 0;\n    let mut al = 0;\n    let mut am = 0;\n    let mut an\
    \ = 0;\n    let mut ao = 0;\n    let mut ap = 0;\n    let mut aq = 0;\n    let\
    \ mut ar = 0;\n    let mut as_ = 0;\n    let mut at = 0;\n    let mut au = 0;\n\
    \    let mut av = 0;\n    let mut aw = 0;\n    let mut ax = 0;\n    let mut ay\
    \ = 0;\n    let mut az = 0;\n    let mut ba = 0;\n    let mut bb = 0;\n    let\
    \ mut bc = 0;\n    let mut bd = 0;\n    let mut be = 0;\n    let mut bf = 0;\n\
    \    let mut bg = 0;\n    let mut bh = 0;\n    let mut bi = 0;\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoa2riy1v.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix = string.clone();\n\
    \    let mut prefix = String::new();\n    while !is_palindrome(&suffix) {\n  \
    \      prefix.push(suffix.pop().unwrap());\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpq5lz3fn1.rs:15:12\n   |\n15 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix = String::new();\n \
    \   let mut prefix = String::new();\n    let mut i = 0;\n    let mut j = string.len()\
    \ - 1;\n    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            suffix.push(string.chars().nth(i).unwrap());\n            prefix.push(string.chars().nth(j).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            break;\n\
    \        }\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp3b3xvdpb.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = String::new();\n\
    \    let mut palindrome_prefix = String::new();\n    let mut is_palindrome = true;\n\
    \    let mut i = 0;\n    let mut j = string.len() - 1;\n    while i < j {\n  \
    \      if string.chars().nth(i) != string.chars().nth(j) {\n            is_palindrome\
    \ = false;\n            break;\n        }\n        i += 1;\n        j -= 1;\n\
    \    }\n    if is_palindrome {\n        return string;\n    }\n    i = 0;\n  \
    \  j = string.len() - 1;\n    while i < j {\n        if string.chars().nth(i)\
    \ != string.chars().nth(j) {\n            palindrome_suffix = string.chars().skip(i).collect();\n\
    \            palindrome_prefix = string.chars().take(j).collect();\n         \
    \   break;\n        }\n        i += 1;\n        j -= 1;\n    }\n    string.push_str(&palindrome_prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpbjroltew.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string.clone();\n\
    \    reversed_string.reverse();\n    let mut longest_palindrome_suffix = String::new();\n\
    \    for i in 0..string.len() {\n        let suffix = &string[i..];\n        let\
    \ prefix = &reversed_string[..string.len() - i];\n        if suffix == prefix\
    \ {\n            longest_palindrome_suffix = suffix.to_string();\n        }\n\
    \    }\n    string.push_str(&reversed_string[..string.len() - longest_palindrome_suffix.len()].chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmphlp20lq7.rs:14:21\n   |\n14 |     reversed_string.reverse();\n\
    \   |                     ^^^^^^^ help: there is an associated function with a\
    \ similar name: `reserve`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut longest_palindrome_suffix_len = 0;\n  \
    \  let mut longest_palindrome_suffix_index = 0;\n    for i in 0..string.len()\
    \ {\n        let suffix_len = string.len() - i;\n        let suffix_str = &string[i..];\n\
    \        if is_palindrome(suffix_str) {\n            if suffix_len > longest_palindrome_suffix_len\
    \ {\n                longest_palindrome_suffix_len = suffix_len;\n           \
    \     longest_palindrome_suffix_index = i;\n            }\n        }\n    }\n\
    \    if longest_palindrome_suffix_len > 0 {\n        suffix = string.split_off(longest_palindrome_suffix_index);\n\
    \        prefix = string;\n    }\n    prefix.chars().rev().collect::<String>()\
    \ + &suffix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp65grp0ia.rs:20:12\n   |\n20 |         if is_palindrome(suffix_str) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut prefix = String::new();\n \
    \   let mut suffix = String::new();\n    let mut is_palindrome = false;\n    for\
    \ i in 0..string.len() {\n        prefix.push(string.chars().nth(i).unwrap());\n\
    \        suffix.push(string.chars().nth(string.len() - i - 1).unwrap());\n   \
    \     if prefix == suffix {\n            is_palindrome = true;\n            break;\n\
    \        }\n    }\n    if !is_palindrome {\n        result.push_str(&prefix);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyzxyz\"`,\n right: `\"xyzyx\"`', /tmp/tmpxth1hr4i.rs:34:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut i = 0;\n    let mut j = string.len() -\
    \ 1;\n    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            suffix.push(string.chars().nth(i).unwrap());\n            prefix.push(string.chars().nth(j).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            i = 0;\n\
    \            j -= 1;\n            suffix.clear();\n            prefix.clear();\n\
    \        }\n    }\n    string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmphv38nrwq.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_len = 0;\n    for i in 0..string.len()\
    \ {\n        let suffix = &string[i..];\n        if is_palindrome(suffix) {\n\
    \            if suffix.len() > longest_palindrome_suffix_len {\n             \
    \   longest_palindrome_suffix = suffix.to_string();\n                longest_palindrome_suffix_len\
    \ = suffix.len();\n            }\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix_len];\n    let mut prefix_reversed = prefix.chars().rev().collect::<String>();\n\
    \    string.push_str(&prefix_reversed);\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp47bhc455.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix = String::new();\n \
    \   let mut prefix = String::new();\n    let mut i = string.len();\n    while\
    \ i > 0 {\n        suffix.push(string.chars().nth(i - 1).unwrap());\n        prefix.push(string.chars().nth(string.len()\
    \ - i).unwrap());\n        if is_palindrome(&suffix) {\n            break;\n \
    \       }\n        i -= 1;\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmplae_2z1b.rs:19:12\n   |\n19 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_len = 0;\n    for i in 0..string.len()\
    \ {\n        let suffix = &string[i..];\n        if is_palindrome(suffix) {\n\
    \            if suffix.len() > longest_palindrome_suffix_len {\n             \
    \   longest_palindrome_suffix = suffix.to_string();\n                longest_palindrome_suffix_len\
    \ = suffix.len();\n            }\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix_len];\n    let prefix_reversed = reverse(prefix);\n\
    \    string.push_str(&prefix_reversed);\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp0ma8vnfu.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `reverse` in this scope\n  --> /tmp/tmp0ma8vnfu.rs:25:27\n   |\n\
    25 |     let prefix_reversed = reverse(prefix);\n   |                        \
    \   ^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix_len = 0;\n    let mut prefix_len\
    \ = 0;\n    let mut suffix_is_palindrome = false;\n    let mut prefix_is_palindrome\
    \ = false;\n    let mut palindrome_len = 0;\n    let mut palindrome_start = 0;\n\
    \    let mut palindrome_end = 0;\n    let mut string_len = string.len();\n   \
    \ let mut string_chars = string.chars().collect::<Vec<char>>();\n    let mut string_chars_rev\
    \ = string.chars().rev().collect::<Vec<char>>();\n    let mut string_chars_rev_len\
    \ = string_chars_rev.len();\n    let mut string_chars_len = string_chars.len();\n\
    \    let mut string_chars_rev_iter = string_chars_rev.iter();\n    let mut string_chars_iter\
    \ = string_chars.iter();\n    let mut string_chars_rev_iter_next = string_chars_rev_iter.next();\n\
    \    let mut string_chars_iter_next = string_chars_iter.next();\n    let mut string_chars_rev_iter_next_char\
    \ = string_chars_rev_iter_next.unwrap();\n    let mut string_chars_iter_next_char\
    \ = string_chars_iter_next.unwrap();\n    let mut string_chars_rev_iter_next_char_clone\
    \ = string_chars_rev_iter_next_char.clone();\n    let mut string_chars_iter_next_char_clone\
    \ = string_chars_iter_next_char.clone();\n    let mut string_chars_rev_iter_next_char_clone_clone\
    \ = string_chars_rev_iter_next_char_clone.clone();\n    let mut string_chars_iter_next_char_clone_clone\
    \ = string_chars_iter_next_char_clone.clone();\n    let mut string_chars_rev_iter_next_char_clone_clone_clone\
    \ = string_chars_rev_iter_next_char_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpssu02srw.rs:35:97\n   |\n\
    35 |     let mut string_chars_rev_iter_next_char_clone_clone_clone = string_chars_rev_iter_next_char_\n\
    \   |                                                                        \
    \                         ^ help: add `;` here\n36 | }\n   | - unexpected token\n\
    \nerror[E0425]: cannot find value `string_chars_rev_iter_next_char_` in this scope\n\
    \  --> /tmp/tmpssu02srw.rs:35:65\n   |\n35 |     let mut string_chars_rev_iter_next_char_clone_clone_clone\
    \ = string_chars_rev_iter_next_char_\n   |                                   \
    \                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `string_chars_rev_iter_next_char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpssu02srw.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = String::new();\n\
    \    let mut palindrome_prefix = String::new();\n    let mut palindrome_length\
    \ = 0;\n    let mut palindrome_start = 0;\n    let mut palindrome_end = 0;\n \
    \   for i in 0..string.len() {\n        let mut j = 0;\n        while i - j >=\
    \ 0 && i + j < string.len() && string.chars().nth(i - j).unwrap() == string.chars().nth(i\
    \ + j).unwrap() {\n            j += 1;\n        }\n        if 2 * j - 1 > palindrome_length\
    \ {\n            palindrome_length = 2 * j - 1;\n            palindrome_start\
    \ = i - j + 1;\n            palindrome_end = i + j - 1;\n        }\n        j\
    \ = 0;\n        while i - j >= 0 && i + j + 1 < string.len() && string.chars().nth(i\
    \ - j).unwrap() == string.chars().nth(i + j + 1).unwrap() {\n            j +=\
    \ 1;\n        }\n        if 2 * j > palindrome_length {\n            palindrome_length\
    \ = 2 * j;\n            palindrome_start = i - j + 1;\n            palindrome_end\
    \ = i + j;\n        }\n    }\n    palindrome_suffix = string.chars().skip(palindrome_start).take(palindrome_end\
    \ - palindrome_start + 1).collect();\n    palindrome_prefix = string.chars().take(palindrome_start).collect();\n\
    \    string.push_str(&palindrome_prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpdojjd6v4.rs:20:15\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = String::new();\n\
    \    let mut palindrome_suffix_len = 0;\n    for i in 0..string.len() {\n    \
    \    let suffix = &string[i..];\n        if is_palindrome(suffix) {\n        \
    \    palindrome_suffix = suffix.to_string();\n            palindrome_suffix_len\
    \ = palindrome_suffix.len();\n            break;\n        }\n    }\n    let prefix\
    \ = &string[..string.len() - palindrome_suffix_len];\n    string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp4aktkfvo.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut longest_palindrome_suffix =\
    \ String::new();\n    for i in 0..string.len() {\n        let suffix = &string[i..];\n\
    \        if is_palindrome(suffix) {\n            longest_palindrome_suffix = suffix.to_string();\n\
    \            break;\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix.len()];\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmppi9ajynd.rs:16:12\n   |\n16 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = String::new();\n\
    \    let mut palindrome_prefix = String::new();\n    let mut longest_palindrome_suffix_len\
    \ = 0;\n    let mut longest_palindrome_suffix_start = 0;\n    for i in 0..string.len()\
    \ {\n        let (suffix, prefix) = string.split_at(i);\n        let suffix_len\
    \ = suffix.len();\n        if is_palindrome(suffix) && suffix_len > longest_palindrome_suffix_len\
    \ {\n            longest_palindrome_suffix_len = suffix_len;\n            longest_palindrome_suffix_start\
    \ = i;\n            palindrome_suffix = suffix.to_string();\n            palindrome_prefix\
    \ = prefix.to_string();\n        }\n    }\n    let mut palindrome = palindrome_suffix;\n\
    \    palindrome.push_str(&palindrome_prefix.chars().rev().collect::<String>());\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp6aoev3a_.rs:20:12\n   |\n20 |         if is_palindrome(suffix) && suffix_len\
    \ > longest_palindrome_suffix_len {\n   |            ^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    for i in 0..string.len() {\n        let suffix = &string[i..];\n        if\
    \ is_palindrome(suffix) {\n            longest_palindrome_suffix = suffix.to_string();\n\
    \            break;\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix.len()];\n    let mut reversed_prefix = prefix.chars().rev().collect::<String>();\n\
    \    string.push_str(&reversed_prefix);\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpihip9ofg.rs:16:12\n   |\n16 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix = String::new();\n \
    \   let mut prefix = String::new();\n    let mut is_palindrome = false;\n    for\
    \ c in string.chars().rev() {\n        suffix.push(c);\n        if is_palindrome(&suffix)\
    \ {\n            is_palindrome = true;\n            break;\n        }\n    }\n\
    \    if is_palindrome {\n        for c in string.chars() {\n            prefix.push(c);\n\
    \            if is_palindrome(&prefix) {\n                break;\n           \
    \ }\n        }\n        result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0618]: expected function, found `bool`\n  --> /tmp/tmpldho8i4a.rs:18:12\n\
    \   |\n15 |     let mut is_palindrome = false;\n   |         -----------------\
    \ `is_palindrome` has type `bool`\n...\n18 |         if is_palindrome(&suffix)\
    \ {\n   |            ^^^^^^^^^^^^^---------\n   |            |\n   |         \
    \   call expression requires function\n\nerror[E0618]: expected function, found\
    \ `bool`\n  --> /tmp/tmpldho8i4a.rs:26:16\n   |\n15 |     let mut is_palindrome\
    \ = false;\n   |         ----------------- `is_palindrome` has type `bool`\n...\n\
    26 |             if is_palindrome(&prefix) {\n   |                ^^^^^^^^^^^^^---------\n\
    \   |                |\n   |                call expression requires function\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0618`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut palindrome = String::new();\n    let mut\
    \ i = string.len();\n    while i > 0 {\n        suffix.push_str(&string[i - 1..i]);\n\
    \        prefix.push_str(&string[0..i]);\n        if is_palindrome(&suffix) {\n\
    \            palindrome.push_str(&suffix);\n            palindrome.push_str(&prefix.chars().rev().collect::<String>());\n\
    \            return palindrome;\n        }\n        i -= 1;\n    }\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpw0dif8yn.rs:20:12\n   |\n20 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `palindrome`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = String::new();\n\
    \    let mut palindrome_prefix = String::new();\n    let mut palindrome_suffix_length\
    \ = 0;\n    let mut palindrome_prefix_length = 0;\n    let mut palindrome_length\
    \ = 0;\n    let mut max_palindrome_length = 0;\n    let mut max_palindrome_suffix_length\
    \ = 0;\n    let mut max_palindrome_prefix_length = 0;\n    let mut max_palindrome_suffix\
    \ = String::new();\n    let mut max_palindrome_prefix = String::new();\n    let\
    \ mut max_palindrome = String::new();\n    let mut string_length = string.len();\n\
    \    let mut string_chars = string.chars();\n    let mut string_chars_rev = string.chars().rev();\n\
    \    let mut string_chars_rev_clone = string.chars().rev();\n    let mut string_chars_clone\
    \ = string.chars();\n    let mut string_chars_clone_rev = string.chars().rev();\n\
    \    let mut string_chars_clone_rev_clone = string.chars().rev();\n    let mut\
    \ string_chars_clone_clone = string.chars();\n    let mut string_chars_clone_clone_rev\
    \ = string.chars().rev();\n    let mut string_chars_clone_clone_rev_clone = string.chars().rev();\n\
    \    let mut string_chars_clone_clone_clone = string.chars();\n    let mut string_chars_clone_clone_clone_rev\
    \ = string.chars().rev();\n    let mut string_chars_clone_clone_clone_rev_clone\
    \ = string.chars().rev();\n    let mut string_chars_clone_clone_clone_clone =\
    \ string.chars();\n    let mut string_chars_clone_clone_clone_clone_rev = string.chars().rev();\n\
    \    let mut string_chars_clone_clone_clone_clone_rev_clone = string.chars().rev();\n\
    \    let mut string_chars\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgxn3ia36.rs:40:25\n   |\n\
    40 |     let mut string_chars\n   |                         ^ help: add `;` here\n\
    41 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgxn3ia36.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut prefix_len = 0;\n    let mut suffix_len\
    \ = 0;\n    let mut max_len = 0;\n    let mut max_len_index = 0;\n    let mut\
    \ i = 0;\n    let mut j = string.len() - 1;\n    while i < j {\n        if string.chars().nth(i)\
    \ == string.chars().nth(j) {\n            if i == j {\n                suffix_len\
    \ += 1;\n            } else {\n                suffix_len += 2;\n            }\n\
    \            if suffix_len > max_len {\n                max_len = suffix_len;\n\
    \                max_len_index = i;\n            }\n        } else {\n       \
    \     suffix_len = 0;\n        }\n        i += 1;\n        j -= 1;\n    }\n  \
    \  if max_len == 0 {\n        string.push(string.chars().nth(0).unwrap());\n \
    \       return string;\n    }\n    prefix_len = string.len() - max_len_index -\
    \ max_len;\n    suffix = string.chars().skip(max_len_index + max_len).collect();\n\
    \    prefix = string.chars().take(prefix_len).collect();\n    string.push_str(&suffix.chars().rev().collect::<String>());\n\
    \    string.push_str(&prefix.chars().rev().collect::<String>());\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpl0f_xwvs.rs:20:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut prefix = String::new();\n    let mut\
    \ suffix = String::new();\n    let mut longest_palindrome_length = 0;\n    let\
    \ mut longest_palindrome_index = 0;\n    for i in 0..string.len() {\n        if\
    \ is_palindrome(&string[i..]) {\n            if string.len() - i > longest_palindrome_length\
    \ {\n                longest_palindrome_length = string.len() - i;\n         \
    \       longest_palindrome_index = i;\n            }\n        }\n    }\n    if\
    \ longest_palindrome_length > 0 {\n        prefix = string[0..longest_palindrome_index].to_string();\n\
    \        suffix = string[longest_palindrome_index..].to_string();\n    }\n   \
    \ string.push_str(&prefix.chars().rev().collect::<String>());\n    string.push_str(&suffix);\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp643apa6o.rs:18:12\n   |\n18 |         if is_palindrome(&string[i..])\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_len = 0;\n    for i in 0..string.len()\
    \ {\n        let suffix = &string[i..];\n        if is_palindrome(suffix) {\n\
    \            if suffix.len() > longest_palindrome_suffix_len {\n             \
    \   longest_palindrome_suffix = suffix.to_string();\n                longest_palindrome_suffix_len\
    \ = suffix.len();\n            }\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix_len];\n    let prefix_reversed = reverse(prefix);\n\
    \    string.push_str(&prefix_reversed);\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp7z0abp3e.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `reverse` in this scope\n  --> /tmp/tmp7z0abp3e.rs:25:27\n   |\n\
    25 |     let prefix_reversed = reverse(prefix);\n   |                        \
    \   ^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_length = 0;\n    for i in 0..string.len()\
    \ {\n        let suffix = &string[i..];\n        if is_palindrome(suffix) {\n\
    \            if suffix.len() > longest_palindrome_suffix_length {\n          \
    \      longest_palindrome_suffix = suffix.to_string();\n                longest_palindrome_suffix_length\
    \ = suffix.len();\n            }\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix_length];\n    let prefix = prefix.chars().rev().collect::<String>();\n\
    \    string.push_str(&prefix);\n    string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpohditgmp.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    for i in 0..string.len() {\n        let suffix = &string[i..];\n        if\
    \ is_palindrome(suffix) {\n            longest_palindrome_suffix = suffix.to_string();\n\
    \            break;\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix.len()];\n    string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmppevryzt6.rs:16:12\n   |\n16 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_len = 0;\n    for i in 0..string.len()\
    \ {\n        let suffix = &string[i..];\n        if is_palindrome(suffix) {\n\
    \            if suffix.len() > longest_palindrome_suffix_len {\n             \
    \   longest_palindrome_suffix = suffix.to_string();\n                longest_palindrome_suffix_len\
    \ = suffix.len();\n            }\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix_len];\n    let prefix_reversed = reverse(prefix);\n\
    \    string.push_str(&prefix_reversed);\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp6q3i3d9_.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `reverse` in this scope\n  --> /tmp/tmp6q3i3d9_.rs:25:27\n   |\n\
    25 |     let prefix_reversed = reverse(prefix);\n   |                        \
    \   ^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = String::new();\n\
    \    let mut palindrome_prefix = String::new();\n    let mut is_palindrome = true;\n\
    \    let mut is_palindrome_suffix = true;\n    let mut is_palindrome_prefix =\
    \ true;\n    let mut i = 0;\n    let mut j = string.len() - 1;\n    while i <\
    \ j {\n        if string.chars().nth(i) != string.chars().nth(j) {\n         \
    \   is_palindrome = false;\n            break;\n        }\n        i += 1;\n \
    \       j -= 1;\n    }\n    if !is_palindrome {\n        i = 0;\n        j = string.len()\
    \ - 1;\n        while i < j {\n            if string.chars().nth(i) != string.chars().nth(j)\
    \ {\n                is_palindrome_suffix = false;\n                break;\n \
    \           }\n            palindrome_suffix.push(string.chars().nth(i).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        }\n        if !is_palindrome_suffix\
    \ {\n            i = 0;\n            j = string.len() - 1;\n            while\
    \ i < j {\n                if string.chars().nth(i) != string.chars().nth(j) {\n\
    \                    is_palindrome_prefix = false;\n                    break;\n\
    \                }\n                palindrome_prefix.push(string.chars().nth(j).unwrap());\n\
    \                i += 1;\n                j -= 1;\n            }\n        }\n\
    \    }\n    if is_palindrome {\n        return string;\n    } else if is_palindrome_suffix\
    \ {\n        return format!(\"{}{}\", string, string.chars().rev().collect::<String>());\n\
    \    } else if is_palindrome_prefix {\n        return format!(\"{}{}\", string,\
    \ palindrome_prefix);\n    } else {\n        return format!(\"{}{}{}\", string,\
    \ palindrome_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpnhfkp8vd.rs:71:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n60 |     } else {\n\
    \   |            - this delimiter might not be properly closed...\n61 |      \
    \   return format!(\"{}{}{}\", string, palindrome_\n62 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n71 | }\n   |   ^\n\nerror: mismatched\
    \ closing delimiter: `}`\n  --> /tmp/tmpnhfkp8vd.rs:61:23\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |                                              - closing\
    \ delimiter possibly meant for this\n...\n61 |         return format!(\"{}{}{}\"\
    , string, palindrome_\n   |                       ^ unclosed delimiter\n62 | }\n\
    \   | ^ mismatched closing delimiter\n\nerror: 3 positional arguments in format\
    \ string, but there are 2 arguments\n  --> /tmp/tmpnhfkp8vd.rs:61:25\n   |\n61\
    \ |         return format!(\"{}{}{}\", string, palindrome_\n   |             \
    \            ^^^^^^   ------  -----------\n\nerror[E0425]: cannot find value `palindrome_`\
    \ in this scope\n  --> /tmp/tmpnhfkp8vd.rs:61:42\n   |\n61 |         return format!(\"\
    {}{}{}\", string, palindrome_\n   |                                          ^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_len = 0;\n    for i in 0..string.len()\
    \ {\n        let suffix = &string[i..];\n        if is_palindrome(suffix) {\n\
    \            if suffix.len() > longest_palindrome_suffix_len {\n             \
    \   longest_palindrome_suffix = suffix.to_string();\n                longest_palindrome_suffix_len\
    \ = suffix.len();\n            }\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix_len];\n    let prefix = prefix.chars().rev().collect::<String>();\n\
    \    string.push_str(&prefix);\n    string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpa0s7dcol.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut prefix = String::new();\n \
    \   let mut suffix = String::new();\n    let mut is_palindrome = false;\n    let\
    \ mut i = 0;\n    while !is_palindrome {\n        prefix.push(string.chars().nth(i).unwrap());\n\
    \        suffix.push(string.chars().nth(string.len() - i - 1).unwrap());\n   \
    \     is_palindrome = prefix == suffix;\n        i += 1;\n    }\n    result.push_str(&prefix);\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpe91l2vaz.rs:18:43\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = String::new();\n\
    \    let mut palindrome_suffix_length = 0;\n    let mut palindrome_suffix_start\
    \ = 0;\n    let mut palindrome_suffix_end = 0;\n    let mut string_length = string.len();\n\
    \    let mut string_chars = string.chars();\n    let mut string_chars_rev = string.chars().rev();\n\
    \    let mut string_chars_rev_peekable = string.chars().rev().peekable();\n  \
    \  let mut string_chars_peekable = string.chars().peekable();\n    let mut string_chars_rev_peekable_peek\
    \ = string_chars_rev_peekable.peek();\n    let mut string_chars_peekable_peek\
    \ = string_chars_peekable.peek();\n    let mut string_chars_rev_peekable_next\
    \ = string_chars_rev_peekable.next();\n    let mut string_chars_peekable_next\
    \ = string_chars_peekable.next();\n    let mut string_chars_rev_peekable_next_peek\
    \ = string_chars_rev_peekable.peek();\n    let mut string_chars_peekable_next_peek\
    \ = string_chars_peekable.peek();\n    let mut string_chars_rev_peekable_next_next\
    \ = string_chars_rev_peekable.next();\n    let mut string_chars_peekable_next_next\
    \ = string_chars_peekable.next();\n    let mut string_chars_rev_peekable_next_next_peek\
    \ = string_chars_rev_peekable.peek();\n    let mut string_chars_peekable_next_next_peek\
    \ = string_chars_peekable.peek();\n    let mut string_chars_rev_peekable_next_next_next\
    \ = string_chars_rev_peekable.next();\n    let mut string_chars_pe\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpivu2bt3a.rs:33:28\n   |\n\
    33 |     let mut string_chars_pe\n   |                            ^ help: add\
    \ `;` here\n34 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpivu2bt3a.rs:11:39\n   |\n11 | fn make_palindrome(string: String)\
    \ -> String {\n   |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_length = 0;\n    let mut current_palindrome_suffix\
    \ = String::new();\n    let mut current_palindrome_suffix_length = 0;\n    for\
    \ (i, c) in string.chars().enumerate() {\n        current_palindrome_suffix.insert(0,\
    \ c);\n        current_palindrome_suffix_length += 1;\n        if is_palindrome(&current_palindrome_suffix)\
    \ {\n            longest_palindrome_suffix = current_palindrome_suffix.clone();\n\
    \            longest_palindrome_suffix_length = current_palindrome_suffix_length;\n\
    \        }\n        if i == string.len() - 1 {\n            break;\n        }\n\
    \        current_palindrome_suffix.remove(0);\n        current_palindrome_suffix_length\
    \ -= 1;\n    }\n    string.push_str(&longest_palindrome_suffix);\n    string.remove(0..longest_palindrome_suffix_length);\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpqtlbblae.rs:20:12\n   |\n20 |         if is_palindrome(&current_palindrome_suffix)\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqtlbblae.rs:31:19\n   |\n31 |     string.remove(0..longest_palindrome_suffix_length);\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`,\
    \ found struct `std::ops::Range`\n   |\n   = note: expected type `usize`\n   \
    \         found struct `std::ops::Range<{integer}>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if string.is_empty() {\n        return string;\n    }\n    let mut prefix\
    \ = string.clone();\n    let mut suffix = string.clone();\n    let mut palindrome\
    \ = String::new();\n    while !suffix.is_empty() {\n        if is_palindrome(&suffix)\
    \ {\n            palindrome.push_str(&suffix);\n            palindrome.push_str(&prefix.chars().rev().collect::<String>());\n\
    \            return palindrome;\n        }\n        prefix.pop();\n        suffix.remove(0);\n\
    \    }\n    panic!(\"Could not find a palindrome\");\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpnjryqxsa.rs:19:12\n   |\n19 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `palindrome`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    for i in 0..string.len() {\n        let suffix = &string[i..];\n        if\
    \ is_palindrome(suffix) {\n            longest_palindrome_suffix = suffix.to_string();\n\
    \            break;\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix.len()];\n    let mut prefix_reversed = prefix.chars().rev().collect::<String>();\n\
    \    string.push_str(&prefix_reversed);\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpyz0y4daj.rs:16:12\n   |\n16 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut longest_palindrome_length = 0;\n    let\
    \ mut longest_palindrome_index = 0;\n    let mut i = 0;\n    let mut j = string.len()\
    \ - 1;\n    let mut k = 0;\n    while i < j {\n        if string.chars().nth(i)\
    \ == string.chars().nth(j) {\n            k += 1;\n            if k > longest_palindrome_length\
    \ {\n                longest_palindrome_length = k;\n                longest_palindrome_index\
    \ = i;\n            }\n        } else {\n            k = 0;\n        }\n     \
    \   i += 1;\n        j -= 1;\n    }\n    if longest_palindrome_length > 0 {\n\
    \        suffix = string.chars().skip(longest_palindrome_index - longest_palindrome_length\
    \ + 1).collect();\n        prefix = string.chars().take(longest_palindrome_index\
    \ - longest_palindrome_length + 1).collect();\n        string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    }\n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp020lgl4u.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = String::new();\n\
    \    let mut palindrome_suffix_length = 0;\n    for i in 0..string.len() {\n \
    \       let suffix = &string[i..];\n        if is_palindrome(suffix) {\n     \
    \       palindrome_suffix = suffix.to_string();\n            palindrome_suffix_length\
    \ = palindrome_suffix.len();\n            break;\n        }\n    }\n    let prefix\
    \ = &string[..string.len() - palindrome_suffix_length];\n    string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpdb194v8p.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut suffix_len = 0;\n    let mut prefix_len\
    \ = 0;\n    let mut i = 0;\n    let mut j = string.len() - 1;\n    while i < j\
    \ {\n        if string.chars().nth(i) == string.chars().nth(j) {\n           \
    \ suffix.push(string.chars().nth(i).unwrap());\n            suffix_len += 1;\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            i = 0;\n\
    \            j -= 1;\n            suffix_len = 0;\n            suffix.clear();\n\
    \        }\n    }\n    i = 0;\n    j = string.len() - 1;\n    while i < j {\n\
    \        if string.chars().nth(i) == string.chars().nth(j) {\n            prefix.push(string.chars().nth(i).unwrap());\n\
    \            prefix_len += 1;\n            i += 1;\n            j -= 1;\n    \
    \    } else {\n            i += 1;\n            j = string.len() - 1;\n      \
    \      prefix_len = 0;\n            prefix.clear();\n        }\n    }\n    if\
    \ suffix_len > prefix_len {\n        string.push_str(&suffix);\n        string.push_str(&suffix.chars().rev().collect::<String>());\n\
    \    } else {\n        string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \        string.push_str(&prefix);\n    }\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpz1txvb7f.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut palindrome = String::new();\n    let mut\
    \ palindrome_length = 0;\n    let mut i = 0;\n    let mut j = string.len() - 1;\n\
    \    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            palindrome_length += 1;\n            palindrome.push(string.chars().nth(i).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            i = 0;\n\
    \            j -= 1;\n            palindrome_length = 0;\n            palindrome.clear();\n\
    \        }\n    }\n    if palindrome_length > 0 {\n        suffix = palindrome.clone();\n\
    \        prefix = palindrome.chars().rev().collect();\n        string.drain(..palindrome_length);\n\
    \    }\n    string.push_str(&prefix);\n    string.push_str(&suffix);\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpm4ahppbv.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = String::new();\n\
    \    let mut palindrome_prefix = String::new();\n    let mut palindrome_suffix_length\
    \ = 0;\n    let mut palindrome_prefix_length = 0;\n    let mut i = 0;\n    let\
    \ mut j = string.len() - 1;\n    while i < j {\n        if string.chars().nth(i)\
    \ == string.chars().nth(j) {\n            palindrome_suffix.push(string.chars().nth(i).unwrap());\n\
    \            palindrome_prefix.push(string.chars().nth(j).unwrap());\n       \
    \     palindrome_suffix_length += 1;\n            palindrome_prefix_length +=\
    \ 1;\n            i += 1;\n            j -= 1;\n        } else {\n           \
    \ palindrome_suffix = String::new();\n            palindrome_prefix = String::new();\n\
    \            palindrome_suffix_length = 0;\n            palindrome_prefix_length\
    \ = 0;\n            i = 0;\n            j -= 1;\n        }\n    }\n    if palindrome_suffix_length\
    \ == 0 {\n        string.push(string.chars().nth(0).unwrap());\n    } else {\n\
    \        string.push_str(&palindrome_prefix.chars().rev().collect::<String>());\n\
    \    }\n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpm3yruant.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_len = 0;\n    for i in 0..string.len()\
    \ {\n        let suffix = &string[i..];\n        if is_palindrome(suffix) {\n\
    \            if suffix.len() > longest_palindrome_suffix_len {\n             \
    \   longest_palindrome_suffix = suffix.to_string();\n                longest_palindrome_suffix_len\
    \ = suffix.len();\n            }\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix_len];\n    let reversed_prefix = reverse(prefix);\n\
    \    string.push_str(&reversed_prefix);\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp7myzv_0v.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `reverse` in this scope\n  --> /tmp/tmp7myzv_0v.rs:25:27\n   |\n\
    25 |     let reversed_prefix = reverse(prefix);\n   |                        \
    \   ^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_length = 0;\n    let mut longest_palindrome_suffix_index\
    \ = 0;\n    let mut i = 0;\n    while i < string.len() {\n        let mut j =\
    \ i;\n        let mut k = i;\n        while k < string.len() && string.chars().nth(k)\
    \ == string.chars().nth(j) {\n            k += 1;\n            j -= 1;\n     \
    \   }\n        if j < 0 && k - j - 1 > longest_palindrome_suffix_length {\n  \
    \          longest_palindrome_suffix_length = k - j - 1;\n            longest_palindrome_suffix_index\
    \ = i;\n        }\n        i += 1;\n    }\n    if longest_palindrome_suffix_length\
    \ > 0 {\n        let mut prefix = String::new();\n        for i in 0..longest_palindrome_suffix_index\
    \ {\n            prefix.push(string.chars().nth(i).unwrap());\n        }\n   \
    \     string.push_str(&prefix.chars().rev().collect::<String>());\n    }\n   \
    \ string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpst2vreyo.rs:22:13\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut prefix = String::new();\n    let mut\
    \ suffix = String::new();\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_len = 0;\n    let mut i = 0;\n    let mut\
    \ j = string.len() - 1;\n    while i < j {\n        if string.chars().nth(i) ==\
    \ string.chars().nth(j) {\n            suffix.push(string.chars().nth(i).unwrap());\n\
    \            prefix.push(string.chars().nth(j).unwrap());\n            if suffix.len()\
    \ > longest_palindrome_suffix_len {\n                longest_palindrome_suffix\
    \ = suffix.clone();\n                longest_palindrome_suffix_len = suffix.len();\n\
    \            }\n            i += 1;\n            j -= 1;\n        } else {\n \
    \           suffix.clear();\n            prefix.clear();\n            i += 1;\n\
    \        }\n    }\n    let mut prefix = prefix.chars().rev().collect::<String>();\n\
    \    string.push_str(&prefix);\n    string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp55_qyopw.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = String::new();\n\
    \    let mut palindrome_prefix = String::new();\n    let mut longest_palindrome_suffix_length\
    \ = 0;\n    let mut longest_palindrome_suffix_index = 0;\n    let mut longest_palindrome_prefix_length\
    \ = 0;\n    let mut longest_palindrome_prefix_index = 0;\n    let mut i = 0;\n\
    \    let mut j = string.len() - 1;\n    while i < j {\n        if string.chars().nth(i)\
    \ == string.chars().nth(j) {\n            if i == j {\n                palindrome_suffix.push(string.chars().nth(i).unwrap());\n\
    \                palindrome_prefix.push(string.chars().nth(i).unwrap());\n   \
    \         } else {\n                palindrome_suffix.push(string.chars().nth(i).unwrap());\n\
    \                palindrome_prefix.push(string.chars().nth(j).unwrap());\n   \
    \         }\n            if palindrome_suffix.len() > longest_palindrome_suffix_length\
    \ {\n                longest_palindrome_suffix_length = palindrome_suffix.len();\n\
    \                longest_palindrome_suffix_index = i;\n            }\n       \
    \     if palindrome_prefix.len() > longest_palindrome_prefix_length {\n      \
    \          longest_palindrome_prefix_length = palindrome_prefix.len();\n     \
    \           longest_palindrome_prefix_index = j;\n            }\n            i\
    \ += 1;\n            j -= 1;\n        } else {\n            if palindrome_suffix.len()\
    \ > longest_palindrome_suffix_length {\n                longest_palindrome_suffix_length\
    \ = palindrome_suffix.len();\n                longest_palindrome_suffix_index\
    \ = i;\n            }\n            if palindrome_prefix.len() > longest_palindrome_prefix_length\
    \ {\n                longest_palindrome_prefix_length = palindrome_prefix.len();\n\
    \n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpx3wbv2v8.rs:57:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n21 |     while i\
    \ < j {\n   |                 - unclosed delimiter\n...\n40 |         } else {\n\
    \   |                - unclosed delimiter\n...\n45 |             if palindrome_prefix.len()\
    \ > longest_palindrome_prefix_length {\n   |                                 \
    \                                          - this delimiter might not be properly\
    \ closed...\n...\n48 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n57 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx3wbv2v8.rs:21:5\n\
    \   |\n11 |   fn make_palindrome(string: String) -> String {\n   |           \
    \                              ------ expected `String` because of return type\n\
    ...\n21 | /     while i < j {\n22 | |         if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n23 | |             if i == j {\n24 | |                 palindrome_suffix.push(string.chars().nth(i).unwrap());\n\
    ...  |\n56 | |     assert_eq!(candidate(String::from(\"jerry\")), String::from(\"\
    jerryrrej\"));\n57 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = find_longest_palindrome_suffix(&string);\n\
    \    let prefix = &string[..string.len() - palindrome_suffix.len()];\n    let\
    \ prefix = prefix.chars().rev().collect::<String>();\n    string.push_str(&prefix);\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_longest_palindrome_suffix` in\
    \ this scope\n  --> /tmp/tmpg34agsp9.rs:13:33\n   |\n13 |     let mut palindrome_suffix\
    \ = find_longest_palindrome_suffix(&string);\n   |                           \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix = String::new();\n \
    \   let mut prefix = String::new();\n    let mut is_palindrome = false;\n    let\
    \ mut i = 0;\n    while !is_palindrome {\n        suffix.push(string.chars().nth(i).unwrap());\n\
    \        prefix.push(string.chars().nth(string.len() - i - 1).unwrap());\n   \
    \     if suffix == prefix {\n            is_palindrome = true;\n        }\n  \
    \      i += 1;\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'called `Option::unwrap()` on a `None` value',\
    \ /tmp/tmpjp2iufx2.rs:18:43\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix = String::new();\n \
    \   let mut prefix = String::new();\n    let mut i = 0;\n    let mut j = string.len()\
    \ - 1;\n    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            suffix.push(string.chars().nth(i).unwrap());\n            prefix.push(string.chars().nth(j).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            break;\n\
    \        }\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp0hlscr88.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = String::new();\n\
    \    let mut palindrome_prefix = String::new();\n    let mut i = 0;\n    let mut\
    \ j = string.len() - 1;\n    while i < j {\n        if string.chars().nth(i) ==\
    \ string.chars().nth(j) {\n            palindrome_suffix.push(string.chars().nth(i).unwrap());\n\
    \            palindrome_prefix.push(string.chars().nth(j).unwrap());\n       \
    \     i += 1;\n            j -= 1;\n        } else {\n            break;\n   \
    \     }\n    }\n    if i == j {\n        palindrome_suffix.push(string.chars().nth(i).unwrap());\n\
    \    }\n    string.push_str(&palindrome_prefix.chars().rev().collect::<String>());\n\
    \    string.push_str(&palindrome_suffix);\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpjwibuuty.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = String::new();\n\
    \    let mut palindrome_suffix_len = 0;\n    let mut palindrome_suffix_start =\
    \ 0;\n    let mut palindrome_suffix_end = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n    let\
    \ mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n   \
    \ let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n\
    \    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n\
    \    let mut z = 0;\n    let mut aa = 0;\n    let mut ab = 0;\n    let mut ac\
    \ = 0;\n    let mut ad = 0;\n    let mut ae = 0;\n    let mut af = 0;\n    let\
    \ mut ag = 0;\n    let mut ah = 0;\n    let mut ai = 0;\n    let mut aj = 0;\n\
    \    let mut ak = 0;\n    let mut al = 0;\n    let mut am = 0;\n    let mut an\
    \ = 0;\n    let mut ao = 0;\n    let mut ap = 0;\n    let mut aq = 0;\n    let\
    \ mut ar = 0;\n    let mut as_ = 0;\n    let mut at = 0;\n    let mut au = 0;\n\
    \    let mut av = 0;\n    let mut aw = 0;\n    let mut ax = 0;\n    let mut ay\
    \ = 0;\n    let mut az = 0;\n    let mut ba = 0;\n    let mut bb = 0;\n    let\
    \ mut bc = 0;\n    let mut bd = 0;\n    let mut be = 0;\n    let mut bf = 0;\n\
    \    let mut bg = 0;\n    let mut bh = 0;\n    let mut bi = 0;\n    let mut bj\
    \ = 0\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpkqp7m_1l.rs:70:19\n   |\n\
    70 |     let mut bj = 0\n   |                   ^ help: add `;` here\n71 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkqp7m_1l.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix = string.clone();\n\
    \    let mut prefix = String::new();\n    while !is_palindrome(&suffix) {\n  \
    \      prefix.push(suffix.pop().unwrap());\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpeeogr1k8.rs:15:12\n   |\n15 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_len = 0;\n    let mut longest_palindrome_suffix_start\
    \ = 0;\n    let mut longest_palindrome_suffix_end = 0;\n    let mut longest_palindrome_suffix_start_index\
    \ = 0;\n    let mut longest_palindrome_suffix_end_index = 0;\n    let mut longest_palindrome_suffix_len_index\
    \ = 0;\n    let mut longest_palindrome_suffix_start_index_index = 0;\n    let\
    \ mut longest_palindrome_suffix_end_index_index = 0;\n    let mut longest_palindrome_suffix_start_index_index_index\
    \ = 0;\n    let mut longest_palindrome_suffix_end_index_index_index = 0;\n   \
    \ let mut longest_palindrome_suffix_len_index_index = 0;\n    let mut longest_palindrome_suffix_len_index_index_index\
    \ = 0;\n    let mut longest_palindrome_suffix_len_index_index_index_index = 0;\n\
    \    let mut longest_palindrome_suffix_len_index_index_index_index_index = 0;\n\
    \    let mut longest_palindrome_suffix_len_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_palindrome_suffix_len_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_palindrome_suffix_len_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_palindrome_suffix_len_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_palindrome_suffix_len_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_palindrome_suffix_len_index_index_index_index_index_index_index_index\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdmys1hyt.rs:33:90\n   |\n\
    33 |     let mut longest_palindrome_suffix_len_index_index_index_index_index_index_index_index\n\
    \   |                                                                        \
    \                  ^ help: add `;` here\n34 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdmys1hyt.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut prefix = String::new();\n \
    \   let mut suffix = String::new();\n    let mut i = 0;\n    while i < string.len()\
    \ {\n        let (p, s) = string.split_at(i);\n        if is_palindrome(s) {\n\
    \            prefix = p.to_string();\n            suffix = s.to_string();\n  \
    \          break;\n        }\n        i += 1;\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp2_ug4jal.rs:18:12\n   |\n18 |         if is_palindrome(s) {\n   |  \
    \          ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_len = 0;\n    for i in 0..string.len()\
    \ {\n        let suffix = &string[i..];\n        if is_palindrome(suffix) {\n\
    \            if suffix.len() > longest_palindrome_suffix_len {\n             \
    \   longest_palindrome_suffix = suffix.to_string();\n                longest_palindrome_suffix_len\
    \ = suffix.len();\n            }\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix_len];\n    string.push_str(&reverse(prefix));\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpq0bm31ar.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `reverse` in this scope\n  --> /tmp/tmpq0bm31ar.rs:25:22\n   |\n\
    25 |     string.push_str(&reverse(prefix));\n   |                      ^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix = String::new();\n \
    \   let mut prefix = String::new();\n    let mut longest_palindrome_length = 0;\n\
    \    for i in 0..string.len() {\n        let (mut suffix_length, mut prefix_length)\
    \ = (0, 0);\n        for j in 0..i {\n            if string.chars().nth(i - j\
    \ - 1) == string.chars().nth(i + j) {\n                suffix_length += 1;\n \
    \           } else {\n                break;\n            }\n        }\n     \
    \   for j in 0..i + 1 {\n            if string.chars().nth(i - j) == string.chars().nth(i\
    \ + j) {\n                prefix_length += 1;\n            } else {\n        \
    \        break;\n            }\n        }\n        if suffix_length > longest_palindrome_length\
    \ {\n            longest_palindrome_length = suffix_length;\n            suffix\
    \ = string[i - suffix_length + 1..i + 1].to_string();\n        }\n        if prefix_length\
    \ > longest_palindrome_length {\n            longest_palindrome_length = prefix_length;\n\
    \            prefix = string[i - prefix_length + 1..i + prefix_length].to_string();\n\
    \        }\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpuv5md8tw.rs:38:29\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix = String::new();\n \
    \   let mut prefix = String::new();\n    let mut i = 0;\n    while i < string.len()\
    \ {\n        let (s, p) = find_palindrome_suffix(&string, i);\n        if s.len()\
    \ > suffix.len() {\n            suffix = s;\n            prefix = p;\n       \
    \ }\n        i += 1;\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_palindrome_suffix` in this scope\n\
    \  --> /tmp/tmprrw8bsuh.rs:17:22\n   |\n17 |         let (s, p) = find_palindrome_suffix(&string,\
    \ i);\n   |                      ^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut palindrome = String::new();\n    let mut\
    \ max_palindrome_length = 0;\n    let mut max_palindrome_index = 0;\n    let mut\
    \ string_length = string.len();\n\n    for i in 0..string_length {\n        suffix.push(string.pop().unwrap());\n\
    \        if is_palindrome(&string) {\n            max_palindrome_length = string.len();\n\
    \            max_palindrome_index = i;\n            break;\n        }\n    }\n\
    \n    for _ in 0..max_palindrome_index {\n        prefix.push(suffix.pop().unwrap());\n\
    \    }\n\n    palindrome.push_str(&string);\n    palindrome.push_str(&prefix.chars().rev().collect::<String>());\n\
    \n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n   \
    \ assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp_epr1ank.rs:22:12\n   |\n22 |         if is_palindrome(&string) {\n\
    \   |            ^^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `palindrome`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut i = string.len();\n    while i > 0\
    \ {\n        if is_palindrome(&string[..i]) {\n            break;\n        }\n\
    \        i -= 1;\n    }\n    string.push_str(&string[..i].chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpq0c4lhti.rs:15:12\n   |\n15 |         if is_palindrome(&string[..i])\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string_chars = string.chars().collect::<Vec<char>>();\n    let mut\
    \ palindrome_suffix = String::new();\n    let mut palindrome_prefix = String::new();\n\
    \    let mut palindrome_suffix_length = 0;\n    let mut palindrome_prefix_length\
    \ = 0;\n    let mut palindrome_length = 0;\n    let mut palindrome_start = 0;\n\
    \    let mut palindrome_end = 0;\n    let mut palindrome_center = 0;\n    let\
    \ mut palindrome_center_left = 0;\n    let mut palindrome_center_right = 0;\n\
    \    let mut palindrome_center_left_length = 0;\n    let mut palindrome_center_right_length\
    \ = 0;\n    let mut palindrome_center_length = 0;\n    let mut palindrome_center_start\
    \ = 0;\n    let mut palindrome_center_end = 0;\n    let mut palindrome_center_left_start\
    \ = 0;\n    let mut palindrome_center_left_end = 0;\n    let mut palindrome_center_right_start\
    \ = 0;\n    let mut palindrome_center_right_end = 0;\n    let mut palindrome_center_left_center\
    \ = 0;\n    let mut palindrome_center_right_center = 0;\n    let mut palindrome_center_left_center_left\
    \ = 0;\n    let mut palindrome_center_left_center_right = 0;\n    let mut palindrome_center_right_center_left\
    \ = 0;\n    let mut palindrome_center_right_center_right = 0;\n    let mut palindrome_center_left_center_left_length\
    \ = 0;\n    let mut palindrome_center_left_center_right_length = 0;\n    let mut\
    \ palindrome_center_right_center_left_length = 0;\n    let mut palindrome_center_right_center_right_length\
    \ = 0;\n    let mut palindrome_center_left_center_length = 0;\n    let mut palindrome_center_right_center_length\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpt16nvdke.rs:43:50\n   |\n\
    43 |     let mut palindrome_center_right_center_length\n   |                 \
    \                                 ^ help: add `;` here\n44 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt16nvdke.rs:11:39\n \
    \  |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    for i in 0..string.len() {\n        let suffix = &string[i..];\n        if\
    \ is_palindrome(suffix) {\n            longest_palindrome_suffix = suffix.to_string();\n\
    \            break;\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix.len()];\n    let prefix_reversed = reverse_string(prefix);\n\
    \    string.push_str(&prefix_reversed);\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpboodctit.rs:16:12\n   |\n16 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `reverse_string` in this scope\n  --> /tmp/tmpboodctit.rs:22:27\n\
    \   |\n22 |     let prefix_reversed = reverse_string(prefix);\n   |          \
    \                 ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_length = 0;\n    for i in 0..string.len()\
    \ {\n        let suffix = &string[i..];\n        if is_palindrome(suffix) {\n\
    \            if suffix.len() > longest_palindrome_suffix_length {\n          \
    \      longest_palindrome_suffix = suffix.to_string();\n                longest_palindrome_suffix_length\
    \ = suffix.len();\n            }\n        }\n    }\n    string.push_str(&string[..string.len()\
    \ - longest_palindrome_suffix_length].chars().rev().collect::<String>());\n  \
    \  string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp225uaayt.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    for i in 0..string.len() {\n        let suffix = string.split_off(string.len()\
    \ - i);\n        if is_palindrome(&suffix) {\n            longest_palindrome_suffix\
    \ = suffix;\n            break;\n        }\n    }\n    string.push_str(&longest_palindrome_suffix);\n\
    \    string.push_str(&string[..string.len() - longest_palindrome_suffix.len()].chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpmf9q2q6m.rs:16:12\n   |\n16 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut longest_suffix_len = 0;\n    let mut longest_suffix_start\
    \ = 0;\n    let mut longest_suffix_end = 0;\n    let mut longest_prefix_len =\
    \ 0;\n    let mut longest_prefix_start = 0;\n    let mut longest_prefix_end =\
    \ 0;\n    let mut i = 0;\n    let mut j = string.len() - 1;\n    while i < j {\n\
    \        if string.chars().nth(i) == string.chars().nth(j) {\n            if i\
    \ == j {\n                longest_suffix_len += 1;\n                longest_suffix_start\
    \ = i;\n                longest_suffix_end = j;\n            } else {\n      \
    \          longest_suffix_len += 2;\n                longest_suffix_start = i;\n\
    \                longest_suffix_end = j;\n            }\n        } else {\n  \
    \          if longest_suffix_len > longest_prefix_len {\n                longest_prefix_len\
    \ = longest_suffix_len;\n                longest_prefix_start = longest_suffix_start;\n\
    \                longest_prefix_end = longest_suffix_end;\n            }\n   \
    \         longest_suffix_len = 0;\n            longest_suffix_start = 0;\n   \
    \         longest_suffix_end = 0;\n        }\n        i += 1;\n        j -= 1;\n\
    \    }\n    if longest_suffix_len > longest_prefix_len {\n        longest_prefix_len\
    \ = longest_suffix_len;\n        longest_prefix_start = longest_suffix_start;\n\
    \        longest_prefix_end = longest_suffix_end;\n    }\n    if longest_prefix_len\
    \ > 0 {\n        suffix = string[longest_prefix_start..longest_prefix_end + 1].to_string();\n\
    \        prefix = string[0..longest_prefix_start].to_string();\n        prefix\
    \ = prefix.chars().rev().collect();\n        string.push_str(&prefix);\n    }\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp7704ppwr.rs:22:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_length = 0;\n    let mut longest_palindrome_suffix_index\
    \ = 0;\n    for i in 0..string.len() {\n        let suffix = &string[i..];\n \
    \       let suffix_length = suffix.len();\n        if is_palindrome(suffix) &&\
    \ suffix_length > longest_palindrome_suffix_length {\n            longest_palindrome_suffix\
    \ = suffix.to_string();\n            longest_palindrome_suffix_length = suffix_length;\n\
    \            longest_palindrome_suffix_index = i;\n        }\n    }\n    let prefix\
    \ = &string[..longest_palindrome_suffix_index];\n    string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpanqxenmz.rs:19:12\n   |\n19 |         if is_palindrome(suffix) && suffix_length\
    \ > longest_palindrome_suffix_length {\n   |            ^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_len = 0;\n    let mut string_len = string.len();\n\
    \    let mut i = 0;\n    while i < string_len {\n        let mut j = 1;\n    \
    \    while i - j >= 0 && i + j < string_len && string.chars().nth(i - j).unwrap()\
    \ == string.chars().nth(i + j).unwrap() {\n            j += 1;\n        }\n  \
    \      if j > longest_palindrome_suffix_len {\n            longest_palindrome_suffix_len\
    \ = j;\n            longest_palindrome_suffix = string.chars().skip(i - j + 1).take(2\
    \ * j - 1).collect();\n        }\n        i += 1;\n    }\n    let mut prefix =\
    \ string.chars().take(string_len - longest_palindrome_suffix_len).collect::<String>();\n\
    \    prefix.chars().rev().chain(longest_palindrome_suffix.chars()).collect()\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpjx_rebut.rs:19:15\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = String::new();\n\
    \    let mut palindrome_prefix = String::new();\n    let mut i = string.len();\n\
    \    while i > 0 {\n        let (prefix, suffix) = string.split_at(i);\n     \
    \   if is_palindrome(suffix) {\n            palindrome_suffix = suffix.to_string();\n\
    \            palindrome_prefix = prefix.chars().rev().collect();\n           \
    \ break;\n        }\n        i -= 1;\n    }\n    format!(\"{}{}\", string, palindrome_prefix)\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp9f7pdb3h.rs:18:12\n   |\n18 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_length = 0;\n    let mut longest_palindrome_suffix_index\
    \ = 0;\n    let mut string_length = string.len();\n    for i in 0..string_length\
    \ {\n        let mut is_palindrome = true;\n        for j in 0..i {\n        \
    \    if string.chars().nth(j) != string.chars().nth(i - j) {\n               \
    \ is_palindrome = false;\n                break;\n            }\n        }\n \
    \       if is_palindrome {\n            if i > longest_palindrome_suffix_length\
    \ {\n                longest_palindrome_suffix_length = i;\n                longest_palindrome_suffix_index\
    \ = i;\n            }\n        }\n    }\n    if longest_palindrome_suffix_length\
    \ > 0 {\n        longest_palindrome_suffix = string.chars().skip(longest_palindrome_suffix_index).collect();\n\
    \        string.truncate(longest_palindrome_suffix_index);\n        string.push_str(&longest_palindrome_suffix.chars().rev().collect::<String>());\n\
    \    }\n    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyz\"`,\n right: `\"xyzyx\"`', /tmp/tmpydwz84ph.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut prefix = String::new();\n \
    \   let mut suffix = String::new();\n    let mut is_palindrome = false;\n    for\
    \ i in 0..string.len() {\n        let (pre, suf) = string.split_at(i);\n     \
    \   if suf == suf.chars().rev().collect::<String>() {\n            prefix = pre.to_string();\n\
    \            suffix = suf.to_string();\n            is_palindrome = true;\n  \
    \      }\n    }\n    if is_palindrome {\n        result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyxyx\"`,\n right: `\"xyx\"`', /tmp/tmp21sbwjz6.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = String::new();\n\
    \    let mut palindrome_prefix = String::new();\n    let mut i = 0;\n    let mut\
    \ j = string.len() - 1;\n    while i < j {\n        if string.chars().nth(i) ==\
    \ string.chars().nth(j) {\n            palindrome_suffix.push(string.chars().nth(i).unwrap());\n\
    \            palindrome_prefix.push(string.chars().nth(j).unwrap());\n       \
    \     i += 1;\n            j -= 1;\n        } else {\n            i = 0;\n   \
    \         j -= 1;\n            palindrome_suffix.clear();\n            palindrome_prefix.clear();\n\
    \        }\n    }\n    string.push_str(&palindrome_prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp6_t2shrh.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut prefix = String::new();\n    let mut\
    \ suffix = String::new();\n    let mut longest_palindrome_length = 0;\n    let\
    \ mut longest_palindrome_start = 0;\n    let mut longest_palindrome_end = 0;\n\
    \    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n\
    \    let mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n\
    \    let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n\
    \    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n\
    \    let mut y = 0;\n    let mut z = 0;\n    let mut aa = 0;\n    let mut bb =\
    \ 0;\n    let mut cc = 0;\n    let mut dd = 0;\n    let mut ee = 0;\n    let mut\
    \ ff = 0;\n    let mut gg = 0;\n    let mut hh = 0;\n    let mut ii = 0;\n   \
    \ let mut jj = 0;\n    let mut kk = 0;\n    let mut ll = 0;\n    let mut mm =\
    \ 0;\n    let mut nn = 0;\n    let mut oo = 0;\n    let mut pp = 0;\n    let mut\
    \ qq = 0;\n    let mut rr = 0;\n    let mut ss = 0;\n    let mut tt = 0;\n   \
    \ let mut uu = 0;\n    let mut vv = 0;\n    let mut ww = 0;\n    let mut xx =\
    \ 0;\n    let mut yy = 0;\n    let mut zz = 0;\n    let mut aaa = 0;\n    let\
    \ mut bbb = 0;\n    let mut ccc = 0;\n    let mut ddd = 0;\n    let mut eee =\
    \ 0;\n    let mut fff = 0;\n    let mut ggg = 0;\n    let mut hhh = 0;\n\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt8q_wf53.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut palindrome = String::new();\n    let mut\
    \ i = 0;\n    let mut j = string.len() - 1;\n    while i < j {\n        if string.chars().nth(i)\
    \ == string.chars().nth(j) {\n            suffix.push(string.chars().nth(i).unwrap());\n\
    \            prefix.push(string.chars().nth(j).unwrap());\n            i += 1;\n\
    \            j -= 1;\n        } else {\n            if suffix.len() > 0 {\n  \
    \              palindrome.push_str(&suffix);\n                palindrome.push_str(&prefix.chars().rev().collect::<String>());\n\
    \                return palindrome;\n            } else {\n                palindrome.push(string.chars().nth(i).unwrap());\n\
    \                palindrome.push_str(&string.chars().rev().collect::<String>());\n\
    \                return palindrome;\n            }\n        }\n    }\n    if suffix.len()\
    \ > 0 {\n        palindrome.push_str(&suffix);\n        palindrome.push_str(&prefix.chars().rev().collect::<String>());\n\
    \        return palindrome;\n    } else {\n        palindrome.push(string.chars().nth(i).unwrap());\n\
    \        palindrome.push_str(&string.chars().rev().collect::<String>());\n   \
    \     return palindrome;\n    }\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp18p0hg4_.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    for i in 0..string.len() {\n        let suffix = string.split_off(string.len()\
    \ - i);\n        if is_palindrome(&suffix) {\n            longest_palindrome_suffix\
    \ = suffix;\n            break;\n        }\n    }\n    let prefix = string.chars().rev().collect::<String>();\n\
    \    string.push_str(&prefix);\n    string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp0r9y4k2e.rs:16:12\n   |\n16 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix = String::new();\n \
    \   let mut prefix = String::new();\n    let mut prefix_len = 0;\n    let mut\
    \ suffix_len = 0;\n    let mut max_len = 0;\n    let mut i = 0;\n    let mut j\
    \ = string.len() - 1;\n    while i < j {\n        if string.chars().nth(i) ==\
    \ string.chars().nth(j) {\n            if i == j - 1 {\n                max_len\
    \ = 2;\n                suffix_len = 2;\n                suffix = string[i..j\
    \ + 1].to_string();\n            } else {\n                max_len = j - i + 1;\n\
    \                suffix_len = j - i + 1;\n                suffix = string[i..j\
    \ + 1].to_string();\n            }\n        }\n        i += 1;\n        j -= 1;\n\
    \    }\n    if max_len == 0 {\n        return string;\n    }\n    prefix_len =\
    \ string.len() - suffix_len;\n    prefix = string[0..prefix_len].to_string();\n\
    \    result.push_str(&prefix.chars().rev().collect::<String>());\n    result\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp26i0939b.rs:19:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut s = string.clone();\n    let mut longest_palindrome_suffix = String::new();\n\
    \    for i in 0..s.len() {\n        let suffix = &s[i..];\n        if is_palindrome(suffix)\
    \ {\n            longest_palindrome_suffix = suffix.to_string();\n           \
    \ break;\n        }\n    }\n    let prefix = &s[..s.len() - longest_palindrome_suffix.len()];\n\
    \    let mut prefix_reversed = prefix.chars().rev().collect::<String>();\n   \
    \ s.push_str(&prefix_reversed);\n    s\n}\n\nfn main() {\n    let candidate =\
    \ make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpxlwuacbt.rs:16:12\n   |\n16 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix = String::new();\n \
    \   let mut prefix = String::new();\n    let mut i = 0;\n    let mut j = string.len()\
    \ - 1;\n    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            suffix.push(string.chars().nth(i).unwrap());\n            prefix.push(string.chars().nth(j).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            i = 0;\n\
    \            j -= 1;\n            suffix.clear();\n            prefix.clear();\n\
    \        }\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpzkamny67.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut longest_palindrome_suffix_length = 0;\n\
    \    let mut longest_palindrome_suffix_index = 0;\n    let mut current_palindrome_suffix_length\
    \ = 0;\n    let mut current_palindrome_suffix_index = 0;\n    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n\
    \    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n\
    \    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n\
    \    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n\
    \    let mut z = 0;\n    let mut aa = 0;\n    let mut bb = 0;\n    let mut cc\
    \ = 0;\n    let mut dd = 0;\n    let mut ee = 0;\n    let mut ff = 0;\n    let\
    \ mut gg = 0;\n    let mut hh = 0;\n    let mut ii = 0;\n    let mut jj = 0;\n\
    \    let mut kk = 0;\n    let mut ll = 0;\n    let mut mm = 0;\n    let mut nn\
    \ = 0;\n    let mut oo = 0;\n    let mut pp = 0;\n    let mut qq = 0;\n    let\
    \ mut rr = 0;\n    let mut ss = 0;\n    let mut tt = 0;\n    let mut uu = 0;\n\
    \    let mut vv = 0;\n    let mut ww = 0;\n    let mut xx = 0;\n    let mut yy\
    \ = 0;\n    let mut zz = 0;\n    let mut aaa = 0;\n    let mut bbb = 0;\n    let\
    \ mut ccc = 0;\n    let mut ddd = 0;\n    let mut eee = 0;\n   \n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjr_vqf6d.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut prefix = String::new();\n    let mut\
    \ suffix = String::new();\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_length = 0;\n    let mut i = 0;\n    let\
    \ mut j = string.len() - 1;\n    while i < j {\n        if string.chars().nth(i)\
    \ == string.chars().nth(j) {\n            suffix.push(string.chars().nth(i).unwrap());\n\
    \            prefix.push(string.chars().nth(j).unwrap());\n            if suffix.len()\
    \ > longest_palindrome_suffix_length {\n                longest_palindrome_suffix\
    \ = suffix.clone();\n                longest_palindrome_suffix_length = suffix.len();\n\
    \            }\n            i += 1;\n            j -= 1;\n        } else {\n \
    \           suffix.clear();\n            prefix.clear();\n            i += 1;\n\
    \        }\n    }\n    string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmppyv9ddyk.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix = string.clone();\n\
    \    let mut prefix = String::new();\n    while !is_palindrome(&suffix) {\n  \
    \      prefix.push(suffix.pop().unwrap());\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp6qk4vjd7.rs:15:12\n   |\n15 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_len = 0;\n    for i in 0..string.len()\
    \ {\n        let suffix = &string[i..];\n        if is_palindrome(suffix) {\n\
    \            if suffix.len() > longest_palindrome_suffix_len {\n             \
    \   longest_palindrome_suffix = suffix.to_string();\n                longest_palindrome_suffix_len\
    \ = suffix.len();\n            }\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix_len];\n    string.push_str(&reverse(prefix));\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpm5n36cob.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `reverse` in this scope\n  --> /tmp/tmpm5n36cob.rs:25:22\n   |\n\
    25 |     string.push_str(&reverse(prefix));\n   |                      ^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut prefix = String::new();\n \
    \   let mut suffix = String::new();\n    let mut is_palindrome = false;\n    for\
    \ (i, _) in string.chars().enumerate() {\n        prefix.push(string.chars().nth(i).unwrap());\n\
    \        suffix.push(string.chars().nth(string.len() - i - 1).unwrap());\n   \
    \     if prefix == suffix {\n            is_palindrome = true;\n            break;\n\
    \        }\n    }\n    if !is_palindrome {\n        result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyzzyx\"`,\n right: `\"xyzyx\"`', /tmp/tmpbiujs0cz.rs:34:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut palindrome = String::new();\n    let mut\
    \ i = 0;\n    let mut j = string.len() - 1;\n    while i < j {\n        if string.chars().nth(i)\
    \ == string.chars().nth(j) {\n            suffix.push(string.chars().nth(i).unwrap());\n\
    \            prefix.push(string.chars().nth(j).unwrap());\n            i += 1;\n\
    \            j -= 1;\n        } else {\n            break;\n        }\n    }\n\
    \    if i == j {\n        suffix.push(string.chars().nth(i).unwrap());\n    }\n\
    \    palindrome.push_str(&suffix);\n    palindrome.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpit7r7d3i.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    for i in 0..string.len() {\n        let suffix = &string[i..];\n        if\
    \ is_palindrome(suffix) {\n            longest_palindrome_suffix = suffix.to_string();\n\
    \            break;\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix.len()];\n    string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpv5d1vf2s.rs:16:12\n   |\n16 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut i = 0;\n    let mut j = string.len() -\
    \ 1;\n    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            suffix.push(string.chars().nth(i).unwrap());\n            i +=\
    \ 1;\n            j -= 1;\n        } else {\n            i = 0;\n            j\
    \ -= 1;\n            prefix.push(string.chars().nth(j + 1).unwrap());\n      \
    \  }\n    }\n    string.push_str(&prefix);\n    string.push_str(&suffix);\n  \
    \  string.push_str(&prefix.chars().rev().collect::<String>());\n    string\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp0zttb5a5.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut prefix = String::new();\n    let mut\
    \ suffix = String::new();\n    let mut longest_palindrome_length = 0;\n    let\
    \ mut longest_palindrome_index = 0;\n    for i in 0..string.len() {\n        let\
    \ (p, s) = string.split_at(i);\n        if is_palindrome(s) {\n            if\
    \ s.len() > longest_palindrome_length {\n                longest_palindrome_length\
    \ = s.len();\n                longest_palindrome_index = i;\n            }\n \
    \       }\n    }\n    let (p, s) = string.split_at(longest_palindrome_index);\n\
    \    prefix = p.to_string();\n    suffix = s.to_string();\n    prefix.push_str(&reverse(&prefix));\n\
    \    suffix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp423mggo3.rs:19:12\n   |\n19 |         if is_palindrome(s) {\n   |  \
    \          ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `reverse` in this scope\n  --> /tmp/tmp423mggo3.rs:29:22\n   |\n29\
    \ |     prefix.push_str(&reverse(&prefix));\n   |                      ^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_len = 0;\n    for i in 0..string.len()\
    \ {\n        let suffix = &string[i..];\n        if is_palindrome(suffix) {\n\
    \            if suffix.len() > longest_palindrome_suffix_len {\n             \
    \   longest_palindrome_suffix = suffix.to_string();\n                longest_palindrome_suffix_len\
    \ = suffix.len();\n            }\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix_len];\n    let prefix_reversed = reverse(prefix);\n\
    \    string.push_str(&prefix_reversed);\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpoeey84ac.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `reverse` in this scope\n  --> /tmp/tmpoeey84ac.rs:25:27\n   |\n\
    25 |     let prefix_reversed = reverse(prefix);\n   |                        \
    \   ^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed = string.clone();\n    reversed.reverse();\n    let mut\
    \ result = string.clone();\n    result.push_str(&reversed[string.len()..]);\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpy2lrw471.rs:13:14\n   |\n13 |     reversed.reverse();\n\
    \   |              ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut prefix = string.clone();\n\
    \    let mut suffix = String::new();\n    while !is_palindrome(&prefix) {\n  \
    \      suffix.push(prefix.pop().unwrap());\n    }\n    result.push_str(&suffix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpi0pv2up5.rs:15:12\n   |\n15 |     while !is_palindrome(&prefix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix = string.clone();\n\
    \    let mut prefix = String::new();\n    while !is_palindrome(&suffix) {\n  \
    \      prefix.push(suffix.pop().unwrap());\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpjnsnk8mw.rs:15:12\n   |\n15 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix = String::new();\n \
    \   let mut prefix = String::new();\n    let mut i = 0;\n    while i < string.len()\
    \ {\n        let mut j = string.len() - 1;\n        while j >= i {\n         \
    \   if string.chars().nth(i) == string.chars().nth(j) {\n                suffix.push(string.chars().nth(i).unwrap());\n\
    \                prefix.push(string.chars().nth(j).unwrap());\n              \
    \  i += 1;\n                j -= 1;\n            } else {\n                break;\n\
    \            }\n        }\n        if j < i {\n            break;\n        }\n\
    \        suffix.clear();\n        prefix.clear();\n        i += 1;\n    }\n  \
    \  result.push_str(&prefix.chars().rev().collect::<String>());\n    result\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp34kjxxnx.rs:23:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_length = 0;\n    for i in 0..string.len()\
    \ {\n        let mut suffix = String::new();\n        for j in i..string.len()\
    \ {\n            suffix.push(string.chars().nth(j).unwrap());\n        }\n   \
    \     if is_palindrome(&suffix) {\n            if suffix.len() > longest_palindrome_suffix_length\
    \ {\n                longest_palindrome_suffix = suffix;\n                longest_palindrome_suffix_length\
    \ = suffix.len();\n            }\n        }\n    }\n    let mut prefix = String::new();\n\
    \    for i in 0..string.len() - longest_palindrome_suffix_length {\n        prefix.push(string.chars().nth(i).unwrap());\n\
    \    }\n    string.push_str(&prefix.chars().rev().collect::<String>());\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpb9st94es.rs:20:12\n   |\n20 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    if string.is_empty() {\n        return string;\n    }\n    let mut prefix\
    \ = string.clone();\n    let mut suffix = string.clone();\n    while !is_palindrome(&suffix)\
    \ {\n        suffix.pop();\n        prefix.remove(0);\n    }\n    suffix.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    suffix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp0l8g6k2z.rs:17:12\n   |\n17 |     while !is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = String::new();\n\
    \    let mut palindrome_suffix_length = 0;\n    let mut i = 0;\n    while i <\
    \ string.len() {\n        let mut j = 0;\n        while j <= i && string.chars().nth(i\
    \ - j) == string.chars().nth(i + j) {\n            j += 1;\n        }\n      \
    \  if j > palindrome_suffix_length {\n            palindrome_suffix_length = j;\n\
    \            palindrome_suffix = string.chars().skip(i - j + 1).take(j * 2 - 1).collect();\n\
    \        }\n        i += 1;\n    }\n    string.push_str(&palindrome_suffix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp63xad99t.rs:23:53\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome = String::new();\n\
    \    let mut longest_palindrome_length = 0;\n    for i in 0..string.len() {\n\
    \        let (prefix, suffix) = string.split_at(i);\n        if is_palindrome(suffix)\
    \ {\n            if suffix.len() > longest_palindrome_length {\n             \
    \   longest_palindrome = suffix.to_string();\n                longest_palindrome_length\
    \ = suffix.len();\n            }\n        }\n    }\n    let prefix = string.split_at(longest_palindrome_length).0;\n\
    \    let reversed_prefix = reverse_string(prefix);\n    string.push_str(&reversed_prefix);\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpm4prt8et.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `reverse_string` in this scope\n  --> /tmp/tmpm4prt8et.rs:25:27\n\
    \   |\n25 |     let reversed_prefix = reverse_string(prefix);\n   |          \
    \                 ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    for i in 0..string.len() {\n        let suffix = &string[i..];\n        if\
    \ is_palindrome(suffix) {\n            longest_palindrome_suffix = suffix.to_string();\n\
    \            break;\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix.len()];\n    let mut reversed_prefix = prefix.chars().rev().collect::<String>();\n\
    \    string.push_str(&reversed_prefix);\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpik1dxhcy.rs:16:12\n   |\n16 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = String::new();\n\
    \    let mut palindrome_prefix = String::new();\n    let mut palindrome_suffix_length\
    \ = 0;\n    let mut palindrome_prefix_length = 0;\n    let mut i = 0;\n    let\
    \ mut j = string.len() - 1;\n    while i < j {\n        if string.chars().nth(i)\
    \ == string.chars().nth(j) {\n            palindrome_suffix.push(string.chars().nth(i).unwrap());\n\
    \            palindrome_prefix.push(string.chars().nth(j).unwrap());\n       \
    \     palindrome_suffix_length += 1;\n            palindrome_prefix_length +=\
    \ 1;\n            i += 1;\n            j -= 1;\n        } else {\n           \
    \ break;\n        }\n    }\n    if palindrome_suffix_length == 0 {\n        return\
    \ string;\n    }\n    let mut string_prefix = String::new();\n    for _ in 0..palindrome_prefix_length\
    \ {\n        string_prefix.push(string.pop().unwrap());\n    }\n    string.push_str(&palindrome_prefix);\n\
    \    string.push_str(&string_prefix.chars().rev().collect::<String>());\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmptxpubsuw.rs:18:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut longest_palindrome_suffix_len = 0;\n  \
    \  let mut longest_palindrome_suffix_start = 0;\n    let mut longest_palindrome_suffix_end\
    \ = 0;\n    let mut longest_palindrome_prefix_len = 0;\n    let mut longest_palindrome_prefix_start\
    \ = 0;\n    let mut longest_palindrome_prefix_end = 0;\n    let mut i = 0;\n \
    \   let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n\
    \    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n\
    \    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n\
    \    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n\
    \    let mut z = 0;\n    let mut aa = 0;\n    let mut ab = 0;\n    let mut ac\
    \ = 0;\n    let mut ad = 0;\n    let mut ae = 0;\n    let mut af = 0;\n    let\
    \ mut ag = 0;\n    let mut ah = 0;\n    let mut ai = 0;\n    let mut aj = 0;\n\
    \    let mut ak = 0;\n    let mut al = 0;\n    let mut am = 0;\n    let mut an\
    \ = 0;\n    let mut ao = 0;\n    let mut ap = 0;\n    let mut aq = 0;\n    let\
    \ mut ar = 0;\n    let mut as_ = 0;\n    let mut at = 0;\n    let mut au = 0;\n\
    \    let mut av = 0;\n    let mut aw = 0;\n    let mut ax = 0;\n    let mut ay\
    \ = 0;\n    let mut az = 0;\n    let mut ba = 0;\n    let mut bb = 0;\n    let\
    \ mut bc = 0;\n\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpufdeiy_q.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_length = 0;\n    let mut longest_palindrome_suffix_index\
    \ = 0;\n    let mut index = 0;\n    for c in string.chars() {\n        let mut\
    \ palindrome_suffix = String::new();\n        let mut palindrome_suffix_length\
    \ = 0;\n        let mut palindrome_suffix_index = 0;\n        for (i, c) in string.chars().enumerate().skip(index)\
    \ {\n            palindrome_suffix.push(c);\n            if palindrome_suffix\
    \ == palindrome_suffix.chars().rev().collect::<String>() {\n                palindrome_suffix_length\
    \ = palindrome_suffix.len();\n                palindrome_suffix_index = i;\n \
    \           }\n        }\n        if palindrome_suffix_length > longest_palindrome_suffix_length\
    \ {\n            longest_palindrome_suffix = palindrome_suffix;\n            longest_palindrome_suffix_length\
    \ = palindrome_suffix_length;\n            longest_palindrome_suffix_index = palindrome_suffix_index;\n\
    \        }\n        index += 1;\n    }\n    if longest_palindrome_suffix_length\
    \ > 0 {\n        string.push_str(\n            &string[..longest_palindrome_suffix_index\
    \ - longest_palindrome_suffix_length + 1]\n                .chars()\n        \
    \        .rev()\n                .collect::<String>(),\n        );\n    }\n  \
    \  string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpefus4ial.rs:37:23\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut palindrome = String::new();\n    let mut\
    \ i = 0;\n    let mut j = string.len() - 1;\n    while i < j {\n        if string.chars().nth(i)\
    \ == string.chars().nth(j) {\n            suffix.push(string.chars().nth(i).unwrap());\n\
    \            prefix.push(string.chars().nth(j).unwrap());\n            i += 1;\n\
    \            j -= 1;\n        } else {\n            break;\n        }\n    }\n\
    \    if i == j {\n        suffix.push(string.chars().nth(i).unwrap());\n    }\n\
    \    palindrome.push_str(&suffix);\n    palindrome.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpbs6s60wc.rs:17:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix = String::new();\n \
    \   let mut prefix = String::new();\n    for i in 0..string.len() {\n        let\
    \ (s, p) = string.split_at(i);\n        if is_palindrome(s) {\n            suffix\
    \ = s.to_string();\n            prefix = p.to_string();\n        }\n    }\n  \
    \  result.push_str(&prefix.chars().rev().collect::<String>());\n    result\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpjsbnvn3r.rs:17:12\n   |\n17 |         if is_palindrome(s) {\n   |  \
    \          ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = String::new();\n\
    \    let mut palindrome_prefix = String::new();\n    let mut palindrome_suffix_len\
    \ = 0;\n    let mut palindrome_prefix_len = 0;\n    let mut i = 0;\n    let mut\
    \ j = string.len() - 1;\n    while i < j {\n        if string.chars().nth(i) ==\
    \ string.chars().nth(j) {\n            palindrome_suffix.push(string.chars().nth(i).unwrap());\n\
    \            palindrome_prefix.push(string.chars().nth(j).unwrap());\n       \
    \     palindrome_suffix_len += 1;\n            palindrome_prefix_len += 1;\n \
    \           i += 1;\n            j -= 1;\n        } else {\n            break;\n\
    \        }\n    }\n    if palindrome_suffix_len == 0 {\n        return string;\n\
    \    }\n    let mut palindrome_prefix = palindrome_prefix.chars().rev().collect::<String>();\n\
    \    let mut palindrome_suffix = palindrome_suffix.chars().rev().collect::<String>();\n\
    \    let mut palindrome_prefix_len = palindrome_prefix_len;\n    let mut palindrome_suffix_len\
    \ = palindrome_suffix_len;\n    while palindrome_prefix_len > 0 && palindrome_suffix_len\
    \ > 0 {\n        if palindrome_prefix.chars().nth(palindrome_prefix_len - 1) ==\
    \ palindrome_suffix.chars().nth(palindrome_suffix_len - 1) {\n            palindrome_prefix_len\
    \ -= 1;\n            palindrome_suffix_len -= 1;\n        } else {\n         \
    \   break;\n        }\n    }\n    palindrome_prefix = palindrome_prefix.chars().skip(palindrome_prefix_len).collect::<String>();\n\
    \    palindrome_suffix = palindrome_suffix.chars().skip(palindrome_suff\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpsnnt5g1v.rs:47:55\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - closing delimiter possibly meant for this\n\
    ...\n47 |     palindrome_suffix = palindrome_suffix.chars().skip(palindrome_suff\n\
    \   |                                                       ^ unclosed delimiter\n\
    48 | }\n   | ^ mismatched closing delimiter\n\nerror[E0425]: cannot find value\
    \ `palindrome_suff` in this scope\n  --> /tmp/tmpsnnt5g1v.rs:47:56\n   |\n47 |\
    \     palindrome_suffix = palindrome_suffix.chars().skip(palindrome_suff\n   |\
    \                                                        ^^^^^^^^^^^^^^^ help:\
    \ a local variable with a similar name exists: `palindrome_suffix`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsnnt5g1v.rs:47:25\n   |\n35 |       let mut\
    \ palindrome_suffix = palindrome_suffix.chars().rev().collect::<String>();\n \
    \  |                                   ---------------------------------------------------\
    \ expected due to this value\n...\n47 |       palindrome_suffix = palindrome_suffix.chars().skip(palindrome_suff\n\
    \   |  _________________________^\n48 | | }\n   | |_^ expected struct `String`,\
    \ found struct `Skip`\n   |\n   = note: expected struct `String`\n           \
    \   found struct `Skip<Chars<'_>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsnnt5g1v.rs:47:5\n\
    \   |\n11 |   fn make_palindrome(string: String) -> String {\n   |           \
    \                              ------ expected `String` because of return type\n\
    ...\n47 | /     palindrome_suffix = palindrome_suffix.chars().skip(palindrome_suff\n\
    48 | | }\n   | |_^ expected struct `String`, found `()`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    for i in 0..string.len() {\n        let suffix = string.split_off(string.len()\
    \ - i);\n        if is_palindrome(&suffix) {\n            longest_palindrome_suffix\
    \ = suffix;\n            break;\n        }\n    }\n    string.push_str(&longest_palindrome_suffix);\n\
    \    string.push_str(&string[..string.len() - longest_palindrome_suffix.len()].chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpdh9bf2rp.rs:16:12\n   |\n16 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut prefix = String::new();\n    let mut\
    \ suffix = String::new();\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_len = 0;\n    for i in 0..string.len()\
    \ {\n        let (prefix_str, suffix_str) = string.split_at(i);\n        let prefix\
    \ = prefix_str.to_string();\n        let suffix = suffix_str.to_string();\n  \
    \      if is_palindrome(&suffix) && suffix.len() > longest_palindrome_suffix_len\
    \ {\n            longest_palindrome_suffix = suffix;\n            longest_palindrome_suffix_len\
    \ = suffix.len();\n        }\n    }\n    string.push_str(&reverse(&prefix));\n\
    \    string.push_str(&longest_palindrome_suffix);\n    string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpf8jiq4bc.rs:21:12\n   |\n21 |         if is_palindrome(&suffix) && suffix.len()\
    \ > longest_palindrome_suffix_len {\n   |            ^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `reverse` in this scope\n \
    \ --> /tmp/tmpf8jiq4bc.rs:26:22\n   |\n26 |     string.push_str(&reverse(&prefix));\n\
    \   |                      ^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut longest_palindrome_length = 0;\n    let\
    \ mut longest_palindrome_index = 0;\n    for i in 0..string.len() {\n        let\
    \ mut j = 0;\n        while i - j >= 0 && i + j < string.len() {\n           \
    \ if string.chars().nth(i - j).unwrap() == string.chars().nth(i + j).unwrap()\
    \ {\n                j += 1;\n            } else {\n                break;\n \
    \           }\n        }\n        if j > longest_palindrome_length {\n       \
    \     longest_palindrome_length = j;\n            longest_palindrome_index = i;\n\
    \        }\n    }\n    suffix = string.chars().skip(longest_palindrome_index -\
    \ longest_palindrome_length + 1).take(longest_palindrome_length - 1).collect();\n\
    \    prefix = string.chars().take(longest_palindrome_index - longest_palindrome_length\
    \ + 1).collect();\n    string.push_str(&suffix.chars().rev().collect::<String>());\n\
    \    string.push_str(&prefix.chars().rev().collect::<String>());\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp4_vdetxt.rs:31:97\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut i = 0;\n    let mut j = string.len() -\
    \ 1;\n    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            suffix.push(string.chars().nth(i).unwrap());\n            prefix.push(string.chars().nth(j).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            i = 0;\n\
    \            suffix.clear();\n            j -= 1;\n        }\n    }\n    string.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpibc8ye9t.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = String::new();\n\
    \    let mut palindrome_prefix = String::new();\n    let mut longest_palindrome_suffix_len\
    \ = 0;\n    let mut longest_palindrome_suffix_start = 0;\n    let mut longest_palindrome_suffix_end\
    \ = 0;\n    let mut longest_palindrome_prefix_len = 0;\n    let mut longest_palindrome_prefix_start\
    \ = 0;\n    let mut longest_palindrome_prefix_end = 0;\n    let mut palindrome_suffix_len\
    \ = 0;\n    let mut palindrome_prefix_len = 0;\n    let mut palindrome_suffix_start\
    \ = 0;\n    let mut palindrome_suffix_end = 0;\n    let mut palindrome_prefix_start\
    \ = 0;\n    let mut palindrome_prefix_end = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n    let\
    \ mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n   \
    \ let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n\
    \    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n\
    \    let mut z = 0;\n    let mut aa = 0;\n    let mut bb = 0;\n    let mut cc\
    \ = 0;\n    let mut dd = 0;\n    let mut ee = 0;\n    let mut ff = 0;\n    let\
    \ mut gg = 0;\n    let mut hh = 0;\n    let mut ii = 0;\n    let mut jj = 0;\n\
    \    let mut kk = 0;\n    let mut ll = 0;\n    let mut mm = 0;\n    let mut nn\
    \ = 0;\n    let mut oo = 0;\n    let mut pp = 0;\n    let mut qq = 0\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7bs77m16.rs:61:19\n   |\n\
    61 |     let mut qq = 0\n   |                   ^ help: add `;` here\n62 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7bs77m16.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome_suffix = String::new();\n\
    \    let mut palindrome_suffix_len = 0;\n    let mut i = 0;\n    while i < string.len()\
    \ {\n        let mut j = 0;\n        while j <= i && string.chars().nth(i - j)\
    \ == string.chars().nth(i + j) {\n            j += 1;\n        }\n        if j\
    \ > palindrome_suffix_len {\n            palindrome_suffix_len = j;\n        \
    \    palindrome_suffix = string.chars().skip(i - j + 1).take(2 * j - 1).collect();\n\
    \        }\n        i += 1;\n    }\n    string.push_str(&palindrome_suffix.chars().rev().collect::<String>());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpkssrvklt.rs:23:53\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string.clone();\n    let mut longest_palindrome_suffix_len\
    \ = 0;\n    for i in 0..string.len() {\n        if string[i..].chars().eq(string[i..].chars().rev())\
    \ {\n            longest_palindrome_suffix_len = i;\n        }\n    }\n    palindrome.push_str(&string[..string.len()\
    \ - longest_palindrome_suffix_len].chars().rev().collect::<String>());\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xx\"`,\n right: `\"x\"`', /tmp/tmplh7xncqe.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut longest_palindrome_suffix =\
    \ 0;\n    for i in 0..string.len() {\n        if is_palindrome(&string[i..]) {\n\
    \            longest_palindrome_suffix = i;\n            break;\n        }\n \
    \   }\n    result.push_str(&string[..longest_palindrome_suffix].chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpbphgoaff.rs:15:12\n   |\n15 |         if is_palindrome(&string[i..])\
    \ {\n   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_length = 0;\n    for i in 0..string.len()\
    \ {\n        let suffix = string.split_off(i);\n        if is_palindrome(&suffix)\
    \ {\n            if suffix.len() > longest_palindrome_suffix_length {\n      \
    \          longest_palindrome_suffix = suffix;\n                longest_palindrome_suffix_length\
    \ = suffix.len();\n            }\n        }\n        string = suffix;\n    }\n\
    \    let prefix = string.split_off(longest_palindrome_suffix_length);\n    let\
    \ mut prefix_reversed = prefix.chars().rev().collect::<String>();\n    prefix_reversed.push_str(&longest_palindrome_suffix);\n\
    \    prefix_reversed\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpth4fi553.rs:17:12\n   |\n17 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_length = 0;\n    for i in 0..string.len()\
    \ {\n        let suffix = &string[i..];\n        if is_palindrome(suffix) {\n\
    \            if suffix.len() > longest_palindrome_suffix_length {\n          \
    \      longest_palindrome_suffix = suffix.to_string();\n                longest_palindrome_suffix_length\
    \ = suffix.len();\n            }\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix_length];\n    string.push_str(&reverse(prefix));\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp2_wj2yjp.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `reverse` in this scope\n  --> /tmp/tmp2_wj2yjp.rs:25:22\n   |\n\
    25 |     string.push_str(&reverse(prefix));\n   |                      ^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_len = 0;\n    for i in 0..string.len()\
    \ {\n        let suffix = &string[i..];\n        if is_palindrome(suffix) {\n\
    \            if suffix.len() > longest_palindrome_suffix_len {\n             \
    \   longest_palindrome_suffix = suffix.to_string();\n                longest_palindrome_suffix_len\
    \ = suffix.len();\n            }\n        }\n    }\n    let prefix = &string[..string.len()\
    \ - longest_palindrome_suffix_len];\n    let prefix_reversed = reverse(prefix);\n\
    \    string.push_str(&prefix_reversed);\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpcx3yf1zf.rs:17:12\n   |\n17 |         if is_palindrome(suffix) {\n \
    \  |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `reverse` in this scope\n  --> /tmp/tmpcx3yf1zf.rs:25:27\n   |\n\
    25 |     let prefix_reversed = reverse(prefix);\n   |                        \
    \   ^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut suffix = String::new();\n    let mut\
    \ prefix = String::new();\n    let mut palindrome = String::new();\n    let mut\
    \ i = 0;\n    let mut j = string.len() - 1;\n    let mut k = 0;\n    let mut l\
    \ = 0;\n    let mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n    let mut\
    \ p = 0;\n    let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n    let\
    \ mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n   \
    \ let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n    let mut aa = 0;\n\
    \    let mut ab = 0;\n    let mut ac = 0;\n    let mut ad = 0;\n    let mut ae\
    \ = 0;\n    let mut af = 0;\n    let mut ag = 0;\n    let mut ah = 0;\n    let\
    \ mut ai = 0;\n    let mut aj = 0;\n    let mut ak = 0;\n    let mut al = 0;\n\
    \    let mut am = 0;\n    let mut an = 0;\n    let mut ao = 0;\n    let mut ap\
    \ = 0;\n    let mut aq = 0;\n    let mut ar = 0;\n    let mut as_ = 0;\n    let\
    \ mut at = 0;\n    let mut au = 0;\n    let mut av = 0;\n    let mut aw = 0;\n\
    \    let mut ax = 0;\n    let mut ay = 0;\n    let mut az = 0;\n    let mut ba\
    \ = 0;\n    let mut bb = 0;\n    let mut bc = 0;\n    let mut bd = 0;\n    let\
    \ mut be = 0;\n    let mut bf = 0;\n    let mut bg = 0;\n    let mut bh = 0;\n\
    \    let mut bi = 0;\n    let mut bj = 0;\n    let mut bk = 0;\n    let mut bl\
    \ = 0;\n    let mut b\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnfgqt860.rs:72:14\n   |\n\
    72 |     let mut b\n   |              ^ help: add `;` here\n73 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnfgqt860.rs:11:39\n \
    \  |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix = String::new();\n \
    \   let mut prefix = String::new();\n    let mut i = 0;\n    while i < string.len()\
    \ {\n        let (mut s, mut p) = (suffix.clone(), prefix.clone());\n        suffix.push(string.chars().nth(i).unwrap());\n\
    \        prefix.insert(0, string.chars().nth(i).unwrap());\n        if is_palindrome(&suffix)\
    \ {\n            result.push_str(&p);\n            break;\n        }\n       \
    \ if is_palindrome(&prefix) {\n            result.push_str(&s.chars().rev().collect::<String>());\n\
    \            break;\n        }\n        i += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp5939e8ra.rs:20:12\n   |\n20 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_palindrome` in this scope\n  --> /tmp/tmp5939e8ra.rs:24:12\n\
    \   |\n24 |         if is_palindrome(&prefix) {\n   |            ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_len = 0;\n    let mut longest_palindrome_suffix_idx\
    \ = 0;\n    let mut string_len = string.len();\n    let mut string_chars = string.chars();\n\
    \    let mut string_chars_rev = string.chars().rev();\n    let mut string_chars_rev_len\
    \ = string_len;\n    let mut string_chars_rev_idx = string_len - 1;\n    let mut\
    \ string_chars_idx = 0;\n    let mut string_chars_rev_next = string_chars_rev.next();\n\
    \    let mut string_chars_next = string_chars.next();\n    while let Some(string_chars_rev_next_char)\
    \ = string_chars_rev_next {\n        if let Some(string_chars_next_char) = string_chars_next\
    \ {\n            if string_chars_rev_next_char == string_chars_next_char {\n \
    \               if string_chars_idx == string_chars_rev_idx {\n              \
    \      longest_palindrome_suffix_len += 1;\n                    longest_palindrome_suffix_idx\
    \ = string_chars_idx;\n                    longest_palindrome_suffix = string_chars_rev_next_char.to_string();\n\
    \                } else {\n                    longest_palindrome_suffix_len +=\
    \ 2;\n                    longest_palindrome_suffix_idx = string_chars_idx;\n\
    \                    longest_palindrome_suffix = string_chars_rev_next_char.to_string()\
    \ + &longest_palindrome_suffix;\n                }\n            } else {\n   \
    \             if string_chars_idx == string_chars_rev_idx {\n                \
    \    longest_palindrome_suffix_len = 0;\n                    longest_palindrome_suffix_idx\
    \ = 0;\n                    longest_palindrome_suffix = String::new();\n     \
    \           } else {\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpd7q1bqrk.rs:51:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n24 |     while let\
    \ Some(string_chars_rev_next_char) = string_chars_rev_next {\n   |           \
    \                                                             - unclosed delimiter\n\
    25 |         if let Some(string_chars_next_char) = string_chars_next {\n   | \
    \                                                                - unclosed delimiter\n\
    ...\n36 |             } else {\n   |                    - unclosed delimiter\n\
    ...\n41 |                 } else {\n   |                        - this delimiter\
    \ might not be properly closed...\n42 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n51 | }\n   |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpd7q1bqrk.rs:24:5\n   |\n11 |   fn make_palindrome(string:\
    \ String) -> String {\n   |                                         ------ expected\
    \ `String` because of return type\n...\n24 | /     while let Some(string_chars_rev_next_char)\
    \ = string_chars_rev_next {\n25 | |         if let Some(string_chars_next_char)\
    \ = string_chars_next {\n26 | |             if string_chars_rev_next_char == string_chars_next_char\
    \ {\n27 | |                 if string_chars_idx == string_chars_rev_idx {\n...\
    \  |\n50 | |     assert_eq!(candidate(String::from(\"jerry\")), String::from(\"\
    jerryrrej\"));\n51 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix = String::new();\n \
    \   let mut prefix = String::new();\n    let mut i = string.len();\n    while\
    \ i > 0 {\n        suffix.push(string.chars().nth(i - 1).unwrap());\n        prefix.push(string.chars().nth(string.len()\
    \ - i).unwrap());\n        if is_palindrome(&suffix) {\n            result.push_str(&prefix);\n\
    \            break;\n        }\n        i -= 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpv4pls2su.rs:19:12\n   |\n19 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut palindrome_suffix = find_palindrome_suffix(&string);\n\
    \    let mut prefix = string.chars().take(string.len() - palindrome_suffix.len()).collect::<String>();\n\
    \    prefix.chars().rev().for_each(|c| result.push(c));\n    result\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `find_palindrome_suffix` in this scope\n\
    \  --> /tmp/tmp14aeuitd.rs:13:33\n   |\n13 |     let mut palindrome_suffix = find_palindrome_suffix(&string);\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix = String::new();\n \
    \   let mut prefix = String::new();\n    let mut i = 0;\n    let mut j = string.len()\
    \ - 1;\n    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            suffix.push(string.chars().nth(i).unwrap());\n            prefix.push(string.chars().nth(j).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            i = 0;\n\
    \            j -= 1;\n            suffix.clear();\n            prefix.clear();\n\
    \        }\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp4tff5dqj.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix = String::new();\n \
    \   let mut prefix = String::new();\n    let mut i = 0;\n    let mut j = string.len()\
    \ - 1;\n    while i < j {\n        if string.chars().nth(i) == string.chars().nth(j)\
    \ {\n            suffix.push(string.chars().nth(i).unwrap());\n            prefix.push(string.chars().nth(j).unwrap());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            i = 0;\n\
    \            j -= 1;\n            suffix.clear();\n            prefix.clear();\n\
    \        }\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp7051q1qt.rs:16:17\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut longest_palindrome_suffix = String::new();\n\
    \    let mut longest_palindrome_suffix_length = 0;\n    let mut current_palindrome_suffix\
    \ = String::new();\n    let mut current_palindrome_suffix_length = 0;\n    let\
    \ mut current_palindrome_suffix_index = 0;\n    let mut current_palindrome_suffix_start_index\
    \ = 0;\n    let mut current_palindrome_suffix_end_index = 0;\n    let mut current_palindrome_suffix_start_index_in_string\
    \ = 0;\n    let mut current_palindrome_suffix_end_index_in_string = 0;\n    let\
    \ mut current_palindrome_suffix_start_index_in_string_reversed = 0;\n    let mut\
    \ current_palindrome_suffix_end_index_in_string_reversed = 0;\n    let mut current_palindrome_suffix_start_index_in_string_reversed_temp\
    \ = 0;\n    let mut current_palindrome_suffix_end_index_in_string_reversed_temp\
    \ = 0;\n    let mut current_palindrome_suffix_start_index_in_string_temp = 0;\n\
    \    let mut current_palindrome_suffix_end_index_in_string_temp = 0;\n    let\
    \ mut current_palindrome_suffix_start_index_temp = 0;\n    let mut current_palindrome_suffix_end_index_temp\
    \ = 0;\n    let mut current_palindrome_suffix_index_temp = 0;\n    let mut current_palindrome_suffix_length_temp\
    \ = 0;\n    let mut current_palindrome_suffix_temp = String::new();\n    let mut\
    \ current_palindrome_suffix_reversed = String::new();\n    let mut current_palindrome_suffix_reversed_temp\
    \ = String::new();\n    let mut string_reversed = string.chars().rev().collect::<String>();\n\
    \    let mut string_re\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpaf5qbp_c.rs:36:22\n   |\n\
    36 |     let mut string_re\n   |                      ^ help: add `;` here\n37\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaf5qbp_c.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut prefix = String::new();\n \
    \   let mut suffix = String::new();\n    for i in 0..string.len() {\n        prefix.push(string.chars().nth(i).unwrap());\n\
    \        suffix.push(string.chars().nth(string.len() - i - 1).unwrap());\n   \
    \     if prefix == suffix {\n            result.push_str(&prefix[0..prefix.len()\
    \ - 1].chars().rev().collect::<String>());\n            break;\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n   \
    \ assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"xyz\"`,\n right: `\"xyzyx\"`', /tmp/tmpside53js.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix_length = 0;\n    for\
    \ i in 0..string.len() {\n        if string[i..] == string[i..].chars().rev().collect::<String>()\
    \ {\n            suffix_length = string.len() - i;\n            break;\n     \
    \   }\n    }\n    result.push_str(&string[..string.len() - suffix_length].chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut result = string.clone();\n    let mut suffix = String::new();\n \
    \   let mut prefix = String::new();\n    let mut i = 0;\n    while i < string.len()\
    \ {\n        let c = string.chars().nth(i).unwrap();\n        suffix.push(c);\n\
    \        if is_palindrome(&suffix) {\n            prefix = string.chars().take(i).collect();\n\
    \        }\n        i += 1;\n    }\n    result.push_str(&prefix.chars().rev().collect::<String>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpu0p71gen.rs:19:12\n   |\n19 |         if is_palindrome(&suffix) {\n\
    \   |            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
