name: HumanEval_41_car_race_collision
language: rs
results:
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if left_to_right[i as usize] == right_to_left[j as usize] {\n           \
    \     collisions += 1;\n            }\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpgai9r7ay.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars = Vec::with_capacity(n as usize);\n    for\
    \ i in 0..n {\n        cars.push(i);\n    }\n    cars.sort();\n    let mut collisions\
    \ = 0;\n    for i in 0..n {\n        let mut j = n - 1 - i;\n        while j >\
    \ i {\n            if cars[i as usize] > cars[j as usize] {\n                collisions\
    \ += 1;\n            }\n            j -= 1;\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpuohgopa2.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = Vec::new();\n   \
    \ let mut right_to_left: Vec<isize> = Vec::new();\n    for i in 0..n {\n     \
    \   left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n    }\n  \
    \  let mut collisions = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        if left_to_right[0] < right_to_left[0] {\n            left_to_right.remove(0);\n\
    \            collisions += 1;\n        } else {\n            right_to_left.remove(0);\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp0qa4917o.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).collect();\n    left_to_right.sort();\n\
    \    right_to_left.sort();\n    let mut collisions = 0;\n    let mut i = 0;\n\
    \    let mut j = n - 1;\n    while i < n && j >= 0 {\n        if left_to_right[i]\
    \ < right_to_left[j] {\n            collisions += j + 1;\n            i += 1;\n\
    \        } else {\n            j -= 1;\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpkj7kgy90.rs:18:12\n\
    \   |\n18 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpkj7kgy90.rs:18:31\n\
    \   |\n18 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n\n    let mut\
    \ left_to_right = Vec::new();\n    let mut right_to_left = Vec::new();\n\n   \
    \ for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n\n    let mut collisions = 0;\n    let mut i = 0;\n    let\
    \ mut j = 0;\n\n    while i < n && j < n {\n        if left_to_right[i] < right_to_left[j]\
    \ {\n            collisions += j;\n            i += 1;\n        } else {\n   \
    \         j += 1;\n        }\n    }\n\n    collisions += (n - i) * (n - j);\n\n\
    \    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp4160xzp_.rs:27:12\n\
    \   |\n27 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp4160xzp_.rs:27:31\n\
    \   |\n27 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left_to_right_car = left_to_right.pop().unwrap();\n\
    \        let right_to_left_car = right_to_left.pop().unwrap();\n        if left_to_right_car\
    \ > right_to_left_car {\n            collisions += 1;\n        } else {\n    \
    \        left_to_right.push(left_to_right_car);\n            right_to_left.push(right_to_left_car);\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    for\
    \ i in 0..n {\n        if left_to_right[i as usize] == right_to_left[i as usize]\
    \ {\n            collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp9dtysnw9.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    while i < n && j < n {\n        if left_to_right[i] < right_to_left[j]\
    \ {\n            collisions += j;\n            i += 1;\n        } else {\n   \
    \         j += 1;\n        }\n    }\n    collisions += (n - i) * (n - j);\n  \
    \  collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n   \
    \ assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpqtmgiw2m.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpqtmgiw2m.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    for i in 0..n {\n       \
    \ for j in 0..n {\n            if left_to_right[i] == right_to_left[j] {\n   \
    \             collisions += 1;\n            }\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpopkzzmqt.rs:19:16\n\
    \   |\n19 |             if left_to_right[i] == right_to_left[j] {\n   |      \
    \          ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpopkzzmqt.rs:19:36\n\
    \   |\n19 |             if left_to_right[i] == right_to_left[j] {\n   |      \
    \                              ^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = Vec::new();\n    let mut cars_right\
    \ = Vec::new();\n    for i in 0..n {\n        cars_left.push(i);\n        cars_right.push(i);\n\
    \    }\n    let mut collisions = 0;\n    while !cars_left.is_empty() && !cars_right.is_empty()\
    \ {\n        let left_car = cars_left.pop().unwrap();\n        let right_car =\
    \ cars_right.pop().unwrap();\n        if left_car == right_car {\n           \
    \ collisions += 1;\n        } else {\n            cars_left.push(left_car);\n\
    \            cars_right.push(right_car);\n        }\n    }\n    collisions\n}\n\
    \nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpb7e3rp9w.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 1 {\n        return 0;\n    }\n    let mut left_to_right:\
    \ Vec<isize> = Vec::new();\n    let mut right_to_left: Vec<isize> = Vec::new();\n\
    \    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let l = left_to_right.pop().unwrap();\n\
    \        let r = right_to_left.pop().unwrap();\n        if l == r {\n        \
    \    collisions += 1;\n        } else if l > r {\n            left_to_right.push(l);\n\
    \        } else {\n            right_to_left.push(r);\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp2o0f7pmt.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    while\
    \ !left_to_right.is_empty() && !right_to_left.is_empty() {\n        let left_car\
    \ = left_to_right.pop().unwrap();\n        let right_car = right_to_left.pop().unwrap();\n\
    \        if left_car > right_car {\n            collisions += 1;\n        }\n\
    \    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmps_vv0yoz.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left_to_right_car = left_to_right.pop().unwrap();\n\
    \        let right_to_left_car = right_to_left.pop().unwrap();\n        if left_to_right_car\
    \ > right_to_left_car {\n            collisions += 1;\n        } else {\n    \
    \        left_to_right.push(left_to_right_car);\n            right_to_left.push(right_to_left_car);\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let l = left_to_right.pop().unwrap();\n\
    \        let r = right_to_left.pop().unwrap();\n        if l == r {\n        \
    \    collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n  \
    \  let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n   \
    \ assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpfayhy32a.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = Vec::new();\n   \
    \ let mut right_to_left: Vec<isize> = Vec::new();\n    for i in 0..n {\n     \
    \   left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n    }\n  \
    \  let mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n   \
    \         if left_to_right[i as usize] == right_to_left[j as usize] {\n      \
    \          collisions += 1;\n            }\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpknszntqj.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if left_to_right[i as usize] < right_to_left[j as usize] {\n            \
    \    collisions += 1;\n            }\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpakh_9tou.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::with_capacity(n as usize);\n\
    \    let mut right_to_left = Vec::with_capacity(n as usize);\n    for i in 0..n\
    \ {\n        left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n\
    \    }\n    let mut collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    while i < n && j < n {\n        if left_to_right[i as usize] < right_to_left[j\
    \ as usize] {\n            collisions += j;\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    collisions += (n - i) * (j + 1);\n\
    \    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpxvtuzaht.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut count = 0;\n    for i in\
    \ 0..n {\n        for j in 0..n {\n            if left_to_right[i] == right_to_left[j]\
    \ {\n                count += 1;\n            }\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp3b5iswt0.rs:19:16\n\
    \   |\n19 |             if left_to_right[i] == right_to_left[j] {\n   |      \
    \          ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp3b5iswt0.rs:19:36\n\
    \   |\n19 |             if left_to_right[i] == right_to_left[j] {\n   |      \
    \                              ^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i]\
    \ < right_to_left[j] {\n            collisions += j;\n            i += 1;\n  \
    \      } else {\n            j += 1;\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpechds7pi.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpechds7pi.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ {\n        let left_car = left_to_right.pop().unwrap();\n        let right_car\
    \ = right_to_left.pop().unwrap();\n        if left_car == right_car {\n      \
    \      collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp5jjgrel6.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i]\
    \ < right_to_left[j] {\n            collisions += j;\n            i += 1;\n  \
    \      } else {\n            j += 1;\n        }\n    }\n    collisions += j *\
    \ (n - i);\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpo57p_hm7.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpo57p_hm7.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i]\
    \ < right_to_left[j] {\n            collisions += j;\n            i += 1;\n  \
    \      } else {\n            j += 1;\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpnl8727o9.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpnl8727o9.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if left_to_right[i as usize] == right_to_left[j as usize] {\n           \
    \     collisions += 1;\n            }\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp1w3uu7wg.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).rev().collect();\n    left_to_right.sort();\n\
    \    right_to_left.sort();\n    let mut collisions = 0;\n    let mut i = 0;\n\
    \    let mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i as\
    \ usize] < right_to_left[j as usize] {\n            collisions += j;\n       \
    \     i += 1;\n        } else {\n            j += 1;\n        }\n    }\n    collisions\
    \ += j * (n - i);\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpm93_bzem.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars = vec![0; n as usize];\n    let mut collisions\
    \ = 0;\n    for i in 0..n {\n        cars[i as usize] = i;\n    }\n    for i in\
    \ 0..n {\n        for j in 0..n {\n            if cars[i as usize] > cars[j as\
    \ usize] {\n                collisions += 1;\n            }\n        }\n    }\n\
    \    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpj83iwoh7.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut left_to_right =\
    \ 0;\n    let mut right_to_left = 0;\n    while left_to_right < n || right_to_left\
    \ < n {\n        if left_to_right < n {\n            left_to_right += 1;\n   \
    \     }\n        if right_to_left < n {\n            right_to_left += 1;\n   \
    \     }\n        if left_to_right == right_to_left {\n            collisions +=\
    \ 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpjvzxmmr7.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO: Implement this function.\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp7dz789je.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left_car = left_to_right.remove(0);\n\
    \        let right_car = right_to_left.remove(0);\n        if left_car == right_car\
    \ {\n            collisions += 1;\n        } else {\n            left_to_right.push(left_car);\n\
    \            right_to_left.push(right_car);\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut left_to_right =\
    \ 0;\n    let mut right_to_left = 0;\n    for i in 0..n {\n        left_to_right\
    \ += 1;\n        right_to_left += 1;\n        if left_to_right == right_to_left\
    \ {\n            collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpazerfvm8.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if left_to_right[i as usize] == right_to_left[j as usize] {\n           \
    \     collisions += 1;\n            }\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpiavooy_c.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).rev().collect();\n    let mut\
    \ collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < n &&\
    \ j < n {\n        if left_to_right[i] < right_to_left[j] {\n            collisions\
    \ += j;\n            i += 1;\n        } else {\n            j += 1;\n        }\n\
    \    }\n    collisions += j * (n - i);\n    collisions\n}\n\nfn main() {\n   \
    \ let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpg5wx269i.rs:16:12\n\
    \   |\n16 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpg5wx269i.rs:16:31\n\
    \   |\n16 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 1 {\n        return 0;\n    }\n    let mut left_to_right:\
    \ Vec<isize> = Vec::new();\n    let mut right_to_left: Vec<isize> = Vec::new();\n\
    \    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    while i < n && j < n {\n        if left_to_right[i] < right_to_left[j]\
    \ {\n            collisions += j;\n            i += 1;\n        } else {\n   \
    \         j += 1;\n        }\n    }\n    collisions += (n - i) * (n - j);\n  \
    \  collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n   \
    \ assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpqfumjzh3.rs:23:12\n\
    \   |\n23 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpqfumjzh3.rs:23:31\n\
    \   |\n23 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut count = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left = left_to_right.pop().unwrap();\n\
    \        let right = right_to_left.pop().unwrap();\n        if left == right {\n\
    \            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpfub4j1in.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ {\n        let left_car = left_to_right.pop().unwrap();\n        let right_car\
    \ = right_to_left.pop().unwrap();\n        if left_car == right_car {\n      \
    \      collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpkmd1bdmi.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO: implement this function\n    0\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpicbczmw9.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i]\
    \ < right_to_left[j] {\n            collisions += j;\n            i += 1;\n  \
    \      } else {\n            j += 1;\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpgm65x9yy.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpgm65x9yy.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    while\
    \ !left_to_right.is_empty() && !right_to_left.is_empty() {\n        let l = left_to_right.pop().unwrap();\n\
    \        let r = right_to_left.pop().unwrap();\n        if l == r {\n        \
    \    collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n  \
    \  let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n   \
    \ assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp26np5llb.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::with_capacity(n as usize);\n\
    \    let mut right_to_left = Vec::with_capacity(n as usize);\n    for i in 0..n\
    \ {\n        left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n\
    \    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        let left = left_to_right.pop().unwrap();\n        let right = right_to_left.pop().unwrap();\n\
    \        if left > right {\n            collisions += 1;\n        } else {\n \
    \           left_to_right.push(left);\n            right_to_left.push(right);\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left = left_to_right.pop().unwrap();\n\
    \        let right = right_to_left.pop().unwrap();\n        if left > right {\n\
    \            collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpmd3xdx2j.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    while\
    \ left_to_right.len() > 0 && right_to_left.len() > 0 {\n        let left_car =\
    \ left_to_right[0];\n        let right_car = right_to_left[0];\n        if left_car\
    \ < right_car {\n            left_to_right.remove(0);\n        } else if left_car\
    \ > right_car {\n            right_to_left.remove(0);\n        } else {\n    \
    \        collisions += 1;\n            left_to_right.remove(0);\n            right_to_left.remove(0);\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpxs4c0g5j.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count: isize = 0;\n    for i in 0..n {\n    \
    \    for j in 0..n {\n            if i < j {\n                count += 1;\n  \
    \          }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpjdw01n0r.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars = vec![];\n    for i in 0..n {\n       \
    \ cars.push(Car::new(i as isize, true));\n        cars.push(Car::new(i as isize,\
    \ false));\n    }\n    cars.sort_by(|a, b| a.pos.cmp(&b.pos));\n    let mut collisions\
    \ = 0;\n    for i in 0..cars.len() {\n        for j in i + 1..cars.len() {\n \
    \           if cars[i].pos == cars[j].pos {\n                if cars[i].dir !=\
    \ cars[j].dir {\n                    collisions += 1;\n                }\n   \
    \         } else {\n                break;\n            }\n        }\n    }\n\
    \    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Car`\n  --> /tmp/tmpq4ysujdp.rs:12:19\n\
    \   |\n12 |         cars.push(Car::new(i as isize, true));\n   |             \
    \      ^^^ use of undeclared type `Car`\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `Car`\n  --> /tmp/tmpq4ysujdp.rs:13:19\n   |\n13 |      \
    \   cars.push(Car::new(i as isize, false));\n   |                   ^^^ use of\
    \ undeclared type `Car`\n\nerror[E0609]: no field `pos` on type `&_`\n  --> /tmp/tmpq4ysujdp.rs:15:27\n\
    \   |\n15 |     cars.sort_by(|a, b| a.pos.cmp(&b.pos));\n   |                \
    \           ^^^\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0433, E0609.\nFor more information about an error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left_car = left_to_right.remove(0);\n\
    \        let right_car = right_to_left.remove(0);\n        if left_car == right_car\
    \ {\n            collisions += 1;\n        } else {\n            left_to_right.push(left_car);\n\
    \            right_to_left.push(right_car);\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = Vec::new();\n   \
    \ let mut right_to_left: Vec<isize> = Vec::new();\n    for i in 0..n {\n     \
    \   left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n    }\n  \
    \  let mut collision_count = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        let left_to_right_car = left_to_right.pop().unwrap();\n        let\
    \ right_to_left_car = right_to_left.pop().unwrap();\n        if left_to_right_car\
    \ > right_to_left_car {\n            collision_count += 1;\n        }\n    }\n\
    \    collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp6ozci7nj.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO: implement this function\n    0\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpug4ssqhn.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ {\n        let left_to_right_car = left_to_right.pop().unwrap();\n        let\
    \ right_to_left_car = right_to_left.pop().unwrap();\n        if left_to_right_car\
    \ == right_to_left_car {\n            collisions += 1;\n        }\n    }\n   \
    \ collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp4c96j4ot.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let l = left_to_right.pop().unwrap();\n\
    \        let r = right_to_left.pop().unwrap();\n        if l > r {\n         \
    \   collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n   \
    \ let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpzwou4dek.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collision = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < n\
    \ && j < n {\n        if left_to_right[i as usize] < right_to_left[j as usize]\
    \ {\n            i += 1;\n        } else if left_to_right[i as usize] > right_to_left[j\
    \ as usize] {\n            j += 1;\n        } else {\n            collision +=\
    \ 1;\n            i += 1;\n            j += 1;\n        }\n    }\n    collision\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpw19fhwso.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        if left_to_right[0] < right_to_left[0]\
    \ {\n            left_to_right.remove(0);\n            collisions += 1;\n    \
    \    } else {\n            right_to_left.remove(0);\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpuplv76_l.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collision_count = 0;\n  \
    \  while !left_to_right.is_empty() && !right_to_left.is_empty() {\n        let\
    \ left_to_right_car = left_to_right.pop().unwrap();\n        let right_to_left_car\
    \ = right_to_left.pop().unwrap();\n        if left_to_right_car == right_to_left_car\
    \ {\n            collision_count += 1;\n        } else if left_to_right_car >\
    \ right_to_left_car {\n            left_to_right.push(left_to_right_car);\n  \
    \      } else {\n            right_to_left.push(right_to_left_car);\n        }\n\
    \    }\n    collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpm9ldtqkd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = Vec::new();\n   \
    \ let mut right_to_left: Vec<isize> = Vec::new();\n    for i in 0..n {\n     \
    \   left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n    }\n  \
    \  let mut collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < n && j < n {\n        if left_to_right[i] < right_to_left[j] {\n       \
    \     collisions += j;\n            i += 1;\n        } else {\n            j +=\
    \ 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp6gmcyljw.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp6gmcyljw.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut left_to_right =\
    \ vec![];\n    let mut right_to_left = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n\
    \        right_to_left.push(n - i - 1);\n    }\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        if left_to_right[0] < right_to_left[0]\
    \ {\n            left_to_right.remove(0);\n            collisions += 1;\n    \
    \    } else {\n            right_to_left.remove(0);\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpnrqd3qnt.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO: implement this function\n    0\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp92y5e4pn.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    left_to_right.sort();\n    right_to_left.sort();\n   \
    \ let mut collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i\
    \ < n && j < n {\n        if left_to_right[i as usize] < right_to_left[j as usize]\
    \ {\n            collisions += j;\n            i += 1;\n        } else {\n   \
    \         j += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpu3pr3iqe.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut count = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left = left_to_right.remove(0);\n\
    \        let right = right_to_left.remove(0);\n        if left == right {\n  \
    \          count += 1;\n        } else {\n            left_to_right.push(left);\n\
    \            right_to_left.push(right);\n        }\n    }\n    count\n}\n\nfn\
    \ main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left = left_to_right.pop().unwrap();\n\
    \        let right = right_to_left.pop().unwrap();\n        if left > right {\n\
    \            collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpev21pna9.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars = vec![0; n as usize];\n    let mut collisions\
    \ = 0;\n    for i in 0..n {\n        cars[i as usize] = i;\n    }\n    for i in\
    \ 0..n {\n        for j in 0..n {\n            if cars[i as usize] > cars[j as\
    \ usize] {\n                collisions += 1;\n            }\n        }\n    }\n\
    \    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpnmnpygwb.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(i);\n\
    \    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        let left = left_to_right.pop().unwrap();\n        let right = right_to_left.pop().unwrap();\n\
    \        if left == right {\n            collisions += 1;\n        }\n    }\n\
    \    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmppk8pelyu.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left = left_to_right.remove(0);\n\
    \        let right = right_to_left.remove(0);\n        if left > right {\n   \
    \         collisions += 1;\n        } else {\n            left_to_right.push(left);\n\
    \            right_to_left.push(right);\n        }\n    }\n    collisions\n}\n\
    \nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).rev().collect();\n    let mut\
    \ collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < n &&\
    \ j < n {\n        if left_to_right[i] < right_to_left[j] {\n            collisions\
    \ += j;\n            i += 1;\n        } else {\n            j += 1;\n        }\n\
    \    }\n    collisions += j * (n - i);\n    collisions\n}\n\nfn main() {\n   \
    \ let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp8k7j7668.rs:16:12\n\
    \   |\n16 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp8k7j7668.rs:16:31\n\
    \   |\n16 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 1 {\n        return 0;\n    }\n    let mut left_to_right\
    \ = Vec::new();\n    let mut right_to_left = Vec::new();\n    for i in 0..n {\n\
    \        left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n    }\n\
    \    let mut collisions = 0;\n    while left_to_right.len() > 0 {\n        let\
    \ l = left_to_right.pop().unwrap();\n        let r = right_to_left.pop().unwrap();\n\
    \        if l == r {\n            collisions += 1;\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmphm_6he31.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left_car = left_to_right.pop().unwrap();\n\
    \        let right_car = right_to_left.pop().unwrap();\n        if left_car >\
    \ right_car {\n            collisions += 1;\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpj1v0attb.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < n\
    \ && j < n {\n        if left_to_right[i as usize] < right_to_left[j as usize]\
    \ {\n            i += 1;\n        } else if left_to_right[i as usize] > right_to_left[j\
    \ as usize] {\n            j += 1;\n        } else {\n            collisions +=\
    \ 1;\n            i += 1;\n            j += 1;\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpf4cs98g8.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::with_capacity(n as usize);\n\
    \    let mut right_to_left = Vec::with_capacity(n as usize);\n    for i in 0..n\
    \ {\n        left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n\
    \    }\n    let mut collisions = 0;\n    let mut left_to_right_index = 0;\n  \
    \  let mut right_to_left_index = 0;\n    while left_to_right_index < n && right_to_left_index\
    \ < n {\n        if left_to_right[left_to_right_index as usize] < right_to_left[right_to_left_index\
    \ as usize] {\n            collisions += right_to_left_index;\n            left_to_right_index\
    \ += 1;\n        } else {\n            right_to_left_index += 1;\n        }\n\
    \    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp50i8z56a.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        if left_to_right[0] < right_to_left[0]\
    \ {\n            left_to_right.remove(0);\n            collisions += 1;\n    \
    \    } else {\n            right_to_left.remove(0);\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmplkas5x_7.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = vec![0; n as usize];\n    let mut\
    \ cars_right = vec![0; n as usize];\n    for i in 0..n {\n        cars_left[i\
    \ as usize] = i;\n        cars_right[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if cars_left[i as usize] == cars_right[j as usize] {\n                collisions\
    \ += 1;\n            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp3zxlwgws.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = Vec::new();\n   \
    \ let mut right_to_left: Vec<isize> = Vec::new();\n    for i in 0..n {\n     \
    \   left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n    }\n  \
    \  let mut collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < n && j < n {\n        if left_to_right[i] < right_to_left[j] {\n       \
    \     collisions += j;\n            i += 1;\n        } else {\n            j +=\
    \ 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpy13h1u1a.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpy13h1u1a.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left = left_to_right.remove(0);\n\
    \        let right = right_to_left.remove(0);\n        if left == right {\n  \
    \          collisions += 1;\n        } else if left > right {\n            right_to_left.push(right);\n\
    \        } else {\n            left_to_right.push(left);\n        }\n    }\n \
    \   collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n  \
    \  assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpa19pr6qu.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left_to_right_car = left_to_right.pop().unwrap();\n\
    \        let right_to_left_car = right_to_left.pop().unwrap();\n        if left_to_right_car\
    \ > right_to_left_car {\n            collisions += 1;\n        } else {\n    \
    \        left_to_right.push(left_to_right_car);\n            right_to_left.push(right_to_left_car);\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(i);\n\
    \    }\n    left_to_right.sort();\n    right_to_left.sort();\n    let mut collisions\
    \ = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < n && j < n {\n \
    \       if left_to_right[i as usize] < right_to_left[j as usize] {\n         \
    \   collisions += j;\n            i += 1;\n        } else {\n            j +=\
    \ 1;\n        }\n    }\n    collisions += (n - i) * j;\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmp5geie3x3.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 1 {\n        return 0;\n    }\n    let mut left_to_right\
    \ = vec![0; n as usize];\n    let mut right_to_left = vec![0; n as usize];\n \
    \   for i in 0..n {\n        left_to_right[i as usize] = i;\n        right_to_left[i\
    \ as usize] = n - i - 1;\n    }\n    let mut collisions = 0;\n    for i in 0..n\
    \ {\n        for j in 0..n {\n            if left_to_right[i as usize] == right_to_left[j\
    \ as usize] {\n                collisions += 1;\n            }\n        }\n  \
    \  }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmplne565q6.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut left_to_right =\
    \ vec![];\n    let mut right_to_left = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n\
    \        right_to_left.push(n - i - 1);\n    }\n    for i in 0..n {\n        for\
    \ j in 0..n {\n            if left_to_right[i] == right_to_left[j] {\n       \
    \         collisions += 1;\n            }\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpdb8dfndc.rs:19:16\n\
    \   |\n19 |             if left_to_right[i] == right_to_left[j] {\n   |      \
    \          ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpdb8dfndc.rs:19:36\n\
    \   |\n19 |             if left_to_right[i] == right_to_left[j] {\n   |      \
    \                              ^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = n;\n    let mut cars_right = n;\n\
    \    let mut collisions = 0;\n    while cars_left > 0 && cars_right > 0 {\n  \
    \      if cars_left > cars_right {\n            collisions += cars_right;\n  \
    \          cars_left -= cars_right;\n        } else {\n            collisions\
    \ += cars_left;\n            cars_right -= cars_left;\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp51mstzbr.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while left_to_right.len()\
    \ > 0 && right_to_left.len() > 0 {\n        let l = left_to_right[0];\n      \
    \  let r = right_to_left[0];\n        if l < r {\n            left_to_right.remove(0);\n\
    \        } else if l > r {\n            right_to_left.remove(0);\n        } else\
    \ {\n            left_to_right.remove(0);\n            right_to_left.remove(0);\n\
    \            collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpzxhlp8sk.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n    for i in 1..n {\n        count\
    \ += i;\n    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp4x7g09ec.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collision_count = 0;\n  \
    \  while !left_to_right.is_empty() {\n        let left_car = left_to_right.pop().unwrap();\n\
    \        let right_car = right_to_left.pop().unwrap();\n        if left_car ==\
    \ right_car {\n            collision_count += 1;\n        }\n    }\n    collision_count\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpc487m50b.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    while\
    \ !left_to_right.is_empty() && !right_to_left.is_empty() {\n        let left_to_right_car\
    \ = left_to_right.pop().unwrap();\n        let right_to_left_car = right_to_left.pop().unwrap();\n\
    \        if left_to_right_car > right_to_left_car {\n            collisions +=\
    \ 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpnfokyf0o.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = Vec::new();\n    let mut cars_right\
    \ = Vec::new();\n    for i in 0..n {\n        cars_left.push(i);\n        cars_right.push(n\
    \ + i);\n    }\n    let mut collisions = 0;\n    for i in 0..n {\n        for\
    \ j in 0..n {\n            if cars_left[i as usize] == cars_right[j as usize]\
    \ {\n                collisions += 1;\n            }\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp8_eziet1.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i]\
    \ < right_to_left[j] {\n            collisions += j;\n            i += 1;\n  \
    \      } else {\n            j += 1;\n        }\n    }\n    collisions += (n -\
    \ i) * (n - j);\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmplh4819rt.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmplh4819rt.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = Vec::new();\n    let mut cars_right\
    \ = Vec::new();\n    for i in 0..n {\n        cars_left.push(i);\n        cars_right.push(i);\n\
    \    }\n    let mut collisions = 0;\n    while !cars_left.is_empty() && !cars_right.is_empty()\
    \ {\n        let left_car = cars_left.pop().unwrap();\n        let right_car =\
    \ cars_right.pop().unwrap();\n        if left_car > right_car {\n            collisions\
    \ += 1;\n        } else {\n            cars_left.push(left_car);\n           \
    \ cars_right.push(right_car);\n        }\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = Vec::new();\n   \
    \ let mut right_to_left: Vec<isize> = Vec::new();\n    for i in 0..n {\n     \
    \   left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n    }\n  \
    \  let mut collisions = 0;\n    while left_to_right.len() > 0 && right_to_left.len()\
    \ > 0 {\n        let left_to_right_car = left_to_right.pop().unwrap();\n     \
    \   let right_to_left_car = right_to_left.pop().unwrap();\n        if left_to_right_car\
    \ < right_to_left_car {\n            left_to_right.push(left_to_right_car);\n\
    \            collisions += 1;\n        } else {\n            right_to_left.push(right_to_left_car);\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpcq_1_pt0.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < n\
    \ && j < n {\n        if left_to_right[i as usize] < right_to_left[j as usize]\
    \ {\n            collisions += j;\n            i += 1;\n        } else {\n   \
    \         j += 1;\n        }\n    }\n    collisions += (n - i) * (n - i - 1) /\
    \ 2;\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmp46rt770c.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut left_to_right =\
    \ vec![];\n    let mut right_to_left = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n\
    \        right_to_left.push(n - i - 1);\n    }\n    let mut left_to_right_index\
    \ = 0;\n    let mut right_to_left_index = 0;\n    while left_to_right_index <\
    \ n && right_to_left_index < n {\n        if left_to_right[left_to_right_index]\
    \ < right_to_left[right_to_left_index] {\n            collisions += 1;\n     \
    \       left_to_right_index += 1;\n        } else {\n            right_to_left_index\
    \ += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpsrbrq883.rs:20:12\n\
    \   |\n20 |         if left_to_right[left_to_right_index] < right_to_left[right_to_left_index]\
    \ {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpsrbrq883.rs:20:49\n   |\n20 |         if left_to_right[left_to_right_index]\
    \ < right_to_left[right_to_left_index] {\n   |                               \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO: implement this function\n    0\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpzmk57dqy.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = vec![0; n as usize];\n    let mut\
    \ cars_right = vec![0; n as usize];\n    for i in 0..n {\n        cars_left[i\
    \ as usize] = i;\n        cars_right[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if cars_left[i as usize] == cars_right[j as usize] {\n                collisions\
    \ += 1;\n            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpbelm0lpy.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n    for i in 1..n {\n        count\
    \ += i;\n    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpa0wloyty.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(i);\n\
    \    }\n    let mut collision_count = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left_car = left_to_right.remove(0);\n\
    \        let right_car = right_to_left.remove(0);\n        if left_car == right_car\
    \ {\n            collision_count += 1;\n        } else {\n            left_to_right.push(left_car);\n\
    \            right_to_left.push(right_car);\n        }\n    }\n    collision_count\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmphzmtx_d0.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut n = n;\n    let mut collisions = 0;\n    while\
    \ n > 0 {\n        collisions += n;\n        n -= 1;\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpv_eptoig.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = vec![];\n    let mut cars_right =\
    \ vec![];\n    for i in 0..n {\n        cars_left.push(i);\n        cars_right.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !cars_left.is_empty()\
    \ {\n        let car_left = cars_left.pop().unwrap();\n        let car_right =\
    \ cars_right.pop().unwrap();\n        if car_left > car_right {\n            collisions\
    \ += 1;\n        } else {\n            cars_left.push(car_left);\n           \
    \ cars_right.push(car_right);\n        }\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut left_to_right =\
    \ 0;\n    let mut right_to_left = 0;\n    while left_to_right < n || right_to_left\
    \ < n {\n        if left_to_right < n {\n            left_to_right += 1;\n   \
    \     }\n        if right_to_left < n {\n            right_to_left += 1;\n   \
    \     }\n        if left_to_right == right_to_left {\n            collisions +=\
    \ 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpxym1b_fe.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    while i < n && j < n {\n        if left_to_right[i] < right_to_left[j]\
    \ {\n            collisions += j;\n            i += 1;\n        } else {\n   \
    \         j += 1;\n        }\n    }\n    collisions += (n - i) * (n - j);\n  \
    \  collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n   \
    \ assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpe6pf3uxe.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpe6pf3uxe.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for i in 0..n {\n      \
    \  for j in 0..n {\n            if i < j {\n                collisions += 1;\n\
    \            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpy928umlo.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = Vec::new();\n   \
    \ let mut right_to_left: Vec<isize> = Vec::new();\n    for i in 0..n {\n     \
    \   left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n    }\n  \
    \  let mut collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < n && j < n {\n        if left_to_right[i] < right_to_left[j] {\n       \
    \     collisions += j;\n            i += 1;\n        } else {\n            j +=\
    \ 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpoqdarczm.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpoqdarczm.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    while i < n && j < n {\n        if left_to_right[i] < right_to_left[j]\
    \ {\n            collisions += j;\n            i += 1;\n        } else {\n   \
    \         j += 1;\n        }\n    }\n    collisions += (n - i) * j;\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpiyj38iz4.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpiyj38iz4.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO: Implement this function\n    0\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpepsu0jpn.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = Vec::new();\n   \
    \ let mut right_to_left: Vec<isize> = Vec::new();\n    for i in 0..n {\n     \
    \   left_to_right.push(i);\n        right_to_left.push(i);\n    }\n    let mut\
    \ collisions = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        let l = left_to_right.pop().unwrap();\n        let r = right_to_left.pop().unwrap();\n\
    \        if l == r {\n            collisions += 1;\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp4e6wjnmk.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if left_to_right[i as usize] == right_to_left[j as usize] {\n           \
    \     collisions += 1;\n            }\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp9w7hks08.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left_car = left_to_right.pop().unwrap();\n\
    \        let right_car = right_to_left.pop().unwrap();\n        if left_car >\
    \ right_car {\n            collisions += 1;\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpjpr27tvj.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if left_to_right[i as usize] == right_to_left[j as usize] {\n           \
    \     collisions += 1;\n            }\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpps9p4_k2.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for i in 0..n {\n      \
    \  for j in 0..n {\n            if i < j {\n                collisions += 1;\n\
    \            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpi37u3tmi.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n\n    let mut\
    \ left_to_right = Vec::new();\n    let mut right_to_left = Vec::new();\n\n   \
    \ for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n\n    let mut collisions = 0;\n    let mut i = 0;\n    let\
    \ mut j = 0;\n\n    while i < n && j < n {\n        if left_to_right[i] < right_to_left[j]\
    \ {\n            collisions += j;\n            i += 1;\n        } else {\n   \
    \         j += 1;\n        }\n    }\n\n    collisions += (n - i) * (n - j);\n\n\
    \    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp02vr2zi9.rs:27:12\n\
    \   |\n27 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp02vr2zi9.rs:27:31\n\
    \   |\n27 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    while\
    \ !left_to_right.is_empty() {\n        let left_car = left_to_right.pop().unwrap();\n\
    \        let right_car = right_to_left.pop().unwrap();\n        if left_car ==\
    \ right_car {\n            collisions += 1;\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpvk0za8ca.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    while i < n && j < n {\n        if left_to_right[i] < right_to_left[j]\
    \ {\n            collisions += j;\n            i += 1;\n        } else {\n   \
    \         j += 1;\n        }\n    }\n    collisions += j * (n - i);\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpw4ml2qup.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpw4ml2qup.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i]\
    \ < right_to_left[j] {\n            collisions += j;\n            i += 1;\n  \
    \      } else {\n            j += 1;\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp5_1huvh3.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp5_1huvh3.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < n\
    \ && j < n {\n        if left_to_right[i as usize] < right_to_left[j as usize]\
    \ {\n            collisions += j;\n            i += 1;\n        } else {\n   \
    \         j += 1;\n        }\n    }\n    collisions += (n - i) * i;\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp499ibg_0.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let mut left_to_right\
    \ = vec![];\n    let mut right_to_left = vec![];\n    for i in 0..n {\n      \
    \  left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n    }\n   \
    \ let mut collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i\
    \ < n && j < n {\n        if left_to_right[i] < right_to_left[j] {\n         \
    \   collisions += j;\n            i += 1;\n        } else {\n            j +=\
    \ 1;\n        }\n    }\n    collisions += (n - i) * (n - j);\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp523x702q.rs:23:12\n\
    \   |\n23 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp523x702q.rs:23:31\n\
    \   |\n23 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    for i in 0..n {\n       \
    \ for j in 0..n {\n            if left_to_right[i] == right_to_left[j] {\n   \
    \             collisions += 1;\n            }\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp8rc85iti.rs:19:16\n\
    \   |\n19 |             if left_to_right[i] == right_to_left[j] {\n   |      \
    \          ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp8rc85iti.rs:19:36\n\
    \   |\n19 |             if left_to_right[i] == right_to_left[j] {\n   |      \
    \                              ^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left_to_right_car = left_to_right.pop().unwrap();\n\
    \        let right_to_left_car = right_to_left.pop().unwrap();\n        if left_to_right_car\
    \ > right_to_left_car {\n            collisions += 1;\n        } else {\n    \
    \        left_to_right.push(left_to_right_car);\n            right_to_left.push(right_to_left_car);\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left_to_right_car = left_to_right.pop().unwrap();\n\
    \        let right_to_left_car = right_to_left.pop().unwrap();\n        if left_to_right_car\
    \ > right_to_left_car {\n            collisions += 1;\n        } else {\n    \
    \        left_to_right.push(left_to_right_car);\n            right_to_left.push(right_to_left_car);\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    for i in 0..n {\n       \
    \ for j in 0..n {\n            if left_to_right[i] == right_to_left[j] {\n   \
    \             collisions += 1;\n            }\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp19ud7u6g.rs:19:16\n\
    \   |\n19 |             if left_to_right[i] == right_to_left[j] {\n   |      \
    \          ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp19ud7u6g.rs:19:36\n\
    \   |\n19 |             if left_to_right[i] == right_to_left[j] {\n   |      \
    \                              ^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for i in 0..n {\n      \
    \  for j in 0..n {\n            if i > j {\n                collisions += 1;\n\
    \            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp7v5g8997.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).rev().collect();\n    let mut\
    \ collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < n &&\
    \ j < n {\n        if left_to_right[i] < right_to_left[j] {\n            collisions\
    \ += j;\n            i += 1;\n        } else {\n            j += 1;\n        }\n\
    \    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpewwndpfz.rs:16:12\n\
    \   |\n16 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpewwndpfz.rs:16:31\n\
    \   |\n16 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let mut left_to_right\
    \ = vec![];\n    let mut right_to_left = vec![];\n    for i in 0..n {\n      \
    \  left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n    }\n   \
    \ let mut collisions = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        let left_car = left_to_right.pop().unwrap();\n        let right_car\
    \ = right_to_left.pop().unwrap();\n        if left_car > right_car {\n       \
    \     collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpdn4llryq.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = Vec::new();\n    let mut cars_right\
    \ = Vec::new();\n    for i in 0..n {\n        cars_left.push(i);\n        cars_right.push(i);\n\
    \    }\n    let mut collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    while i < n && j < n {\n        if cars_left[i as usize] < cars_right[j as\
    \ usize] {\n            collisions += 1;\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp0rdy73p8.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left = left_to_right.pop().unwrap();\n\
    \        let right = right_to_left.pop().unwrap();\n        if left < right {\n\
    \            left_to_right.push(left);\n            right_to_left.push(right);\n\
    \        } else {\n            collisions += 1;\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).rev().collect();\n    let mut\
    \ collisions = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        let left = left_to_right[0];\n        let right = right_to_left[0];\n\
    \        if left < right {\n            left_to_right.remove(0);\n        } else\
    \ if right < left {\n            right_to_left.remove(0);\n        } else {\n\
    \            collisions += 1;\n            left_to_right.remove(0);\n        \
    \    right_to_left.remove(0);\n        }\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpv0ojvzd1.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i]\
    \ == right_to_left[j] {\n            collisions += 1;\n            i += 1;\n \
    \           j += 1;\n        } else if left_to_right[i] < right_to_left[j] {\n\
    \            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n\
    \    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp18uk_s8o.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] == right_to_left[j] {\n   |          \
    \  ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n \
    \  |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp18uk_s8o.rs:20:32\n\
    \   |\n20 |         if left_to_right[i] == right_to_left[j] {\n   |          \
    \                      ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp18uk_s8o.rs:24:19\n   |\n24 |         } else if left_to_right[i]\
    \ < right_to_left[j] {\n   |                   ^^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp18uk_s8o.rs:24:38\n   |\n24 |         } else\
    \ if left_to_right[i] < right_to_left[j] {\n   |                             \
    \         ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more "
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let mut left_to_right\
    \ = vec![0; n as usize];\n    let mut right_to_left = vec![0; n as usize];\n \
    \   for i in 0..n {\n        left_to_right[i as usize] = i;\n        right_to_left[i\
    \ as usize] = n - i - 1;\n    }\n    let mut collision_count = 0;\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i\
    \ as usize] < right_to_left[j as usize] {\n            i += 1;\n        } else\
    \ if left_to_right[i as usize] > right_to_left[j as usize] {\n            j +=\
    \ 1;\n        } else {\n            collision_count += 1;\n            i += 1;\n\
    \            j += 1;\n        }\n    }\n    collision_count\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmprv2k3_ya.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if left_to_right[i as usize] == right_to_left[j as usize] {\n           \
    \     collisions += 1;\n            }\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmptgjey746.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left_car = left_to_right.remove(0);\n\
    \        let right_car = right_to_left.remove(0);\n        if left_car == right_car\
    \ {\n            collisions += 1;\n        } else {\n            left_to_right.push(left_car);\n\
    \            right_to_left.push(right_car);\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = Vec::new();\n   \
    \ let mut right_to_left: Vec<isize> = Vec::new();\n    for i in 0..n {\n     \
    \   left_to_right.push(i);\n        right_to_left.push(i);\n    }\n    let mut\
    \ collisions = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        let left_car = left_to_right.pop().unwrap();\n        let right_car\
    \ = right_to_left.pop().unwrap();\n        if left_car == right_car {\n      \
    \      collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpve_foskx.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = Vec::new();\n   \
    \ let mut right_to_left: Vec<isize> = Vec::new();\n    for i in 0..n {\n     \
    \   left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n    }\n  \
    \  let mut collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < n && j < n {\n        if left_to_right[i] < right_to_left[j] {\n       \
    \     collisions += j;\n            i += 1;\n        } else {\n            j +=\
    \ 1;\n        }\n    }\n    collisions += (n - i) * (n - j);\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpnljo6pmf.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpnljo6pmf.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    while\
    \ !left_to_right.is_empty() && !right_to_left.is_empty() {\n        let l = left_to_right.pop().unwrap();\n\
    \        let r = right_to_left.pop().unwrap();\n        if l > r {\n         \
    \   collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n   \
    \ let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpc7zb4s45.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(i);\n\
    \    }\n    let mut collision_count = 0;\n    let mut left_to_right_index = 0;\n\
    \    let mut right_to_left_index = 0;\n    while left_to_right_index < n && right_to_left_index\
    \ < n {\n        if left_to_right[left_to_right_index] == right_to_left[right_to_left_index]\
    \ {\n            collision_count += 1;\n            left_to_right_index += 1;\n\
    \            right_to_left_index += 1;\n        } else if left_to_right[left_to_right_index]\
    \ < right_to_left[right_to_left_index] {\n            left_to_right_index += 1;\n\
    \        } else {\n            right_to_left_index += 1;\n        }\n    }\n \
    \   collision_count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpga675q89.rs:20:12\n\
    \   |\n20 |         if left_to_right[left_to_right_index] == right_to_left[right_to_left_index]\
    \ {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpga675q89.rs:20:50\n   |\n20 |         if left_to_right[left_to_right_index]\
    \ == right_to_left[right_to_left_index] {\n   |                              \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpga675q89.rs:24:19\n   |\n24 |         } else\
    \ if left_to_right[left_to_right_index] < right_to_left[right_to_left_index] {\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpga675q89.rs:24:56\n   |\n24 |         } else\
    \ if left_to_right[left_to_right_index] < right_to_left[right_to_left_index] {\n\
    \   |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[i"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if left_to_right[i as usize] == right_to_left[j as usize] {\n           \
    \     collisions += 1;\n            }\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpg5r16vgz.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if left_to_right[i as usize] == right_to_left[j as usize] {\n           \
    \     collisions += 1;\n            }\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpfohrl3bm.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = Vec::new();\n   \
    \ let mut right_to_left: Vec<isize> = Vec::new();\n    for i in 0..n {\n     \
    \   left_to_right.push(i);\n        right_to_left.push(i);\n    }\n    let mut\
    \ collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n            if\
    \ left_to_right[i as usize] == right_to_left[j as usize] {\n                collisions\
    \ += 1;\n            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp_dn5305k.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    for i in 0..n {\n       \
    \ for j in 0..n {\n            if left_to_right[i] == right_to_left[j] {\n   \
    \             collisions += 1;\n            }\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpzek2ny49.rs:19:16\n\
    \   |\n19 |             if left_to_right[i] == right_to_left[j] {\n   |      \
    \          ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpzek2ny49.rs:19:36\n\
    \   |\n19 |             if left_to_right[i] == right_to_left[j] {\n   |      \
    \                              ^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO: implement this function\n    0\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpe_lqxrtx.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = vec![0; n as usize];\n    let mut\
    \ cars_right = vec![0; n as usize];\n    for i in 0..n {\n        cars_left[i\
    \ as usize] = i;\n        cars_right[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < n\
    \ && j < n {\n        if cars_left[i as usize] < cars_right[j as usize] {\n  \
    \          collisions += j;\n            i += 1;\n        } else {\n         \
    \   j += 1;\n        }\n    }\n    collisions += (n - i) * (j as isize);\n   \
    \ collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp1t7v2v7e.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left_to_right_car = left_to_right.pop().unwrap();\n\
    \        let right_to_left_car = right_to_left.pop().unwrap();\n        if left_to_right_car\
    \ < right_to_left_car {\n            left_to_right.push(left_to_right_car);\n\
    \            collisions += 1;\n        } else {\n            right_to_left.push(right_to_left_car);\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpqqgr3j6s.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut count = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left = left_to_right.pop().unwrap();\n\
    \        let right = right_to_left.pop().unwrap();\n        if left == right {\n\
    \            count += 1;\n        } else if left > right {\n            left_to_right.push(left);\n\
    \        } else {\n            right_to_left.push(right);\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpd9styz9t.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let mut left_to_right\
    \ = Vec::new();\n    let mut right_to_left = Vec::new();\n    for i in 0..n {\n\
    \        left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n    }\n\
    \    let mut collisions = 0;\n    while !left_to_right.is_empty() {\n        let\
    \ left_car = left_to_right.pop().unwrap();\n        let right_car = right_to_left.pop().unwrap();\n\
    \        if left_car == right_car {\n            collisions += 1;\n        }\n\
    \    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpupjm63i1.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 1 {\n        return 0;\n    }\n\n    let mut\
    \ left_to_right: Vec<isize> = Vec::new();\n    let mut right_to_left: Vec<isize>\
    \ = Vec::new();\n\n    for i in 0..n {\n        left_to_right.push(i);\n     \
    \   right_to_left.push(n - i - 1);\n    }\n\n    let mut collisions = 0;\n   \
    \ let mut i = 0;\n    let mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i]\
    \ < right_to_left[j] {\n            collisions += j;\n            i += 1;\n  \
    \      } else {\n            j += 1;\n        }\n    }\n\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpi9c20r7m.rs:26:12\n\
    \   |\n26 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpi9c20r7m.rs:26:31\n\
    \   |\n26 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = Vec::new();\n   \
    \ let mut right_to_left: Vec<isize> = Vec::new();\n    let mut collision_count\
    \ = 0;\n\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n\n    for i in 0..n {\n        for j in 0..n {\n         \
    \   if left_to_right[i] == right_to_left[j] {\n                collision_count\
    \ += 1;\n            }\n        }\n    }\n\n    collision_count\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp2vlw7hkv.rs:21:16\n\
    \   |\n21 |             if left_to_right[i] == right_to_left[j] {\n   |      \
    \          ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp2vlw7hkv.rs:21:36\n\
    \   |\n21 |             if left_to_right[i] == right_to_left[j] {\n   |      \
    \                              ^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n    for i in 1..n {\n        count\
    \ += i;\n    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpm1wrmybi.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n    for i in 1..n {\n        count\
    \ += i;\n    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpxt8_esqr.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collision_count = 0;\n    let mut i = 0;\n   \
    \ let mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i] < right_to_left[j]\
    \ {\n            collision_count += j;\n            i += 1;\n        } else {\n\
    \            j += 1;\n        }\n    }\n    collision_count\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpl8nyt1oh.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpl8nyt1oh.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left = left_to_right.pop().unwrap();\n\
    \        let right = right_to_left.pop().unwrap();\n        if left > right {\n\
    \            collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp3snnsc0h.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left_to_right_car = left_to_right.pop().unwrap();\n\
    \        let right_to_left_car = right_to_left.pop().unwrap();\n        if left_to_right_car\
    \ > right_to_left_car {\n            collisions += 1;\n            left_to_right.push(left_to_right_car);\n\
    \        } else {\n            right_to_left.push(right_to_left_car);\n      \
    \  }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpdldrtxdn.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut left_to_right =\
    \ Vec::new();\n    let mut right_to_left = Vec::new();\n    for i in 0..n {\n\
    \        left_to_right.push(i);\n        right_to_left.push(i);\n    }\n    left_to_right.sort();\n\
    \    right_to_left.sort();\n    let mut left_to_right_index = 0;\n    let mut\
    \ right_to_left_index = 0;\n    while left_to_right_index < n && right_to_left_index\
    \ < n {\n        if left_to_right[left_to_right_index] == right_to_left[right_to_left_index]\
    \ {\n            collisions += 1;\n            left_to_right_index += 1;\n   \
    \         right_to_left_index += 1;\n        } else if left_to_right[left_to_right_index]\
    \ < right_to_left[right_to_left_index] {\n            left_to_right_index += 1;\n\
    \        } else {\n            right_to_left_index += 1;\n        }\n    }\n \
    \   collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n  \
    \  assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpfqa1dn_6.rs:22:12\n\
    \   |\n22 |         if left_to_right[left_to_right_index] == right_to_left[right_to_left_index]\
    \ {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpfqa1dn_6.rs:22:50\n   |\n22 |         if left_to_right[left_to_right_index]\
    \ == right_to_left[right_to_left_index] {\n   |                              \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpfqa1dn_6.rs:26:19\n   |\n26 |         } else\
    \ if left_to_right[left_to_right_index] < right_to_left[right_to_left_index] {\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpfqa1dn_6.rs:26:56\n   |\n26 |         } else\
    \ if left_to_right[left_to_right_index] < right_to_left[right_to_left_index] {\n\
    \   |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[i"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i]\
    \ < right_to_left[j] {\n            collisions += j;\n            i += 1;\n  \
    \      } else {\n            j += 1;\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp8wq383_o.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp8wq383_o.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = Vec::new();\n   \
    \ let mut right_to_left: Vec<isize> = Vec::new();\n    for i in 0..n {\n     \
    \   left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n    }\n  \
    \  let mut collisions = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        let left_car = left_to_right.pop().unwrap();\n        let right_car\
    \ = right_to_left.pop().unwrap();\n        if left_car > right_car {\n       \
    \     collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n \
    \   let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n  \
    \  assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpldu_t2a4.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left_to_right = vec![];\n    let mut cars_right_to_left\
    \ = vec![];\n    for i in 0..n {\n        cars_left_to_right.push(i);\n      \
    \  cars_right_to_left.push(i);\n    }\n    let mut collisions = 0;\n    while\
    \ !cars_left_to_right.is_empty() && !cars_right_to_left.is_empty() {\n       \
    \ let left_to_right_car = cars_left_to_right.pop().unwrap();\n        let right_to_left_car\
    \ = cars_right_to_left.pop().unwrap();\n        if left_to_right_car == right_to_left_car\
    \ {\n            collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmps9pbntpp.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if left_to_right[i as usize] == right_to_left[j as usize] {\n           \
    \     collisions += 1;\n            }\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpzshph2gp.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let l = left_to_right.pop().unwrap();\n\
    \        let r = right_to_left.pop().unwrap();\n        if l == r {\n        \
    \    collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n  \
    \  let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n   \
    \ assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmppm6eth4y.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left_car = left_to_right.pop().unwrap();\n\
    \        let right_car = right_to_left.pop().unwrap();\n        if left_car <\
    \ right_car {\n            left_to_right.push(left_car);\n            right_to_left.push(right_car);\n\
    \        } else {\n            collisions += 1;\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left = vec![0; n as usize];\n    let mut right\
    \ = vec![0; n as usize];\n    for i in 0..n {\n        left[i as usize] = i;\n\
    \        right[i as usize] = n - i - 1;\n    }\n    let mut collisions = 0;\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < n && j < n {\n        if\
    \ left[i as usize] < right[j as usize] {\n            collisions += j;\n     \
    \       i += 1;\n        } else {\n            j += 1;\n        }\n    }\n   \
    \ collisions += (n - i) * i;\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp6wo1d134.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    while i < n && j < n {\n        if left_to_right[i] < right_to_left[j]\
    \ {\n            collisions += j;\n            i += 1;\n        } else {\n   \
    \         j += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp9qopshhj.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp9qopshhj.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left = left_to_right.pop().unwrap();\n\
    \        let right = right_to_left.pop().unwrap();\n        if left == right {\n\
    \            collisions += 1;\n        } else if left > right {\n            left_to_right.push(left);\n\
    \        } else {\n            right_to_left.push(right);\n        }\n    }\n\
    \    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp56tyffl3.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if left_to_right[i as usize] == right_to_left[j as usize] {\n           \
    \     collisions += 1;\n            }\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpjyft5fkg.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if left_to_right[i as usize] == right_to_left[j as usize] {\n           \
    \     collisions += 1;\n            }\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpn8qwkg_j.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = Vec::new();\n   \
    \ let mut right_to_left: Vec<isize> = Vec::new();\n    for i in 0..n {\n     \
    \   left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n    }\n  \
    \  let mut collisions = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        let left_to_right_car = left_to_right.pop().unwrap();\n        let\
    \ right_to_left_car = right_to_left.pop().unwrap();\n        if left_to_right_car\
    \ > right_to_left_car {\n            collisions += 1;\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpz_vn645m.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars = vec![0; n as usize];\n    for i in 0..n\
    \ {\n        cars[i as usize] = i;\n    }\n    let mut collisions = 0;\n    for\
    \ i in 0..n {\n        for j in 0..n {\n            if cars[i as usize] > cars[j\
    \ as usize] {\n                collisions += 1;\n            }\n        }\n  \
    \  }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp_56zyyan.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < n\
    \ && j < n {\n        if left_to_right[i as usize] < right_to_left[j as usize]\
    \ {\n            collisions += j;\n            i += 1;\n        } else {\n   \
    \         j += 1;\n        }\n    }\n    collisions += (n - i) * (n - i - 1) /\
    \ 2;\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpgbvsx1he.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut left_to_right =\
    \ 0;\n    let mut right_to_left = 0;\n    for i in 0..n {\n        left_to_right\
    \ += i;\n        right_to_left += n - i - 1;\n        collisions += left_to_right\
    \ * (n - i - 1) + right_to_left * i;\n    }\n    collisions\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp9jjzpk36.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 1 {\n        return 0;\n    }\n    let mut collisions\
    \ = 0;\n    let mut left_to_right = vec![0; n as usize];\n    let mut right_to_left\
    \ = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i as usize]\
    \ = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    for i in 0..n\
    \ {\n        for j in 0..n {\n            if left_to_right[i as usize] == right_to_left[j\
    \ as usize] {\n                collisions += 1;\n            }\n        }\n  \
    \  }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp_boh6rr0.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut left_to_right =\
    \ 0;\n    let mut right_to_left = 0;\n    while left_to_right < n {\n        left_to_right\
    \ += 1;\n        if right_to_left > 0 {\n            right_to_left -= 1;\n   \
    \         collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n\
    \    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n \
    \   assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpbqo04ndh.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = (0..n).collect();\n\
    \    let mut right_to_left: Vec<isize> = (0..n).rev().collect();\n    let mut\
    \ collisions = 0;\n    while !left_to_right.is_empty() && !right_to_left.is_empty()\
    \ {\n        if left_to_right[0] < right_to_left[0] {\n            collisions\
    \ += 1;\n            left_to_right.remove(0);\n            right_to_left.remove(0);\n\
    \        } else {\n            left_to_right.remove(0);\n        }\n    }\n  \
    \  collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n   \
    \ assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpaw5lb2_2.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 1 {\n        return 0;\n    }\n    let mut left_to_right\
    \ = vec![0; n as usize];\n    let mut right_to_left = vec![0; n as usize];\n \
    \   for i in 0..n {\n        left_to_right[i as usize] = i;\n        right_to_left[i\
    \ as usize] = n - i - 1;\n    }\n    let mut count = 0;\n    let mut i = 0;\n\
    \    let mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i as\
    \ usize] < right_to_left[j as usize] {\n            i += 1;\n        } else if\
    \ left_to_right[i as usize] > right_to_left[j as usize] {\n            j += 1;\n\
    \        } else {\n            count += 1;\n            i += 1;\n            j\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpad0ebboq.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if left_to_right[i as usize] == right_to_left[j as usize] {\n           \
    \     collisions += 1;\n            }\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp9hshb07y.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n == 0 {\n        return 0;\n    }\n    let mut left_to_right:\
    \ Vec<isize> = Vec::new();\n    let mut right_to_left: Vec<isize> = Vec::new();\n\
    \    for i in 1..=n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ + 1 - i);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left_car = left_to_right.remove(0);\n\
    \        let right_car = right_to_left.remove(0);\n        if left_car == right_car\
    \ {\n            collisions += 1;\n        } else if left_car < right_car {\n\
    \            left_to_right.push(left_car);\n            right_to_left.push(right_car);\n\
    \        } else {\n            left_to_right.push(right_car);\n            right_to_left.push(left_car);\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for i in 0..n {\n      \
    \  for j in 0..n {\n            if i < j {\n                collisions += 1;\n\
    \            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmppip_n_c6.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = Vec::new();\n   \
    \ let mut right_to_left: Vec<isize> = Vec::new();\n    for i in 0..n {\n     \
    \   left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n    }\n  \
    \  let mut collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < n && j < n {\n        if left_to_right[i] < right_to_left[j] {\n       \
    \     collisions += j;\n            i += 1;\n        } else {\n            j +=\
    \ 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp68n6ycwc.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp68n6ycwc.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = Vec::new();\n   \
    \ let mut right_to_left: Vec<isize> = Vec::new();\n    for i in 0..n {\n     \
    \   left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n    }\n  \
    \  let mut collisions = 0;\n    let mut left_index = 0;\n    let mut right_index\
    \ = 0;\n    while left_index < n && right_index < n {\n        if left_to_right[left_index]\
    \ < right_to_left[right_index] {\n            collisions += 1;\n            left_index\
    \ += 1;\n        } else {\n            right_index += 1;\n        }\n    }\n \
    \   collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n  \
    \  assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpe9vf9f2w.rs:20:12\n\
    \   |\n20 |         if left_to_right[left_index] < right_to_left[right_index]\
    \ {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpe9vf9f2w.rs:20:40\n   |\n20 |         if left_to_right[left_index]\
    \ < right_to_left[right_index] {\n   |                                       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut left_to_right =\
    \ vec![0; n as usize];\n    let mut right_to_left = vec![0; n as usize];\n   \
    \ for i in 0..n {\n        left_to_right[i as usize] = i;\n        right_to_left[i\
    \ as usize] = n - i - 1;\n    }\n    for i in 0..n {\n        for j in 0..n {\n\
    \            if left_to_right[i as usize] == right_to_left[j as usize] {\n   \
    \             collisions += 1;\n            }\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp8ssx_6s4.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    while\
    \ !left_to_right.is_empty() && !right_to_left.is_empty() {\n        let l = left_to_right.pop().unwrap();\n\
    \        let r = right_to_left.pop().unwrap();\n        if l == r {\n        \
    \    collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n  \
    \  let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n   \
    \ assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpx02wwfg1.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    while\
    \ !left_to_right.is_empty() && !right_to_left.is_empty() {\n        let left =\
    \ left_to_right.pop().unwrap();\n        let right = right_to_left.pop().unwrap();\n\
    \        if left == right {\n            collisions += 1;\n        } else if left\
    \ > right {\n            left_to_right.push(left);\n        } else {\n       \
    \     right_to_left.push(right);\n        }\n    }\n    collisions\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp36jiqlsk.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    while i < n && j < n {\n        if left_to_right[i] < right_to_left[j]\
    \ {\n            collisions += j;\n            i += 1;\n        } else {\n   \
    \         j += 1;\n        }\n    }\n    collisions += (n - i) * (n - j);\n  \
    \  collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n   \
    \ assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpqce2hspr.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpqce2hspr.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for i in 0..n {\n      \
    \  for j in 0..n {\n            if i < j {\n                collisions += 1;\n\
    \            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpalj1grfi.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = Vec::new();\n    let mut right_to_left\
    \ = Vec::new();\n    for i in 0..n {\n        left_to_right.push(i);\n       \
    \ right_to_left.push(n - i - 1);\n    }\n    let mut collisions = 0;\n    while\
    \ left_to_right.len() > 0 && right_to_left.len() > 0 {\n        if left_to_right[0]\
    \ < right_to_left[0] {\n            collisions += 1;\n            left_to_right.remove(0);\n\
    \            right_to_left.remove(0);\n        } else {\n            left_to_right.remove(0);\n\
    \            right_to_left.remove(0);\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpr8b662b4.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut left_to_right_cars\
    \ = Vec::new();\n    let mut right_to_left_cars = Vec::new();\n    for i in 0..n\
    \ {\n        left_to_right_cars.push(i);\n        right_to_left_cars.push(n -\
    \ i - 1);\n    }\n    while !left_to_right_cars.is_empty() && !right_to_left_cars.is_empty()\
    \ {\n        if left_to_right_cars[0] < right_to_left_cars[0] {\n            left_to_right_cars.remove(0);\n\
    \            collisions += 1;\n        } else {\n            right_to_left_cars.remove(0);\n\
    \        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp8bs1qp2y.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right: Vec<isize> = Vec::new();\n   \
    \ let mut right_to_left: Vec<isize> = Vec::new();\n    for i in 0..n {\n     \
    \   left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n    }\n  \
    \  let mut collisions = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < n && j < n {\n        if left_to_right[i] < right_to_left[j] {\n       \
    \     collisions += j;\n            i += 1;\n        } else {\n            j +=\
    \ 1;\n        }\n    }\n    collisions += (n - i) * (n - j);\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmphhi165bp.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmphhi165bp.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let l = left_to_right.pop().unwrap();\n\
    \        let r = right_to_left.pop().unwrap();\n        if l > r {\n         \
    \   collisions += 1;\n        }\n    }\n    collisions\n}\n\nfn main() {\n   \
    \ let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpmaos0wf5.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n <= 1 {\n        return 0;\n    }\n    let mut left_to_right\
    \ = vec![0; n as usize];\n    let mut right_to_left = vec![0; n as usize];\n \
    \   for i in 0..n {\n        left_to_right[i as usize] = i;\n        right_to_left[i\
    \ as usize] = n - i - 1;\n    }\n    let mut count = 0;\n    for i in 0..n {\n\
    \        for j in 0..n {\n            if left_to_right[i as usize] == right_to_left[j\
    \ as usize] {\n                count += 1;\n            }\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpf1ne5i49.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut left_to_right =\
    \ 0;\n    let mut right_to_left = 0;\n    while left_to_right < n {\n        if\
    \ left_to_right == right_to_left {\n            collisions += 1;\n        }\n\
    \        left_to_right += 1;\n        right_to_left += 1;\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpj55gbdsd.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO: Implement this function.\n    //\n    // Hint:\
    \ You can use the modulo operator to determine whether a number is even or odd.\n\
    \    //\n    // Hint: You can use the modulo operator to determine whether a number\
    \ is even or odd.\n    //\n    // Hint: You can use the modulo operator to determine\
    \ whether a number is even or odd.\n    //\n    // Hint: You can use the modulo\
    \ operator to determine whether a number is even or odd.\n    //\n    // Hint:\
    \ You can use the modulo operator to determine whether a number is even or odd.\n\
    \    //\n    // Hint: You can use the modulo operator to determine whether a number\
    \ is even or odd.\n    //\n    // Hint: You can use the modulo operator to determine\
    \ whether a number is even or odd.\n    //\n    // Hint: You can use the modulo\
    \ operator to determine whether a number is even or odd.\n    //\n    // Hint:\
    \ You can use the modulo operator to determine whether a number is even or odd.\n\
    \    //\n    // Hint: You can use the modulo operator to determine whether a number\
    \ is even or odd.\n    //\n    // Hint: You can use the modulo operator to determine\
    \ whether a number is even or odd.\n    //\n    // Hint: You can use the modulo\
    \ operator to determine whether a number is even or odd.\n    //\n    // Hint:\
    \ You can use the modulo operator to determine whether a number is even or odd.\n\
    \    //\n    // Hint: You can use the modulo operator to determine whether a number\
    \ is even or odd.\n    //\n    // Hint: You can use the modulo operator to determine\
    \ whether a number is even or odd.\n    //\n    // Hint: You can use the modulo\
    \ operator to determine whether a number is even or odd.\n    //\n    // Hint:\
    \ You can use the modulo operator to determine whether a number is even or odd.\n\
    \    //\n    // Hint: You can use the modulo operator to determine whether a number\
    \ is even or odd.\n    //\n    // Hint: You can use the modulo operator to determine\
    \ whether a number is even or odd.\n    //\n    // Hint\n}\n\nfn main() {\n  \
    \  let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n   \
    \ assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp31zan1ss.rs:9:36\n  |\n9 |\
    \ fn car_race_collision(n: isize) -> isize {\n  |    ------------------      \
    \        ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    if n < 1 {\n        return 0;\n    }\n    let mut left_to_right\
    \ = vec![0; n as usize];\n    let mut right_to_left = vec![0; n as usize];\n \
    \   for i in 0..n {\n        left_to_right[i as usize] = i;\n        right_to_left[i\
    \ as usize] = n - i - 1;\n    }\n    let mut collisions = 0;\n    let mut i =\
    \ 0;\n    let mut j = 0;\n    while i < n && j < n {\n        if left_to_right[i\
    \ as usize] < right_to_left[j as usize] {\n            collisions += j;\n    \
    \        i += 1;\n        } else {\n            j += 1;\n        }\n    }\n  \
    \  collisions += (n - i) * (j + 1);\n    collisions\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpbg5g_7qv.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO\n    0\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpec5gx315.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if left_to_right[i as usize] == right_to_left[j as usize] {\n           \
    \     collisions += 1;\n            }\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp0dbmqbci.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        if left_to_right[0] < right_to_left[0]\
    \ {\n            left_to_right.remove(0);\n            collisions += 1;\n    \
    \    } else {\n            right_to_left.remove(0);\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpv6qj3osv.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        if left_to_right[0] < right_to_left[0]\
    \ {\n            left_to_right.remove(0);\n            collisions += 1;\n    \
    \    } else {\n            right_to_left.remove(0);\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpb8chf8ha.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ && !right_to_left.is_empty() {\n        let left = left_to_right.pop().unwrap();\n\
    \        let right = right_to_left.pop().unwrap();\n        if left == right {\n\
    \            collisions += 1;\n        } else if left > right {\n            left_to_right.push(left);\n\
    \        } else {\n            right_to_left.push(right);\n        }\n    }\n\
    \    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpjfkd37yv.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for i in 1..n + 1 {\n  \
    \      collisions += i;\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpcd9s9tc3.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ {\n        let left = left_to_right.pop().unwrap();\n        let right = right_to_left.pop().unwrap();\n\
    \        if left == right {\n            collisions += 1;\n        }\n    }\n\
    \    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmppeso1zil.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    while !left_to_right.is_empty()\
    \ {\n        let left = left_to_right.pop().unwrap();\n        let right = right_to_left.pop().unwrap();\n\
    \        if left == right {\n            collisions += 1;\n        }\n    }\n\
    \    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n \
    \   assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpj5ylck37.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut left_to_right =\
    \ 0;\n    let mut right_to_left = 0;\n    while left_to_right < n {\n        left_to_right\
    \ += 1;\n        right_to_left += 1;\n        collisions += right_to_left;\n \
    \   }\n    collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpggvcekf7.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO\n    0\n}\n\nfn main() {\n    let candidate =\
    \ car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpmt26t_oh.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n    for i in 0..n {\n        for\
    \ j in 0..n {\n            if i < j {\n                count += 1;\n         \
    \   }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpvvvic4pe.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut count = 0;\n    for i in 0..n {\n        for j in 0..n {\n            if\
    \ left_to_right[i as usize] == right_to_left[j as usize] {\n                count\
    \ += 1;\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpch9su74y.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut num_collisions = 0;\n    let mut left_to_right\
    \ = vec![];\n    let mut right_to_left = vec![];\n    for i in 0..n {\n      \
    \  left_to_right.push(i);\n        right_to_left.push(n - i - 1);\n    }\n   \
    \ while !left_to_right.is_empty() && !right_to_left.is_empty() {\n        let\
    \ left_car = left_to_right.pop().unwrap();\n        let right_car = right_to_left.pop().unwrap();\n\
    \        if left_car == right_car {\n            num_collisions += 1;\n      \
    \  }\n    }\n    num_collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmplv2qqhyt.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut left_to_right =\
    \ vec![0; n as usize];\n    let mut right_to_left = vec![0; n as usize];\n   \
    \ for i in 0..n {\n        left_to_right[i as usize] = i;\n        right_to_left[i\
    \ as usize] = n - i - 1;\n    }\n    for i in 0..n {\n        for j in 0..n {\n\
    \            if left_to_right[i as usize] > right_to_left[j as usize] {\n    \
    \            collisions += 1;\n            }\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpmveu5s5d.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    // TODO: implement this function\n    0\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `4`', /tmp/tmpkg6rmheo.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    let mut left_to_right =\
    \ vec![0; n as usize];\n    let mut right_to_left = vec![0; n as usize];\n   \
    \ for i in 0..n {\n        left_to_right[i as usize] = i;\n        right_to_left[i\
    \ as usize] = n - i - 1;\n    }\n    for i in 0..n {\n        for j in 0..n {\n\
    \            if left_to_right[i as usize] == right_to_left[j as usize] {\n   \
    \             collisions += 1;\n            }\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp_5sqyxfn.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut cars_left = vec![0; n as usize];\n    let mut\
    \ cars_right = vec![0; n as usize];\n    let mut collision_count = 0;\n    for\
    \ i in 0..n {\n        cars_left[i as usize] = i;\n        cars_right[i as usize]\
    \ = n - i - 1;\n    }\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if cars_left[i as usize] == cars_right[j as usize] {\n                collision_count\
    \ += 1;\n            }\n        }\n    }\n    collision_count\n}\n\nfn main()\
    \ {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n\
    \    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8),\
    \ 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5bpw5j77.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    let mut collisions = 0;\n    for\
    \ i in 0..n {\n        left_to_right[i as usize] = i;\n        right_to_left[i\
    \ as usize] = n - i - 1;\n    }\n    for i in 0..n {\n        for j in 0..n {\n\
    \            if left_to_right[i as usize] == right_to_left[j as usize] {\n   \
    \             collisions += 1;\n            }\n        }\n    }\n    collisions\n\
    }\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpq8xo4o94.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut count = 0;\n    for i in 0..n {\n        for\
    \ j in 0..n {\n            if i < j {\n                count += 1;\n         \
    \   }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = car_race_collision;\n\
    \    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp6m4izfpz.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![0; n as usize];\n    let\
    \ mut right_to_left = vec![0; n as usize];\n    for i in 0..n {\n        left_to_right[i\
    \ as usize] = i;\n        right_to_left[i as usize] = n - i - 1;\n    }\n    let\
    \ mut collisions = 0;\n    for i in 0..n {\n        for j in 0..n {\n        \
    \    if left_to_right[i as usize] == right_to_left[j as usize] {\n           \
    \     collisions += 1;\n            }\n        }\n    }\n    collisions\n}\n\n\
    fn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2),\
    \ 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n \
    \   assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpvqtlb769.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut left_to_right = vec![];\n    let mut right_to_left\
    \ = vec![];\n    for i in 0..n {\n        left_to_right.push(i);\n        right_to_left.push(n\
    \ - i - 1);\n    }\n    let mut collisions = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    while i < n && j < n {\n        if left_to_right[i] < right_to_left[j]\
    \ {\n            collisions += j;\n            i += 1;\n        } else {\n   \
    \         j += 1;\n        }\n    }\n    collisions += (n - i) * (n - j);\n  \
    \  collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n   \
    \ assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4),\
    \ 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n\
    }\n"
  stdout: ''
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmphep5oo6u.rs:20:12\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \ ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmphep5oo6u.rs:20:31\n\
    \   |\n20 |         if left_to_right[i] < right_to_left[j] {\n   |           \
    \                    ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Imagine a road that's a perfectly straight infinitely long line.\n\
    /// n cars are driving left to right;  simultaneously, a different set of n cars\n\
    /// are driving right to left.   The two sets of cars start out being very far\
    \ from\n/// each other.  All cars move in the same speed.  Two cars are said to\
    \ collide\n/// when a car that's moving left to right hits a car that's moving\
    \ right to left.\n/// However, the cars are infinitely sturdy and strong; as a\
    \ result, they continue moving\n/// in their trajectory as if they did not collide.\n\
    /// This function outputs the number of such collisions.\nfn car_race_collision(n:\
    \ isize) -> isize {\n    let mut collisions = 0;\n    for i in 0..n {\n      \
    \  for j in 0..n {\n            if i < j {\n                collisions += 1;\n\
    \            }\n        }\n    }\n    collisions\n}\n\nfn main() {\n    let candidate\
    \ = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3),\
    \ 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n\
    \    assert_eq!(candidate(10), 100);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp0mtya11s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
