language: rs
name: HumanEval_68_pluck
results:
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, &v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < min_even {\n            min_even = v;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n  \
    \  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut evens_indices: Vec<usize> = Vec::new();\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 {\n            evens.push(x);\n            evens_indices.push(i);\n\
    \        }\n    }\n    if evens.is_empty() {\n        return vec![];\n    }\n\
    \    let mut min_even = evens[0];\n    let mut min_even_index = evens_indices[0];\n\
    \    for (i, &x) in evens.iter().enumerate() {\n        if x < min_even {\n  \
    \          min_even = x;\n            min_even_index = evens_indices[i];\n   \
    \     }\n    }\n    vec![min_even, min_even_index as isize]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if *val % 2 == 0 && *val < min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < min_even {\n            min_even = x;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        return vec![];\n    }\n    vec![min_even, min_even_index]\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|&x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let smallest_even = evens[0];\n    let\
    \ mut smallest_even_index = 0;\n    for (i, &x) in arr.iter().enumerate() {\n\
    \        if x == smallest_even {\n            smallest_even_index = i;\n     \
    \       break;\n        }\n    }\n    vec![smallest_even, smallest_even_index\
    \ as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut evens_idx: Vec<usize> = Vec::new();\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 {\n            evens.push(*v);\n            evens_idx.push(i);\n\
    \        }\n    }\n    if evens.is_empty() {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_idx = evens_idx[evens.iter().position(|&r|\
    \ r == *min_even).unwrap()];\n    vec![*min_even, min_even_idx as isize]\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_nums: Vec<isize> =\
    \ Vec::new();\n    let mut even_nums_index: Vec<usize> = Vec::new();\n    for\
    \ (i, num) in arr.iter().enumerate() {\n        if num % 2 == 0 {\n          \
    \  even_nums.push(*num);\n            even_nums_index.push(i);\n        }\n  \
    \  }\n    if even_nums.is_empty() {\n        return vec![];\n    }\n    let min_even_num\
    \ = even_nums.iter().min().unwrap();\n    let min_even_num_index = even_nums_index[even_nums.iter().position(|&r|\
    \ r == *min_even_num).unwrap()];\n    vec![*min_even_num, min_even_num_index as\
    \ isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < &min_even {\n            min_even = *v;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_nums: Vec<isize> =\
    \ vec![];\n    let mut even_nums_index: Vec<usize> = vec![];\n    for (i, &num)\
    \ in arr.iter().enumerate() {\n        if num % 2 == 0 {\n            even_nums.push(num);\n\
    \            even_nums_index.push(i);\n        }\n    }\n    if even_nums.is_empty()\
    \ {\n        return vec![];\n    }\n    let min_even_num = even_nums.iter().min().unwrap();\n\
    \    let min_even_num_index = even_nums_index[even_nums.iter().position(|&x| x\
    \ == *min_even_num).unwrap()];\n    vec![*min_even_num, min_even_num_index as\
    \ isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < min_even {\n            min_even = x;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n  \
    \  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = isize::max_value();\n\
    \    let mut min_even_idx = isize::max_value();\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ isize::max_value() {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < min_even {\n            min_even = x;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n  \
    \  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if *val % 2 == 0 && *val < min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < min_even {\n            min_even = x;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        return vec![];\n    }\n    vec![min_even, min_even_index]\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < &min_even {\n            min_even = *x;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < &min_even {\n            min_even = *v;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_index]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|&x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let min_even = evens[0];\n    let mut\
    \ min_even_index = 0;\n    for (i, &x) in arr.iter().enumerate() {\n        if\
    \ x == min_even {\n            min_even_index = i;\n            break;\n     \
    \   }\n    }\n    vec![min_even, min_even_index as isize]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut evens_index: Vec<usize> = Vec::new();\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 {\n            evens.push(*n);\n            evens_index.push(i);\n\
    \        }\n    }\n    if evens.is_empty() {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_index = evens_index[evens.iter().position(|&x|\
    \ x == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if *val % 2 == 0 && *val < min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let smallest_even = evens[0];\n    let\
    \ index = arr.iter().position(|x| x == &smallest_even).unwrap();\n    vec![smallest_even,\
    \ index as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmph2oz8ioi.rs:27:57\n\
    \   |\n27 |     let mut evens: Vec<isize> = arr.iter().filter(|x| x % 2 == 0).cloned().collect();\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &&isize\n   |\nhelp: `%` can be\
    \ used on `isize`, you can dereference `x`\n   |\n27 |     let mut evens: Vec<isize>\
    \ = arr.iter().filter(|x| *x % 2 == 0).cloned().collect();\n   |             \
    \                                          +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut evens_index: Vec<usize> = Vec::new();\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 {\n            evens.push(*n);\n            evens_index.push(i);\n\
    \        }\n    }\n    if evens.is_empty() {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_index = evens_index[evens.iter().position(|&x|\
    \ x == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut evens_index: Vec<usize> = Vec::new();\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 {\n            evens.push(*n);\n            evens_index.push(i);\n\
    \        }\n    }\n    if evens.is_empty() {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_index = evens_index[evens.iter().position(|&r|\
    \ r == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, &val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < min_even {\n            min_even = val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if *val % 2 == 0 && *val < min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|&x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let smallest_even = evens[0];\n    let\
    \ mut smallest_even_index = 0;\n    for (i, &x) in arr.iter().enumerate() {\n\
    \        if x == smallest_even {\n            smallest_even_index = i;\n     \
    \       break;\n        }\n    }\n    vec![smallest_even, smallest_even_index\
    \ as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = isize::max_value();\n\
    \    let mut min_even_index = isize::max_value();\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 && n < &min_even {\n            min_even = *n;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even ==\
    \ isize::max_value() {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 && n < &min_even {\n            min_even = *n;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even = isize::max_value();\n\
    \    let mut smallest_even_index = isize::max_value();\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < smallest_even {\n            smallest_even =\
    \ x;\n            smallest_even_index = i as isize;\n        }\n    }\n    if\
    \ smallest_even == isize::max_value() {\n        vec![]\n    } else {\n      \
    \  vec![smallest_even, smallest_even_index]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut evens_index: Vec<usize> = Vec::new();\n    for (index, value) in\
    \ arr.iter().enumerate() {\n        if value % 2 == 0 {\n            evens.push(*value);\n\
    \            evens_index.push(index);\n        }\n    }\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut min_even = evens[0];\n    let\
    \ mut min_even_index = evens_index[0];\n    for (index, value) in evens.iter().enumerate()\
    \ {\n        if value < &min_even {\n            min_even = *value;\n        \
    \    min_even_index = evens_index[index];\n        }\n    }\n    vec![min_even,\
    \ min_even_index as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n   \
    \ assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|&x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let smallest_even = evens[0];\n    let\
    \ mut smallest_even_index = 0;\n    for (i, &x) in arr.iter().enumerate() {\n\
    \        if x == smallest_even {\n            smallest_even_index = i;\n     \
    \       break;\n        }\n    }\n    vec![smallest_even, smallest_even_index\
    \ as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut evens_indexes: Vec<usize> = Vec::new();\n    for (index, value) in\
    \ arr.iter().enumerate() {\n        if value % 2 == 0 {\n            evens.push(*value);\n\
    \            evens_indexes.push(index);\n        }\n    }\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let min_even = evens.iter().min().unwrap();\n\
    \    let min_even_index = evens_indexes[evens.iter().position(|&x| x == *min_even).unwrap()];\n\
    \    vec![*min_even, min_even_index as isize]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, &v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < min_even {\n            min_even = v;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        return vec![];\n    }\n    vec![min_even, min_even_index]\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut evens_index: Vec<usize> = Vec::new();\n    for (index, value) in\
    \ arr.iter().enumerate() {\n        if value % 2 == 0 {\n            evens.push(*value);\n\
    \            evens_index.push(index);\n        }\n    }\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut min = evens[0];\n    let mut min_index\
    \ = evens_index[0];\n    for (index, value) in evens.iter().enumerate() {\n  \
    \      if value < &min {\n            min = *value;\n            min_index = evens_index[index];\n\
    \        }\n    }\n    vec![min, min_index as isize]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|&x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let smallest_even = evens[0];\n    let\
    \ mut smallest_even_index = 0;\n    for (i, &x) in arr.iter().enumerate() {\n\
    \        if x == smallest_even {\n            smallest_even_index = i;\n     \
    \       break;\n        }\n    }\n    vec![smallest_even, smallest_even_index\
    \ as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut evens_index: Vec<usize> = Vec::new();\n    for (i, &v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 {\n            evens.push(v);\n            evens_index.push(i);\n\
    \        }\n    }\n    if evens.is_empty() {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_index = evens_index[evens.iter().position(|&x|\
    \ x == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < min_even {\n            min_even = x;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        return vec![];\n    }\n    vec![min_even, min_even_index]\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, &val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < min_even {\n            min_even = val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut evens_index: Vec<usize> = Vec::new();\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 {\n            evens.push(*v);\n            evens_index.push(i);\n\
    \        }\n    }\n    if evens.is_empty() {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_index = evens_index[evens.iter().position(|&r|\
    \ r == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min = std::isize::MAX;\n\
    \    let mut min_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && *val < min {\n            min = *val;\n      \
    \      min_idx = idx as isize;\n        }\n    }\n    if min == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min, min_idx]\n    }\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even_idx\
    \ == std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    if arr.is_empty() {\n        return\
    \ vec![];\n    }\n    let mut min_even = std::isize::MAX;\n    let mut min_even_idx\
    \ = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate() {\n       \
    \ if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n       \
    \     min_even_idx = idx as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        return vec![];\n    }\n    vec![min_even, min_even_idx]\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|&x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    let mut result: Vec<isize>\
    \ = Vec::new();\n    if evens.len() > 0 {\n        let min = evens[0];\n     \
    \   let index = arr.iter().position(|&x| x == min).unwrap();\n        result.push(min);\n\
    \        result.push(index as isize);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut evens_index: Vec<usize> = Vec::new();\n    for (index, value) in\
    \ arr.iter().enumerate() {\n        if value % 2 == 0 {\n            evens.push(*value);\n\
    \            evens_index.push(index);\n        }\n    }\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut min_even = evens[0];\n    let\
    \ mut min_even_index = evens_index[0];\n    for (index, value) in evens.iter().enumerate()\
    \ {\n        if value < &min_even {\n            min_even = *value;\n        \
    \    min_even_index = evens_index[index];\n        }\n    }\n    vec![min_even,\
    \ min_even_index as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n   \
    \ assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let min = evens[0];\n    let idx = arr.iter().position(|x|\
    \ x == &min).unwrap();\n    vec![min, idx as isize]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpm4p5lzbe.rs:27:57\n\
    \   |\n27 |     let mut evens: Vec<isize> = arr.iter().filter(|x| x % 2 == 0).cloned().collect();\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &&isize\n   |\nhelp: `%` can be\
    \ used on `isize`, you can dereference `x`\n   |\n27 |     let mut evens: Vec<isize>\
    \ = arr.iter().filter(|x| *x % 2 == 0).cloned().collect();\n   |             \
    \                                          +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min = std::isize::MAX;\n\
    \    let mut min_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min {\n            min = *val;\n      \
    \      min_idx = idx as isize;\n        }\n    }\n    if min == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min, min_idx]\n    }\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, &val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < min_even {\n            min_even = val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, &v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < min_even {\n            min_even = v;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n  \
    \  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = isize::max_value();\n\
    \    let mut min_even_index = isize::max_value();\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < &min_even {\n            min_even = *v;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even ==\
    \ isize::max_value() {\n        return vec![];\n    }\n    vec![min_even, min_even_index]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min = std::isize::MAX;\n\
    \    let mut min_index = std::isize::MAX;\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 && n < &min {\n            min = *n;\n            min_index\
    \ = i as isize;\n        }\n    }\n    if min == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min, min_index]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, &val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < min_even {\n            min_even = val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|&x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let min = evens[0];\n    let mut min_index\
    \ = 0;\n    for (i, &x) in arr.iter().enumerate() {\n        if x == min {\n \
    \           min_index = i;\n            break;\n        }\n    }\n    vec![min,\
    \ min_index as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < min_even {\n            min_even = x;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n  \
    \  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < &min_even {\n            min_even = *v;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even_index\
    \ == std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_index]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut evens_idx: Vec<usize> = Vec::new();\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 {\n            evens.push(*val);\n            evens_idx.push(idx);\n\
    \        }\n    }\n    if evens.is_empty() {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_idx = evens_idx[evens.iter().position(|&x|\
    \ x == *min_even).unwrap()];\n    vec![*min_even, min_even_idx as isize]\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = isize::max_value();\n\
    \    let mut min_even_idx = isize::max_value();\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even_idx\
    \ == isize::max_value() {\n        return vec![];\n    }\n    vec![min_even, min_even_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, &val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < min_even {\n            min_even = val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even = std::isize::MAX;\n\
    \    let mut smallest_even_index = std::isize::MAX;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < smallest_even {\n            smallest_even =\
    \ x;\n            smallest_even_index = i as isize;\n        }\n    }\n    if\
    \ smallest_even_index == std::isize::MAX {\n        return vec![];\n    }\n  \
    \  vec![smallest_even, smallest_even_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, &n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 && n < min_even {\n            min_even = n;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even_index\
    \ == std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min = std::isize::MAX;\n\
    \    let mut min_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min {\n            min = *val;\n      \
    \      min_idx = idx as isize;\n        }\n    }\n    if min == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min, min_idx]\n    }\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min = std::isize::MAX;\n\
    \    let mut min_idx = std::isize::MAX;\n    for (idx, item) in arr.iter().enumerate()\
    \ {\n        if item % 2 == 0 && item < &min {\n            min = *item;\n   \
    \         min_idx = idx as isize;\n        }\n    }\n    if min == std::isize::MAX\
    \ {\n        return vec![];\n    }\n    vec![min, min_idx]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|&x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let smallest_even = evens[0];\n    let\
    \ mut smallest_even_index = 0;\n    for (index, &value) in arr.iter().enumerate()\
    \ {\n        if value == smallest_even {\n            smallest_even_index = index;\n\
    \            break;\n        }\n    }\n    vec![smallest_even, smallest_even_index\
    \ as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|&x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    let mut result: Vec<isize>\
    \ = Vec::new();\n    if evens.len() > 0 {\n        let min = evens[0];\n     \
    \   let mut min_index = 0;\n        for (i, x) in arr.iter().enumerate() {\n \
    \           if x == &min {\n                min_index = i;\n                break;\n\
    \            }\n        }\n        result.push(min);\n        result.push(min_index\
    \ as isize);\n    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let min = evens[0];\n    let min_index\
    \ = arr.iter().position(|x| x == &min).unwrap();\n    vec![min, min_index as isize]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmp2v6hl_xs.rs:27:57\n\
    \   |\n27 |     let mut evens: Vec<isize> = arr.iter().filter(|x| x % 2 == 0).cloned().collect();\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &&isize\n   |\nhelp: `%` can be\
    \ used on `isize`, you can dereference `x`\n   |\n27 |     let mut evens: Vec<isize>\
    \ = arr.iter().filter(|x| *x % 2 == 0).cloned().collect();\n   |             \
    \                                          +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even = std::isize::MAX;\n\
    \    let mut smallest_even_index = std::isize::MAX;\n    for (i, &val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < smallest_even {\n            smallest_even\
    \ = val;\n            smallest_even_index = i as isize;\n        }\n    }\n  \
    \  if smallest_even == std::isize::MAX {\n        vec![]\n    } else {\n     \
    \   vec![smallest_even, smallest_even_index]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut evens_index: Vec<usize> = Vec::new();\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 {\n            evens.push(*n);\n            evens_index.push(i);\n\
    \        }\n    }\n    if evens.is_empty() {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_index = evens_index[evens.iter().position(|&x|\
    \ x == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_nums: Vec<isize> =\
    \ vec![];\n    let mut even_nums_index: Vec<usize> = vec![];\n    for (index,\
    \ num) in arr.iter().enumerate() {\n        if num % 2 == 0 {\n            even_nums.push(*num);\n\
    \            even_nums_index.push(index);\n        }\n    }\n    if even_nums.is_empty()\
    \ {\n        return vec![];\n    }\n    let min_even_num = even_nums.iter().min().unwrap();\n\
    \    let min_even_num_index = even_nums_index[even_nums.iter().position(|&x| x\
    \ == *min_even_num).unwrap()];\n    vec![*min_even_num, min_even_num_index as\
    \ isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut evens_index: Vec<usize> = Vec::new();\n    for (i, x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 {\n            evens.push(*x);\n            evens_index.push(i);\n\
    \        }\n    }\n    if evens.is_empty() {\n        return vec![];\n    }\n\
    \    let min_value = evens.iter().min().unwrap();\n    let min_index = evens_index[evens.iter().position(|&r|\
    \ r == *min_value).unwrap()];\n    vec![*min_value, min_index as isize]\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min = std::isize::MAX;\n\
    \    let mut min_idx = std::isize::MAX;\n    for (idx, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < &min {\n            min = *v;\n            min_idx\
    \ = idx as isize;\n        }\n    }\n    if min == std::isize::MAX {\n       \
    \ vec![]\n    } else {\n        vec![min, min_idx]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = isize::max_value();\n\
    \    let mut min_even_index = isize::max_value();\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < min_even {\n            min_even = x;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even == isize::max_value()\
    \ {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n  \
    \  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min = std::isize::MAX;\n\
    \    let mut min_index = std::isize::MAX;\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 && n < &min {\n            min = *n;\n            min_index\
    \ = i as isize;\n        }\n    }\n    if min == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min, min_index]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|&x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let min = evens[0];\n    let mut index\
    \ = 0;\n    for (i, &x) in arr.iter().enumerate() {\n        if x == min {\n \
    \           index = i;\n            break;\n        }\n    }\n    vec![min, index\
    \ as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 && n < &min_even {\n            min_even = *n;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_index]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even_idx\
    \ == std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let\
    \ mut min = std::isize::MAX;\n    let mut index = 0;\n    for (i, x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < &min {\n            min = *x;\n            index\
    \ = i;\n        }\n    }\n    if min != std::isize::MAX {\n        result.push(min);\n\
    \        result.push(index as isize);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = isize::max_value();\n\
    \    let mut min_even_idx = isize::max_value();\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ isize::max_value() {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, &v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < min_even {\n            min_even = v;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n  \
    \  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even = isize::max_value();\n\
    \    let mut smallest_even_index = isize::max_value();\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if *v % 2 == 0 && *v < smallest_even {\n            smallest_even\
    \ = *v;\n            smallest_even_index = i as isize;\n        }\n    }\n   \
    \ if smallest_even == isize::max_value() {\n        return vec![];\n    }\n  \
    \  vec![smallest_even, smallest_even_index]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = isize::max_value();\n\
    \    let mut min_even_index = isize::max_value();\n    for (i, x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < &min_even {\n            min_even = *x;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even ==\
    \ isize::max_value() {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_numbers: Vec<isize>\
    \ = vec![];\n    let mut even_numbers_indexes: Vec<usize> = vec![];\n    for (i,\
    \ num) in arr.iter().enumerate() {\n        if num % 2 == 0 {\n            even_numbers.push(*num);\n\
    \            even_numbers_indexes.push(i);\n        }\n    }\n    if even_numbers.is_empty()\
    \ {\n        return vec![];\n    }\n    let min_even_number = even_numbers.iter().min().unwrap();\n\
    \    let min_even_number_index = even_numbers_indexes[even_numbers.iter().position(|&x|\
    \ x == *min_even_number).unwrap()];\n    vec![*min_even_number, min_even_number_index\
    \ as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min = std::isize::MAX;\n\
    \    let mut min_index = std::isize::MAX;\n    for (index, value) in arr.iter().enumerate()\
    \ {\n        if value % 2 == 0 && value < &min {\n            min = *value;\n\
    \            min_index = index as isize;\n        }\n    }\n    if min == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min, min_index]\n    }\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_index = std::isize::MAX;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < min_even {\n            min_even = x;\n    \
    \        min_index = i as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min_even, min_index]\n    }\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if *v % 2 == 0 && *v < min_even {\n            min_even = *v;\n \
    \           min_even_index = i as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let\
    \ mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, v) in arr.iter().enumerate() {\n        if v % 2 == 0 && v < &min_even\
    \ {\n            min_even = *v;\n            min_even_index = i as isize;\n  \
    \      }\n    }\n    if min_even != std::isize::MAX {\n        result.push(min_even);\n\
    \        result.push(min_even_index);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, &val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < min_even {\n            min_even = val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even_idx\
    \ == std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even = std::isize::MAX;\n\
    \    let mut smallest_even_index = std::isize::MAX;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < smallest_even {\n            smallest_even =\
    \ x;\n            smallest_even_index = i as isize;\n        }\n    }\n    if\
    \ smallest_even == std::isize::MAX {\n        vec![]\n    } else {\n        vec![smallest_even,\
    \ smallest_even_index]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n\
    \    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut smallest_even = std::isize::MAX;\n\
    \    let mut smallest_even_index = std::isize::MAX;\n    for (index, value) in\
    \ arr.iter().enumerate() {\n        if value % 2 == 0 && value < &smallest_even\
    \ {\n            smallest_even = *value;\n            smallest_even_index = index\
    \ as isize;\n        }\n    }\n    if smallest_even == std::isize::MAX {\n   \
    \     vec![]\n    } else {\n        vec![smallest_even, smallest_even_index]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 && n < &min_even {\n            min_even = *n;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even_index\
    \ == std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = isize::max_value();\n\
    \    let mut min_even_idx = isize::max_value();\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && *val < min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ isize::max_value() {\n        return vec![];\n    }\n    vec![min_even, min_even_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_index = 0;\n    let\
    \ mut min_value = 0;\n    let mut min_found = false;\n    for (index, value) in\
    \ arr.iter().enumerate() {\n        if value % 2 == 0 {\n            if !min_found\
    \ {\n                min_found = true;\n                min_index = index;\n \
    \               min_value = *value;\n            } else if *value < min_value\
    \ {\n                min_index = index;\n                min_value = *value;\n\
    \            }\n        }\n    }\n    if min_found {\n        vec![min_value,\
    \ min_index as isize]\n    } else {\n        vec![]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min = isize::max_value();\n\
    \    let mut min_index = isize::max_value();\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 && n < &min {\n            min = *n;\n            min_index\
    \ = i as isize;\n        }\n    }\n    if min == isize::max_value() {\n      \
    \  vec![]\n    } else {\n        vec![min, min_index]\n    }\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut evens_index: Vec<usize> = Vec::new();\n    for (index, value) in\
    \ arr.iter().enumerate() {\n        if value % 2 == 0 {\n            evens.push(*value);\n\
    \            evens_index.push(index);\n        }\n    }\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let min_even = evens.iter().min().unwrap();\n\
    \    let min_even_index = evens_index[evens.iter().position(|&r| r == *min_even).unwrap()];\n\
    \    vec![*min_even, min_even_index as isize]\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < min_even {\n            min_even = x;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        return vec![];\n    }\n    vec![min_even, min_even_index]\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let min = evens[0];\n    let min_index\
    \ = arr.iter().position(|x| x == &min).unwrap();\n    vec![min, min_index as isize]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmp2v6hl_xs.rs:27:57\n\
    \   |\n27 |     let mut evens: Vec<isize> = arr.iter().filter(|x| x % 2 == 0).cloned().collect();\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &&isize\n   |\nhelp: `%` can be\
    \ used on `isize`, you can dereference `x`\n   |\n27 |     let mut evens: Vec<isize>\
    \ = arr.iter().filter(|x| *x % 2 == 0).cloned().collect();\n   |             \
    \                                          +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = isize::max_value();\n\
    \    let mut min_even_index = isize::max_value();\n    for (index, value) in arr.iter().enumerate()\
    \ {\n        if value % 2 == 0 && value < &min_even {\n            min_even =\
    \ *value;\n            min_even_index = index as isize;\n        }\n    }\n  \
    \  if min_even_index == isize::max_value() {\n        vec![]\n    } else {\n \
    \       vec![min_even, min_even_index]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = 0;\n    for (i, n) in arr.iter().enumerate() {\n\
    \        if n % 2 == 0 && n < &min_even {\n            min_even = *n;\n      \
    \      min_even_index = i;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min_even, min_even_index as isize]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (index, value) in arr.iter().enumerate()\
    \ {\n        if value % 2 == 0 && value < &min_even {\n            min_even =\
    \ *value;\n            min_even_index = index as isize;\n        }\n    }\n  \
    \  if min_even == std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even,\
    \ min_even_index]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut evens_index: Vec<usize> = Vec::new();\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 {\n            evens.push(*n);\n            evens_index.push(i);\n\
    \        }\n    }\n    if evens.is_empty() {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_index = evens.iter().position(|&x|\
    \ x == *min_even).unwrap();\n    vec![*min_even, evens_index[min_even_index] as\
    \ isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < &min_even {\n            min_even = *v;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_index]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = isize::max_value();\n\
    \    let mut min_even_idx = isize::max_value();\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ isize::max_value() {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = isize::max_value();\n\
    \    let mut min_even_index = isize::max_value();\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < &min_even {\n            min_even = *v;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even_index\
    \ == isize::max_value() {\n        vec![]\n    } else {\n        vec![min_even,\
    \ min_even_index]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = isize::max_value();\n\
    \    let mut min_even_idx = isize::max_value();\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ isize::max_value() {\n        return vec![];\n    }\n    vec![min_even, min_even_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = isize::max_value();\n\
    \    let mut min_even_idx = isize::max_value();\n    for (idx, &val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < min_even {\n            min_even = val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ isize::max_value() {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 && n < &min_even {\n            min_even = *n;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_index]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min = std::isize::MAX;\n\
    \    let mut min_idx = std::isize::MAX;\n    for (idx, &val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < min {\n            min = val;\n        \
    \    min_idx = idx as isize;\n        }\n    }\n    if min == std::isize::MAX\
    \ {\n        return vec![];\n    }\n    vec![min, min_idx]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|&x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let min_even = evens[0];\n    let min_even_index\
    \ = arr.iter().position(|&x| x == min_even).unwrap();\n    vec![min_even, min_even_index\
    \ as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let min_even = evens[0];\n    let mut\
    \ min_even_index = 0;\n    for (i, x) in arr.iter().enumerate() {\n        if\
    \ x == &min_even {\n            min_even_index = i;\n            break;\n    \
    \    }\n    }\n    vec![min_even, min_even_index as isize]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpna3audla.rs:27:57\n\
    \   |\n27 |     let mut evens: Vec<isize> = arr.iter().filter(|x| x % 2 == 0).cloned().collect();\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &&isize\n   |\nhelp: `%` can be\
    \ used on `isize`, you can dereference `x`\n   |\n27 |     let mut evens: Vec<isize>\
    \ = arr.iter().filter(|x| *x % 2 == 0).cloned().collect();\n   |             \
    \                                          +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659748549
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let min = evens[0];\n    let mut min_index\
    \ = 0;\n    for (i, x) in arr.iter().enumerate() {\n        if x == &min {\n \
    \           min_index = i;\n            break;\n        }\n    }\n    vec![min,\
    \ min_index as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpolhs0f4e.rs:27:57\n\
    \   |\n27 |     let mut evens: Vec<isize> = arr.iter().filter(|x| x % 2 == 0).cloned().collect();\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &&isize\n   |\nhelp: `%` can be\
    \ used on `isize`, you can dereference `x`\n   |\n27 |     let mut evens: Vec<isize>\
    \ = arr.iter().filter(|x| *x % 2 == 0).cloned().collect();\n   |             \
    \                                          +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = isize::max_value();\n\
    \    let mut min_even_idx = isize::max_value();\n    for (idx, &val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < min_even {\n            min_even = val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ isize::max_value() {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < &min_even {\n            min_even = *v;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if *val % 2 == 0 && *val < min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = isize::max_value();\n\
    \    let mut min_even_idx = isize::max_value();\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if *val % 2 == 0 && *val < min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ isize::max_value() {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let min = evens[0];\n    let index = arr.iter().position(|x|\
    \ x == &min).unwrap();\n    vec![min, index as isize]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpljefmzpm.rs:27:57\n\
    \   |\n27 |     let mut evens: Vec<isize> = arr.iter().filter(|x| x % 2 == 0).cloned().collect();\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &&isize\n   |\nhelp: `%` can be\
    \ used on `isize`, you can dereference `x`\n   |\n27 |     let mut evens: Vec<isize>\
    \ = arr.iter().filter(|x| *x % 2 == 0).cloned().collect();\n   |             \
    \                                          +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut evens_index: Vec<usize> = Vec::new();\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 {\n            evens.push(x);\n            evens_index.push(i);\n\
    \        }\n    }\n    if evens.is_empty() {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_index = evens_index[evens.iter().position(|&x|\
    \ x == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min = std::isize::MAX;\n\
    \    let mut idx = std::isize::MAX;\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < &min {\n            min = *v;\n            idx\
    \ = i as isize;\n        }\n    }\n    if min == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![min, idx]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut evens_index: Vec<usize> = Vec::new();\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 {\n            evens.push(*n);\n            evens_index.push(i);\n\
    \        }\n    }\n    if evens.is_empty() {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_index = evens_index[evens.iter().position(|&r|\
    \ r == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, &val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < min_even {\n            min_even = val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut evens_idx: Vec<usize> = Vec::new();\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 {\n            evens.push(*val);\n            evens_idx.push(idx);\n\
    \        }\n    }\n    if evens.is_empty() {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_idx = evens_idx[evens.iter().position(|&x|\
    \ x == *min_even).unwrap()];\n    vec![*min_even, min_even_idx as isize]\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut evens_index: Vec<usize> = Vec::new();\n    for (index, value) in\
    \ arr.iter().enumerate() {\n        if value % 2 == 0 {\n            evens.push(*value);\n\
    \            evens_index.push(index);\n        }\n    }\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut min = evens[0];\n    let mut min_index\
    \ = evens_index[0];\n    for (index, value) in evens.iter().enumerate() {\n  \
    \      if value < &min {\n            min = *value;\n            min_index = evens_index[index];\n\
    \        }\n    }\n    vec![min, min_index as isize]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, item) in arr.iter().enumerate()\
    \ {\n        if item % 2 == 0 && item < &min_even {\n            min_even = *item;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 && n < &min_even {\n            min_even = *n;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min = isize::max_value();\n\
    \    let mut min_index = isize::max_value();\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 && n < &min {\n            min = *n;\n            min_index\
    \ = i as isize;\n        }\n    }\n    if min == isize::max_value() {\n      \
    \  return vec![];\n    }\n    vec![min, min_index]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < &min_even {\n            min_even = *v;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_index]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut indices: Vec<usize> = Vec::new();\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 {\n            evens.push(*n);\n            indices.push(i);\n\
    \        }\n    }\n    if evens.is_empty() {\n        return vec![];\n    }\n\
    \    let min = evens.iter().min().unwrap();\n    let mut min_indices: Vec<usize>\
    \ = Vec::new();\n    for (i, n) in evens.iter().enumerate() {\n        if n ==\
    \ min {\n            min_indices.push(i);\n        }\n    }\n    let mut min_index\
    \ = min_indices[0];\n    for i in min_indices {\n        if indices[i] < indices[min_index]\
    \ {\n            min_index = i;\n        }\n    }\n    vec![*min, indices[min_index]\
    \ as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|&x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    let min_even = evens.first().cloned();\n\
    \    match min_even {\n        Some(x) => {\n            let index = arr.iter().position(|&y|\
    \ y == x).unwrap();\n            vec![x, index as isize]\n        }\n        None\
    \ => vec![],\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748550
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let smallest_even = evens[0];\n    let\
    \ mut smallest_even_index = 0;\n    for (i, x) in arr.iter().enumerate() {\n \
    \       if x == &smallest_even {\n            smallest_even_index = i;\n     \
    \       break;\n        }\n    }\n    vec![smallest_even, smallest_even_index\
    \ as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpp3lif0r1.rs:27:57\n\
    \   |\n27 |     let mut evens: Vec<isize> = arr.iter().filter(|x| x % 2 == 0).cloned().collect();\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &&isize\n   |\nhelp: `%` can be\
    \ used on `isize`, you can dereference `x`\n   |\n27 |     let mut evens: Vec<isize>\
    \ = arr.iter().filter(|x| *x % 2 == 0).cloned().collect();\n   |             \
    \                                          +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if *val % 2 == 0 && *val < min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|&x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let smallest_even = evens[0];\n    let\
    \ mut smallest_even_index = 0;\n    for (i, &x) in arr.iter().enumerate() {\n\
    \        if x == smallest_even {\n            smallest_even_index = i;\n     \
    \       break;\n        }\n    }\n    vec![smallest_even, smallest_even_index\
    \ as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < &min_even {\n            min_even = *v;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, &v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < min_even {\n            min_even = v;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n  \
    \  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, &val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < min_even {\n            min_even = val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|&x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        vec![]\n    } else {\n        let min_even = evens[0];\n        let\
    \ min_even_index = arr.iter().position(|&x| x == min_even).unwrap();\n       \
    \ vec![min_even, min_even_index as isize]\n    }\n}\n\nfn main() {\n    let candidate\
    \ = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748550
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|&x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        vec![]\n    } else {\n        let min_even = evens[0];\n        let\
    \ mut min_even_index: isize = -1;\n        for (i, &x) in arr.iter().enumerate()\
    \ {\n            if x == min_even {\n                min_even_index = i as isize;\n\
    \                break;\n            }\n        }\n        vec![min_even, min_even_index]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748550
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|&x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let min = evens[0];\n    let mut min_index\
    \ = 0;\n    for (i, &x) in arr.iter().enumerate() {\n        if x == min {\n \
    \           min_index = i;\n            break;\n        }\n    }\n    vec![min,\
    \ min_index as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = isize::max_value();\n\
    \    let mut min_even_idx = isize::max_value();\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ isize::max_value() {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 && n < &min_even {\n            min_even = *n;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, &val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < min_even {\n            min_even = val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|&x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let min_even = evens[0];\n    let min_even_index\
    \ = arr.iter().position(|&x| x == min_even).unwrap();\n    vec![min_even, min_even_index\
    \ as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, &val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < min_even {\n            min_even = val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = None;\n    let\
    \ mut min_even_idx = None;\n    for (idx, val) in arr.iter().enumerate() {\n \
    \       if val % 2 == 0 {\n            if min_even.is_none() || val < min_even.unwrap()\
    \ {\n                min_even = Some(*val);\n                min_even_idx = Some(idx\
    \ as isize);\n            }\n        }\n    }\n    match (min_even, min_even_idx)\
    \ {\n        (Some(min_even), Some(min_even_idx)) => vec![min_even, min_even_idx],\n\
    \        _ => vec![],\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n \
    \   assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwivuudwp.rs:32:33\n   |\n\
    32 |                 min_even = Some(*val);\n   |                            \
    \     ^^^^\n   |                                 |\n   |                     \
    \            expected `&isize`, found `isize`\n   |                          \
    \       help: consider borrowing here: `&*val`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwivuudwp.rs:38:54\n   |\n38 |         (Some(min_even), Some(min_even_idx))\
    \ => vec![min_even, min_even_idx],\n   |                                     \
    \                 ^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n38 |         (Some(min_even), Some(min_even_idx))\
    \ => vec![*min_even, min_even_idx],\n   |                                    \
    \                  +\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < min_even {\n            min_even = x;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n  \
    \  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut evens_idx: Vec<usize> = Vec::new();\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 {\n            evens.push(*val);\n            evens_idx.push(idx);\n\
    \        }\n    }\n    if evens.is_empty() {\n        return vec![];\n    }\n\
    \    let min_idx = evens.iter().enumerate().min_by_key(|(_, &val)| val).unwrap().0;\n\
    \    vec![evens[min_idx], evens_idx[min_idx] as isize]\n}\n\nfn main() {\n   \
    \ let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748550
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|&x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    let mut result: Vec<isize>\
    \ = Vec::new();\n    if evens.len() > 0 {\n        let smallest_even = evens[0];\n\
    \        let mut index = 0;\n        for (i, &x) in arr.iter().enumerate() {\n\
    \            if x == smallest_even {\n                index = i;\n           \
    \     break;\n            }\n        }\n        result.push(smallest_even);\n\
    \        result.push(index as isize);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748550
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let min = evens[0];\n    let mut idx =\
    \ 0;\n    for (i, x) in arr.iter().enumerate() {\n        if x == &min {\n   \
    \         idx = i;\n            break;\n        }\n    }\n    vec![min, idx as\
    \ isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpdhqabfdj.rs:27:57\n\
    \   |\n27 |     let mut evens: Vec<isize> = arr.iter().filter(|x| x % 2 == 0).cloned().collect();\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &&isize\n   |\nhelp: `%` can be\
    \ used on `isize`, you can dereference `x`\n   |\n27 |     let mut evens: Vec<isize>\
    \ = arr.iter().filter(|x| *x % 2 == 0).cloned().collect();\n   |             \
    \                                          +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_nums: Vec<isize> =\
    \ Vec::new();\n    let mut even_nums_index: Vec<usize> = Vec::new();\n    for\
    \ (i, n) in arr.iter().enumerate() {\n        if n % 2 == 0 {\n            even_nums.push(*n);\n\
    \            even_nums_index.push(i);\n        }\n    }\n    if even_nums.is_empty()\
    \ {\n        return vec![];\n    }\n    let min_even_num = even_nums.iter().min().unwrap();\n\
    \    let min_even_num_index = even_nums_index[even_nums.iter().position(|&x| x\
    \ == *min_even_num).unwrap()];\n    vec![*min_even_num, min_even_num_index as\
    \ isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748550
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = isize::max_value();\n\
    \    let mut min_even_index = isize::max_value();\n    for (i, &n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 && n < min_even {\n            min_even = n;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even == isize::max_value()\
    \ {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n  \
    \  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748550
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if *val % 2 == 0 && *val < min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let\
    \ mut min = std::isize::MAX;\n    let mut index = std::isize::MAX;\n    for (i,\
    \ x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < &min {\n      \
    \      min = *x;\n            index = i as isize;\n        }\n    }\n    if min\
    \ != std::isize::MAX {\n        result.push(min);\n        result.push(index);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748550
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = isize::max_value();\n\
    \    let mut min_even_idx = isize::max_value();\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ isize::max_value() {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = isize::max_value();\n\
    \    let mut min_even_index = isize::max_value();\n    for (i, &v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < min_even {\n            min_even = v;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even == isize::max_value()\
    \ {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n  \
    \  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748550
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let\
    \ mut evens = vec![];\n    for (i, n) in arr.iter().enumerate() {\n        if\
    \ n % 2 == 0 {\n            evens.push((n, i));\n        }\n    }\n    if evens.is_empty()\
    \ {\n        return result;\n    }\n    evens.sort_by(|a, b| a.0.cmp(b.0));\n\
    \    result.push(evens[0].0);\n    result.push(evens[0].1 as isize);\n    result\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp68tmst64.rs:38:17\n   |\n\
    38 |     result.push(evens[0].0);\n   |                 ^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n38 |  \
    \   result.push(*evens[0].0);\n   |                 +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659748550
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_nums: Vec<isize> =\
    \ vec![];\n    let mut even_nums_indices: Vec<usize> = vec![];\n    for (i, num)\
    \ in arr.iter().enumerate() {\n        if num % 2 == 0 {\n            even_nums.push(*num);\n\
    \            even_nums_indices.push(i);\n        }\n    }\n    if even_nums.is_empty()\
    \ {\n        return vec![];\n    }\n    let min_even_num = even_nums.iter().min().unwrap();\n\
    \    let min_even_num_index = even_nums_indices[even_nums.iter().position(|&r|\
    \ r == *min_even_num).unwrap()];\n    vec![*min_even_num, min_even_num_index as\
    \ isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748550
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 && n < &min_even {\n            min_even = *n;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let\
    \ mut min_even = isize::max_value();\n    let mut min_even_index = isize::max_value();\n\
    \    for (i, v) in arr.iter().enumerate() {\n        if v % 2 == 0 && *v < min_even\
    \ {\n            min_even = *v;\n            min_even_index = i as isize;\n  \
    \      }\n    }\n    if min_even != isize::max_value() {\n        result.push(min_even);\n\
    \        result.push(min_even_index);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748550
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min = std::isize::MAX;\n\
    \    let mut min_idx = std::isize::MAX;\n    for (idx, &val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < min {\n            min = val;\n        \
    \    min_idx = idx as isize;\n        }\n    }\n    if min == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min, min_idx]\n    }\n}\n\nfn\
    \ main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748550
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|&x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    let mut result: Vec<isize>\
    \ = Vec::new();\n    if evens.len() > 0 {\n        result.push(evens[0]);\n  \
    \      result.push(arr.iter().position(|&x| x == evens[0]).unwrap() as isize);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748550
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let\
    \ mut min_even = std::isize::MAX;\n    let mut min_even_index = std::isize::MAX;\n\
    \    for (i, &x) in arr.iter().enumerate() {\n        if x % 2 == 0 && x < min_even\
    \ {\n            min_even = x;\n            min_even_index = i as isize;\n   \
    \     }\n    }\n    if min_even != std::isize::MAX {\n        result.push(min_even);\n\
    \        result.push(min_even_index);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748550
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < &min_even {\n            min_even = *x;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = isize::max_value();\n\
    \    let mut min_even_idx = isize::max_value();\n    for (idx, item) in arr.iter().enumerate()\
    \ {\n        if item % 2 == 0 && item < &min_even {\n            min_even = *item;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ isize::max_value() {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748550
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < &min_even {\n            min_even = *v;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_index]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|&x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    let mut result: Vec<isize>\
    \ = Vec::new();\n    if evens.len() > 0 {\n        let min_even = evens[0];\n\
    \        let min_even_index = arr.iter().position(|&x| x == min_even).unwrap();\n\
    \        result.push(min_even);\n        result.push(min_even_index as isize);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748550
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = None;\n    let\
    \ mut min_even_idx = None;\n    for (idx, &val) in arr.iter().enumerate() {\n\
    \        if val % 2 == 0 {\n            if min_even.is_none() || val < min_even.unwrap()\
    \ {\n                min_even = Some(val);\n                min_even_idx = Some(idx\
    \ as isize);\n            }\n        }\n    }\n    match (min_even, min_even_idx)\
    \ {\n        (Some(min_even), Some(min_even_idx)) => vec![min_even, min_even_idx],\n\
    \        _ => vec![],\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n \
    \   assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748550
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let min = evens[0];\n    let idx = arr.iter().position(|x|\
    \ x == &min).unwrap();\n    vec![min, idx as isize]\n}\n\nfn main() {\n    let\
    \ candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpm4p5lzbe.rs:27:57\n\
    \   |\n27 |     let mut evens: Vec<isize> = arr.iter().filter(|x| x % 2 == 0).cloned().collect();\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &&isize\n   |\nhelp: `%` can be\
    \ used on `isize`, you can dereference `x`\n   |\n27 |     let mut evens: Vec<isize>\
    \ = arr.iter().filter(|x| *x % 2 == 0).cloned().collect();\n   |             \
    \                                          +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|&x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let min = evens[0];\n    let mut min_index\
    \ = 0;\n    for (i, &x) in arr.iter().enumerate() {\n        if x == min {\n \
    \           min_index = i;\n            break;\n        }\n    }\n    vec![min,\
    \ min_index as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < min_even {\n            min_even = x;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n  \
    \  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = isize::max_value();\n\
    \    let mut min_even_idx = isize::max_value();\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even_idx\
    \ == isize::max_value() {\n        vec![]\n    } else {\n        vec![min_even,\
    \ min_even_idx]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748550
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = isize::max_value();\n\
    \    let mut min_even_index = isize::max_value();\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 && n < &min_even {\n            min_even = *n;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even ==\
    \ isize::max_value() {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (index, value) in arr.iter().enumerate()\
    \ {\n        if value % 2 == 0 && value < &min_even {\n            min_even =\
    \ *value;\n            min_even_index = index as isize;\n        }\n    }\n  \
    \  if min_even == std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even,\
    \ min_even_index]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748550
- exit_code: 1
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let min_even = evens[0];\n    let index\
    \ = arr.iter().position(|x| x == &min_even).unwrap();\n    vec![min_even, index\
    \ as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&&isize` by `{integer}`\n  --> /tmp/tmpsn9lgut5.rs:27:57\n\
    \   |\n27 |     let mut evens: Vec<isize> = arr.iter().filter(|x| x % 2 == 0).cloned().collect();\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &&isize\n   |\nhelp: `%` can be\
    \ used on `isize`, you can dereference `x`\n   |\n27 |     let mut evens: Vec<isize>\
    \ = arr.iter().filter(|x| *x % 2 == 0).cloned().collect();\n   |             \
    \                                          +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659748550
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (index, value) in arr.iter().enumerate()\
    \ {\n        if value % 2 == 0 && value < &min_even {\n            min_even =\
    \ *value;\n            min_even_index = index as isize;\n        }\n    }\n  \
    \  if min_even == std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even,\
    \ min_even_index]\n    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748550
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, &n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 && n < min_even {\n            min_even = n;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even_index\
    \ == std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|&x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let min = evens[0];\n    let mut index\
    \ = 0;\n    for (i, &x) in arr.iter().enumerate() {\n        if x == min {\n \
    \           index = i;\n            break;\n        }\n    }\n    vec![min, index\
    \ as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748549
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|&x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let smallest_even = evens[0];\n    let\
    \ mut smallest_even_index = 0;\n    for (i, &x) in arr.iter().enumerate() {\n\
    \        if x == smallest_even {\n            smallest_even_index = i;\n     \
    \       break;\n        }\n    }\n    vec![smallest_even, smallest_even_index\
    \ as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut evens_idx: Vec<usize> = Vec::new();\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 {\n            evens.push(x);\n            evens_idx.push(i);\n\
    \        }\n    }\n    if evens.is_empty() {\n        return vec![];\n    }\n\
    \    let min_idx = evens.iter().enumerate().min_by_key(|&(_, &x)| x).unwrap().0;\n\
    \    vec![evens[min_idx], evens_idx[min_idx] as isize]\n}\n\nfn main() {\n   \
    \ let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748550
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < &min_even {\n            min_even = *v;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut evens_index: Vec<usize> = Vec::new();\n    for (index, value) in\
    \ arr.iter().enumerate() {\n        if value % 2 == 0 {\n            evens.push(*value);\n\
    \            evens_index.push(index);\n        }\n    }\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut min_even = evens[0];\n    let\
    \ mut min_even_index = evens_index[0];\n    for (index, value) in evens.iter().enumerate()\
    \ {\n        if value < &min_even {\n            min_even = *value;\n        \
    \    min_even_index = evens_index[index];\n        }\n    }\n    vec![min_even,\
    \ min_even_index as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n   \
    \ assert_eq!(candidate(vec![4, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]),\
    \ vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n   \
    \ assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659748548
- exit_code: 0
  program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
