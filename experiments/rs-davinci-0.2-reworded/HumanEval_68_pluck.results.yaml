name: HumanEval_68_pluck
language: rs
results:
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, &v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < min_even {\n            min_even = v;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n  \
    \  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut evens_indices: Vec<usize> = Vec::new();\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 {\n            evens.push(x);\n            evens_indices.push(i);\n\
    \        }\n    }\n    if evens.is_empty() {\n        return vec![];\n    }\n\
    \    let mut min_even = evens[0];\n    let mut min_even_index = evens_indices[0];\n\
    \    for (i, &x) in evens.iter().enumerate() {\n        if x < min_even {\n  \
    \          min_even = x;\n            min_even_index = evens_indices[i];\n   \
    \     }\n    }\n    vec![min_even, min_even_index as isize]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if *val % 2 == 0 && *val < min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < min_even {\n            min_even = x;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        return vec![];\n    }\n    vec![min_even, min_even_index]\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|&x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let smallest_even = evens[0];\n    let\
    \ mut smallest_even_index = 0;\n    for (i, &x) in arr.iter().enumerate() {\n\
    \        if x == smallest_even {\n            smallest_even_index = i;\n     \
    \       break;\n        }\n    }\n    vec![smallest_even, smallest_even_index\
    \ as isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut evens_idx: Vec<usize> = Vec::new();\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 {\n            evens.push(*v);\n            evens_idx.push(i);\n\
    \        }\n    }\n    if evens.is_empty() {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_idx = evens_idx[evens.iter().position(|&r|\
    \ r == *min_even).unwrap()];\n    vec![*min_even, min_even_idx as isize]\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_nums: Vec<isize> =\
    \ Vec::new();\n    let mut even_nums_index: Vec<usize> = Vec::new();\n    for\
    \ (i, num) in arr.iter().enumerate() {\n        if num % 2 == 0 {\n          \
    \  even_nums.push(*num);\n            even_nums_index.push(i);\n        }\n  \
    \  }\n    if even_nums.is_empty() {\n        return vec![];\n    }\n    let min_even_num\
    \ = even_nums.iter().min().unwrap();\n    let min_even_num_index = even_nums_index[even_nums.iter().position(|&r|\
    \ r == *min_even_num).unwrap()];\n    vec![*min_even_num, min_even_num_index as\
    \ isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < &min_even {\n            min_even = *v;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut even_nums: Vec<isize> =\
    \ vec![];\n    let mut even_nums_index: Vec<usize> = vec![];\n    for (i, &num)\
    \ in arr.iter().enumerate() {\n        if num % 2 == 0 {\n            even_nums.push(num);\n\
    \            even_nums_index.push(i);\n        }\n    }\n    if even_nums.is_empty()\
    \ {\n        return vec![];\n    }\n    let min_even_num = even_nums.iter().min().unwrap();\n\
    \    let min_even_num_index = even_nums_index[even_nums.iter().position(|&x| x\
    \ == *min_even_num).unwrap()];\n    vec![*min_even_num, min_even_num_index as\
    \ isize]\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < min_even {\n            min_even = x;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n  \
    \  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = isize::max_value();\n\
    \    let mut min_even_idx = isize::max_value();\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 && val < &min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ isize::max_value() {\n        vec![]\n    } else {\n        vec![min_even, min_even_idx]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < min_even {\n            min_even = x;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n  \
    \  }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_idx = std::isize::MAX;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if *val % 2 == 0 && *val < min_even {\n            min_even = *val;\n\
    \            min_even_idx = idx as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_idx]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < min_even {\n            min_even = x;\n    \
    \        min_even_index = i as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        return vec![];\n    }\n    vec![min_even, min_even_index]\n}\n\n\
    fn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]),\
    \ vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < &min_even {\n            min_even = *x;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        vec![]\n    } else {\n        vec![min_even, min_even_index]\n\
    \    }\n}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < &min_even {\n            min_even = *v;\n  \
    \          min_even_index = i as isize;\n        }\n    }\n    if min_even ==\
    \ std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even, min_even_index]\n\
    }\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
    \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = arr.iter().filter(|&x|\
    \ x % 2 == 0).cloned().collect();\n    evens.sort();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let min_even = evens[0];\n    let mut\
    \ min_even_index = 0;\n    for (i, &x) in arr.iter().enumerate() {\n        if\
    \ x == min_even {\n            min_even_index = i;\n            break;\n     \
    \   }\n    }\n    vec![min_even, min_even_index as isize]\n}\n\nfn main() {\n\
    \    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2, 3]), vec![2,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5, 0, 3, 0, 4, 2]), vec![0,\
    \ 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5,\
    \ 4, 8, 4, 8]), vec![4, 1]);\n    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6,\
    \ 1]);\n    assert_eq!(candidate(vec![7, 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// \"Given a vector representing a branch of a tree that has non-negative\
    \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
    \ The plucked node should be the node with the smallest even value.\n/// If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n/// The plucked node should be returned in a vector, [ smalest_value,\
    \ its index ],\n/// If there are no even values or the given vector is empty,\
    \ return [].\n/// Example 1:\n/// >>> pluck(vec![4, 2, 3])\n/// vec![2, 1]\n///\
    \ Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    /// Example 2:\n/// >>> pluck(vec![1, 2, 3])\n/// vec![2, 1]\n/// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 3:\n\
    /// >>> pluck(vec![])\n/// vec![]\n/// Example 4:\n/// >>> pluck(vec![5, 0, 3,\
    \ 0, 4, 2])\n/// vec![0, 1]\n/// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n/// so we will choose the first zero, which has the smallest\
    \ index.\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
    fn pluck(arr: Vec<isize>) -> Vec<isize> {\n    let mut evens: Vec<isize> = Vec::new();\n\
    \    let mut evens_index: Vec<usize> = Vec::new();\n    for (i, n) in arr.iter().enumerate()\
    \ {\n        if n % 2 == 0 {\n            evens.push(*n);\n            evens_index.push(i);\n\
    \        }\n    }\n    if evens.is_empty() {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().min().unwrap();\n    let min_even_index = evens_index[evens.iter().position(|&x|\
    \ x == *min_even).unwrap()];\n    vec![*min_even, min_even_index as isize]\n}\n\
    \nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4, 2,\
    \ 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
    \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5,\
    \ 3]), vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n\
    \    assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
    \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
