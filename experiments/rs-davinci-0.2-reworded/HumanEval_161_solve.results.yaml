name: HumanEval_161_solve
language: rs
results:
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            if c.is_lowercase() {\n                res.push(c.to_uppercase().next().unwrap());\n\
    \            } else {\n                res.push(c.to_lowercase().next().unwrap());\n\
    \            }\n        } else {\n            res.push(c);\n        }\n    }\n\
    \    if !has_letter {\n        res.chars().rev().collect()\n    } else {\n   \
    \     res\n    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpug7pr8re.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut is_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     is_letter = true;\n            result.push(c.to_ascii_uppercase());\n  \
    \      } else {\n            result.push(c);\n        }\n    }\n    if is_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp5tqbhqbi.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            res.push(c.to_ascii_uppercase());\n    \
    \    } else {\n            res.push(c);\n        }\n    }\n    if has_letter {\n\
    \        res\n    } else {\n        res.chars().rev().collect()\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpxcth1u16.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut is_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     is_letter = true;\n            result.push(c.to_ascii_uppercase());\n  \
    \      } else {\n            result.push(c);\n        }\n    }\n    if is_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpi_kxyjnl.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            if c.is_lowercase() {\n                result.push(c.to_uppercase().next().unwrap());\n\
    \            } else {\n                result.push(c.to_lowercase().next().unwrap());\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    if !has_letter {\n        result.chars().rev().collect()\n    } else\
    \ {\n        result\n    }\n}\n\nfn main() {\n    let candidate = solve;\n   \
    \ assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n   \
    \ assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp5c3j71lv.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            res.push(c.to_ascii_uppercase());\n    \
    \    } else {\n            res.push(c);\n        }\n    }\n    if has_letter {\n\
    \        res\n    } else {\n        res.chars().rev().collect()\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpc5zcacyc.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            if c.is_lowercase() {\n                result.push(c.to_uppercase().next().unwrap());\n\
    \            } else {\n                result.push(c.to_lowercase().next().unwrap());\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    if !has_letter {\n        result.chars().rev().collect()\n    } else\
    \ {\n        result\n    }\n}\n\nfn main() {\n    let candidate = solve;\n   \
    \ assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n   \
    \ assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            if c.is_lowercase() {\n                result.push(c.to_uppercase().next().unwrap());\n\
    \            } else {\n                result.push(c.to_lowercase().next().unwrap());\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    if !has_letter {\n        result.chars().rev().collect()\n    } else\
    \ {\n        result\n    }\n}\n\nfn main() {\n    let candidate = solve;\n   \
    \ assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n   \
    \ assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp23h4ushw.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s.chars().collect::<Vec<char>>();\n   \
    \ let mut has_letter = false;\n    for i in 0..s.len() {\n        if s[i].is_ascii_alphabetic()\
    \ {\n            has_letter = true;\n            if s[i].is_ascii_lowercase()\
    \ {\n                s[i] = s[i].to_ascii_uppercase();\n            } else {\n\
    \                s[i] = s[i].to_ascii_lowercase();\n            }\n        }\n\
    \    }\n    if !has_letter {\n        s.reverse();\n    }\n    s.iter().collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_ascii_alphabetic() {\n            result.push(c.to_ascii_uppercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if result.is_empty()\
    \ {\n        s.chars().rev().collect()\n    } else {\n        result\n    }\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmprlfv02cp.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpyk0u_bg4.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_ascii_alphabetic() {\n \
    \           result.push(c.to_ascii_uppercase());\n            has_letter = true;\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp5mf4yzxf.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            res.push(c.to_ascii_uppercase());\n    \
    \    } else {\n            res.push(c);\n        }\n    }\n    if has_letter {\n\
    \        res.chars().rev().collect()\n    } else {\n        res\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmpfkkg5769.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            res.push(c.to_ascii_uppercase());\n    \
    \    } else {\n            res.push(c);\n        }\n    }\n    if has_letter {\n\
    \        res\n    } else {\n        res.chars().rev().collect()\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpcjmchage.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp7cfw8er7.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpzb4jmm46.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpoejamh5v.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp9rifpcax.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            res.push(c.to_ascii_uppercase());\n    \
    \    } else {\n            res.push(c);\n        }\n    }\n    if has_letter {\n\
    \        res\n    } else {\n        res.chars().rev().collect()\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmptt7rm2g8.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            result.push(c.to_ascii_uppercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if result.is_empty()\
    \ {\n        s.chars().rev().collect()\n    } else {\n        result\n    }\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp54dfbjzj.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmplod_dmik.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpjilp2c_7.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp_mmba5xr.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            if c.is_lowercase() {\n                result.push(c.to_uppercase().next().unwrap());\n\
    \            } else {\n                result.push(c.to_lowercase().next().unwrap());\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    if !has_letter {\n        result.chars().rev().collect()\n    } else\
    \ {\n        result\n    }\n}\n\nfn main() {\n    let candidate = solve;\n   \
    \ assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n   \
    \ assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpk9futnet.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            if c.is_lowercase() {\n                result.push(c.to_uppercase().next().unwrap());\n\
    \            } else {\n                result.push(c.to_lowercase().next().unwrap());\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    if !has_letter {\n        result.chars().rev().collect()\n    } else\
    \ {\n        result\n    }\n}\n\nfn main() {\n    let candidate = solve;\n   \
    \ assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n   \
    \ assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut is_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     is_letter = true;\n            result.push(c.to_ascii_uppercase());\n  \
    \      } else {\n            result.push(c);\n        }\n    }\n    if is_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpb3t0mpmv.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpb2g_gjgd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(if c.is_lowercase() { c.to_uppercase().next().unwrap()\
    \ } else { c.to_lowercase().next().unwrap() });\n        } else {\n          \
    \  result.push(c);\n        }\n    }\n    if !has_letter {\n        result.chars().rev().collect()\n\
    \    } else {\n        result\n    }\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpqbjcpvby.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp9eibgkal.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for ch in s.chars() {\n        if ch.is_alphabetic() {\n     \
    \       has_letter = true;\n            if ch.is_uppercase() {\n             \
    \   result.push(ch.to_lowercase().next().unwrap());\n            } else {\n  \
    \              result.push(ch.to_uppercase().next().unwrap());\n            }\n\
    \        } else {\n            result.push(ch);\n        }\n    }\n    if !has_letter\
    \ {\n        result.chars().rev().collect()\n    } else {\n        result\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpja2w922j.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            if c.is_lowercase() {\n                result.push(c.to_uppercase().next().unwrap());\n\
    \            } else {\n                result.push(c.to_lowercase().next().unwrap());\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    if !has_letter {\n        result.chars().rev().collect()\n    } else\
    \ {\n        result\n    }\n}\n\nfn main() {\n    let candidate = solve;\n   \
    \ assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n   \
    \ assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut is_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     is_letter = true;\n            result.push(c.to_ascii_uppercase());\n  \
    \      } else {\n            result.push(c);\n        }\n    }\n    if is_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpee6vioqw.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut contains_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     contains_letter = true;\n            result.push(c.to_ascii_uppercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if !contains_letter\
    \ {\n        result = result.chars().rev().collect();\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpgouo234z.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut flag = false;\n\
    \    for c in s.chars() {\n        if c.is_alphabetic() {\n            flag =\
    \ true;\n            res.push(c.to_ascii_uppercase());\n        } else {\n   \
    \         res.push(c);\n        }\n    }\n    if flag {\n        res\n    } else\
    \ {\n        res.chars().rev().collect()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpc83k8j_r.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpxfuk0sll.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            res.push(c.to_ascii_uppercase());\n\
    \        } else {\n            res.push(c);\n        }\n    }\n    if res.is_empty()\
    \ {\n        res = s;\n    }\n    res\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmptyr2ofxv.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp8c9nbugw.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut is_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     is_letter = true;\n            result.push(c.to_ascii_uppercase());\n  \
    \      } else {\n            result.push(c);\n        }\n    }\n    if !is_letter\
    \ {\n        result.chars().rev().collect()\n    } else {\n        result\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp03ozc0fc.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut is_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     is_letter = true;\n            result.push(c.to_ascii_uppercase());\n  \
    \      } else {\n            result.push(c);\n        }\n    }\n    if is_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpmexbw5d7.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp8d2judz1.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpq_fpgx52.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpcm1q_6jq.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut is_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     is_letter = true;\n            result.push(c.to_ascii_uppercase());\n  \
    \      } else {\n            result.push(c);\n        }\n    }\n    if is_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp6pkkuw63.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result.chars().rev().collect()\n    } else {\n        result\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmpwnqfqpeg.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut flag =\
    \ false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n         \
    \   flag = true;\n            result.push(c.to_ascii_uppercase());\n        }\
    \ else {\n            result.push(c);\n        }\n    }\n    if flag {\n     \
    \   result\n    } else {\n        result.chars().rev().collect()\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp4wo61cg1.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            res.push(c.to_ascii_uppercase());\n    \
    \    } else {\n            res.push(c);\n        }\n    }\n    if has_letter {\n\
    \        res\n    } else {\n        res.chars().rev().collect()\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpqh25vb0i.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut is_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     is_letter = true;\n            result.push(c.to_ascii_uppercase());\n  \
    \      } else {\n            result.push(c);\n        }\n    }\n    if is_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpzdm8pm8q.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            res.push(c.to_ascii_uppercase());\n    \
    \    } else {\n            res.push(c);\n        }\n    }\n    if has_letter {\n\
    \        res\n    } else {\n        res.chars().rev().collect()\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpc62t_3lc.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut flag = false;\n\
    \    for c in s.chars() {\n        if c.is_alphabetic() {\n            flag =\
    \ true;\n            res.push(c.to_ascii_uppercase());\n        } else {\n   \
    \         res.push(c);\n        }\n    }\n    if flag {\n        res\n    } else\
    \ {\n        res.chars().rev().collect()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmplf8c2v5i.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpf6xp7sty.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp3kswaoi3.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpgtw_2shs.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            if c.is_lowercase() {\n                result.push(c.to_uppercase().next().unwrap());\n\
    \            } else {\n                result.push(c.to_lowercase().next().unwrap());\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    if !has_letter {\n        result.chars().rev().collect()\n    } else\
    \ {\n        result\n    }\n}\n\nfn main() {\n    let candidate = solve;\n   \
    \ assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n   \
    \ assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            res.push(c.to_ascii_uppercase());\n    \
    \    } else {\n            res.push(c);\n        }\n    }\n    if has_letter {\n\
    \        res\n    } else {\n        res.chars().rev().collect()\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpcgd13xo3.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmphrm_8zcr.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            res.push(c.to_ascii_uppercase());\n\
    \        } else {\n            res.push(c);\n        }\n    }\n    if res.is_empty()\
    \ {\n        s.chars().rev().collect()\n    } else {\n        res\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpuz787yom.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpk4_4l2px.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp5w3ksadq.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpb2xgni7_.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmposyh8hcm.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            res.push(c.to_ascii_uppercase());\n    \
    \    } else {\n            res.push(c);\n        }\n    }\n    if has_letter {\n\
    \        res\n    } else {\n        res.chars().rev().collect()\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp79yl3fgi.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s.chars().collect::<Vec<char>>();\n   \
    \ let mut has_letter = false;\n    for i in 0..s.len() {\n        if s[i].is_alphabetic()\
    \ {\n            has_letter = true;\n            if s[i].is_lowercase() {\n  \
    \              s[i] = s[i].to_uppercase().next().unwrap();\n            } else\
    \ {\n                s[i] = s[i].to_lowercase().next().unwrap();\n           \
    \ }\n        }\n    }\n    if !has_letter {\n        s.reverse();\n    }\n   \
    \ s.into_iter().collect()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(if c.is_lowercase() {\n    \
    \            c.to_uppercase().next().unwrap()\n            } else {\n        \
    \        c.to_lowercase().next().unwrap()\n            });\n        } else {\n\
    \            result.push(c);\n        }\n    }\n    if !has_letter {\n       \
    \ result.chars().rev().collect()\n    } else {\n        result\n    }\n}\n\nfn\
    \ main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpu8tfvbeb.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut flag = false;\n\
    \    for c in s.chars() {\n        if c.is_alphabetic() {\n            flag =\
    \ true;\n            res.push(if c.is_uppercase() {\n                c.to_lowercase().to_string()\n\
    \            } else {\n                c.to_uppercase().to_string()\n        \
    \    });\n        } else {\n            res.push(c);\n        }\n    }\n    if\
    \ !flag {\n        res.chars().rev().collect()\n    } else {\n        res\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp660s55lc.rs:20:17\n   |\n\
    20 |                 c.to_lowercase().to_string()\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp660s55lc.rs:22:17\n   |\n22 |                 c.to_uppercase().to_string()\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut contains_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     contains_letter = true;\n            if c.is_lowercase() {\n           \
    \     result.push(c.to_uppercase().next().unwrap());\n            } else {\n \
    \               result.push(c.to_lowercase().next().unwrap());\n            }\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if !contains_letter\
    \ {\n        result.chars().rev().collect()\n    } else {\n        result\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_ascii_alphabetic() {\n \
    \           has_letter = true;\n            result.push(c.to_ascii_uppercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp4b4n_v8f.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp7d5n20l0.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s.chars().collect::<Vec<char>>();\n   \
    \ let mut has_letter = false;\n    for i in 0..s.len() {\n        if s[i].is_alphabetic()\
    \ {\n            has_letter = true;\n            if s[i].is_uppercase() {\n  \
    \              s[i] = s[i].to_lowercase().next().unwrap();\n            } else\
    \ {\n                s[i] = s[i].to_uppercase().next().unwrap();\n           \
    \ }\n        }\n    }\n    if !has_letter {\n        s.reverse();\n    }\n   \
    \ s.into_iter().collect()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpao2ocr_2.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut is_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     is_letter = true;\n            result.push(c.to_ascii_uppercase());\n  \
    \      } else {\n            result.push(c);\n        }\n    }\n    if is_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp7w7r9h9u.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut chars = s.chars();\n    let mut result = String::new();\n\
    \    let mut has_letter = false;\n    while let Some(c) = chars.next() {\n   \
    \     if c.is_alphabetic() {\n            has_letter = true;\n            result.push(c.to_ascii_uppercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpcodl_nf7.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpc7jq9zdu.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut is_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     is_letter = true;\n            if c.is_lowercase() {\n                result.push(c.to_uppercase().to_string().chars().next().unwrap());\n\
    \            } else {\n                result.push(c.to_lowercase().to_string().chars().next().unwrap());\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    if !is_letter {\n        result = result.chars().rev().collect();\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp7m0johaq.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmph06a0___.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut flag =\
    \ false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n         \
    \   flag = true;\n            result.push(c.to_ascii_uppercase());\n        }\
    \ else {\n            result.push(c);\n        }\n    }\n    if flag {\n     \
    \   result\n    } else {\n        result.chars().rev().collect()\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmprj60efk7.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            res.push(c.to_ascii_uppercase());\n    \
    \    } else {\n            res.push(c);\n        }\n    }\n    if has_letter {\n\
    \        res.chars().rev().collect()\n    } else {\n        res\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmp0j0pr75j.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            res.push(c.to_ascii_uppercase());\n    \
    \    } else {\n            res.push(c);\n        }\n    }\n    if has_letter {\n\
    \        res.chars().rev().collect()\n    } else {\n        res\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"FDSA\"`,\n right: `\"aSdF\"`', /tmp/tmp7ynercho.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp1witvqzq.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            result.push(c.to_ascii_uppercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if result.is_empty()\
    \ {\n        s.chars().rev().collect()\n    } else {\n        result\n    }\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpvxzemxwy.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp2u6sy413.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpwlbhc9nr.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            res.push(c.to_ascii_uppercase());\n    \
    \    } else {\n            res.push(c);\n        }\n    }\n    if has_letter {\n\
    \        res\n    } else {\n        res.chars().rev().collect()\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp12uxahl8.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpl84_htfw.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s.chars().collect::<Vec<char>>();\n   \
    \ let mut has_letter = false;\n    for i in 0..s.len() {\n        if s[i].is_alphabetic()\
    \ {\n            has_letter = true;\n            s[i] = if s[i].is_lowercase()\
    \ {\n                s[i].to_ascii_uppercase()\n            } else {\n       \
    \         s[i].to_ascii_lowercase()\n            };\n        }\n    }\n    if\
    \ !has_letter {\n        s.reverse();\n    }\n    s.iter().collect()\n}\n\nfn\
    \ main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpwq06bt2z.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp4y53qwdo.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp462gx691.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpdjo49wrx.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp2uczfc0z.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            if c.is_lowercase() {\n     \
    \           result.push(c.to_uppercase().next().unwrap());\n            } else\
    \ {\n                result.push(c.to_lowercase().next().unwrap());\n        \
    \    }\n        } else {\n            result.push(c);\n        }\n    }\n    if\
    \ result.chars().all(|c| !c.is_alphabetic()) {\n        result.chars().rev().collect()\n\
    \    } else {\n        result\n    }\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            if c.is_lowercase() {\n                result.push(c.to_uppercase().next().unwrap());\n\
    \            } else {\n                result.push(c.to_lowercase().next().unwrap());\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    if !has_letter {\n        result.chars().rev().collect()\n    } else\
    \ {\n        result\n    }\n}\n\nfn main() {\n    let candidate = solve;\n   \
    \ assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n   \
    \ assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpqa0af9g_.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpu9gc2n69.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_ascii_alphabetic() {\n \
    \           has_letter = true;\n            result.push(c.to_ascii_uppercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if !has_letter\
    \ {\n        result.chars().rev().collect()\n    } else {\n        result\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpymz3exoo.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            if c.is_uppercase() {\n                result.push(c.to_lowercase().next().unwrap());\n\
    \            } else {\n                result.push(c.to_uppercase().next().unwrap());\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    if !has_letter {\n        result.chars().rev().collect()\n    } else\
    \ {\n        result\n    }\n}\n\nfn main() {\n    let candidate = solve;\n   \
    \ assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n   \
    \ assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut contains_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     contains_letter = true;\n            result.push(c.to_ascii_uppercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if !contains_letter\
    \ {\n        result = result.chars().rev().collect();\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpzp3frqyc.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmph9u3bois.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut flag =\
    \ false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n         \
    \   flag = true;\n            result.push(c.to_ascii_uppercase());\n        }\
    \ else {\n            result.push(c);\n        }\n    }\n    if flag {\n     \
    \   result\n    } else {\n        result.chars().rev().collect()\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp5362ymnm.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            if c.is_lowercase() {\n     \
    \           result.push(c.to_uppercase().next().unwrap());\n            } else\
    \ {\n                result.push(c.to_lowercase().next().unwrap());\n        \
    \    }\n        } else {\n            result.push(c);\n        }\n    }\n    if\
    \ result.chars().all(|c| !c.is_alphabetic()) {\n        result.chars().rev().collect()\n\
    \    } else {\n        result\n    }\n}\n\nfn main() {\n    let candidate = solve;\n\
    \    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n\
    \    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpq9c365gi.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpsww00029.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            res.push(c.to_ascii_uppercase());\n    \
    \    } else {\n            res.push(c);\n        }\n    }\n    if has_letter {\n\
    \        res\n    } else {\n        res.chars().rev().collect()\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpjpl2_wfx.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpv897bw5l.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpo1xfm6bq.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s.chars().collect::<Vec<char>>();\n   \
    \ let mut has_letter = false;\n    for i in 0..s.len() {\n        if s[i].is_alphabetic()\
    \ {\n            has_letter = true;\n            s[i] = s[i].to_ascii_lowercase();\n\
    \        }\n    }\n    if has_letter {\n        s.reverse();\n    }\n    s.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"fdsa\"`,\n right: `\"aSdF\"`', /tmp/tmpsxlg04ji.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s.chars().collect::<Vec<char>>();\n   \
    \ let mut has_letter = false;\n    for i in 0..s.len() {\n        if s[i].is_alphabetic()\
    \ {\n            has_letter = true;\n            if s[i].is_uppercase() {\n  \
    \              s[i] = s[i].to_lowercase().next().unwrap();\n            } else\
    \ {\n                s[i] = s[i].to_uppercase().next().unwrap();\n           \
    \ }\n        }\n    }\n    if !has_letter {\n        s.reverse();\n    }\n   \
    \ s.into_iter().collect()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s.chars().collect::<Vec<char>>();\n   \
    \ let mut has_letter = false;\n    for c in s.iter_mut() {\n        if c.is_ascii_alphabetic()\
    \ {\n            has_letter = true;\n            *c = if c.is_ascii_lowercase()\
    \ {\n                c.to_ascii_uppercase()\n            } else {\n          \
    \      c.to_ascii_lowercase()\n            };\n        }\n    }\n    if !has_letter\
    \ {\n        s.reverse();\n    }\n    s.into_iter().collect()\n}\n\nfn main()\
    \ {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\"\
    )), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")),\
    \ String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"\
    ));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpmf7j81gp.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut flag = false;\n\
    \    for c in s.chars() {\n        if c.is_alphabetic() {\n            flag =\
    \ true;\n            res.push(c.to_ascii_uppercase());\n        } else {\n   \
    \         res.push(c);\n        }\n    }\n    if flag {\n        res\n    } else\
    \ {\n        res.chars().rev().collect()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp6qrywj1t.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpsvzb12fr.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut flag = false;\n\
    \    for c in s.chars() {\n        if c.is_alphabetic() {\n            flag =\
    \ true;\n            if c.is_lowercase() {\n                res.push(c.to_uppercase().next().unwrap());\n\
    \            } else {\n                res.push(c.to_lowercase().next().unwrap());\n\
    \            }\n        } else {\n            res.push(c);\n        }\n    }\n\
    \    if flag {\n        res\n    } else {\n        res.chars().rev().collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            result.push(c.to_ascii_uppercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if result.is_empty()\
    \ {\n        s.chars().rev().collect()\n    } else {\n        result\n    }\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpbqc7r97r.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut has_letters\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letters = true;\n            res.push(c.to_ascii_uppercase());\n   \
    \     } else {\n            res.push(c);\n        }\n    }\n    if has_letters\
    \ {\n        res\n    } else {\n        res.chars().rev().collect()\n    }\n}\n\
    \nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp27rnsd1v.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp8x955x4i.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            res.push(c.to_ascii_uppercase());\n    \
    \    } else {\n            res.push(c);\n        }\n    }\n    if has_letter {\n\
    \        res\n    } else {\n        res.chars().rev().collect()\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpwdysqtlt.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            result.push(c.to_ascii_uppercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if result.is_empty()\
    \ {\n        s.chars().rev().collect()\n    } else {\n        result\n    }\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp9syq_l6w.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut chars = s.chars();\n    let mut result = String::new();\n\
    \    let mut has_letter = false;\n    while let Some(c) = chars.next() {\n   \
    \     if c.is_alphabetic() {\n            has_letter = true;\n            result.push(c.to_ascii_uppercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpz4r63c2q.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            res.push(c.to_ascii_uppercase());\n\
    \        } else {\n            res.push(c);\n        }\n    }\n    if res.is_empty()\
    \ {\n        s.chars().rev().collect()\n    } else {\n        res\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpb36l9p7g.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            if c.is_lowercase() {\n     \
    \           result.push(c.to_uppercase().next().unwrap());\n            } else\
    \ {\n                result.push(c.to_lowercase().next().unwrap());\n        \
    \    }\n        } else {\n            result.push(c);\n        }\n    }\n    if\
    \ result.is_empty() {\n        s.chars().rev().collect()\n    } else {\n     \
    \   result\n    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"1234\"`,\n right: `\"4321\"`', /tmp/tmpkbrs4tds.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp9sk1a2k_.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp8t1nuz3w.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut found_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     found_letter = true;\n            result.push(c.to_ascii_uppercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if found_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpx_z3z6xt.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp3h5cger_.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp_mh0qctl.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut found_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     found_letter = true;\n            result.push(c.to_ascii_uppercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if found_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpx3mr1mz1.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut contains_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     contains_letter = true;\n            result.push(c.to_lowercase().next().unwrap());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if contains_letter\
    \ {\n        result.chars().rev().collect()\n    } else {\n        result\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"fdsa\"`,\n right: `\"aSdF\"`', /tmp/tmprvjypjs2.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s.chars().collect::<Vec<char>>();\n   \
    \ let mut has_letter = false;\n    for i in 0..s.len() {\n        if s[i].is_alphabetic()\
    \ {\n            has_letter = true;\n            if s[i].is_lowercase() {\n  \
    \              s[i] = s[i].to_uppercase().next().unwrap();\n            } else\
    \ {\n                s[i] = s[i].to_lowercase().next().unwrap();\n           \
    \ }\n        }\n    }\n    if !has_letter {\n        s.reverse();\n    }\n   \
    \ s.into_iter().collect()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            res.push(c.to_ascii_uppercase());\n    \
    \    } else {\n            res.push(c);\n        }\n    }\n    if has_letter {\n\
    \        res\n    } else {\n        res.chars().rev().collect()\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpq7q2wu62.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            result.push(c.to_ascii_uppercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if result.is_empty()\
    \ {\n        s.chars().rev().collect()\n    } else {\n        result\n    }\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpg2be5kin.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp5102t61t.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_ascii_alphabetic() {\n \
    \           has_letter = true;\n            result.push(c.to_ascii_uppercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp7z9gyyl0.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            res.push(c.to_ascii_uppercase());\n\
    \        } else {\n            res.push(c);\n        }\n    }\n    if res.is_empty()\
    \ {\n        s.chars().rev().collect()\n    } else {\n        res\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp31y6aa0l.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            res.push(c.to_ascii_uppercase());\n\
    \        } else {\n            res.push(c);\n        }\n    }\n    if res.is_empty()\
    \ {\n        s.chars().rev().collect()\n    } else {\n        res\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpps9v_n9a.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            if c.is_lowercase() {\n                result.push(c.to_uppercase().next().unwrap());\n\
    \            } else {\n                result.push(c.to_lowercase().next().unwrap());\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    if !has_letter {\n        result.chars().rev().collect()\n    } else\
    \ {\n        result\n    }\n}\n\nfn main() {\n    let candidate = solve;\n   \
    \ assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n   \
    \ assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpecu995ci.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut is_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     is_letter = true;\n            result.push(c.to_ascii_uppercase());\n  \
    \      } else {\n            result.push(c);\n        }\n    }\n    if is_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpj_jeo7qr.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpz9bxliug.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            res.push(c.to_ascii_uppercase());\n\
    \        } else {\n            res.push(c);\n        }\n    }\n    if res.is_empty()\
    \ {\n        s.chars().rev().collect()\n    } else {\n        res\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpvzgh9kgt.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            result.push(c.to_ascii_uppercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if result.is_empty()\
    \ {\n        s.chars().rev().collect()\n    } else {\n        result\n    }\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp4egvm55l.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut is_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     is_letter = true;\n            if c.is_lowercase() {\n                result.push(c.to_uppercase().next().unwrap());\n\
    \            } else {\n                result.push(c.to_lowercase().next().unwrap());\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    if !is_letter {\n        result.chars().rev().collect()\n    } else {\n\
    \        result\n    }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpl0yjfyz4.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut is_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     is_letter = true;\n            result.push(c.to_ascii_uppercase());\n  \
    \      } else {\n            result.push(c);\n        }\n    }\n    if is_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp3rm2m97m.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpv7p_rxtj.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp6ip8tj5e.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut flag = false;\n\
    \    for c in s.chars() {\n        if c.is_alphabetic() {\n            flag =\
    \ true;\n            res.push(c.to_ascii_uppercase());\n        } else {\n   \
    \         res.push(c);\n        }\n    }\n    if flag {\n        res\n    } else\
    \ {\n        res.chars().rev().collect()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp3kgvnm0i.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpycr1oplr.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpaicnbtg7.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp_5hzlwo8.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut flag = false;\n\
    \    for c in s.chars() {\n        if c.is_alphabetic() {\n            flag =\
    \ true;\n            res.push(c.to_ascii_uppercase());\n        } else {\n   \
    \         res.push(c);\n        }\n    }\n    if flag {\n        res\n    } else\
    \ {\n        res.chars().rev().collect()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpenflrc2p.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut flag = false;\n\
    \    for c in s.chars() {\n        if c.is_alphabetic() {\n            flag =\
    \ true;\n            res.push(c.to_ascii_uppercase());\n        } else {\n   \
    \         res.push(c);\n        }\n    }\n    if flag {\n        res\n    } else\
    \ {\n        res.chars().rev().collect()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp01na5fsy.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpok9lhy4b.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s.chars().collect::<Vec<char>>();\n   \
    \ let mut is_letter = false;\n    for i in 0..s.len() {\n        if s[i].is_alphabetic()\
    \ {\n            is_letter = true;\n            if s[i].is_lowercase() {\n   \
    \             s[i] = s[i].to_uppercase().next().unwrap();\n            } else\
    \ {\n                s[i] = s[i].to_lowercase().next().unwrap();\n           \
    \ }\n        }\n    }\n    if !is_letter {\n        s.reverse();\n    }\n    s.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut found_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     found_letter = true;\n            result.push(c.to_ascii_uppercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if found_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp19sksjz7.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmprdwt071o.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            if c.is_lowercase() {\n                result.push(c.to_uppercase().next().unwrap());\n\
    \            } else {\n                result.push(c.to_lowercase().next().unwrap());\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    if !has_letter {\n        result.chars().rev().collect()\n    } else\
    \ {\n        result\n    }\n}\n\nfn main() {\n    let candidate = solve;\n   \
    \ assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n   \
    \ assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpzo76c8bv.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp1c_718oy.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut is_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     is_letter = true;\n            if c.is_lowercase() {\n                result.push(c.to_uppercase().to_string());\n\
    \            } else {\n                result.push(c.to_lowercase().to_string());\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    if !is_letter {\n        result = result.chars().rev().collect();\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0v3lv3tm.rs:20:29\n   |\n\
    20 |                 result.push(c.to_uppercase().to_string());\n   |        \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0v3lv3tm.rs:22:29\n\
    \   |\n22 |                 result.push(c.to_lowercase().to_string());\n   | \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found\
    \ struct `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpmqyj0crk.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp_58nf2in.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpgzsvc06d.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            res.push(c.to_ascii_uppercase());\n    \
    \    } else {\n            res.push(c);\n        }\n    }\n    if has_letter {\n\
    \        res\n    } else {\n        res.chars().rev().collect()\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpou67yqpc.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpm4gcu4gd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s.chars().collect::<Vec<char>>();\n   \
    \ let mut has_letter = false;\n    for i in 0..s.len() {\n        if s[i].is_alphabetic()\
    \ {\n            has_letter = true;\n            s[i] = if s[i].is_lowercase()\
    \ {\n                s[i].to_ascii_uppercase()\n            } else {\n       \
    \         s[i].to_ascii_lowercase()\n            };\n        }\n    }\n    if\
    \ !has_letter {\n        s.reverse();\n    }\n    s.iter().collect()\n}\n\nfn\
    \ main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            res.push(c.to_ascii_uppercase());\n    \
    \    } else {\n            res.push(c);\n        }\n    }\n    if has_letter {\n\
    \        res\n    } else {\n        res.chars().rev().collect()\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpx60h28r_.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpj7e_qrs8.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            res.push(c.to_ascii_uppercase());\n    \
    \    } else {\n            res.push(c);\n        }\n    }\n    if has_letter {\n\
    \        res\n    } else {\n        res.chars().rev().collect()\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpb44aphbp.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpmga66ikq.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpotplmr3s.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            if c.is_lowercase() {\n                result.push(c.to_uppercase().next().unwrap());\n\
    \            } else {\n                result.push(c.to_lowercase().next().unwrap());\n\
    \            }\n        } else {\n            result.push(c);\n        }\n   \
    \ }\n    if !has_letter {\n        result.chars().rev().collect()\n    } else\
    \ {\n        result\n    }\n}\n\nfn main() {\n    let candidate = solve;\n   \
    \ assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n   \
    \ assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"\
    #a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\"\
    )), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\"\
    )), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\"\
    )), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\"\
    )), String::from(\"#CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_ascii_alphabetic() {\n \
    \           has_letter = true;\n            result.push(c.to_ascii_uppercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if !has_letter\
    \ {\n        result.chars().rev().collect()\n    } else {\n        result\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpfkhad44p.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            res.push(c.to_ascii_uppercase());\n    \
    \    } else {\n            res.push(c);\n        }\n    }\n    if has_letter {\n\
    \        res\n    } else {\n        res.chars().rev().collect()\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpfw7vb4ae.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut is_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     is_letter = true;\n            result.push(c.to_ascii_uppercase());\n  \
    \      } else {\n            result.push(c);\n        }\n    }\n    if is_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp_bpmqslz.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpq06z99uw.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s = s.chars().collect::<Vec<char>>();\n   \
    \ let mut has_letter = false;\n    for i in 0..s.len() {\n        if s[i].is_alphabetic()\
    \ {\n            has_letter = true;\n            if s[i].is_uppercase() {\n  \
    \              s[i] = s[i].to_lowercase().next().unwrap();\n            } else\
    \ {\n                s[i] = s[i].to_uppercase().next().unwrap();\n           \
    \ }\n        }\n    }\n    if !has_letter {\n        s.reverse();\n    }\n   \
    \ s.into_iter().collect()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut flag = false;\n\
    \    for c in s.chars() {\n        if c.is_alphabetic() {\n            flag =\
    \ true;\n            res.push(c.to_ascii_uppercase());\n        } else {\n   \
    \         res.push(c);\n        }\n    }\n    if flag {\n        res\n    } else\
    \ {\n        res.chars().rev().collect()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpnjoakphj.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp3v6rhu0m.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            res.push(c.to_ascii_uppercase());\n    \
    \    } else {\n            res.push(c);\n        }\n    }\n    if has_letter {\n\
    \        res\n    } else {\n        res.chars().rev().collect()\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp8i_7wutb.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut flag = false;\n\
    \    for c in s.chars() {\n        if c.is_alphabetic() {\n            flag =\
    \ true;\n            res.push(c.to_ascii_uppercase());\n        } else {\n   \
    \         res.push(c);\n        }\n    }\n    if flag {\n        res\n    } else\
    \ {\n        res.chars().rev().collect()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"\
    aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"\
    ));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n\
    \    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n\
    \    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"\
    ));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n\
    \    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n\
    \    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpvoq9wmmz.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmplmit6lqc.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpc1f2pazn.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s: Vec<char> = s.chars().collect();\n    let\
    \ mut has_letter = false;\n    for i in 0..s.len() {\n        if s[i].is_alphabetic()\
    \ {\n            has_letter = true;\n            if s[i].is_lowercase() {\n  \
    \              s[i] = s[i].to_uppercase().next().unwrap();\n            } else\
    \ {\n                s[i] = s[i].to_lowercase().next().unwrap();\n           \
    \ }\n        }\n    }\n    if !has_letter {\n        s.reverse();\n    }\n   \
    \ s.into_iter().collect()\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            result.push(c.to_ascii_uppercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if result.is_empty()\
    \ {\n        s.chars().rev().collect()\n    } else {\n        result\n    }\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpuj1cp6a_.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp1awdb6l6.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            result.push(c.to_ascii_uppercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if result.is_empty()\
    \ {\n        s.chars().rev().collect()\n    } else {\n        result\n    }\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpyhe36r7e.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s: Vec<char> = s.chars().collect();\n    let\
    \ mut has_letter = false;\n    for i in 0..s.len() {\n        if s[i].is_alphabetic()\
    \ {\n            has_letter = true;\n            s[i] = if s[i].is_lowercase()\
    \ {\n                s[i].to_ascii_uppercase()\n            } else {\n       \
    \         s[i].to_ascii_lowercase()\n            };\n        }\n    }\n    if\
    \ !has_letter {\n        s.reverse();\n    }\n    s.into_iter().collect()\n}\n\
    \nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        if c.is_alphabetic() {\n            result.push(c.to_ascii_uppercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if result.is_empty()\
    \ {\n        s.chars().rev().collect()\n    } else {\n        result\n    }\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpaircjn18.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmpz2wfngkf.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut found_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     found_letter = true;\n            result.push(c.to_ascii_uppercase());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if found_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp8ot07_09.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            result.push(c.to_ascii_uppercase());\n \
    \       } else {\n            result.push(c);\n        }\n    }\n    if has_letter\
    \ {\n        result\n    } else {\n        result.chars().rev().collect()\n  \
    \  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp1mlae_36.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut has_letter\
    \ = false;\n    for c in s.chars() {\n        if c.is_alphabetic() {\n       \
    \     has_letter = true;\n            res.push(c.to_ascii_uppercase());\n    \
    \    } else {\n            res.push(c);\n        }\n    }\n    if has_letter {\n\
    \        res\n    } else {\n        res.chars().rev().collect()\n    }\n}\n\n\
    fn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ASDF\"`,\n right: `\"aSdF\"`', /tmp/tmp2i92bgdi.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a string s.\n/// if s[i] is a letter, reverse its case\
    \ from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If\
    \ the string contains no letters, reverse the string.\n/// The function should\
    \ return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"\
    ))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"\
    AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s:\
    \ String) -> String {\n    let mut s: Vec<char> = s.chars().collect();\n    let\
    \ mut has_letter = false;\n    for i in 0..s.len() {\n        if s[i].is_alphabetic()\
    \ {\n            has_letter = true;\n            s[i] = s[i].to_ascii_lowercase();\n\
    \        }\n    }\n    if has_letter {\n        s.reverse();\n    }\n    s.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"\
    AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\"\
    )), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")),\
    \ String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"\
    #A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"\
    #aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"\
    2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"\
    #$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"\
    #CCC\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"fdsa\"`,\n right: `\"aSdF\"`', /tmp/tmpbe3expac.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
