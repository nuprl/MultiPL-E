{
  "name": "mbpp_89_closest_num",
  "language": "go_test.go",
  "prompt": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_89_closest_num.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // find the first 1 from right to left\n    var index int\n    for index = 0; index < 32; index++ {\n        if (N & (1 << index)) != 0 {\n            break\n        }\n    }\n    if index == 32 {\n        return -1\n    }\n    // flip the bit at index\n    N = N ^ (1 << index)\n    // set the bit at index - 1\n    N = N | (1 << (index - 1))\n    // clear all bits to the right of index - 1\n    N = N & ((1 << (index - 1)) - 1)\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510431,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\npanic: runtime error: negative shift amount [recovered]\n\tpanic: runtime error: negative shift amount\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523060, 0x616a10)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523060, 0x616a10)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.closest_num(...)\n\t/tmp/tmp7kkdfgt9_test.go:23\ncommand-line-arguments_test.TestClosest_Num(0xc000001380)\n\t/tmp/tmp7kkdfgt9_test.go:36 +0x45e\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiiii int\n    var jjjjj int\n    var kkkkk int\n    var lllll int\n    var mmmmm int\n    var nnnnn int\n    var ooooo int\n    var ppppp int\n    var qqqqq int\n    var rrrrr int\n    var sssss int\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510431,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3fdgnltc_test.go:100:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return 0\n    }\n\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if (i & (i + 1)) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510431,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpihnk0ryj_test.go:38: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpihnk0ryj_test.go:38: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpihnk0ryj_test.go:38: expected '%!s(int=11)', got '%!s(int=7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return 0\n    }\n    var i, j int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    for j = i - 1; j >= 0; j-- {\n        if (N & (1 << j)) == 0 {\n            break\n        }\n    }\n    N = N & ((1 << j) - 1)\n    N = N | (1 << j)\n    N = N | ((1 << (i - j - 1)) - 1)\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510431,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmph9sbydqm_test.go:48: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmph9sbydqm_test.go:48: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmph9sbydqm_test.go:48: expected '%!s(int=11)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N < 0 {\n        return -1\n    }\n    if N == 0 {\n        return 0\n    }\n    if N == 1 {\n        return 0\n    }\n\n    var count int = 0\n    var result int = 0\n    for i := 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            count++\n        }\n        if (N & (1 << i)) == 0 && count == 1 {\n            result = N | (1 << i)\n            break\n        }\n    }\n    return result\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510431,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpolc_ypin_test.go:49: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpolc_ypin_test.go:49: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpolc_ypin_test.go:49: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N-1; i > 0; i-- {\n        if i & N == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510431,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp9_gmvimq_test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp9_gmvimq_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp9_gmvimq_test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n\n    var i uint\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n\n    if i == 0 {\n        return 0\n    }\n\n    return N & ^(1 << i)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510431,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp03w66n_s_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp03w66n_s_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp03w66n_s_test.go:43: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j int\n    var n int\n    n = N\n    for i = 0; i < 32; i++ {\n        if (n & (1 << i)) != 0 {\n            break\n        }\n    }\n    for j = i + 1; j < 32; j++ {\n        if (n & (1 << j)) == 0 {\n            break\n        }\n    }\n    n = n & ((1 << i) - 1)\n    n = n | (1 << j)\n    n = n | ((1 << (j - 1)) - 1)\n    return n\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510431,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpjivixu62_test.go:44: expected '%!s(int=10)', got '%!s(int=5)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpjivixu62_test.go:44: expected '%!s(int=6)', got '%!s(int=11)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpjivixu62_test.go:44: expected '%!s(int=11)', got '%!s(int=23)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            break\n        }\n    }\n    if i == 32 {\n        return 0\n    }\n    return N & ((1 << i) - 1)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510431,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp_x17r7c3_test.go:40: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp_x17r7c3_test.go:40: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp_x17r7c3_test.go:40: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n\n    i = N & 0x55555555\n    j = N & 0xAAAAAAAA\n    k = i | (j >> 1)\n    l = N & 0x33333333\n    m = N & 0xCCCCCCCC\n    n = l | (m >> 2)\n    o = k & n\n    p = N & 0x0F0F0F0F\n    q = N & 0xF0F0F0F0\n    r = p | (q >> 4)\n    s = o & r\n    t = N & 0x00FF00FF\n    u = N & 0xFF00FF00\n    v = t | (u >> 8)\n    w = s & v\n    x = N & 0x0000FFFF\n    y = N & 0xFFFF0000\n    z = x | (y >> 16)\n\n    return w & z\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510431,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp0rt51_nb_test.go:66: expected '%!s(int=10)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp0rt51_nb_test.go:66: expected '%!s(int=6)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp0rt51_nb_test.go:66: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return 0\n    }\n    var i int = 1\n    var j int = 1\n    var k int = 1\n    var n int = N\n    var count int = 0\n    for n > 0 {\n        if n & 1 == 1 {\n            count++\n        }\n        n >>= 1\n    }\n    for i < count {\n        j <<= 1\n        i++\n    }\n    for j > 0 {\n        if N & j == 0 {\n            N |= j\n            break\n        }\n        j >>= 1\n    }\n    for k < count {\n        N &= ^(1 << k)\n        k++\n    }\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510431,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpf2f8y28k_test.go:57: expected '%!s(int=10)', got '%!s(int=9)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpf2f8y28k_test.go:57: expected '%!s(int=6)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpf2f8y28k_test.go:57: expected '%!s(int=11)', got '%!s(int=12)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // convert N to binary\n    var binary_N string\n    for N > 0 {\n        binary_N = fmt.Sprintf(\"%d%s\", N % 2, binary_N)\n        N /= 2\n    }\n    fmt.Println(binary_N)\n\n    // find the first 1\n    var first_one int\n    for i := 0; i < len(binary_N); i++ {\n        if binary_N[i] == '1' {\n            first_one = i\n            break\n        }\n    }\n    fmt.Println(first_one)\n\n    // find the first 0 after the first 1\n    var first_zero int\n    for i := first_one + 1; i < len(binary_N); i++ {\n        if binary_N[i] == '0' {\n            first_zero = i\n            break\n        }\n    }\n    fmt.Println(first_zero)\n\n    // swap the first 1 and the first 0\n    var new_binary_N string\n    for i := 0; i < len(binary_N); i++ {\n        if i == first_one {\n            new_binary_N += \"0\"\n        } else if i == first_zero {\n            new_binary_N += \"1\"\n        } else {\n            new_binary_N += string(binary_N[i])\n        }\n    }\n    fmt.Println(new_binary_N)\n\n    // convert new_binary_N to decimal\n    var new_N int\n    for i := 0; i < len(new_binary_N); i++ {\n        if new_binary_N[i] == '1' {\n            new_N += 1 << uint(len(new_binary_N) - i - 1)\n        }\n    }\n    fmt.Println(new_N)\n\n    return new_N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510431,
      "stdout": "1011\n0\n1\n0111\n7\n111\n0\n0\n011\n3\n1100\n0\n2\n0110\n6\n--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpct6trc5w_test.go:78: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpct6trc5w_test.go:78: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpct6trc5w_test.go:78: expected '%!s(int=11)', got '%!s(int=6)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if (N & i) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmph5_v2fg4_test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmph5_v2fg4_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmph5_v2fg4_test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // Find the first bit that is 1\n    var i uint\n    for i = 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            break\n        }\n    }\n    // If the first bit is 1, then the closest number is N - 2^i\n    if i > 0 {\n        return N - (1 << i)\n    }\n    // If the first bit is 0, then the closest number is N + 2^i\n    return N + (1 << i)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510431,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp_kohzy91_test.go:40: expected '%!s(int=10)', got '%!s(int=12)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp_kohzy91_test.go:40: expected '%!s(int=6)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp_kohzy91_test.go:40: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << uint(i))) != 0 {\n            break\n        }\n    }\n    if i == 32 {\n        return 0\n    }\n    if i == 0 {\n        return N - 1\n    }\n    return N - (1 << uint(i))\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510431,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpp7f34vl4_test.go:43: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if i & N == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510431,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp3kw1fbv7_test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp3kw1fbv7_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp3kw1fbv7_test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    // find the first bit that is 1\n    i := 0\n    for N & (1 << i) == 0 {\n        i++\n    }\n    // flip the first bit that is 1\n    N = N & ^(1 << i)\n    // set the bit that is 0 to 1\n    N = N | (1 << (i - 1))\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510431,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\npanic: runtime error: negative shift amount [recovered]\n\tpanic: runtime error: negative shift amount\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x522060, 0x615a10)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x522060, 0x615a10)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.closest_num(...)\n\t/tmp/tmptsssdhou_test.go:21\ncommand-line-arguments_test.TestClosest_Num(0xc000102600)\n\t/tmp/tmptsssdhou_test.go:32 +0x3de\ntesting.tRunner(0xc000102600, 0x54e1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return 0\n    }\n    if N == 1 {\n        return 0\n    }\n    if N == 2 {\n        return 1\n    }\n    if N == 3 {\n        return 2\n    }\n    if N == 4 {\n        return 3\n    }\n    if N == 5 {\n        return 4\n    }\n    if N == 6 {\n        return 5\n    }\n    if N == 7 {\n        return 6\n    }\n    if N == 8 {\n        return 7\n    }\n    if N == 9 {\n        return 8\n    }\n    if N == 10 {\n        return 9\n    }\n    if N == 11 {\n        return 10\n    }\n    if N == 12 {\n        return 11\n    }\n    if N == 13 {\n        return 12\n    }\n    if N == 14 {\n        return 13\n    }\n    if N == 15 {\n        return 14\n    }\n    if N == 16 {\n        return 15\n    }\n    if N == 17 {\n        return 16\n    }\n    if N == 18 {\n        return 17\n    }\n    if N == 19 {\n        return 18\n    }\n    if N == 20 {\n        return 19\n    }\n    if N == 21 {\n        return 20\n    }\n    if N == 22 {\n        return 21\n    }\n    if N == 23 {\n        return 22\n    }\n    if N == 24 {\n        return 23\n    }\n    if N == 25 {\n        return 24\n    }\n    if N == 26 {\n        return 25\n    }\n    if N == 27 {\n        return 26\n    }\n    if N == 28 {\n        return 27\n    }\n    if N == 29 {\n        return 28\n    }\n    if N == 30 {\n        return 29\n    }\n    if N == 31 {\n        return 30\n    }\n    if N == 32 {\n        return 31\n    }\n    if N == 33 {\n        return 32\n    }\n    if N == 34 {\n        return 33\n    }\n    if N == 35 {\n        return 34\n    }\n    if N == 36 {\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510431,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxw40qj2g_test.go:120:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if i & (i-1) == 0 {\n            return i\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510431,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpweiwlpsz_test.go:34: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpweiwlpsz_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpweiwlpsz_test.go:34: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return 0\n    }\n\n    var (\n        num = N\n        count = 0\n    )\n\n    for num > 0 {\n        if num & 1 == 1 {\n            count++\n        }\n        num >>= 1\n    }\n\n    if count == 1 {\n        return N - 1\n    }\n\n    return N - 1 - (1 << uint(count - 1))\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510431,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpbnfw9f59_test.go:48: expected '%!s(int=10)', got '%!s(int=6)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpbnfw9f59_test.go:48: expected '%!s(int=6)', got '%!s(int=2)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpbnfw9f59_test.go:48: expected '%!s(int=11)', got '%!s(int=9)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j, k int\n    var result int\n    var num_list []int\n    var num_list_len int\n\n    for i = 0; i < N; i++ {\n        num_list = append(num_list, i)\n    }\n\n    num_list_len = len(num_list)\n\n    for j = 0; j < num_list_len; j++ {\n        for k = j + 1; k < num_list_len; k++ {\n            if num_list[j] + num_list[k] == N {\n                result = num_list[j]\n                break\n            }\n        }\n    }\n\n    return result\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123280,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpodi5xhkt_test.go:48: expected '%!s(int=10)', got '%!s(int=5)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpodi5xhkt_test.go:48: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpodi5xhkt_test.go:48: expected '%!s(int=11)', got '%!s(int=5)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N-1; i > 0; i-- {\n        if (i & N) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123244,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpm_003ilt_test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpm_003ilt_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpm_003ilt_test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // find the first 1 from right to left\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    // find the first 0 from right to left\n    var j int\n    for j = i + 1; j < 32; j++ {\n        if (N & (1 << j)) == 0 {\n            break\n        }\n    }\n    // swap i and j\n    N = N | (1 << i)\n    N = N & ^(1 << j)\n    // set all bits from i+1 to j-1 to 1\n    for k := i + 1; k < j; k++ {\n        N = N | (1 << k)\n    }\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123280,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp301avyog_test.go:49: expected '%!s(int=10)', got '%!s(int=11)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp301avyog_test.go:49: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp301avyog_test.go:49: expected '%!s(int=11)', got '%!s(int=12)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // Find the first 1 bit from the right.\n    var i uint\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n\n    // Flip the first 1 bit from the right.\n    N = N ^ (1 << i)\n\n    // Set all the bits to the right of the first 1 bit from the right.\n    N = N | ((1 << i) - 1)\n\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123280,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n\n    var i uint\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n\n    if i == 0 {\n        return 0\n    }\n\n    return N - (1 << i) + 1\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123279,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpiqf90nlp_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpiqf90nlp_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpiqf90nlp_test.go:43: expected '%!s(int=11)', got '%!s(int=9)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n\n    i = N & 0x55555555\n    j = N & 0xAAAAAAAA\n    k = i | (j >> 1)\n    l = N & 0x33333333\n    m = N & 0xCCCCCCCC\n    n = l | (m >> 2)\n    o = N & 0x0F0F0F0F\n    p = N & 0xF0F0F0F0\n    q = o | (p >> 4)\n    r = N & 0x00FF00FF\n    s = N & 0xFF00FF00\n    t = r | (s >> 8)\n    u = N & 0x0000FFFF\n    v = N & 0xFFFF0000\n    w = u | (v >> 16)\n    x = k & n & q & t & w\n    y = N & x\n    z = N & (~x)\n    return z\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123278,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmphf3wn9pi_test.go:46:14: illegal character U+007E '~'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var (\n        i int\n        j int\n        k int\n    )\n    for i = 0; i < N; i++ {\n        for j = 0; j < N; j++ {\n            for k = 0; k < N; k++ {\n                if (i * i + j * j + k * k) == N {\n                    return i * i + j * j + k * k\n                }\n            }\n        }\n    }\n    return -1\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123280,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmprlg13qks_test.go:42: expected '%!s(int=10)', got '%!s(int=11)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmprlg13qks_test.go:42: expected '%!s(int=6)', got '%!s(int=-1)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmprlg13qks_test.go:42: expected '%!s(int=11)', got '%!s(int=12)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    for j = i + 1; j < 32; j++ {\n        if (N & (1 << j)) == 0 {\n            break\n        }\n    }\n    if j == 32 {\n        return -1\n    }\n    N = N & ((1 << i) - 1)\n    N = N | (1 << j)\n    N = N | ((1 << (j - i - 1)) - 1)\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123280,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpa589mi1__test.go:45: expected '%!s(int=10)', got '%!s(int=5)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpa589mi1__test.go:45: expected '%!s(int=6)', got '%!s(int=11)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpa589mi1__test.go:45: expected '%!s(int=11)', got '%!s(int=17)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n    var ssss int\n    var\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510428,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpz4ky4r0n_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n\n    for i = 0; i < N; i++ {\n        for j = 0; j < N; j++ {\n            for k = 0; k < N; k++ {\n                for l = 0; l < N; l++ {\n                    for m = 0; m < N; m++ {\n                        for n = 0; n < N; n++ {\n                            for o = 0; o < N; o++ {\n                                for p = 0; p < N; p++ {\n                                    for q = 0; q < N; q++ {\n                                        for r = 0; r < N; r++ {\n                                            for s = 0; s < N; s++ {\n                                                for t = 0; t < N; t++ {\n                                                    for u = 0; u < N; u++ {\n                                                        for v = 0; v < N; v++ {\n                                                            for w = 0; w < N; w++ {\n                                                                for x = 0; x < N; x++ {\n                                                                    for y = 0; y < N; y++ {\n                                                                        for z = 0; z < N; z++ {\n                                                                            if i + j + k + l + m + n + o + p + q + r + s + t + u + v + w + x + y + z == N {\n                                                                                return i + j + k + l + m + n + o + p + q + r + s + t + u + v + w + x + y + z\n                                                                            }\n                                                                        }\n                                                                    }\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123278,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpe2wwtruh_test.go:60:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if i & N == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510431,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp3kw1fbv7_test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp3kw1fbv7_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp3kw1fbv7_test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // TODO: implement\n    return 0\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123280,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpornq3npl_test.go:29: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpornq3npl_test.go:29: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpornq3npl_test.go:29: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i, j int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    for j = i + 1; j < 32; j++ {\n        if (N & (1 << j)) == 0 {\n            break\n        }\n    }\n    if j == 32 {\n        return -1\n    }\n    N = N & ((1 << i) - 1)\n    N = N | (1 << j)\n    N = N | ((1 << (j - i - 1)) - 1)\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123280,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmptefd0cv1_test.go:48: expected '%!s(int=10)', got '%!s(int=5)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmptefd0cv1_test.go:48: expected '%!s(int=6)', got '%!s(int=11)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmptefd0cv1_test.go:48: expected '%!s(int=11)', got '%!s(int=17)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // 1. find the first 1 from right to left\n    // 2. find the first 0 from right to left\n    // 3. swap 1 and 0\n    // 4. move all 1s to right\n    // 5. move all 0s to left\n    var i, j int\n    var n int = N\n    for i = 0; i < 32; i++ {\n        if n & 1 == 1 {\n            break\n        }\n        n = n >> 1\n    }\n    for j = i + 1; j < 32; j++ {\n        if n & 1 == 0 {\n            break\n        }\n        n = n >> 1\n    }\n    n = N\n    n = n | (1 << j)\n    n = n & ^(1 << i)\n    n = n & ((1 << j) - 1)\n    n = n | ((1 << (i - j - 1)) - 1)\n    return n\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123280,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\npanic: runtime error: negative shift amount [recovered]\n\tpanic: runtime error: negative shift amount\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x522060, 0x615a10)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x522060, 0x615a10)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.closest_num(0xb, 0x5f90c0)\n\t/tmp/tmpjqxuznsb_test.go:33 +0xc7\ncommand-line-arguments_test.TestClosest_Num(0xc000001380)\n\t/tmp/tmpjqxuznsb_test.go:44 +0x47\ntesting.tRunner(0xc000001380, 0x54e1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if (i & (i + 1)) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpyxbf0m5n_test.go:34: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpyxbf0m5n_test.go:34: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpyxbf0m5n_test.go:34: expected '%!s(int=11)', got '%!s(int=7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j int\n    var tmp int\n    var result int\n    var result_diff int\n    var diff int\n    var N_bin []int\n    var N_bin_len int\n    var N_bin_str string\n    var N_bin_str_len int\n\n    // Convert N to binary\n    for i = 0; N > 0; i++ {\n        N_bin = append(N_bin, N % 2)\n        N = N / 2\n    }\n    N_bin_len = len(N_bin)\n\n    // Convert N_bin to string\n    for j = 0; j < N_bin_len; j++ {\n        N_bin_str += fmt.Sprintf(\"%d\", N_bin[N_bin_len - j - 1])\n    }\n    N_bin_str_len = len(N_bin_str)\n\n    // Find the closest smaller number\n    for i = 0; i < N_bin_str_len; i++ {\n        if N_bin_str[i] == '1' {\n            tmp = N_bin_str[i]\n            N_bin_str[i] = '0'\n            result, _ = strconv.Atoi(N_bin_str)\n            result = result * int(math.Pow(2, N_bin_str_len - i - 1))\n            diff = N - result\n            if diff < result_diff {\n                result_diff = diff\n            }\n            N_bin_str[i] = tmp\n        }\n    }\n\n    return result_diff\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123279,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkhk71jt5_test.go:36:17: cannot use N_bin_str[i] (type byte) as type int in assignment\n/tmp/tmpkhk71jt5_test.go:37:26: cannot assign to N_bin_str[i] (strings are immutable)\n/tmp/tmpkhk71jt5_test.go:38:25: undefined: strconv\n/tmp/tmpkhk71jt5_test.go:39:35: undefined: math\n/tmp/tmpkhk71jt5_test.go:44:26: cannot assign to N_bin_str[i] (strings are immutable)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    for j = i + 1; j < 32; j++ {\n        if (N & (1 << j)) == 0 {\n            break\n        }\n    }\n    if j == 32 {\n        return -1\n    }\n    N = N & ((1 << i) - 1)\n    N = N | (1 << j)\n    N = N | ((1 << (j - i - 1)) - 1)\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123280,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpa589mi1__test.go:45: expected '%!s(int=10)', got '%!s(int=5)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpa589mi1__test.go:45: expected '%!s(int=6)', got '%!s(int=11)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpa589mi1__test.go:45: expected '%!s(int=11)', got '%!s(int=17)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var num int\n    for i := N; i >= 0; i-- {\n        if i % 10 == 0 {\n            num = i\n            break\n        }\n    }\n    return num\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123280,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp7jed3lh3_test.go:35: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp7jed3lh3_test.go:35: expected '%!s(int=11)', got '%!s(int=10)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = 0; i < N; i++ {\n        if (N & i) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123280,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpwc0urvgp_test.go:34: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpwc0urvgp_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpwc0urvgp_test.go:34: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    return N & ^(1 << (i - 1))\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp77vwm_gf_test.go:40: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp77vwm_gf_test.go:40: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp77vwm_gf_test.go:40: expected '%!s(int=11)', got '%!s(int=12)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var num int\n    var count int\n    for i := 0; i < N; i++ {\n        if i & N == i {\n            count++\n            num = i\n        }\n    }\n    if count == 1 {\n        return num\n    }\n    return 0\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123280,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp6_4h5l4k_test.go:39: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp6_4h5l4k_test.go:39: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp6_4h5l4k_test.go:39: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // find the first 1 from right to left\n    var i uint\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    // set the bit i to 0\n    N = N & ^(1 << i)\n    // set the bit i-1 to 1\n    N = N | (1 << (i - 1))\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123280,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpydmtje3t_test.go:39: expected '%!s(int=11)', got '%!s(int=10)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if (i & N) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp3aikxi66_test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp3aikxi66_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp3aikxi66_test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int = 1\n    var j int = 1\n    var result int = 0\n    for i < N {\n        j = 1\n        for j < N {\n            if i * j == N {\n                if result == 0 {\n                    result = i\n                } else if i > result {\n                    result = i\n                }\n            }\n            j++\n        }\n        i++\n    }\n    return result\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123280,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpcyyk6ajy_test.go:45: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpcyyk6ajy_test.go:45: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpcyyk6ajy_test.go:45: expected '%!s(int=11)', got '%!s(int=6)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if (i & (i + 1)) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpyxbf0m5n_test.go:34: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpyxbf0m5n_test.go:34: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpyxbf0m5n_test.go:34: expected '%!s(int=11)', got '%!s(int=7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // Find the first non-trailing zero.\n    var i int\n    for i = 0; i < 31; i++ {\n        if N & (1 << i) != 0 {\n            break\n        }\n    }\n    // Flip the bit.\n    N ^= 1 << i\n    // Set all the bits to the right of the flipped bit to 1.\n    N |= (1 << i) - 1\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123280,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if i & (i - 1) == 0 {\n            return i\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123280,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmplqp0m9r4_test.go:34: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmplqp0m9r4_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmplqp0m9r4_test.go:34: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    for j = i + 1; j < 32; j++ {\n        if (N & (1 << j)) == 0 {\n            break\n        }\n    }\n    if j == 32 {\n        return -1\n    }\n    N &= ^(1 << j)\n    N |= (1 << j) - 1\n    N &= ^((1 << i) - 1)\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123280,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmphhyom3tr_test.go:45: expected '%!s(int=10)', got '%!s(int=11)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmphhyom3tr_test.go:45: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmphhyom3tr_test.go:45: expected '%!s(int=11)', got '%!s(int=12)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n    var ssss int\n    var\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510428,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpz4ky4r0n_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int = 1\n    var j int = 1\n    var c int = 0\n    var n int = N\n    for n > 0 {\n        if n & 1 == 1 {\n            c++\n        }\n        i <<= 1\n        n >>= 1\n    }\n    if c == 1 {\n        return N - 1\n    }\n    for j < i {\n        if N & j == 0 {\n            return N - j\n        }\n        j <<= 1\n    }\n    return 0\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123280,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp_n8jr8qq_test.go:48: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp_n8jr8qq_test.go:48: expected '%!s(int=6)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // find the first 1 from the right\n    var i uint\n    for i = 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            break\n        }\n    }\n    // set the rightmost 1 to 0\n    N = N & (^(1 << i))\n    // set the rightmost 0 to 1\n    N = N | (1 << (i - 1))\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123280,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp9cp0mcxa_test.go:39: expected '%!s(int=11)', got '%!s(int=10)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // find the first 1 from the right\n    var i uint\n    for i = 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            break\n        }\n    }\n    // flip the first 1 from the right\n    N = N & ^(1 << i)\n    // flip the first 0 from the right\n    N = N | (1 << (i - 1))\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123280,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp801am5t6_test.go:39: expected '%!s(int=11)', got '%!s(int=10)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return 0\n    }\n    if N == 1 {\n        return 0\n    }\n    if N == 2 {\n        return 1\n    }\n    if N == 3 {\n        return 2\n    }\n    if N == 4 {\n        return 3\n    }\n    if N == 5 {\n        return 4\n    }\n    if N == 6 {\n        return 5\n    }\n    if N == 7 {\n        return 6\n    }\n    if N == 8 {\n        return 7\n    }\n    if N == 9 {\n        return 8\n    }\n    if N == 10 {\n        return 9\n    }\n    if N == 11 {\n        return 10\n    }\n    if N == 12 {\n        return 11\n    }\n    if N == 13 {\n        return 12\n    }\n    if N == 14 {\n        return 13\n    }\n    if N == 15 {\n        return 14\n    }\n    if N == 16 {\n        return 15\n    }\n    if N == 17 {\n        return 16\n    }\n    if N == 18 {\n        return 17\n    }\n    if N == 19 {\n        return 18\n    }\n    if N == 20 {\n        return 19\n    }\n    if N == 21 {\n        return 20\n    }\n    if N == 22 {\n        return 21\n    }\n    if N == 23 {\n        return 22\n    }\n    if N == 24 {\n        return 23\n    }\n    if N == 25 {\n        return 24\n    }\n    if N == 26 {\n        return 25\n    }\n    if N == 27 {\n        return 26\n    }\n    if N == 28 {\n        return 27\n    }\n    if N == 29 {\n        return 28\n    }\n    if N == 30 {\n        return 29\n    }\n    if N == 31 {\n        return 30\n    }\n    if N == 32 {\n        return 31\n    }\n    if N == 33 {\n        return 32\n    }\n    if N == 34 {\n        return 33\n    }\n    if N == 35 {\n        return 34\n    }\n    if N == 36 {\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510431,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxw40qj2g_test.go:120:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // find the first 1 from right to left\n    var i uint\n    for i = 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            break\n        }\n    }\n    // find the first 0 from right to left\n    var j uint\n    for j = i + 1; j < 32; j++ {\n        if N & (1 << j) == 0 {\n            break\n        }\n    }\n    // set the bit j to 1\n    N |= (1 << j)\n    // set the bit j-1 to 0\n    N &= ^(1 << (j - 1))\n    // set the bits from j-1 to i to 0\n    N &= (1 << (j - 1)) - 1\n    // set the bits from i to 0 to 1\n    N |= (1 << (i + 1)) - 1\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123281,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpn5rs71ay_test.go:50: expected '%!s(int=10)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpn5rs71ay_test.go:50: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpn5rs71ay_test.go:50: expected '%!s(int=11)', got '%!s(int=7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int = 1\n    var j int = N\n    var mid int = (i + j) / 2\n    for i < j {\n        if mid * mid > N {\n            j = mid - 1\n        } else if mid * mid < N {\n            i = mid + 1\n        } else {\n            return mid\n        }\n        mid = (i + j) / 2\n    }\n    return mid\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123281,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpc8fmw6ug_test.go:41: expected '%!s(int=10)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpc8fmw6ug_test.go:41: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpc8fmw6ug_test.go:41: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if (i & N) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp3aikxi66_test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp3aikxi66_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp3aikxi66_test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if (i & (i + 1)) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpyxbf0m5n_test.go:34: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpyxbf0m5n_test.go:34: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpyxbf0m5n_test.go:34: expected '%!s(int=11)', got '%!s(int=7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N >> i) & 1 == 1 {\n            break\n        }\n    }\n    return N & ((1 << i) - 1)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123252,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpp962q531_test.go:37: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpp962q531_test.go:37: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpp962q531_test.go:37: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i uint\n    for i = 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    return N & ^(1 << i)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123281,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpjkxq1zt__test.go:40: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpjkxq1zt__test.go:40: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpjkxq1zt__test.go:40: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N < 0 {\n        return -1\n    }\n    if N == 0 {\n        return 0\n    }\n    var i uint\n    for i = 0; i < 32; i++ {\n        if (N >> i) & 1 == 1 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    return N ^ (1 << i)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123282,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpgiufcu72_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpgiufcu72_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpgiufcu72_test.go:43: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var num int\n    for i := 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            num = i\n            break\n        }\n    }\n    return N & ^(1 << num)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123282,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp5ievrnii_test.go:38: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aaa int\n    var bbb int\n    var ccc int\n    var ddd int\n    var eee int\n    var fff int\n    var ggg int\n    var hhh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n   \nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510428,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprtu0muol_test.go:99:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if i & N == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510431,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp3kw1fbv7_test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp3kw1fbv7_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp3kw1fbv7_test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N < 0 {\n        return -1\n    }\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return -1\n    }\n    return N & ((1 << i) - 1)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123282,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpldmk3qoi_test.go:43: expected '%!s(int=10)', got '%!s(int=-1)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpldmk3qoi_test.go:43: expected '%!s(int=6)', got '%!s(int=-1)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpldmk3qoi_test.go:43: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n\n    i = N & 0x55555555\n    j = N & 0xaaaaaaaa\n    k = i | (j >> 1)\n    l = N & 0x33333333\n    m = N & 0xcccccccc\n    n = l | (m >> 2)\n    o = k & n\n    p = N & 0x0f0f0f0f\n    q = N & 0xf0f0f0f0\n    r = p | (q >> 4)\n    s = o & r\n    t = N & 0x00ff00ff\n    u = N & 0xff00ff00\n    v = t | (u >> 8)\n    w = s & v\n    x = N & 0x0000ffff\n    y = N & 0xffff0000\n    z = x | (y >> 16)\n\n    return w & z\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123282,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpal8fhpam_test.go:66: expected '%!s(int=10)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpal8fhpam_test.go:66: expected '%!s(int=6)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpal8fhpam_test.go:66: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    return N - (1 << (i - 1))\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123282,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmppv_9fwwd_test.go:40: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmppv_9fwwd_test.go:40: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmppv_9fwwd_test.go:40: expected '%!s(int=11)', got '%!s(int=10)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaa int\n    var bbb int\n    var ccc int\n    var ddd int\n    var eee int\n    var fff int\n    var ggg int\n    var hhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n    var ssss int\n    var tttt int\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpek5vjkf4_test.go:101:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    if N == 1 {\n        return 0\n    }\n    if N == 2 {\n        return 1\n    }\n    if N == 3 {\n        return 2\n    }\n    if N == 4 {\n        return 3\n    }\n    if N == 5 {\n        return 4\n    }\n    if N == 6 {\n        return 5\n    }\n    if N == 7 {\n        return 6\n    }\n    if N == 8 {\n        return 7\n    }\n    if N == 9 {\n        return 8\n    }\n    if N == 10 {\n        return 9\n    }\n    if N == 11 {\n        return 10\n    }\n    if N == 12 {\n        return 11\n    }\n    if N == 13 {\n        return 12\n    }\n    if N == 14 {\n        return 13\n    }\n    if N == 15 {\n        return 14\n    }\n    if N == 16 {\n        return 15\n    }\n    if N == 17 {\n        return 16\n    }\n    if N == 18 {\n        return 17\n    }\n    if N == 19 {\n        return 18\n    }\n    if N == 20 {\n        return 19\n    }\n    if N == 21 {\n        return 20\n    }\n    if N == 22 {\n        return 21\n    }\n    if N == 23 {\n        return 22\n    }\n    if N == 24 {\n        return 23\n    }\n    if N == 25 {\n        return 24\n    }\n    if N == 26 {\n        return 25\n    }\n    if N == 27 {\n        return 26\n    }\n    if N == 28 {\n        return 27\n    }\n    if N == 29 {\n        return 28\n    }\n    if N == 30 {\n        return 29\n    }\n    if N == 31 {\n        return 30\n    }\n    if N == 32 {\n        return 31\n    }\n    if N == 33 {\n        return 32\n    }\n    if N == 34 {\n        return 33\n    }\n    if N == 35 {\n        return 34\n    }\n    if N == 36 {\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123240,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2a2s5lj9_test.go:120:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N < 0 {\n        return -1\n    }\n\n    if N == 0 {\n        return 0\n    }\n\n    if N == 1 {\n        return 0\n    }\n\n    // find the first 1\n    var first_one int\n    for i := 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            first_one = i\n            break\n        }\n    }\n\n    // find the first 0 after the first 1\n    var first_zero int\n    for i := first_one + 1; i < 32; i++ {\n        if (N & (1 << i)) == 0 {\n            first_zero = i\n            break\n        }\n    }\n\n    // set the first 0 to 1\n    N |= (1 << first_zero)\n\n    // set the first 1 to 0\n    N &= ^(1 << first_one)\n\n    // set the first 1 to 0\n    N |= (1 << (first_zero - 1))\n\n    // set the first 0 to 1\n    N &= ^(1 << (first_zero - 2))\n\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123282,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp08ohlvt4_test.go:70: expected '%!s(int=10)', got '%!s(int=14)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp08ohlvt4_test.go:70: expected '%!s(int=6)', got '%!s(int=12)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp08ohlvt4_test.go:70: expected '%!s(int=11)', got '%!s(int=24)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N < 0 {\n        return -1\n    }\n    if N == 0 {\n        return 0\n    }\n    if N == 1 {\n        return 0\n    }\n    if N == 2 {\n        return 1\n    }\n    if N == 3 {\n        return 2\n    }\n    if N == 4 {\n        return 3\n    }\n    if N == 5 {\n        return 4\n    }\n    if N == 6 {\n        return 5\n    }\n    if N == 7 {\n        return 6\n    }\n    if N == 8 {\n        return 7\n    }\n    if N == 9 {\n        return 8\n    }\n    if N == 10 {\n        return 9\n    }\n    if N == 11 {\n        return 9\n    }\n    if N == 12 {\n        return 9\n    }\n    if N == 13 {\n        return 9\n    }\n    if N == 14 {\n        return 9\n    }\n    if N == 15 {\n        return 9\n    }\n    if N == 16 {\n        return 9\n    }\n    if N == 17 {\n        return 9\n    }\n    if N == 18 {\n        return 9\n    }\n    if N == 19 {\n        return 9\n    }\n    if N == 20 {\n        return 9\n    }\n    if N == 21 {\n        return 9\n    }\n    if N == 22 {\n        return 9\n    }\n    if N == 23 {\n        return 9\n    }\n    if N == 24 {\n        return 9\n    }\n    if N == 25 {\n        return 9\n    }\n    if N == 26 {\n        return 9\n    }\n    if N == 27 {\n        return 9\n    }\n    if N == 28 {\n        return 9\n    }\n    if N == 29 {\n        return 9\n    }\n    if N == 30 {\n        return 9\n    }\n    if N == 31 {\n        return 9\n    }\n    if N == 32 {\n        return 9\n    }\n    if N == 33 {\n        return 9\n    }\n    if N == 34 {\n        return 9\n    }\n    if N == 35 {\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123281,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpwzk7i29b_test.go:119:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if (i & N) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp3aikxi66_test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp3aikxi66_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp3aikxi66_test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    return N ^ (1 << i)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123282,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpt0otnwmo_test.go:40: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpt0otnwmo_test.go:40: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpt0otnwmo_test.go:40: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n\n    i = N % 10\n    j = N / 10 % 10\n    k = N / 100 % 10\n    l = N / 1000 % 10\n    m = N / 10000 % 10\n    n = N / 100000 % 10\n    o = N / 1000000 % 10\n    p = N / 10000000 % 10\n    q = N / 100000000 % 10\n    r = N / 1000000000 % 10\n    s = N / 10000000000 % 10\n    t = N / 100000000000 % 10\n    u = N / 1000000000000 % 10\n    v = N / 10000000000000 % 10\n    w = N / 100000000000000 % 10\n    x = N / 1000000000000000 % 10\n    y = N / 10000000000000000 % 10\n    z = N / 100000000000000000 % 10\n\n    if i > 0 {\n        return N - i\n    } else if j > 0 {\n        return N - j * 10 - i\n    } else if k > 0 {\n        return N - k * 100 - j * 10 - i\n    } else if l > 0 {\n        return N - l * 1000 - k * 100 - j * 10 - i\n    } else if m > 0 {\n        return N - m * 10000 - l * 1000 - k * 100 - j * 10 - i\n    } else if n > 0 {\n        return N - n * 100000 - m * 10000 - l * 1000 - k * 100 - j * 10 - i\n    } else if o > 0 {\n        return N - o * 1000000 - n * 100000 - m * 10000 - l * 1000 - k * 100 - j * 10 - i\n    } else if p > 0 {\n        return N - p * 10000000 - o * 1000000 - n * 100000 - m * 10000 - l * 1000 - k * 100 - j * 10 - i\n    } else if q\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123281,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpwmwj768p_test.go:65:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaa int\n    var bbb int\n    var ccc int\n    var ddd int\n    var eee int\n    var fff int\n    var ggg int\n    var hhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n    var ssss int\n    var tttt int\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpek5vjkf4_test.go:101:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    if N == 1 {\n        return 0\n    }\n    if N == 2 {\n        return 1\n    }\n    if N == 3 {\n        return 2\n    }\n    if N == 4 {\n        return 3\n    }\n    if N == 5 {\n        return 4\n    }\n    if N == 6 {\n        return 5\n    }\n    if N == 7 {\n        return 6\n    }\n    if N == 8 {\n        return 7\n    }\n    if N == 9 {\n        return 8\n    }\n    if N == 10 {\n        return 9\n    }\n    if N == 11 {\n        return 10\n    }\n    if N == 12 {\n        return 11\n    }\n    if N == 13 {\n        return 12\n    }\n    if N == 14 {\n        return 13\n    }\n    if N == 15 {\n        return 14\n    }\n    if N == 16 {\n        return 15\n    }\n    if N == 17 {\n        return 16\n    }\n    if N == 18 {\n        return 17\n    }\n    if N == 19 {\n        return 18\n    }\n    if N == 20 {\n        return 19\n    }\n    if N == 21 {\n        return 20\n    }\n    if N == 22 {\n        return 21\n    }\n    if N == 23 {\n        return 22\n    }\n    if N == 24 {\n        return 23\n    }\n    if N == 25 {\n        return 24\n    }\n    if N == 26 {\n        return 25\n    }\n    if N == 27 {\n        return 26\n    }\n    if N == 28 {\n        return 27\n    }\n    if N == 29 {\n        return 28\n    }\n    if N == 30 {\n        return 29\n    }\n    if N == 31 {\n        return 30\n    }\n    if N == 32 {\n        return 31\n    }\n    if N == 33 {\n        return 32\n    }\n    if N == 34 {\n        return 33\n    }\n    if N == 35 {\n        return 34\n    }\n    if N == 36 {\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123240,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2a2s5lj9_test.go:120:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var n int = N\n    var count int = 0\n    for n > 0 {\n        if n & 1 == 1 {\n            break\n        }\n        count++\n        n = n >> 1\n    }\n    return N ^ (1 << count)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123282,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpxu2c8j39_test.go:37: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // Find the first 1 in the binary representation of N.\n    // If the first 1 is at position i, then the closest smaller number is\n    // N - (1 << i)\n    i := 0\n    for N & (1 << i) == 0 {\n        i++\n    }\n    return N - (1 << i)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123282,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp8975pefe_test.go:35: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // count the number of 1s in N\n    count := 0\n    for N > 0 {\n        if N & 1 == 1 {\n            count++\n        }\n        N = N >> 1\n    }\n    // find the closest number with the same number of 1s\n    return (1 << uint(count)) - 1\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123282,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpymc8icvc_test.go:37: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpymc8icvc_test.go:37: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpymc8icvc_test.go:37: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N-1; i > 0; i-- {\n        if is_prime(i) {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123282,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8p474co1_test.go:12:12: undefined: is_prime\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if i & (i - 1) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp4nnlm1v9_test.go:34: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp4nnlm1v9_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp4nnlm1v9_test.go:34: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return -1\n    }\n    if N == 1 {\n        return 0\n    }\n    var i int = 0\n    var j int = 0\n    var k int = 0\n    var num int = 0\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            j = i\n            break\n        }\n    }\n    for i = j + 1; i < 32; i++ {\n        if (N & (1 << i)) == 0 {\n            k = i\n            break\n        }\n    }\n    num = N & (1 << k)\n    num = num - 1\n    num = num | (1 << k)\n    num = num | (1 << j)\n    num = num & ((1 << k) - 1)\n    return num\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123282,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpi_9dof9x_test.go:55: expected '%!s(int=10)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpi_9dof9x_test.go:55: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpi_9dof9x_test.go:55: expected '%!s(int=11)', got '%!s(int=15)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if i & (i-1) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123244,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    if N == 1 {\n        return 0\n    }\n    var bit int = 1\n    var num int = 0\n    for N > 0 {\n        if N & 1 == 1 {\n            num |= bit\n        }\n        bit <<= 1\n        N >>= 1\n    }\n    return num\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123282,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpbcyeq85u_test.go:43: expected '%!s(int=10)', got '%!s(int=11)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpbcyeq85u_test.go:43: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpbcyeq85u_test.go:43: expected '%!s(int=11)', got '%!s(int=12)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if i & (i - 1) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp4nnlm1v9_test.go:34: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp4nnlm1v9_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp4nnlm1v9_test.go:34: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int = 1\n    var j int = N\n    var mid int = (i + j) / 2\n    var result int = 0\n    for i < j {\n        if mid * mid < N {\n            result = mid\n            i = mid + 1\n        } else {\n            j = mid - 1\n        }\n        mid = (i + j) / 2\n    }\n    return result\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123282,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpne5ycnb8_test.go:41: expected '%!s(int=10)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpne5ycnb8_test.go:41: expected '%!s(int=6)', got '%!s(int=2)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpne5ycnb8_test.go:41: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.010s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n\n    if i == 0 {\n        return 0\n    }\n\n    return N & ^(1 << i)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123254,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp8nk32sfm_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp8nk32sfm_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp8nk32sfm_test.go:43: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // count the number of 1s in N\n    count := 0\n    for N > 0 {\n        if N & 1 == 1 {\n            count++\n        }\n        N = N >> 1\n    }\n    // find the closest number with the same number of 1s\n    return 1 << uint(count)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123282,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp82qxl48u_test.go:37: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp82qxl48u_test.go:37: expected '%!s(int=6)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp82qxl48u_test.go:37: expected '%!s(int=11)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N < 0 {\n        return -1\n    }\n    if N == 0 {\n        return 0\n    }\n    if N == 1 {\n        return 0\n    }\n    if N == 2 {\n        return 1\n    }\n    if N == 3 {\n        return 2\n    }\n\n    var i, j, k int\n    for i = 0; i < 32; i++ {\n        if (N >> i) & 1 == 1 {\n            break\n        }\n    }\n    for j = i + 1; j < 32; j++ {\n        if (N >> j) & 1 == 0 {\n            break\n        }\n    }\n    for k = j + 1; k < 32; k++ {\n        if (N >> k) & 1 == 1 {\n            break\n        }\n    }\n    if k == 32 {\n        return -1\n    }\n    N = N & ((1 << i) - 1)\n    N = N | (1 << j)\n    N = N | ((1 << (k - j - 1)) - 1) << (j + 1)\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123282,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpsylu90ik_test.go:66: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpsylu90ik_test.go:66: expected '%!s(int=6)', got '%!s(int=-1)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpsylu90ik_test.go:66: expected '%!s(int=11)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // Find the first bit that is 1.\n    // For example, N = 10101100, the first bit is at position 7.\n    var pos int\n    for pos = 0; pos < 32; pos++ {\n        if N & (1 << uint(pos)) != 0 {\n            break\n        }\n    }\n    if pos == 32 {\n        return -1\n    }\n    // Find the first bit that is 0.\n    // For example, N = 10101100, the first bit is at position 4.\n    var pos2 int\n    for pos2 = pos + 1; pos2 < 32; pos2++ {\n        if N & (1 << uint(pos2)) == 0 {\n            break\n        }\n    }\n    if pos2 == 32 {\n        return -1\n    }\n    // Set the bit at position pos2 to 1.\n    N |= (1 << uint(pos2))\n    // Set the bits from position pos2 + 1 to position pos to 0.\n    N &= ^((1 << uint(pos2)) - 1)\n    // Set the bits from position pos - 1 to position 0 to 1.\n    N |= ((1 << uint(pos)) - 1)\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123282,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp3v6pc19c_test.go:56: expected '%!s(int=10)', got '%!s(int=12)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp3v6pc19c_test.go:56: expected '%!s(int=6)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp3v6pc19c_test.go:56: expected '%!s(int=11)', got '%!s(int=19)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    return N & ((1 << i) - 1)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpw1706hug_test.go:40: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpw1706hug_test.go:40: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpw1706hug_test.go:40: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int = 0\n    var j int = 0\n    var k int = 0\n    var n int = N\n    for n > 0 {\n        if n & 1 == 1 {\n            i++\n        }\n        n = n >> 1\n    }\n    for j < i {\n        k = k | (1 << j)\n        j++\n    }\n    return N & k\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123282,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpj0as_5gy_test.go:45: expected '%!s(int=10)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpj0as_5gy_test.go:45: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpj0as_5gy_test.go:45: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // Find the first bit from the right that is 1.\n    // This is the bit that will be flipped.\n    var bit int\n    for bit = 0; bit < 32; bit++ {\n        if N & (1 << bit) != 0 {\n            break\n        }\n    }\n\n    // Flip the bit.\n    N ^= 1 << bit\n\n    // Clear all bits to the right of the flipped bit.\n    N &= ^((1 << bit) - 1)\n\n    // Set all bits to the right of the flipped bit.\n    N |= (1 << (bit - 1)) - 1\n\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123283,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\npanic: runtime error: negative shift amount [recovered]\n\tpanic: runtime error: negative shift amount\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523060, 0x616a10)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523060, 0x616a10)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.closest_num(...)\n\t/tmp/tmpiyaw9hy3_test.go:26\ncommand-line-arguments_test.TestClosest_Num(0xc000001380)\n\t/tmp/tmpiyaw9hy3_test.go:38 +0x459\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N < 1 {\n        return -1\n    }\n    var i, j int\n    for i = 0; i < 32; i++ {\n        if N & (1 << i) == 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return -1\n    }\n    for j = i - 1; j >= 0; j-- {\n        if N & (1 << j) == 0 {\n            break\n        }\n    }\n    N = N | (1 << j)\n    N = N & ^((1 << j) - 1)\n    N = N | ((1 << (i - j - 1)) - 1)\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123283,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\npanic: runtime error: negative shift amount [recovered]\n\tpanic: runtime error: negative shift amount\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x522060, 0x615a10)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x522060, 0x615a10)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.closest_num(0xb, 0x5f90c0)\n\t/tmp/tmpl2eghonz_test.go:27 +0xf3\ncommand-line-arguments_test.TestClosest_Num(0xc000186300)\n\t/tmp/tmpl2eghonz_test.go:40 +0x47\ntesting.tRunner(0xc000186300, 0x54e1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // find the first 1 from the right\n    var i uint\n    for i = 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            break\n        }\n    }\n    // if there is no 1, return 0\n    if i == 32 {\n        return 0\n    }\n    // set the first 1 to 0\n    N = N & ^(1 << i)\n    // set the first 0 to 1\n    N = N | (1 << (i-1))\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123283,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpqpszt9_7_test.go:43: expected '%!s(int=11)', got '%!s(int=10)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    return N - (1 << (i - 1))\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123283,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpapnq98x8_test.go:40: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpapnq98x8_test.go:40: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpapnq98x8_test.go:40: expected '%!s(int=11)', got '%!s(int=10)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j int\n    var num int\n    var num_str string\n    var num_str_list []string\n\n    num_str = fmt.Sprintf(\"%d\", N)\n    num_str_list = strings.Split(num_str, \"\")\n\n    for i = 0; i < len(num_str_list); i++ {\n        for j = i + 1; j < len(num_str_list); j++ {\n            if num_str_list[i] > num_str_list[j] {\n                num_str_list[i], num_str_list[j] = num_str_list[j], num_str_list[i]\n                num, _ = strconv.Atoi(strings.Join(num_str_list, \"\"))\n                return num\n            }\n        }\n    }\n\n    return -1\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123283,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp95jzi40l_test.go:16:20: undefined: strings\n/tmp/tmp95jzi40l_test.go:22:26: undefined: strconv\n/tmp/tmp95jzi40l_test.go:22:39: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if i & N == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510431,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp3kw1fbv7_test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp3kw1fbv7_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp3kw1fbv7_test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var n int\n    var m int\n    var l int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n    var ssss int\n    var\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123247,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp66y5vpfw_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i1 int\n    var j1 int\n    var k1 int\n    var l1 int\n    var m1 int\n    var n1 int\n    var o1 int\n    var p1 int\n    var q1 int\n    var r1 int\n    var s1 int\n    var t1 int\n    var u1 int\n    var v1 int\n    var w1 int\n    var x1 int\n    var y1 int\n    var z1 int\n    var a1 int\n    var b1 int\n    var c1 int\n    var d1 int\n    var e1 int\n    var f1 int\n    var g1 int\n    var h1 int\n    var i2 int\n    var j2 int\n    var k2 int\n    var l2 int\n    var m2 int\n    var n2 int\n    var o2 int\n    var p2 int\n    var q2 int\n    var r2 int\n    var s2 int\n    var t2 int\n    var u2 int\n    var v2 int\n    var w2 int\n    var x2 int\n    var y2 int\n    var z2 int\n    var a2 int\n    var b2 int\n    var c2 int\n    var d2 int\n    var e2 int\n    var f2 int\n    var g2 int\n    var h2 int\n    var i3 int\n    var j3 int\n    var k3 int\n    var l3 int\n    var m3 int\n    var n3 int\n    var o3 int\n    var p3 int\n    var q3 int\n    var r3 int\n    var s3 int\n    var t\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510428,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5mrueo1q_test.go:99:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    // count number of 1s\n    cnt := 0\n    for N > 0 {\n        if N & 1 == 1 {\n            cnt += 1\n        }\n        N >>= 1\n    }\n    // count number of 0s\n    cnt2 := 0\n    for N > 0 {\n        if N & 1 == 0 {\n            cnt2 += 1\n        }\n        N >>= 1\n    }\n    // find the closest number\n    return 1 << cnt + 1 << cnt2\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123284,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp1akhkzc5_test.go:48: expected '%!s(int=10)', got '%!s(int=9)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp1akhkzc5_test.go:48: expected '%!s(int=6)', got '%!s(int=9)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp1akhkzc5_test.go:48: expected '%!s(int=11)', got '%!s(int=5)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if (i & N) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp3aikxi66_test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp3aikxi66_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp3aikxi66_test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n\n    i = N & 0x55555555\n    j = N & 0xAAAAAAAA\n    k = i | j\n    l = k & 0x33333333\n    m = k & 0xCCCCCCCC\n    n = l | m\n    o = n & 0x0F0F0F0F\n    p = n & 0xF0F0F0F0\n    q = o | p\n    r = q & 0x00FF00FF\n    s = q & 0xFF00FF00\n    t = r | s\n    u = t & 0x0000FFFF\n    v = t & 0xFFFF0000\n    w = u | v\n    x = w & 0x00000001\n    y = w & 0x00000002\n    z = x | y\n    return z\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123285,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp3cxi8m6b_test.go:68: expected '%!s(int=10)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp3cxi8m6b_test.go:68: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp3cxi8m6b_test.go:68: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int = 1\n    for i < N {\n        if (N & i) == 0 {\n            break\n        }\n        i <<= 1\n    }\n    return N ^ i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123285,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpu4rgu_o1_test.go:35: expected '%!s(int=10)', got '%!s(int=15)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpu4rgu_o1_test.go:35: expected '%!s(int=6)', got '%!s(int=15)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpu4rgu_o1_test.go:35: expected '%!s(int=11)', got '%!s(int=13)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = 0; i < N; i++ {\n        if (N & i) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123280,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpwc0urvgp_test.go:34: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpwc0urvgp_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpwc0urvgp_test.go:34: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if (i & N) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp3aikxi66_test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp3aikxi66_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp3aikxi66_test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n\n    var i uint\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n\n    if i == 0 {\n        return 0\n    }\n\n    return N & ^(1 << i)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510431,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp03w66n_s_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp03w66n_s_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp03w66n_s_test.go:43: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j int\n    var num int\n    var num_list []int\n    var num_list_len int\n    var num_list_mid int\n    var num_list_mid_left int\n    var num_list_mid_right int\n    var num_list_mid_left_value int\n    var num_list_mid_right_value int\n    var num_list_mid_left_value_diff int\n    var num_list_mid_right_value_diff int\n\n    for i = 1; i <= N; i++ {\n        for j = 1; j <= N; j++ {\n            num = i * j\n            if num <= N {\n                num_list = append(num_list, num)\n            }\n        }\n    }\n\n    num_list_len = len(num_list)\n    num_list_mid = num_list_len / 2\n    num_list_mid_left = num_list_mid - 1\n    num_list_mid_right = num_list_mid + 1\n\n    num_list_mid_left_value = num_list[num_list_mid_left]\n    num_list_mid_right_value = num_list[num_list_mid_right]\n\n    num_list_mid_left_value_diff = N - num_list_mid_left_value\n    num_list_mid_right_value_diff = num_list_mid_right_value - N\n\n    if num_list_mid_left_value_diff < num_list_mid_right_value_diff {\n        return num_list_mid_left_value\n    } else {\n        return num_list_mid_right_value\n    }\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123285,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmphpljix57_test.go:64: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N >> i) & 1 == 1 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    return N - (1 << (i - 1))\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123285,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpb_jox_xj_test.go:40: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpb_jox_xj_test.go:40: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpb_jox_xj_test.go:40: expected '%!s(int=11)', got '%!s(int=10)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j, k int\n    var num int\n    var num_arr []int\n    var num_arr_len int\n    var num_arr_max int\n    var num_arr_min int\n    var num_arr_max_index int\n    var num_arr_min_index int\n    var num_arr_max_diff int\n    var num_arr_min_diff int\n    var num_arr_max_diff_index int\n    var num_arr_min_diff_index int\n    var num_arr_max_diff_num int\n    var num_arr_min_diff_num int\n    var num_arr_max_diff_num_index int\n    var num_arr_min_diff_num_index int\n    var num_arr_max_diff_num_diff int\n    var num_arr_min_diff_num_diff int\n\n    num = N\n    for i = 0; i < num; i++ {\n        num_arr = append(num_arr, i)\n    }\n    num_arr_len = len(num_arr)\n    num_arr_max = num_arr[num_arr_len - 1]\n    num_arr_min = num_arr[0]\n    num_arr_max_index = num_arr_len - 1\n    num_arr_min_index = 0\n    num_arr_max_diff = num_arr_max - num\n    num_arr_min_diff = num - num_arr_min\n    num_arr_max_diff_index = num_arr_max_index\n    num_arr_min_diff_index = num_arr_min_index\n    num_arr_max_diff_num = num_arr_max\n    num_arr_min_diff_num = num_arr_min\n    num_arr_max_diff_num_index = num_arr_max_index\n    num_arr_min_diff_num_index = num_arr_min_index\n    num_arr_max_diff_num_diff = num_arr_max_diff\n    num_arr_min_diff_num_diff = num_arr_min_diff\n\n    for j =\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123284,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpi_qowh_b_test.go:50:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) == 0 {\n            break\n        }\n    }\n    return N & ((1 << i) - 1)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpv7bfpa2y_test.go:37: expected '%!s(int=10)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpv7bfpa2y_test.go:37: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpv7bfpa2y_test.go:37: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i uint\n    for ; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    return N & ^(1 << i)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123285,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpiny4s8ee_test.go:37: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // Find the first bit that is 0\n    var i uint\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) == 0 {\n            break\n        }\n    }\n    // If i == 32, then all bits are 1\n    if i == 32 {\n        return -1\n    }\n    // Set the bit to 1\n    N |= (1 << i)\n    // Clear all bits after i\n    N &= ^((1 << i) - 1)\n    // Set the bit after i to 1\n    N |= (1 << (i - 1)) - 1\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123285,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp47nddr05_test.go:45: expected '%!s(int=10)', got '%!s(int=13)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp47nddr05_test.go:45: expected '%!s(int=6)', got '%!s(int=11)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp47nddr05_test.go:45: expected '%!s(int=11)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if (i & (i - 1)) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123285,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpw78xic5g_test.go:34: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpw78xic5g_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpw78xic5g_test.go:34: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var num int\n    for i := 0; i < N; i++ {\n        if i & (i - 1) == 0 {\n            num = i\n        }\n    }\n    return num\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123285,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp3jl1b6u6_test.go:34: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp3jl1b6u6_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp3jl1b6u6_test.go:34: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return -1\n    }\n    if N == 1 {\n        return 0\n    }\n    if N == 2 {\n        return 1\n    }\n    var i int = N - 1\n    for ; i > 0; i-- {\n        if is_prime(i) {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123284,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3mzbq7cz_test.go:21:12: undefined: is_prime\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n\n    for i = 0; i < N; i++ {\n        for j = 0; j < N; j++ {\n            for k = 0; k < N; k++ {\n                for l = 0; l < N; l++ {\n                    for m = 0; m < N; m++ {\n                        for n = 0; n < N; n++ {\n                            for o = 0; o < N; o++ {\n                                for p = 0; p < N; p++ {\n                                    for q = 0; q < N; q++ {\n                                        for r = 0; r < N; r++ {\n                                            for s = 0; s < N; s++ {\n                                                for t = 0; t < N; t++ {\n                                                    for u = 0; u < N; u++ {\n                                                        for v = 0; v < N; v++ {\n                                                            for w = 0; w < N; w++ {\n                                                                for x = 0; x < N; x++ {\n                                                                    for y = 0; y < N; y++ {\n                                                                        for z = 0; z < N; z++ {\n                                                                            if i + j + k + l + m + n + o + p + q + r + s + t + u + v + w + x + y + z == N {\n                                                                                return i + j + k + l + m + n + o + p + q + r + s + t + u + v + w + x + y + z\n                                                                            }\n                                                                        }\n                                                                    }\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123278,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpe2wwtruh_test.go:60:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j int\n    var num int\n    var count int\n    var result int\n    var min int\n    var min_count int\n    for i = 1; i < N; i++ {\n        num = i\n        count = 0\n        for j = 0; j < 32; j++ {\n            if num & 1 == 1 {\n                count++\n            }\n            num = num >> 1\n        }\n        if count == 1 {\n            if min == 0 {\n                min = i\n                min_count = 1\n            } else {\n                if i - result < min {\n                    min = i - result\n                    min_count = 1\n                } else if i - result == min {\n                    min_count++\n                }\n            }\n            result = i\n        }\n    }\n    fmt.Println(min_count)\n    return result\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123285,
      "stdout": "2\n2\n2\n--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp6gxdkcfd_test.go:59: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp6gxdkcfd_test.go:59: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp6gxdkcfd_test.go:59: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n\n    var i uint\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n\n    if i == 0 {\n        return 0\n    }\n\n    return N ^ (1 << i)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123285,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpp6iq6yte_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpp6iq6yte_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpp6iq6yte_test.go:43: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // TODO: implement\n    return 0\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123280,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpornq3npl_test.go:29: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpornq3npl_test.go:29: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpornq3npl_test.go:29: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaa int\n    var bbb int\n    var ccc int\n    var ddd int\n    var eee int\n    var fff int\n    var ggg int\n    var hhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n    var ssss int\n    var tttt int\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpek5vjkf4_test.go:101:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n    var ssss int\n    var\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510428,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpz4ky4r0n_test.go:100:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    if N == 1 {\n        return 0\n    }\n    if N == 2 {\n        return 1\n    }\n    if N == 3 {\n        return 2\n    }\n    if N == 4 {\n        return 3\n    }\n    if N == 5 {\n        return 4\n    }\n    if N == 6 {\n        return 5\n    }\n    if N == 7 {\n        return 6\n    }\n    if N == 8 {\n        return 7\n    }\n    if N == 9 {\n        return 8\n    }\n    if N == 10 {\n        return 9\n    }\n    if N == 11 {\n        return 10\n    }\n    if N == 12 {\n        return 11\n    }\n    if N == 13 {\n        return 12\n    }\n    if N == 14 {\n        return 13\n    }\n    if N == 15 {\n        return 14\n    }\n    if N == 16 {\n        return 15\n    }\n    if N == 17 {\n        return 16\n    }\n    if N == 18 {\n        return 17\n    }\n    if N == 19 {\n        return 18\n    }\n    if N == 20 {\n        return 19\n    }\n    if N == 21 {\n        return 20\n    }\n    if N == 22 {\n        return 21\n    }\n    if N == 23 {\n        return 22\n    }\n    if N == 24 {\n        return 23\n    }\n    if N == 25 {\n        return 24\n    }\n    if N == 26 {\n        return 25\n    }\n    if N == 27 {\n        return 26\n    }\n    if N == 28 {\n        return 27\n    }\n    if N == 29 {\n        return 28\n    }\n    if N == 30 {\n        return 29\n    }\n    if N == 31 {\n        return 30\n    }\n    if N == 32 {\n        return 31\n    }\n    if N == 33 {\n        return 32\n    }\n    if N == 34 {\n        return 33\n    }\n    if N == 35 {\n        return 34\n    }\n    if N == 36 {\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123240,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2a2s5lj9_test.go:120:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // find the first bit that is 1\n    var i uint\n    for i = 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            break\n        }\n    }\n\n    // flip the bit\n    N = N & (^(1 << i))\n\n    // set the bit to the right of the flipped bit\n    N = N | (1 << (i - 1))\n\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123285,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpshtjvgvm_test.go:42: expected '%!s(int=11)', got '%!s(int=10)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaa int\n    var bbb int\n    var ccc int\n    var ddd int\n    var eee int\n    var fff int\n    var ggg int\n    var hhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n    var ssss int\n    var tttt int\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpek5vjkf4_test.go:101:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // Find the first 1 from the right.\n    var i uint\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    // Flip the first 1 from the right.\n    N = N ^ (1 << i)\n    // Set the first 0 from the right to 1.\n    N = N | (1 << (i - 1))\n    // Set all the bits to the right of the first 0 from the right to 0.\n    N = N & ((1 << (i - 1)) - 1)\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123285,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmplil5p2wt_test.go:41: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    return N & ^(1 << (i - 1))\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp77vwm_gf_test.go:40: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp77vwm_gf_test.go:40: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp77vwm_gf_test.go:40: expected '%!s(int=11)', got '%!s(int=12)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return 0\n    }\n\n    var i int\n    for i = 1; i < N; i++ {\n        if (N & i) == 0 {\n            break\n        }\n    }\n\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123285,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp7bh8zeto_test.go:39: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp7bh8zeto_test.go:39: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp7bh8zeto_test.go:39: expected '%!s(int=11)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if i & (i - 1) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp4nnlm1v9_test.go:34: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp4nnlm1v9_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp4nnlm1v9_test.go:34: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N < 0 {\n        return -1\n    }\n    if N == 0 {\n        return 0\n    }\n    if N == 1 {\n        return 0\n    }\n    var i int = 0\n    var j int = 0\n    var k int = 0\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            j = i\n            break\n        }\n    }\n    for i = j + 1; i < 32; i++ {\n        if (N & (1 << i)) == 0 {\n            k = i\n            break\n        }\n    }\n    if k == 0 {\n        return -1\n    }\n    return N & ((1 << k) - 1)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123285,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpe8fbqdc6_test.go:55: expected '%!s(int=10)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpe8fbqdc6_test.go:55: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpe8fbqdc6_test.go:55: expected '%!s(int=11)', got '%!s(int=12)'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if (i & (i + 1)) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpyxbf0m5n_test.go:34: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpyxbf0m5n_test.go:34: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpyxbf0m5n_test.go:34: expected '%!s(int=11)', got '%!s(int=7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // find the first 1 from the right\n    var i uint\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    // clear the first 1 from the right\n    N &= ^(1 << i)\n    // set the next bit to 1\n    N |= (1 << (i - 1))\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123285,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp8fwuxwdi_test.go:39: expected '%!s(int=11)', got '%!s(int=10)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if i & N == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510431,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp3kw1fbv7_test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp3kw1fbv7_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp3kw1fbv7_test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j int\n    var num int\n    var count int\n    var result int\n    var min int\n    for i = 0; i < N; i++ {\n        num = i\n        count = 0\n        for j = 0; j < 32; j++ {\n            if num & 1 == 1 {\n                count++\n            }\n            num >>= 1\n        }\n        if count == 1 {\n            if min == 0 {\n                min = i\n                result = i\n            } else {\n                if i - N < min {\n                    min = i - N\n                    result = i\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123285,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp_gi_1c9__test.go:54: expected '%!s(int=10)', got '%!s(int=2)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp_gi_1c9__test.go:54: expected '%!s(int=6)', got '%!s(int=2)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp_gi_1c9__test.go:54: expected '%!s(int=11)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N < 0 {\n        return -1\n    }\n\n    if N == 0 {\n        return 0\n    }\n\n    num := N\n    for i := 0; i < 32; i++ {\n        if (num & (1 << i)) != 0 {\n            num &= ^(1 << i)\n            break\n        }\n    }\n    return num\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123285,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp7wtfoau0_test.go:43: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var count int\n    var num int\n    for i := 1; i <= N; i++ {\n        if N % i == 0 {\n            count++\n            num = i\n        }\n    }\n    return num\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123286,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp6em9h25w_test.go:36: expected '%!s(int=10)', got '%!s(int=11)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp6em9h25w_test.go:36: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp6em9h25w_test.go:36: expected '%!s(int=11)', got '%!s(int=12)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if is_prime(i) {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123285,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpewvvnmya_test.go:12:12: undefined: is_prime\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N >> i) & 1 == 1 {\n            break\n        }\n    }\n    return N & ((1 << i) - 1)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123252,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpp962q531_test.go:37: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpp962q531_test.go:37: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpp962q531_test.go:37: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if (i & (i + 1)) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpyxbf0m5n_test.go:34: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpyxbf0m5n_test.go:34: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpyxbf0m5n_test.go:34: expected '%!s(int=11)', got '%!s(int=7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // Count the number of 1s in N.\n    count := 0\n    for N > 0 {\n        if N & 1 == 1 {\n            count++\n        }\n        N >>= 1\n    }\n    // Find the closest number with the same number of 1s.\n    num := 0\n    for i := 0; i < count; i++ {\n        num = (num << 1) | 1\n    }\n    return num\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123286,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp3_ob87qr_test.go:41: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp3_ob87qr_test.go:41: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp3_ob87qr_test.go:41: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if i & (i - 1) == 0 {\n            return i\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123280,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmplqp0m9r4_test.go:34: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmplqp0m9r4_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmplqp0m9r4_test.go:34: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // find the first bit from right that is 1\n    var i uint = 0\n    for ; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    // clear the bit\n    N &= ^(1 << i)\n    // set the bit to the right\n    N |= (1 << (i - 1))\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123286,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpssakrlvo_test.go:39: expected '%!s(int=11)', got '%!s(int=10)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if i & (i-1) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123244,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N < 1 {\n        return 0\n    }\n    var i int\n    for i = N; i > 0; i-- {\n        if i & (i-1) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123287,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp6zgz_ddr_test.go:37: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp6zgz_ddr_test.go:37: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp6zgz_ddr_test.go:37: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N-1; i > 0; i-- {\n        if i & N == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510431,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp9_gmvimq_test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp9_gmvimq_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp9_gmvimq_test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n\n    i = N & 0x55555555\n    j = N & 0xaaaaaaaa\n    k = i | (j >> 1)\n    l = N & 0x33333333\n    m = N & 0xcccccccc\n    n = l | (m >> 2)\n    o = k & n\n    p = N & 0x0f0f0f0f\n    q = N & 0xf0f0f0f0\n    r = p | (q >> 4)\n    s = o & r\n    t = N & 0x00ff00ff\n    u = N & 0xff00ff00\n    v = t | (u >> 8)\n    w = s & v\n    x = N & 0x0000ffff\n    y = N & 0xffff0000\n    z = x | (y >> 16)\n\n    return w & z\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123282,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpal8fhpam_test.go:66: expected '%!s(int=10)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpal8fhpam_test.go:66: expected '%!s(int=6)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpal8fhpam_test.go:66: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int = 0\n    var j int = 0\n    var k int = 0\n    var l int = 0\n    var m int = 0\n    var n int = 0\n    var o int = 0\n    var p int = 0\n    var q int = 0\n    var r int = 0\n    var s int = 0\n    var t int = 0\n    var u int = 0\n    var v int = 0\n    var w int = 0\n    var x int = 0\n    var y int = 0\n    var z int = 0\n    var a int = 0\n    var b int = 0\n    var c int = 0\n    var d int = 0\n    var e int = 0\n    var f int = 0\n    var g int = 0\n    var h int = 0\n    var i1 int = 0\n    var j1 int = 0\n    var k1 int = 0\n    var l1 int = 0\n    var m1 int = 0\n    var n1 int = 0\n    var o1 int = 0\n    var p1 int = 0\n    var q1 int = 0\n    var r1 int = 0\n    var s1 int = 0\n    var t1 int = 0\n    var u1 int = 0\n    var v1 int = 0\n    var w1 int = 0\n    var x1 int = 0\n    var y1 int = 0\n    var z1 int = 0\n    var a1 int = 0\n    var b1 int = 0\n    var c1 int = 0\n    var d1 int = 0\n    var e1 int = 0\n    var f1 int = 0\n    var g1 int = 0\n    var h1 int = 0\n    var i2 int = 0\n    var j2 int = 0\n    var k2 int = 0\n    var l2 int = 0\n    var m2 int = 0\n    var n2 int = 0\n    var o2 int = 0\n    var p2 int = 0\n    var q2 int = 0\n    var r2 int = 0\n    var s2 int = 0\n    var t2 int = 0\n    var u2 int = 0\n    var v2 int = 0\n    var w2 int = 0\n   \nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123245,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprot9via1_test.go:78:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N < 0 {\n        return -1\n    }\n    if N == 0 {\n        return 0\n    }\n    var i int\n    var j int\n    for i = 0; i < 32; i++ {\n        if (N >> i) & 1 == 1 {\n            break\n        }\n    }\n    for j = i + 1; j < 32; j++ {\n        if (N >> j) & 1 == 0 {\n            break\n        }\n    }\n    N = N & ((1 << i) - 1)\n    N = N | (1 << j)\n    N = N | ((1 << (j - 1)) - 1)\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123287,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpav2egamj_test.go:49: expected '%!s(int=10)', got '%!s(int=5)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpav2egamj_test.go:49: expected '%!s(int=6)', got '%!s(int=11)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpav2egamj_test.go:49: expected '%!s(int=11)', got '%!s(int=23)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // find the first '1' from the right\n    var i uint\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    // set the bit to 0\n    N &= ^(1 << i)\n    // set the bit to 1\n    N |= (1 << (i - 1))\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123287,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpq65bm8qv_test.go:39: expected '%!s(int=11)', got '%!s(int=10)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << uint(i))) != 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    return N ^ (1 << uint(i))\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123287,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp_56wxbtf_test.go:40: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp_56wxbtf_test.go:40: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp_56wxbtf_test.go:40: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if i & (i-1) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123244,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j int\n    var n int\n    var num int\n    var num_arr []int\n    var num_arr_len int\n    var num_arr_len_half int\n    var num_arr_len_half_floor int\n    var num_arr_len_half_ceil int\n    var num_arr_len_half_floor_val int\n    var num_arr_len_half_ceil_val int\n    var num_arr_len_half_floor_diff int\n    var num_arr_len_half_ceil_diff int\n    var num_arr_len_half_floor_diff_abs int\n    var num_arr_len_half_ceil_diff_abs int\n    var num_arr_len_half_floor_diff_abs_min int\n    var num_arr_len_half_ceil_diff_abs_min int\n    var num_arr_len_half_floor_diff_abs_min_index int\n    var num_arr_len_half_ceil_diff_abs_min_index int\n    var num_arr_len_half_floor_diff_abs_min_val int\n    var num_arr_len_half_ceil_diff_abs_min_val int\n    var num_arr_len_half_floor_diff_abs_min_val_index int\n    var num_arr_len_half_ceil_diff_abs_min_val_index int\n    var num_arr_len_half_floor_diff_abs_min_val_index_val int\n    var num_arr_len_half_ceil_diff_abs_min_val_index_val int\n    var num_arr_len_half_floor_diff_abs_min_val_index_val_diff int\n    var num_arr_len_half_ceil_diff_abs_min_val_index_val_diff int\n    var num_arr_len_half_floor_diff_abs_min_val_index_val_diff_abs int\n    var num_arr_len_half_ceil_diff_abs_min_val_index_val_diff_abs int\n    var num_arr\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123286,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5_wski8a_test.go:38:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n\n    if N == 0 {\n        return 0\n    }\n\n    if N == 1 {\n        return 0\n    }\n\n    if N == 2 {\n        return 1\n    }\n\n    if N == 3 {\n        return 2\n    }\n\n    if N == 4 {\n        return 3\n    }\n\n    if N == 5 {\n        return 4\n    }\n\n    if N == 6 {\n        return 5\n    }\n\n    if N == 7 {\n        return 6\n    }\n\n    if N == 8 {\n        return 7\n    }\n\n    if N == 9 {\n        return 8\n    }\n\n    if N == 10 {\n        return 9\n    }\n\n    if N == 11 {\n        return 10\n    }\n\n    if N == 12 {\n        return 11\n    }\n\n    if N == 13 {\n        return 12\n    }\n\n    if N == 14 {\n        return 13\n    }\n\n    if N == 15 {\n        return 14\n    }\n\n    if N == 16 {\n        return 15\n    }\n\n    if N == 17 {\n        return 16\n    }\n\n    if N == 18 {\n        return 17\n    }\n\n    if N == 19 {\n        return 18\n    }\n\n    if N == 20 {\n        return 19\n    }\n\n    if N == 21 {\n        return 20\n    }\n\n    if N == 22 {\n        return 21\n    }\n\n    if N == 23 {\n        return 22\n    }\n\n    if N == 24 {\n        return 23\n    }\n\n    if N == 25 {\n        return 24\n    }\n\n    if N == 26 {\n        return 25\n    }\n\n    if N == 27 {\n        return 26\n    }\n\n    if N == 28 {\n        return 27\n    }\n\n    if N == 29 {\n        return 28\n    }\n\n   \nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123286,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp8zsb_g10_test.go:150:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return 0\n    }\n    if N == 1 {\n        return 0\n    }\n    var i int\n    for i = N; i > 0; i-- {\n        if (i & (i - 1)) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123287,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp6eugi9pw_test.go:40: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp6eugi9pw_test.go:40: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp6eugi9pw_test.go:40: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var (\n        n = N\n        i = 0\n        j = 0\n        k = 0\n    )\n    for n > 0 {\n        if n & 1 == 1 {\n            i++\n        }\n        n >>= 1\n    }\n    for j = i; j > 0; j-- {\n        if N & (1 << j) > 0 {\n            break\n        }\n    }\n    for k = j; k > 0; k-- {\n        if N & (1 << k) == 0 {\n            break\n        }\n    }\n    N &= ^(1 << j)\n    N |= (1 << k)\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123287,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp7ziltsfa_test.go:52: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp7ziltsfa_test.go:52: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp7ziltsfa_test.go:52: expected '%!s(int=11)', got '%!s(int=10)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var count int = 0\n    var num int = N\n    for num > 0 {\n        if num & 1 == 1 {\n            break\n        }\n        num = num >> 1\n        count++\n    }\n    return N - (1 << count)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123287,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmphyv380mx_test.go:37: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return -1\n    }\n    if N == 1 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) > 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    return N & ^(1 << i)\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123287,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpc8uvdsxe_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpc8uvdsxe_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpc8uvdsxe_test.go:43: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if i & N == 0 {\n            return i\n        }\n    }\n    return 0\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123244,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp0qprw2b9_test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp0qprw2b9_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp0qprw2b9_test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    return (N & ((1 << i) - 1)) | (1 << (i - 1))\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123287,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpntrpdx4s_test.go:40: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpntrpdx4s_test.go:40: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpntrpdx4s_test.go:40: expected '%!s(int=11)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return 0\n    }\n    var count int = 0\n    for N > 0 {\n        if (N & 1) == 0 {\n            count++\n        }\n        N = N >> 1\n    }\n    return (1 << uint(count))\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123287,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp8szonu0o_test.go:38: expected '%!s(int=10)', got '%!s(int=2)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp8szonu0o_test.go:38: expected '%!s(int=6)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp8szonu0o_test.go:38: expected '%!s(int=11)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // find the first 1 from right to left\n    var i uint\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    // clear the first 1 from right to left\n    N &= ^(1 << i)\n    // set the first 0 from right to left\n    N |= 1 << (i - 1)\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123287,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmperie075s_test.go:39: expected '%!s(int=11)', got '%!s(int=10)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N < 0 {\n        return -1\n    }\n    if N == 0 {\n        return 0\n    }\n    if N == 1 {\n        return 0\n    }\n\n    var num int\n    var count int\n    for i := 0; i < 32; i++ {\n        if (N & (1 << uint(i))) != 0 {\n            count++\n            num = i\n        }\n    }\n    if count == 1 {\n        return N ^ (1 << uint(num))\n    }\n    return N ^ (1 << uint(num)) ^ (1 << uint(num - 1))\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123287,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpbd518orn_test.go:49: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpbd518orn_test.go:49: expected '%!s(int=6)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpbd518orn_test.go:49: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return 0\n    }\n    var result int\n    var bit_count int\n    for i := N; i > 0; i >>= 1 {\n        bit_count++\n    }\n    result = 1 << uint(bit_count - 1)\n    for i := bit_count - 2; i >= 0; i-- {\n        result |= (N & (1 << uint(i))) >> uint(i)\n        if result >= N {\n            result ^= 1 << uint(i)\n        }\n    }\n    return result\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123287,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmprxu72owg_test.go:43: expected '%!s(int=10)', got '%!s(int=9)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmprxu72owg_test.go:43: expected '%!s(int=6)', got '%!s(int=5)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmprxu72owg_test.go:43: expected '%!s(int=11)', got '%!s(int=9)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaa int\n    var bbb int\n    var ccc int\n    var ddd int\n    var eee int\n    var fff int\n    var ggg int\n    var hhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n    var ssss int\n    var tttt int\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpek5vjkf4_test.go:101:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return 0\n    }\n    var i, j, k int\n    var nums []int\n    for i = 0; i < N; i++ {\n        nums = append(nums, i)\n    }\n    for j = 0; j < N; j++ {\n        for k = 0; k < N; k++ {\n            if nums[j] + nums[k] == N {\n                return nums[j]\n            }\n        }\n    }\n    return 0\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123287,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpc6xhkn2e_test.go:43: expected '%!s(int=10)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpc6xhkn2e_test.go:43: expected '%!s(int=6)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpc6xhkn2e_test.go:43: expected '%!s(int=11)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // count the number of 1s in N\n    count := 0\n    for N > 0 {\n        if N & 1 == 1 {\n            count++\n        }\n        N >>= 1\n    }\n    // find the closest number with the same number of 1s\n    for N < (1 << count) {\n        N++\n    }\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123287,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpd_9jje53_test.go:40: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpd_9jje53_test.go:40: expected '%!s(int=6)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpd_9jje53_test.go:40: expected '%!s(int=11)', got '%!s(int=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    if N == 1 {\n        return 0\n    }\n    if N == 2 {\n        return 1\n    }\n    if N == 3 {\n        return 2\n    }\n    if N == 4 {\n        return 3\n    }\n    if N == 5 {\n        return 4\n    }\n    if N == 6 {\n        return 5\n    }\n    if N == 7 {\n        return 6\n    }\n    if N == 8 {\n        return 7\n    }\n    if N == 9 {\n        return 8\n    }\n    if N == 10 {\n        return 9\n    }\n    if N == 11 {\n        return 10\n    }\n    if N == 12 {\n        return 11\n    }\n    if N == 13 {\n        return 12\n    }\n    if N == 14 {\n        return 13\n    }\n    if N == 15 {\n        return 14\n    }\n    if N == 16 {\n        return 15\n    }\n    if N == 17 {\n        return 16\n    }\n    if N == 18 {\n        return 17\n    }\n    if N == 19 {\n        return 18\n    }\n    if N == 20 {\n        return 19\n    }\n    if N == 21 {\n        return 20\n    }\n    if N == 22 {\n        return 21\n    }\n    if N == 23 {\n        return 22\n    }\n    if N == 24 {\n        return 23\n    }\n    if N == 25 {\n        return 24\n    }\n    if N == 26 {\n        return 25\n    }\n    if N == 27 {\n        return 26\n    }\n    if N == 28 {\n        return 27\n    }\n    if N == 29 {\n        return 28\n    }\n    if N == 30 {\n        return 29\n    }\n    if N == 31 {\n        return 30\n    }\n    if N == 32 {\n        return 31\n    }\n    if N == 33 {\n        return 32\n    }\n    if N == 34 {\n        return 33\n    }\n    if N == 35 {\n        return 34\n    }\n    if N == 36 {\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123240,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2a2s5lj9_test.go:120:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var num int\n    for i := N; i > 0; i-- {\n        if i % 10 != 0 {\n            num = i\n            break\n        }\n    }\n    return num\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123288,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmprs26_xgy_test.go:35: expected '%!s(int=10)', got '%!s(int=11)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmprs26_xgy_test.go:35: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmprs26_xgy_test.go:35: expected '%!s(int=11)', got '%!s(int=12)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N < 0 {\n        return -1\n    }\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    return N & ^(1 << (i - 1))\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123288,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp7t4zxm72_test.go:43: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp7t4zxm72_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp7t4zxm72_test.go:43: expected '%!s(int=11)', got '%!s(int=12)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // 1. find the first 1 from right to left\n    // 2. find the first 0 from right to left\n    // 3. swap 1 and 0\n    // 4. move all 1s to the right\n    // 5. move all 0s to the left\n    // 6. return the number\n    var i, j int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    for j = i + 1; j < 32; j++ {\n        if (N & (1 << j)) == 0 {\n            break\n        }\n    }\n    N = N ^ (1 << i)\n    N = N ^ (1 << j)\n    for i = i - 1; i >= 0; i-- {\n        N = N | (1 << i)\n    }\n    for j = j + 1; j < 32; j++ {\n        N = N & ^(1 << j)\n    }\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123288,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpje642ae4_test.go:53: expected '%!s(int=10)', got '%!s(int=6)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpje642ae4_test.go:53: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpje642ae4_test.go:53: expected '%!s(int=11)', got '%!s(int=27)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aaa int\n    var bbb int\n    var ccc int\n    var ddd int\n    var eee int\n    var fff int\n    var ggg int\n    var hhh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n    var rrrr int\n   \nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510428,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprtu0muol_test.go:99:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if (i & (i + 1)) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpyxbf0m5n_test.go:34: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpyxbf0m5n_test.go:34: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpyxbf0m5n_test.go:34: expected '%!s(int=11)', got '%!s(int=7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if i & (i + 1) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123242,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp341e8373_test.go:34: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp341e8373_test.go:34: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp341e8373_test.go:34: expected '%!s(int=11)', got '%!s(int=7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if (i & (i + 1)) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510429,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpyxbf0m5n_test.go:34: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpyxbf0m5n_test.go:34: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpyxbf0m5n_test.go:34: expected '%!s(int=11)', got '%!s(int=7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if (i & (i - 1)) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123245,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp03gw52pp_test.go:34: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp03gw52pp_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp03gw52pp_test.go:34: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return 0\n    }\n    var i, j int\n    var tmp int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            tmp = N & ((1 << i) - 1)\n            break\n        }\n    }\n    for j = i - 1; j >= 0; j-- {\n        if (N & (1 << j)) == 0 {\n            tmp |= (1 << j)\n            break\n        }\n    }\n    return tmp\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123288,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp3pe3gj0__test.go:45: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp3pe3gj0__test.go:45: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp3pe3gj0__test.go:45: expected '%!s(int=11)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if i & (i-1) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123244,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpvecis2kg_test.go:34: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // Find the first 1 from the right.\n    var i uint\n    for i = 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            break\n        }\n    }\n    // Flip the first 0 from the right.\n    N = N & ^(1 << i)\n    // Flip the first 1 from the right.\n    N = N | (1 << (i - 1))\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123288,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpjvwvhpcw_test.go:39: expected '%!s(int=11)', got '%!s(int=10)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n\n    i = N & (N - 1)\n    j = N & (N + 1)\n    k = N | (N - 1)\n    l = N | (N + 1)\n    m = N ^ (N - 1)\n    n = N ^ (N + 1)\n    o = N ^ (N - 1) & (N - 1)\n    p = N ^ (N + 1) & (N + 1)\n    q = N ^ (N - 1) & (N + 1)\n    r = N ^ (N + 1) & (N - 1)\n    s = N ^ (N - 1) & (N - 1) & (N - 1)\n    t = N ^ (N + 1) & (N + 1) & (N + 1)\n    u = N ^ (N - 1) & (N + 1) & (N - 1)\n    v = N ^ (N + 1) & (N - 1) & (N + 1)\n    w = N ^ (N - 1) & (N - 1) & (N - 1) & (N - 1)\n    x = N ^ (N + 1) & (N + 1) & (N + 1) & (N + 1)\n    y = N ^ (N - 1) & (N + 1) & (N - 1) & (N - 1)\n    z = N ^ (N + 1) & (N - 1) & (N + 1) & (N + 1)\n\n    fmt.Printf(\"%d\\n\", i)\n    fmt.Printf(\"%d\\n\", j)\n    fmt.Printf(\"%d\\n\", k)\n    fmt.Printf(\"%d\\n\", l)\n    fmt.Printf(\"%d\\n\", m)\n    fmt.Printf(\"%d\\\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123287,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmgpwo7uo_test.go:53:16: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N < 0 {\n        return -1\n    }\n    if N == 0 {\n        return 0\n    }\n    if N == 1 {\n        return 0\n    }\n    if N == 2 {\n        return 1\n    }\n    if N == 3 {\n        return 2\n    }\n    if N == 4 {\n        return 3\n    }\n    if N == 5 {\n        return 4\n    }\n    if N == 6 {\n        return 5\n    }\n    if N == 7 {\n        return 6\n    }\n    if N == 8 {\n        return 7\n    }\n    if N == 9 {\n        return 8\n    }\n    if N == 10 {\n        return 9\n    }\n    if N == 11 {\n        return 10\n    }\n    if N == 12 {\n        return 11\n    }\n    if N == 13 {\n        return 12\n    }\n    if N == 14 {\n        return 13\n    }\n    if N == 15 {\n        return 14\n    }\n    if N == 16 {\n        return 15\n    }\n    if N == 17 {\n        return 16\n    }\n    if N == 18 {\n        return 17\n    }\n    if N == 19 {\n        return 18\n    }\n    if N == 20 {\n        return 19\n    }\n    if N == 21 {\n        return 20\n    }\n    if N == 22 {\n        return 21\n    }\n    if N == 23 {\n        return 22\n    }\n    if N == 24 {\n        return 23\n    }\n    if N == 25 {\n        return 24\n    }\n    if N == 26 {\n        return 25\n    }\n    if N == 27 {\n        return 26\n    }\n    if N == 28 {\n        return 27\n    }\n    if N == 29 {\n        return 28\n    }\n    if N == 30 {\n        return 29\n    }\n    if N == 31 {\n        return 30\n    }\n    if N == 32 {\n        return 31\n    }\n    if N == 33 {\n        return 32\n    }\n    if N == 34 {\n        return 33\n    }\n    if N == 35 {\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123240,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmphp5zypny_test.go:119:6: expected '(', found TestClosest_Num\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return -1\n    }\n    if N == 1 {\n        return 0\n    }\n\n    // Find the first 1 from the right.\n    var i uint\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n\n    // Flip the first 1 from the right.\n    N = N & ^(1 << i)\n\n    // Add 1 to the right of the first 1 from the right.\n    N = N | (1 << (i - 1))\n\n    // Add 1 to the right of the first 1 from the right.\n    N = N | (1 << (i - 2))\n\n    // Clear the right bits.\n    N = N & ^((1 << (i - 2)) - 1)\n\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123289,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpwqdfvn_b_test.go:55: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpwqdfvn_b_test.go:55: expected '%!s(int=6)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // count the number of 1s in N\n    num_of_1s := 0\n    for N > 0 {\n        N = N & (N - 1)\n        num_of_1s++\n    }\n\n    // find the closest number with the same number of 1s\n    N = N + 1\n    for N > 0 {\n        if N & 1 == 1 {\n            num_of_1s--\n        }\n        if num_of_1s == 0 {\n            break\n        }\n        N = N >> 1\n    }\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123288,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpo6v5h0mw_test.go:46: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpo6v5h0mw_test.go:46: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpo6v5h0mw_test.go:46: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N; i > 0; i-- {\n        if i & (i - 1) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp4nnlm1v9_test.go:34: expected '%!s(int=10)', got '%!s(int=8)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp4nnlm1v9_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp4nnlm1v9_test.go:34: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    for j = i + 1; j < 32; j++ {\n        if (N & (1 << j)) == 0 {\n            break\n        }\n    }\n    if j == 32 {\n        return -1\n    }\n    N = N & ((1 << j) - 1)\n    N = N | (1 << j)\n    N = N | ((1 << (j - i - 1)) - 1)\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123289,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpecemobkj_test.go:45: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpecemobkj_test.go:45: expected '%!s(int=6)', got '%!s(int=15)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpecemobkj_test.go:45: expected '%!s(int=11)', got '%!s(int=29)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N <= 0 {\n        return 0\n    }\n    var num int\n    for i := 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            num = i\n            break\n        }\n    }\n    return N & (^(1 << num))\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123289,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpoz7h979c_test.go:38: expected '%!s(int=11)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if i & N == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510431,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp3kw1fbv7_test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp3kw1fbv7_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp3kw1fbv7_test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // find the first 1 from the right\n    var i uint\n    for i = 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            break\n        }\n    }\n    // find the first 0 from the right\n    for ; i < 32; i++ {\n        if N & (1 << i) == 0 {\n            break\n        }\n    }\n    // set the bit to 1\n    N |= (1 << i)\n    // set the bit to 0\n    N &= ^(1 << i)\n    // set the bit to 1\n    N |= (1 << (i - 1))\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123289,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpn944d6io_test.go:47: expected '%!s(int=10)', got '%!s(int=11)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpn944d6io_test.go:47: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpn944d6io_test.go:47: expected '%!s(int=11)', got '%!s(int=12)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    if N == 1 {\n        return 0\n    }\n    var i int\n    for i = N-1; i > 0; i-- {\n        if (N & i) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123289,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpcgcs4pzv_test.go:40: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpcgcs4pzv_test.go:40: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpcgcs4pzv_test.go:40: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j int\n    var num int\n    var count int\n    var res int\n    for i = 0; i < N; i++ {\n        num = i\n        count = 0\n        for j = 0; j < 32; j++ {\n            if num & 1 == 1 {\n                count++\n            }\n            num = num >> 1\n        }\n        if count == 1 {\n            res = i\n            break\n        }\n    }\n    return res\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123289,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpzbyclocp_test.go:46: expected '%!s(int=10)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpzbyclocp_test.go:46: expected '%!s(int=6)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpzbyclocp_test.go:46: expected '%!s(int=11)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // get the binary representation of N\n    // and count the number of 1s\n    var count int = 0\n    for N > 0 {\n        N = N & (N - 1)\n        count++\n    }\n    return count\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123289,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpbiff6_b__test.go:35: expected '%!s(int=10)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpbiff6_b__test.go:35: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpbiff6_b__test.go:35: expected '%!s(int=11)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var num int\n    for i := 0; i < N; i++ {\n        if i < N {\n            num = i\n        }\n    }\n    return num\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123289,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j int\n    var num int\n    var num_arr []int\n    var num_arr_len int\n\n    for i = 0; i < N; i++ {\n        num = i\n        num_arr = []int{}\n        for j = 0; j < 32; j++ {\n            if num & 1 == 1 {\n                num_arr = append(num_arr, 1)\n            } else {\n                num_arr = append(num_arr, 0)\n            }\n            num = num >> 1\n        }\n        num_arr_len = len(num_arr)\n        for j = 0; j < num_arr_len; j++ {\n            if num_arr[j] == 1 {\n                if j > 0 && num_arr[j-1] == 0 {\n                    num_arr[j] = 0\n                    num_arr[j-1] = 1\n                    break\n                }\n            }\n        }\n        num = 0\n        for j = num_arr_len - 1; j >= 0; j-- {\n            num = num << 1\n            num = num | num_arr[j]\n        }\n        fmt.Println(num)\n    }\n    return 0\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123289,
      "stdout": "0\n1\n1\n3\n2\n3\n5\n7\n4\n5\n9\n0\n1\n1\n3\n2\n3\n5\n0\n1\n1\n3\n2\n3\n5\n7\n4\n5\n9\n7\n--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmple0srwo5_test.go:61: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmple0srwo5_test.go:61: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmple0srwo5_test.go:61: expected '%!s(int=11)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    // find the first 1 from right to left\n    // find the first 0 from right to left\n    // swap the two bits\n    // move all the 1s to the right of the 0 to the right\n    // move all the 0s to the left of the 1 to the left\n    var i, j int\n    for i = 0; i < 32; i++ {\n        if (N & (1 << i)) != 0 {\n            break\n        }\n    }\n    for j = i + 1; j < 32; j++ {\n        if (N & (1 << j)) == 0 {\n            break\n        }\n    }\n    if j == 32 {\n        return -1\n    }\n    N = N & ^(1 << i)\n    N = N | (1 << j)\n    for i = i - 1; i >= 0; i-- {\n        if (N & (1 << i)) != 0 {\n            N = N & ^(1 << i)\n            N = N | (1 << (j - 1))\n            j--\n        }\n    }\n    for j = j + 1; j < 32; j++ {\n        if (N & (1 << j)) == 0 {\n            N = N | (1 << j)\n            break\n        }\n    }\n    return N\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123289,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpe9gqvfe__test.go:62: expected '%!s(int=10)', got '%!s(int=30)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpe9gqvfe__test.go:62: expected '%!s(int=6)', got '%!s(int=30)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpe9gqvfe__test.go:62: expected '%!s(int=11)', got '%!s(int=56)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N < 2 {\n        return 0\n    }\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if (i & (i + 1)) == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123289,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp5twpl4an_test.go:37: expected '%!s(int=10)', got '%!s(int=7)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp5twpl4an_test.go:37: expected '%!s(int=6)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp5twpl4an_test.go:37: expected '%!s(int=11)', got '%!s(int=7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int = 1\n    var j int = N\n    var m int = 0\n    var n int = 0\n    var k int = 0\n    for i < j {\n        m = (i + j) / 2\n        n = N / m\n        if n == m {\n            return m\n        } else if n < m {\n            j = m\n        } else {\n            i = m + 1\n        }\n    }\n    k = N / i\n    if k == i {\n        return i\n    } else {\n        return i - 1\n    }\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123289,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpllzbkxzf_test.go:49: expected '%!s(int=10)', got '%!s(int=3)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpllzbkxzf_test.go:49: expected '%!s(int=6)', got '%!s(int=2)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpllzbkxzf_test.go:49: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var (\n        i int\n        j int\n        k int\n    )\n    for i = 0; i < N; i++ {\n        for j = 0; j < N; j++ {\n            k = i + j\n            if k == N {\n                return i\n            }\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123289,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpb27ain8k_test.go:41: expected '%!s(int=10)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpb27ain8k_test.go:41: expected '%!s(int=6)', got '%!s(int=1)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpb27ain8k_test.go:41: expected '%!s(int=11)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j int\n    for i = 1; i < N; i++ {\n        if N & i == 0 {\n            j = i\n        }\n    }\n    return j\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123289,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp9zofni3o_test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp9zofni3o_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp9zofni3o_test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    if N == 0 {\n        return 0\n    }\n    var i int\n    for i = 0; i < 32; i++ {\n        if N & (1 << i) != 0 {\n            break\n        }\n    }\n    if i == 0 {\n        return 0\n    }\n    return N & ^(1 << (i - 1))\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123241,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp77vwm_gf_test.go:40: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp77vwm_gf_test.go:40: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp77vwm_gf_test.go:40: expected '%!s(int=11)', got '%!s(int=12)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i int\n    for i = N - 1; i > 0; i-- {\n        if i & N == 0 {\n            break\n        }\n    }\n    return i\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510431,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmp3kw1fbv7_test.go:34: expected '%!s(int=10)', got '%!s(int=4)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmp3kw1fbv7_test.go:34: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmp3kw1fbv7_test.go:34: expected '%!s(int=11)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var i, j int\n    var num int\n    for i = 0; i < N; i++ {\n        for j = 0; j < N; j++ {\n            if i * j == N {\n                num = i\n                break\n            }\n        }\n    }\n    return num\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123289,
      "stdout": "--- FAIL: TestClosest_Num (0.00s)\n    --- FAIL: TestClosest_Num/test_num__0 (0.00s)\n        tmpn2fi9793_test.go:38: expected '%!s(int=10)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__1 (0.00s)\n        tmpn2fi9793_test.go:38: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestClosest_Num/test_num__2 (0.00s)\n        tmpn2fi9793_test.go:38: expected '%!s(int=11)', got '%!s(int=6)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package closest_num_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the closest smaller number than n.\nfunc closest_num(N int) int {\n    var count int\n    var num int\n    for i := 1; i < N; i++ {\n        if N % i == 0 {\n            count = i\n            num = i\n        }\n    }\n    return num\n}\n\nfunc TestClosest_Num(t *testing.T) {\n  candidate := closest_num\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(11), expected: 10 },\n     { actual: candidate(7), expected: 6 },\n     { actual: candidate(12), expected: 11 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123289,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpo1tsay9r_test.go:10:9: count declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    }
  ]
}