{
  "name": "mbpp_262_split_two_parts",
  "language": "go_test.go",
  "prompt": "package split_two_parts_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list and an integer L and splits the given list into two parts where the length of the first part of the list is L, and returns the resulting lists in a tuple.\nfunc split_two_parts(list1 interface{}, L int) interface{} {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_262_split_two_parts.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestSplit_Two_Parts(t *testing.T) {\n  candidate := split_two_parts\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 1, 2, 3, 4, 4, 5, 1}, 3), expected: []interface{}{[]int{1, 1, 2}, []int{3, 4, 4, 5, 1}} },\n     { actual: candidate([]string{\"a\", \"b\", \"c\", \"d\"}, 2), expected: []interface{}{[]string{\"a\", \"b\"}, []string{\"c\", \"d\"}} },\n     { actual: candidate([]string{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}, 4), expected: []interface{}{[]string{\"p\", \"y\", \"t\", \"h\"}, []string{\"o\", \"n\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    list := list1.([]int)\n    list2 := list[L:]\n    list = list[:L]\n    return []interface{}{list, list2}\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if L > len(list) {\n            return nil\n        }\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        if L > len(list) {\n            return nil\n        }\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return append(list[:L], list[L:]...)\n    case []string:\n        list := list1.([]string)\n        return append(list[:L], list[L:]...)\n    default:\n        return nil\n    }\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    default:\n        return nil\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    // TODO: Implement\n    return nil\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n        case []int:\n            list := list1.([]int)\n            list2 := list[L:]\n            list = list[:L]\n            return list, list2\n        case []string:\n            list := list1.([]string)\n            list2 := list[L:]\n            list = list[:L]\n            return list, list2\n        default:\n            return nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 []interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = make([]interface{}, len(list1.([]int)) - L)\n        for i, v := range list1.([]int) {\n            if i < L {\n                list2[i] = v\n            } else {\n                list2[i - L] = v\n            }\n        }\n    case []string:\n        list2 = make([]interface{}, len(list1.([]string)) - L)\n        for i, v := range list1.([]string) {\n            if i < L {\n                list2[i] = v\n            } else {\n                list2[i - L] = v\n            }\n        }\n    }\n    return list2\n}\n",
    "    switch list1.(type) {\n        case []int:\n            list := list1.([]int)\n            return list[:L], list[L:]\n        case []string:\n            list := list1.([]string)\n            return list[:L], list[L:]\n        default:\n            return nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 []interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    case []float64:\n        list2 = list1.([]float64)[L:]\n        list1 = list1.([]float64)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n        case []int:\n            list := list1.([]int)\n            return list[:L], list[L:]\n        case []string:\n            list := list1.([]string)\n            return list[:L], list[L:]\n        default:\n            return nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 []interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    case []float64:\n        list2 = list1.([]float64)[L:]\n        list1 = list1.([]float64)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n        case []int:\n            list := list1.([]int)\n            return list[:L], list[L:]\n        case []string:\n            list := list1.([]string)\n            return list[:L], list[L:]\n        case []float64:\n            list := list1.([]float64)\n            return list[:L], list[L:]\n        default:\n            return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        return append(list[:L], list[L:]), list[:L]\n    case []int:\n        list := list1.([]int)\n        return append(list[:L], list[L:]), list[:L]\n    default:\n        return nil\n    }\n}\n",
    "    list2 := make([]interface{}, 0)\n    list3 := make([]interface{}, 0)\n    for i, v := range list1.([]interface{}) {\n        if i < L {\n            list2 = append(list2, v)\n        } else {\n            list3 = append(list3, v)\n        }\n    }\n    return []interface{}{list2, list3}\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    list := list1.([]int)\n    list2 := list[L:]\n    list = list[:L]\n    return []interface{}{list, list2}\n}\n",
    "    list := list1.([]int)\n    return list[:L], list[L:]\n}\n",
    "    list := list1.([]int)\n    list2 := list[L:]\n    list = list[:L]\n    return []interface{}{list, list2}\n}\n",
    "    var list2 []interface{}\n    var list3 []interface{}\n    var list4 []interface{}\n    var list5 []interface{}\n    var list6 []interface{}\n    var list7 []interface{}\n    var list8 []interface{}\n    var list9 []interface{}\n    var list10 []interface{}\n    var list11 []interface{}\n    var list12 []interface{}\n    var list13 []interface{}\n    var list14 []interface{}\n    var list15 []interface{}\n    var list16 []interface{}\n    var list17 []interface{}\n    var list18 []interface{}\n    var list19 []interface{}\n    var list20 []interface{}\n    var list21 []interface{}\n    var list22 []interface{}\n    var list23 []interface{}\n    var list24 []interface{}\n    var list25 []interface{}\n    var list26 []interface{}\n    var list27 []interface{}\n    var list28 []interface{}\n    var list29 []interface{}\n    var list30 []interface{}\n    var list31 []interface{}\n    var list32 []interface{}\n    var list33 []interface{}\n    var list34 []interface{}\n    var list35 []interface{}\n    var list36 []interface{}\n    var list37 []interface{}\n    var list38 []interface{}\n    var list39 []interface{}\n    var list40 []interface{}\n    var list41 []interface{}\n    var list42 []interface{}\n    var list43 []interface{}\n    var list44 []interface{}\n    var list45 []interface{}\n    var list46 []interface{}\n    var list47 []interface{}\n    var list48 []interface{}\n    var list49 []interface{}\n    var list50 []interface{}\n    var list51 []interface{}\n    var list52 []interface{}\n    var list53 []interface{}\n    var list54 []interface{}\n    var list55 []interface{}\n    var list56 []interface{}\n    var list57 []interface{}\n    var list58 []interface{",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 []interface{}\n    var list3 []interface{}\n    var list4 []interface{}\n    var list5 []interface{}\n    var list6 []interface{}\n    var list7 []interface{}\n    var list8 []interface{}\n    var list9 []interface{}\n    var list10 []interface{}\n    var list11 []interface{}\n    var list12 []interface{}\n    var list13 []interface{}\n    var list14 []interface{}\n    var list15 []interface{}\n    var list16 []interface{}\n    var list17 []interface{}\n    var list18 []interface{}\n    var list19 []interface{}\n    var list20 []interface{}\n    var list21 []interface{}\n    var list22 []interface{}\n    var list23 []interface{}\n    var list24 []interface{}\n    var list25 []interface{}\n    var list26 []interface{}\n    var list27 []interface{}\n    var list28 []interface{}\n    var list29 []interface{}\n    var list30 []interface{}\n    var list31 []interface{}\n    var list32 []interface{}\n    var list33 []interface{}\n    var list34 []interface{}\n    var list35 []interface{}\n    var list36 []interface{}\n    var list37 []interface{}\n    var list38 []interface{}\n    var list39 []interface{}\n    var list40 []interface{}\n    var list41 []interface{}\n    var list42 []interface{}\n    var list43 []interface{}\n    var list44 []interface{}\n    var list45 []interface{}\n    var list46 []interface{}\n    var list47 []interface{}\n    var list48 []interface{}\n    var list49 []interface{}\n    var list50 []interface{}\n    var list51 []interface{}\n    var list52 []interface{}\n    var list53 []interface{}\n    var list54 []interface{}\n    var list55 []interface{}\n    var list56 []interface{}\n    var list57 []interface{}\n    var list58 []interface{",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    // Your code here\n    return nil\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    case []float64:\n        list := list1.([]float64)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    var list2 []interface{}\n    var list3 []interface{}\n    switch list1.(type) {\n    case []int:\n        for i, v := range list1.([]int) {\n            if i < L {\n                list2 = append(list2, v)\n            } else {\n                list3 = append(list3, v)\n            }\n        }\n    case []string:\n        for i, v := range list1.([]string) {\n            if i < L {\n                list2 = append(list2, v)\n            } else {\n                list3 = append(list3, v)\n            }\n        }\n    }\n    return list2, list3\n}\n",
    "    switch list1.(type) {\n        case []int:\n            list := list1.([]int)\n            return list[:L], list[L:]\n        case []string:\n            list := list1.([]string)\n            return list[:L], list[L:]\n        default:\n            return nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    case []float64:\n        list2 = list1.([]float64)[L:]\n        list1 = list1.([]float64)[:L]\n    case []bool:\n        list2 = list1.([]bool)[L:]\n        list1 = list1.([]bool)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = make([]int, len(list1.([]int)) - L)\n        copy(list2.([]int), list1.([]int)[L:])\n    case []string:\n        list2 = make([]string, len(list1.([]string)) - L)\n        copy(list2.([]string), list1.([]string)[L:])\n    }\n    return list1, list2\n}\n",
    "    switch list1.(type) {\n        case []int:\n            list := list1.([]int)\n            return append(list[:L], list[L:]...)\n        case []string:\n            list := list1.([]string)\n            return append(list[:L], list[L:]...)\n        default:\n            return nil\n    }\n}\n",
    "    list := list1.([]int)\n    list2 := list[L:]\n    list = list[:L]\n    return []interface{}{list, list2}\n}\n",
    "    var list2 []interface{}\n    var list3 []interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)\n    case []string:\n        list2 = list1.([]string)\n    }\n    for i := 0; i < L; i++ {\n        list3 = append(list3, list2[i])\n    }\n    return list3\n}\n",
    "    var list2 []interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = make([]int, 0)\n        for _, v := range list1.([]int) {\n            if L > 0 {\n                list2 = append(list2, v)\n                L--\n            }\n        }\n    case []string:\n        list2 = make([]string, 0)\n        for _, v := range list1.([]string) {\n            if L > 0 {\n                list2 = append(list2, v)\n                L--\n            }\n        }\n    }\n    return list2\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return append(list[:L], list[L:]), list[:L]\n    case []string:\n        list := list1.([]string)\n        return append(list[:L], list[L:]), list[:L]\n    default:\n        return nil\n    }\n}\n",
    "    var list2 []interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    default:\n        fmt.Println(\"Unsupported type\")\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n        case []int:\n            list := list1.([]int)\n            return list[:L], list[L:]\n        case []string:\n            list := list1.([]string)\n            return list[:L], list[L:]\n        default:\n            return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return append(list[:L], list[L:]...)\n    case []string:\n        list := list1.([]string)\n        return append(list[:L], list[L:]...)\n    default:\n        return nil\n    }\n}\n",
    "    // your code here\n    return nil\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 []int\n    var list3 []int\n    var list4 []int\n    var list5 []int\n    var list6 []int\n    var list7 []int\n    var list8 []int\n    var list9 []int\n    var list10 []int\n    var list11 []int\n    var list12 []int\n    var list13 []int\n    var list14 []int\n    var list15 []int\n    var list16 []int\n    var list17 []int\n    var list18 []int\n    var list19 []int\n    var list20 []int\n    var list21 []int\n    var list22 []int\n    var list23 []int\n    var list24 []int\n    var list25 []int\n    var list26 []int\n    var list27 []int\n    var list28 []int\n    var list29 []int\n    var list30 []int\n    var list31 []int\n    var list32 []int\n    var list33 []int\n    var list34 []int\n    var list35 []int\n    var list36 []int\n    var list37 []int\n    var list38 []int\n    var list39 []int\n    var list40 []int\n    var list41 []int\n    var list42 []int\n    var list43 []int\n    var list44 []int\n    var list45 []int\n    var list46 []int\n    var list47 []int\n    var list48 []int\n    var list49 []int\n    var list50 []int\n    var list51 []int\n    var list52 []int\n    var list53 []int\n    var list54 []int\n    var list55 []int\n    var list56 []int\n    var list57 []int\n    var list58 []int\n    var list59 []int\n    var list60 []int\n    var list61 []int\n    var list62 []int\n    var list63 []int\n    var list64 []int\n    var list65 []int\n    var list66 []int\n    var list67 []int\n    var list68 []int\n    var list69 []int\n    var list70 []int\n    var list71 []int\n    var list72 []int\n    var list73 []int\n    var list74 []int\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return list1, list2\n}\n",
    "    var list2 []interface{}\n    var list3 []interface{}\n    var list4 []interface{}\n\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)\n    case []string:\n        list2 = list1.([]string)\n    case []float64:\n        list2 = list1.([]float64)\n    }\n\n    for i := 0; i < L; i++ {\n        list3 = append(list3, list2[i])\n    }\n\n    for i := L; i < len(list2); i++ {\n        list4 = append(list4, list2[i])\n    }\n\n    return []interface{}{list3, list4}\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if L > len(list) {\n            return nil\n        }\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        if L > len(list) {\n            return nil\n        }\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = make([]int, len(list1.([]int)) - L)\n        copy(list2.([]int), list1.([]int)[L:])\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = make([]string, len(list1.([]string)) - L)\n        copy(list2.([]string), list1.([]string)[L:])\n        list1 = list1.([]string)[:L]\n    }\n    return list1, list2\n}\n",
    "    var list2 []interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = make([]interface{}, len(list1.([]int)) - L)\n        for i := 0; i < L; i++ {\n            list2[i] = list1.([]int)[i]\n        }\n        for i := L; i < len(list1.([]int)); i++ {\n            list2[i] = list1.([]int)[i]\n        }\n    case []string:\n        list2 = make([]interface{}, len(list1.([]string)) - L)\n        for i := 0; i < L; i++ {\n            list2[i] = list1.([]string)[i]\n        }\n        for i := L; i < len(list1.([]string)); i++ {\n            list2[i] = list1.([]string)[i]\n        }\n    case []float64:\n        list2 = make([]interface{}, len(list1.([]float64)) - L)\n        for i := 0; i < L; i++ {\n            list2[i] = list1.([]float64)[i]\n        }\n        for i := L; i < len(list1.([]float64)); i++ {\n            list2[i] = list1.([]float64)[i]\n        }\n    }\n    return list2\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return append(list[:L], list[L:]), list[:L]\n    case []string:\n        list := list1.([]string)\n        return append(list[:L], list[L:]), list[:L]\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    list := list1.([]int)\n    list2 := list[L:]\n    list = list[:L]\n    return []interface{}{list, list2}\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    list := list1.([]int)\n    list2 := list[L:]\n    list = list[:L]\n    return []interface{}{list, list2}\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    var list2 []interface{}\n    for i := L; i < len(list1.([]interface{})); i++ {\n        list2 = append(list2, list1.([]interface{})[i])\n    }\n    return list1.([]interface{})[:L], list2\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    }\n    return nil\n}\n",
    "    switch list1.(type) {\n        case []int:\n            list := list1.([]int)\n            return list[:L], list[L:]\n        case []string:\n            list := list1.([]string)\n            return list[:L], list[L:]\n        default:\n            return nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) <= L {\n            return list\n        }\n        return []int{list[:L], list[L:]}\n    case []string:\n        list := list1.([]string)\n        if len(list) <= L {\n            return list\n        }\n        return []string{list[:L], list[L:]}\n    default:\n        return nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n        case []int:\n            list := list1.([]int)\n            if L > len(list) {\n                return list\n            }\n            return append(list[:L], list[L:]...)\n        case []string:\n            list := list1.([]string)\n            if L > len(list) {\n                return list\n            }\n            return append(list[:L], list[L:]...)\n        default:\n            return list1\n    }\n}\n",
    "    switch list1.(type) {\n        case []int:\n            list := list1.([]int)\n            return list[:L], list[L:]\n        case []string:\n            list := list1.([]string)\n            return list[:L], list[L:]\n        default:\n            return nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n        case []int:\n            list := list1.([]int)\n            return list[:L], list[L:]\n        case []string:\n            list := list1.([]string)\n            return list[:L], list[L:]\n        default:\n            return nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    case []float64:\n        list2 = list1.([]float64)[L:]\n        list1 = list1.([]float64)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 []interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = make([]interface{}, len(list1.([]int)) - L)\n        for i := 0; i < L; i++ {\n            list2[i] = list1.([]int)[i]\n        }\n        for i := L; i < len(list1.([]int)); i++ {\n            list2[i - L] = list1.([]int)[i]\n        }\n    case []string:\n        list2 = make([]interface{}, len(list1.([]string)) - L)\n        for i := 0; i < L; i++ {\n            list2[i] = list1.([]string)[i]\n        }\n        for i := L; i < len(list1.([]string)); i++ {\n            list2[i - L] = list1.([]string)[i]\n        }\n    }\n    return list2\n}\n",
    "    list := list1.([]int)\n    list2 := list[L:]\n    list = list[:L]\n    return []interface{}{list, list2}\n}\n",
    "    var list2 []interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    case []float64:\n        list2 = list1.([]float64)[L:]\n        list1 = list1.([]float64)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    }\n    return nil\n}\n",
    "    var list2 []int\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)\n    case []string:\n        list2 = list1.([]string)\n    }\n    return list2[:L], list2[L:]\n}\n",
    "    // write your code here\n    return nil\n}\n",
    "    // your code here\n    return nil\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if L > len(list) {\n            return nil\n        }\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        if L > len(list) {\n            return nil\n        }\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n        case []int:\n            list := list1.([]int)\n            if L > len(list) {\n                return nil\n            }\n            return list[:L], list[L:]\n        case []string:\n            list := list1.([]string)\n            if L > len(list) {\n                return nil\n            }\n            return list[:L], list[L:]\n        default:\n            return nil\n    }\n}\n",
    "    switch list1.(type) {\n        case []int:\n            list := list1.([]int)\n            list2 := list[L:]\n            list1 = list[:L]\n            return list1, list2\n        case []string:\n            list := list1.([]string)\n            list2 := list[L:]\n            list1 = list[:L]\n            return list1, list2\n        default:\n            return nil\n    }\n}\n",
    "    var list2 []interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = make([]int, len(list1.([]int)) - L)\n        copy(list2, list1.([]int)[L:])\n    case []string:\n        list2 = make([]string, len(list1.([]string)) - L)\n        copy(list2, list1.([]string)[L:])\n    case []float64:\n        list2 = make([]float64, len(list1.([]float64)) - L)\n        copy(list2, list1.([]float64)[L:])\n    }\n    return list1, list2\n}\n",
    "    var list2 []interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = make([]interface{}, len(list1.([]int))-L)\n        for i, v := range list1.([]int) {\n            if i < L {\n                continue\n            }\n            list2[i-L] = v\n        }\n    case []string:\n        list2 = make([]interface{}, len(list1.([]string))-L)\n        for i, v := range list1.([]string) {\n            if i < L {\n                continue\n            }\n            list2[i-L] = v\n        }\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n        case []int:\n            list := list1.([]int)\n            return list[:L], list[L:]\n        case []string:\n            list := list1.([]string)\n            return list[:L], list[L:]\n        default:\n            return nil\n    }\n}\n",
    "    if L == 0 {\n        return list1\n    }\n    if L < 0 {\n        return nil\n    }\n    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if L > len(list) {\n            return nil\n        }\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        if L > len(list) {\n            return nil\n        }\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if L > len(list) {\n            return nil\n        }\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        if L > len(list) {\n            return nil\n        }\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n        case []int:\n            list := list1.([]int)\n            return list[:L], list[L:]\n        case []string:\n            list := list1.([]string)\n            return list[:L], list[L:]\n        default:\n            return nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    list := list1.([]int)\n    list2 := list[L:]\n    list = list[:L]\n    return []interface{}{list, list2}\n}\n",
    "    var list2 []interface{}\n    var list3 []interface{}\n    var list4 []interface{}\n    var list5 []interface{}\n    var list6 []interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)\n        list3 = list2[:L]\n        list4 = list2[L:]\n        list5 = append(list5, list3)\n        list5 = append(list5, list4)\n        return list5\n    case []string:\n        list2 = list1.([]string)\n        list3 = list2[:L]\n        list4 = list2[L:]\n        list5 = append(list5, list3)\n        list5 = append(list5, list4)\n        return list5\n    case []float64:\n        list2 = list1.([]float64)\n        list3 = list2[:L]\n        list4 = list2[L:]\n        list5 = append(list5, list3)\n        list5 = append(list5, list4)\n        return list5\n    case []interface{}:\n        list2 = list1.([]interface{})\n        list3 = list2[:L]\n        list4 = list2[L:]\n        list5 = append(list5, list3)\n        list5 = append(list5, list4)\n        return list5\n    default:\n        return list6\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return list1, list2\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n        case []int:\n            list := list1.([]int)\n            return list[:L], list[L:]\n        case []string:\n            list := list1.([]string)\n            return list[:L], list[L:]\n        default:\n            return nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    var list2 []interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    case []float64:\n        list2 = list1.([]float64)[L:]\n        list1 = list1.([]float64)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return append(list[:L], list[L:]...)\n    case []string:\n        list := list1.([]string)\n        return append(list[:L], list[L:]...)\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n        case []int:\n            list := list1.([]int)\n            return list[:L], list[L:]\n        case []string:\n            list := list1.([]string)\n            return list[:L], list[L:]\n        default:\n            return nil\n    }\n}\n",
    "    switch list1.(type) {\n        case []int:\n            list := list1.([]int)\n            return append(list[:L], list[L:]), list[:L]\n        case []string:\n            list := list1.([]string)\n            return append(list[:L], list[L:]), list[:L]\n        case []float64:\n            list := list1.([]float64)\n            return append(list[:L], list[L:]), list[:L]\n        default:\n            return nil\n    }\n}\n",
    "    var list2 []interface{}\n    list2 = append(list2, list1.([]interface{})[L:])\n    list1 = list1.([]interface{})[:L]\n    list2 = append(list2, list1)\n    return list2\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = make([]int, L)\n        copy(list2.([]int), list1.([]int)[:L])\n        list1 = list1.([]int)[L:]\n    case []string:\n        list2 = make([]string, L)\n        copy(list2.([]string), list1.([]string)[:L])\n        list1 = list1.([]string)[L:]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n        case []int:\n            list := list1.([]int)\n            return list[:L], list[L:]\n        case []string:\n            list := list1.([]string)\n            return list[:L], list[L:]\n        case []float64:\n            list := list1.([]float64)\n            return list[:L], list[L:]\n        default:\n            return nil, nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = make([]int, len(list1.([]int)) - L)\n        copy(list2.([]int), list1.([]int)[L:])\n    case []string:\n        list2 = make([]string, len(list1.([]string)) - L)\n        copy(list2.([]string), list1.([]string)[L:])\n    }\n    return list1, list2\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    }\n    return nil\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    case []float64:\n        list := list1.([]float64)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if L > len(list) {\n            return nil\n        }\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        if L > len(list) {\n            return nil\n        }\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    list := list1.([]int)\n    return list[:L], list[L:]\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = make([]int, len(list1.([]int)) - L)\n        copy(list2.([]int), list1.([]int)[L:])\n    case []string:\n        list2 = make([]string, len(list1.([]string)) - L)\n        copy(list2.([]string), list1.([]string)[L:])\n    }\n    return list1, list2\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return append(list[:L], list[L:]...)\n    case []string:\n        list := list1.([]string)\n        return append(list[:L], list[L:]...)\n    case []float64:\n        list := list1.([]float64)\n        return append(list[:L], list[L:]...)\n    }\n    return nil\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 []interface{}\n    var list3 []interface{}\n    switch list1.(type) {\n        case []int:\n            list2 = list1.([]int)[:L]\n            list3 = list1.([]int)[L:]\n        case []string:\n            list2 = list1.([]string)[:L]\n            list3 = list1.([]string)[L:]\n        case []float64:\n            list2 = list1.([]float64)[:L]\n            list3 = list1.([]float64)[L:]\n    }\n    return list2, list3\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    case []float64:\n        list2 = list1.([]float64)[L:]\n        list1 = list1.([]float64)[:L]\n    }\n    return list1, list2\n}\n",
    "    switch list1.(type) {\n        case []int:\n            list := list1.([]int)\n            return append(list[:L], list[L:]), list[:L]\n        case []string:\n            list := list1.([]string)\n            return append(list[:L], list[L:]), list[:L]\n        default:\n            return nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    list2 := make([]interface{}, 0)\n    list3 := make([]interface{}, 0)\n    for _, v := range list1.([]interface{}) {\n        if L > 0 {\n            list2 = append(list2, v)\n            L--\n        } else {\n            list3 = append(list3, v)\n        }\n    }\n    return []interface{}{list2, list3}\n}\n",
    "    var list2 []interface{}\n    for i, v := range list1.([]interface{}) {\n        if i < L {\n            list2 = append(list2, v)\n        }\n    }\n    return list2\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = make([]int, len(list1.([]int)) - L)\n        copy(list2.([]int), list1.([]int)[L:])\n    case []string:\n        list2 = make([]string, len(list1.([]string)) - L)\n        copy(list2.([]string), list1.([]string)[L:])\n    }\n    return list2\n}\n",
    "    list := list1.([]int)\n    return list[:L], list[L:]\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n        case []int:\n            list := list1.([]int)\n            return append(list[:L], list[L:]...)\n        case []string:\n            list := list1.([]string)\n            return append(list[:L], list[L:]...)\n        default:\n            return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n        case []int:\n            list := list1.([]int)\n            return list[:L], list[L:]\n        case []string:\n            list := list1.([]string)\n            return list[:L], list[L:]\n    }\n    return nil\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    list2 := make([]interface{}, 0)\n    list3 := make([]interface{}, 0)\n    list4 := make([]interface{}, 0)\n    list5 := make([]interface{}, 0)\n    list6 := make([]interface{}, 0)\n    list7 := make([]interface{}, 0)\n    list8 := make([]interface{}, 0)\n    list9 := make([]interface{}, 0)\n    list10 := make([]interface{}, 0)\n    list11 := make([]interface{}, 0)\n    list12 := make([]interface{}, 0)\n    list13 := make([]interface{}, 0)\n    list14 := make([]interface{}, 0)\n    list15 := make([]interface{}, 0)\n    list16 := make([]interface{}, 0)\n    list17 := make([]interface{}, 0)\n    list18 := make([]interface{}, 0)\n    list19 := make([]interface{}, 0)\n    list20 := make([]interface{}, 0)\n    list21 := make([]interface{}, 0)\n    list22 := make([]interface{}, 0)\n    list23 := make([]interface{}, 0)\n    list24 := make([]interface{}, 0)\n    list25 := make([]interface{}, 0)\n    list26 := make([]interface{}, 0)\n    list27 := make([]interface{}, 0)\n    list28 := make([]interface{}, 0)\n    list29 := make([]interface{}, 0)\n    list30 := make([]interface{}, 0)\n    list31 := make([]interface{}, 0)\n    list32 := make([]interface{}, 0)\n    list33 := make([]interface{}, 0)\n    list34 := make([]interface{}, 0)\n    list35 := make([]interface{}, 0)\n    list36 := make([]interface{}, 0)\n    list37 := make([]interface{}, 0)\n    list38 := make([]interface{}, 0)\n    list39 := make([]interface{}, 0)\n    list40 := make([]interface{}, 0)\n    list41 :=",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 interface{}\n    if L == 0 {\n        list2 = list1\n        list1 = nil\n    } else {\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    list2 := []int{}\n    list3 := []int{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)\n        list3 = list2[L:]\n        list2 = list2[:L]\n    }\n    return list2, list3\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n        case []int:\n            list := list1.([]int)\n            return list[:L], list[L:]\n        case []string:\n            list := list1.([]string)\n            return list[:L], list[L:]\n        case []float64:\n            list := list1.([]float64)\n            return list[:L], list[L:]\n        default:\n            return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    case []float64:\n        list2 = list1.([]float64)[L:]\n        list1 = list1.([]float64)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    case []float64:\n        list := list1.([]float64)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        list2 := list[L:]\n        list = list[:L]\n        return list, list2\n    case []string:\n        list := list1.([]string)\n        list2 := list[L:]\n        list = list[:L]\n        return list, list2\n    default:\n        return nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    default:\n        fmt.Println(\"Error: unsupported type\")\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if L > len(list) {\n            return nil\n        }\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        if L > len(list) {\n            return nil\n        }\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n        case []int:\n            list := list1.([]int)\n            if L > len(list) {\n                return nil\n            }\n            return list[:L], list[L:]\n        case []string:\n            list := list1.([]string)\n            if L > len(list) {\n                return nil\n            }\n            return list[:L], list[L:]\n        default:\n            return nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    list := list1.([]int)\n    list2 := list[L:]\n    list = list[:L]\n    return []interface{}{list, list2}\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if L > len(list) {\n            return nil\n        }\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        if L > len(list) {\n            return nil\n        }\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    var list2 []interface{}\n    var list3 []interface{}\n    switch list1.(type) {\n    case []int:\n        for i, v := range list1.([]int) {\n            if i < L {\n                list2 = append(list2, v)\n            } else {\n                list3 = append(list3, v)\n            }\n        }\n    case []string:\n        for i, v := range list1.([]string) {\n            if i < L {\n                list2 = append(list2, v)\n            } else {\n                list3 = append(list3, v)\n            }\n        }\n    }\n    return []interface{}{list2, list3}\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        return list[:L], list[L:]\n    case []string:\n        list := list1.([]string)\n        return list[:L], list[L:]\n    default:\n        return nil\n    }\n}\n",
    "    switch list1.(type) {\n        case []int:\n            list := list1.([]int)\n            list2 := list[L:]\n            list = list[:L]\n            return list, list2\n        case []string:\n            list := list1.([]string)\n            list2 := list[L:]\n            list = list[:L]\n            return list, list2\n        default:\n            return nil\n    }\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n",
    "    var list2 []interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = make([]interface{}, len(list1.([]int)))\n        copy(list2, list1.([]int))\n    case []string:\n        list2 = make([]interface{}, len(list1.([]string)))\n        copy(list2, list1.([]string))\n    }\n    return list1, list2\n}\n",
    "    var list2 interface{}\n    switch list1.(type) {\n    case []int:\n        list2 = list1.([]int)[L:]\n        list1 = list1.([]int)[:L]\n    case []string:\n        list2 = list1.([]string)[L:]\n        list1 = list1.([]string)[:L]\n    }\n    return []interface{}{list1, list2}\n}\n"
  ]
}