{
  "name": "mbpp_747_lcs_of_three",
  "language": "go_test.go",
  "prompt": "package lcs_of_three_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the longest common subsequence for the given three string sequence. https://www.geeksforgeeks.org/lcs-longest-common-subsequence-three-strings/\nfunc lcs_of_three(X string, Y string, Z string) int {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_747_lcs_of_three.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestLcs_Of_Three(t *testing.T) {\n  candidate := lcs_of_three\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AGGT12\", \"12TXAYB\", \"12XBA\"), expected: 2 },\n     { actual: candidate(\"Reels\", \"Reelsfor\", \"ReelsforReels\"), expected: 5 },\n     { actual: candidate(\"abcd1e2\", \"bc12ea\", \"bd1ea\"), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    m := len(X)\n    n := len(Y)\n    o := len(Z)\n    L := make([][][]int, m+1)\n    for i := 0; i <= m; i++ {\n        L[i] = make([][]int, n+1)\n        for j := 0; j <= n; j++ {\n            L[i][j] = make([]int, o+1)\n        }\n    }\n    for i := 0; i <= m; i++ {\n        for j := 0; j <= n; j++ {\n            for k := 0; k <= o; k++ {\n                if i == 0 || j == 0 || k == 0 {\n                    L[i][j][k] = 0\n                } else if X[i-1] == Y[j-1] && X[i-1] == Z[k-1] {\n                    L[i][j][k] = L[i-1][j-1][k-1] + 1\n                } else {\n                    L[i][j][k] = max(L[i-1][j][k], L[i][j-1][k], L[i][j][k-1])\n                }\n            }\n        }\n    }\n    return L[m][n][o]\n}\n",
    "    m := len(X)\n    n := len(Y)\n    o := len(Z)\n    L := make([][][]int, m+1)\n    for i := 0; i <= m; i++ {\n        L[i] = make([][]int, n+1)\n        for j := 0; j <= n; j++ {\n            L[i][j] = make([]int, o+1)\n        }\n    }\n    for i := 0; i <= m; i++ {\n        for j := 0; j <= n; j++ {\n            for k := 0; k <= o; k++ {\n                if i == 0 || j == 0 || k == 0 {\n                    L[i][j][k] = 0\n                } else if X[i-1] == Y[j-1] && X[i-1] == Z[k-1] {\n                    L[i][j][k] = L[i-1][j-1][k-1] + 1\n                } else {\n                    L[i][j][k] = max(L[i-1][j][k], L[i][j-1][k], L[i][j][k-1])\n                }\n            }\n        }\n    }\n    return L[m][n][o]\n}\n",
    "    m := len(X)\n    n := len(Y)\n    o := len(Z)\n    L := make([][][]int, m+1)\n    for i := 0; i <= m; i++ {\n        L[i] = make([][]int, n+1)\n        for j := 0; j <= n; j++ {\n            L[i][j] = make([]int, o+1)\n        }\n    }\n\n    for i := 0; i <= m; i++ {\n        for j := 0; j <= n; j++ {\n            for k := 0; k <= o; k++ {\n                if i == 0 || j == 0 || k == 0 {\n                    L[i][j][k] = 0\n                } else if X[i-1] == Y[j-1] && X[i-1] == Z[k-1] {\n                    L[i][j][k] = L[i-1][j-1][k-1] + 1\n                } else {\n                    L[i][j][k] = max(L[i-1][j][k], L[i][j-1][k], L[i][j][k-1])\n                }\n            }\n        }\n    }\n    return L[m][n][o]\n}\n",
    "    m := len(X)\n    n := len(Y)\n    o := len(Z)\n    L := make([][][]int, m+1)\n    for i := 0; i <= m; i++ {\n        L[i] = make([][]int, n+1)\n        for j := 0; j <= n; j++ {\n            L[i][j] = make([]int, o+1)\n        }\n    }\n    for i := 0; i <= m; i++ {\n        for j := 0; j <= n; j++ {\n            for k := 0; k <= o; k++ {\n                if i == 0 || j == 0 || k == 0 {\n                    L[i][j][k] = 0\n                } else if X[i-1] == Y[j-1] && X[i-1] == Z[k-1] {\n                    L[i][j][k] = L[i-1][j-1][k-1] + 1\n                } else {\n                    L[i][j][k] = max(L[i-1][j][k], L[i][j-1][k], L[i][j][k-1])\n                }\n            }\n        }\n    }\n    return L[m][n][o]\n}\n",
    "    m := len(X)\n    n := len(Y)\n    o := len(Z)\n\n    L := make([][][]int, m+1)\n    for i := range L {\n        L[i] = make([][]int, n+1)\n        for j := range L[i] {\n            L[i][j] = make([]int, o+1)\n        }\n    }\n\n    for i := 0; i <= m; i++ {\n        for j := 0; j <= n; j++ {\n            for k := 0; k <= o; k++ {\n                if (i == 0 || j == 0 || k == 0) {\n                    L[i][j][k] = 0\n                } else if (X[i-1] == Y[j-1] && X[i-1] == Z[k-1]) {\n                    L[i][j][k] = L[i-1][j-1][k-1] + 1\n                } else {\n                    L[i][j][k] = max(L[i-1][j][k], L[i][j-1][k], L[i][j][k-1])\n                }\n            }\n        }\n    }\n\n    return L[m][n][o]\n}\n",
    "    m := len(X)\n    n := len(Y)\n    o := len(Z)\n    L := make([][][]int, m+1)\n    for i := 0; i <= m; i++ {\n        L[i] = make([][]int, n+1)\n        for j := 0; j <= n; j++ {\n            L[i][j] = make([]int, o+1)\n        }\n    }\n    for i := 0; i <= m; i++ {\n        for j := 0; j <= n; j++ {\n            for k := 0; k <= o; k++ {\n                if i == 0 || j == 0 || k == 0 {\n                    L[i][j][k] = 0\n                } else if X[i-1] == Y[j-1] && X[i-1] == Z[k-1] {\n                    L[i][j][k] = L[i-1][j-1][k-1] + 1\n                } else {\n                    L[i][j][k] = max(L[i-1][j][k], L[i][j-1][k], L[i][j][k-1])\n                }\n            }\n        }\n    }\n    return L[m][n][o]\n}\n",
    "    m := len(X)\n    n := len(Y)\n    o := len(Z)\n\n    L := make([][][]int, m+1)\n    for i := range L {\n        L[i] = make([][]int, n+1)\n        for j := range L[i] {\n            L[i][j] = make([]int, o+1)\n        }\n    }\n\n    for i := 0; i <= m; i++ {\n        for j := 0; j <= n; j++ {\n            for k := 0; k <= o; k++ {\n                if i == 0 || j == 0 || k == 0 {\n                    L[i][j][k] = 0\n                } else if X[i-1] == Y[j-1] && X[i-1] == Z[k-1] {\n                    L[i][j][k] = L[i-1][j-1][k-1] + 1\n                } else {\n                    L[i][j][k] = max(L[i-1][j][k], L[i][j-1][k], L[i][j][k-1])\n                }\n            }\n        }\n    }\n\n    return L[m][n][o]\n}\n",
    "    m := len(X)\n    n := len(Y)\n    o := len(Z)\n    L := make([][][]int, m+1)\n    for i := 0; i <= m; i++ {\n        L[i] = make([][]int, n+1)\n        for j := 0; j <= n; j++ {\n            L[i][j] = make([]int, o+1)\n        }\n    }\n    for i := 0; i <= m; i++ {\n        for j := 0; j <= n; j++ {\n            for k := 0; k <= o; k++ {\n                if i == 0 || j == 0 || k == 0 {\n                    L[i][j][k] = 0\n                } else if X[i-1] == Y[j-1] && X[i-1] == Z[k-1] {\n                    L[i][j][k] = L[i-1][j-1][k-1] + 1\n                } else {\n                    L[i][j][k] = max(L[i-1][j][k], L[i][j-1][k], L[i][j][k-1])\n                }\n            }\n        }\n    }\n    return L[m][n][o]\n}\n",
    "    m := len(X)\n    n := len(Y)\n    o := len(Z)\n    L := make([][][]int, m+1)\n    for i := range L {\n        L[i] = make([][]int, n+1)\n        for j := range L[i] {\n            L[i][j] = make([]int, o+1)\n        }\n    }\n    for i := 0; i <= m; i++ {\n        for j := 0; j <= n; j++ {\n            for k := 0; k <= o; k++ {\n                if i == 0 || j == 0 || k == 0 {\n                    L[i][j][k] = 0\n                } else if X[i-1] == Y[j-1] && X[i-1] == Z[k-1] {\n                    L[i][j][k] = L[i-1][j-1][k-1] + 1\n                } else {\n                    L[i][j][k] = max(L[i-1][j][k], L[i][j-1][k], L[i][j][k-1])\n                }\n            }\n        }\n    }\n    return L[m][n][o]\n}\n",
    "    m := len(X)\n    n := len(Y)\n    o := len(Z)\n    L := make([][][]int, m+1)\n    for i := 0; i <= m; i++ {\n        L[i] = make([][]int, n+1)\n        for j := 0; j <= n; j++ {\n            L[i][j] = make([]int, o+1)\n        }\n    }\n    for i := 0; i <= m; i++ {\n        for j := 0; j <= n; j++ {\n            for k := 0; k <= o; k++ {\n                if i == 0 || j == 0 || k == 0 {\n                    L[i][j][k] = 0\n                } else if X[i-1] == Y[j-1] && X[i-1] == Z[k-1] {\n                    L[i][j][k] = L[i-1][j-1][k-1] + 1\n                } else {\n                    L[i][j][k] = max(L[i-1][j][k], L[i][j-1][k], L[i][j][k-1])\n                }\n            }\n        }\n    }\n    return L[m][n][o]\n}\n",
    "    m := len(X)\n    n := len(Y)\n    o := len(Z)\n    L := make([][][]int, m+1)\n    for i := 0; i <= m; i++ {\n        L[i] = make([][]int, n+1)\n        for j := 0; j <= n; j++ {\n            L[i][j] = make([]int, o+1)\n        }\n    }\n    for i := 0; i <= m; i++ {\n        for j := 0; j <= n; j++ {\n            for k := 0; k <= o; k++ {\n                if i == 0 || j == 0 || k == 0 {\n                    L[i][j][k] = 0\n                } else if X[i-1] == Y[j-1] && X[i-1] == Z[k-1] {\n                    L[i][j][k] = L[i-1][j-1][k-1] + 1\n                } else {\n                    L[i][j][k] = max(L[i-1][j][k], L[i][j-1][k], L[i][j][k-1])\n                }\n            }\n        }\n    }\n    return L[m][n][o]\n}\n",
    "    m := len(X)\n    n := len(Y)\n    o := len(Z)\n    L := make([][][]int, m+1)\n    for i := 0; i <= m; i++ {\n        L[i] = make([][]int, n+1)\n        for j := 0; j <= n; j++ {\n            L[i][j] = make([]int, o+1)\n        }\n    }\n\n    for i := 0; i <= m; i++ {\n        for j := 0; j <= n; j++ {\n            for k := 0; k <= o; k++ {\n                if i == 0 || j == 0 || k == 0 {\n                    L[i][j][k] = 0\n                } else if X[i-1] == Y[j-1] && X[i-1] == Z[k-1] {\n                    L[i][j][k] = L[i-1][j-1][k-1] + 1\n                } else {\n                    L[i][j][k] = max(L[i-1][j][k], L[i][j-1][k], L[i][j][k-1])\n                }\n            }\n        }\n    }\n    return L[m][n][o]\n}\n",
    "    m := len(X)\n    n := len(Y)\n    o := len(Z)\n    L := make([][][]int, m+1)\n    for i := 0; i <= m; i++ {\n        L[i] = make([][]int, n+1)\n        for j := 0; j <= n; j++ {\n            L[i][j] = make([]int, o+1)\n        }\n    }\n    for i := 0; i <= m; i++ {\n        for j := 0; j <= n; j++ {\n            for k := 0; k <= o; k++ {\n                if i == 0 || j == 0 || k == 0 {\n                    L[i][j][k] = 0\n                } else if X[i-1] == Y[j-1] && X[i-1] == Z[k-1] {\n                    L[i][j][k] = L[i-1][j-1][k-1] + 1\n                } else {\n                    L[i][j][k] = max(L[i-1][j][k], L[i][j-1][k], L[i][j][k-1])\n                }\n            }\n        }\n    }\n    return L[m][n][o]\n}\n",
    "    m := len(X)\n    n := len(Y)\n    o := len(Z)\n    L := make([][][]int, m+1)\n    for i := 0; i <= m; i++ {\n        L[i] = make([][]int, n+1)\n        for j := 0; j <= n; j++ {\n            L[i][j] = make([]int, o+1)\n        }\n    }\n    for i := 0; i <= m; i++ {\n        for j := 0; j <= n; j++ {\n            for k := 0; k <= o; k++ {\n                if i == 0 || j == 0 || k == 0 {\n                    L[i][j][k] = 0\n                } else if X[i-1] == Y[j-1] && X[i-1] == Z[k-1] {\n                    L[i][j][k] = L[i-1][j-1][k-1] + 1\n                } else {\n                    L[i][j][k] = max(L[i-1][j][k], L[i][j-1][k], L[i][j][k-1])\n                }\n            }\n        }\n    }\n    return L[m][n][o]\n}\n",
    "    m := len(X)\n    n := len(Y)\n    o := len(Z)\n    L := make([][][]int, m+1)\n    for i := 0; i <= m; i++ {\n        L[i] = make([][]int, n+1)\n        for j := 0; j <= n; j++ {\n            L[i][j] = make([]int, o+1)\n        }\n    }\n    for i := 0; i <= m; i++ {\n        for j := 0; j <= n; j++ {\n            for k := 0; k <= o; k++ {\n                if i == 0 || j == 0 || k == 0 {\n                    L[i][j][k] = 0\n                } else if X[i-1] == Y[j-1] && X[i-1] == Z[k-1] {\n                    L[i][j][k] = L[i-1][j-1][k-1] + 1\n                } else {\n                    L[i][j][k] = max(L[i-1][j][k], L[i][j-1][k], L[i][j][k-1])\n                }\n            }\n        }\n    }\n    return L[m][n][o]\n}\n",
    "    // Create a table to store lengths of longest common suffixes of\n    // substrings.   Notethat LCSuff[i][j][k] contains length of longest\n    // common suffix of X[0..i-1] and Y[0..j-1] and Z[0..k-1]. The first\n    // row and first column entries have no logical meaning, they are used only\n    // for simplicity of program\n    m := len(X)\n    n := len(Y)\n    o := len(Z)\n    LCSuff := make([][][]int, m+1)\n    for i := 0; i <= m; i++ {\n        LCSuff[i] = make([][]int, n+1)\n        for j := 0; j <= n; j++ {\n            LCSuff[i][j] = make([]int, o+1)\n        }\n    }\n\n    // To store length of the longest common substring\n    result := 0\n\n    // Following steps build LCSuff[m+1][n+1][o+1] in bottom up fashion\n    for i := 0; i <= m; i++ {\n        for j := 0; j <= n; j++ {\n            for k := 0; k <= o; k++ {\n                if (i == 0 || j == 0 || k == 0) {\n                    LCSuff[i][j][k] = 0\n                } else if (X[i-1] == Y[j-1] && X[i-1] == Z[k-1]) {\n                    LCSuff[i][j][k] = LCSuff[i-1][j-1][k-1] + 1\n                    result = max(result, LCSuff[i][j][k])\n                } else {\n                    LCSuff[i][j][k] = 0\n                }\n            }\n        }\n    }\n    return result\n}\n",
    "    m := len(X)\n    n := len(Y)\n    o := len(Z)\n    L := make([][][]int, m+1)\n    for i := 0; i <= m; i++ {\n        L[i] = make([][]int, n+1)\n        for j := 0; j <= n; j++ {\n            L[i][j] = make([]int, o+1)\n        }\n    }\n    for i := 0; i <= m; i++ {\n        for j := 0; j <= n; j++ {\n            for k := 0; k <= o; k++ {\n                if i == 0 || j == 0 || k == 0 {\n                    L[i][j][k] = 0\n                } else if X[i-1] == Y[j-1] && X[i-1] == Z[k-1] {\n                    L[i][j][k] = L[i-1][j-1][k-1] + 1\n                } else {\n                    L[i][j][k] = max(L[i-1][j][k], L[i][j-1][k], L[i][j][k-1])\n                }\n            }\n        }\n    }\n    return L[m][n][o]\n}\n",
    "    m := len(X)\n    n := len(Y)\n    o := len(Z)\n    L := make([][][]int, m+1)\n    for i := 0; i <= m; i++ {\n        L[i] = make([][]int, n+1)\n        for j := 0; j <= n; j++ {\n            L[i][j] = make([]int, o+1)\n        }\n    }\n    for i := 0; i <= m; i++ {\n        for j := 0; j <= n; j++ {\n            for k := 0; k <= o; k++ {\n                if i == 0 || j == 0 || k == 0 {\n                    L[i][j][k] = 0\n                } else if X[i-1] == Y[j-1] && X[i-1] == Z[k-1] {\n                    L[i][j][k] = L[i-1][j-1][k-1] + 1\n                } else {\n                    L[i][j][k] = max(L[i-1][j][k], L[i][j-1][k], L[i][j][k-1])\n                }\n            }\n        }\n    }\n    return L[m][n][o]\n}\n",
    "    m := len(X)\n    n := len(Y)\n    o := len(Z)\n    L := make([][][]int, m+1)\n    for i := 0; i <= m; i++ {\n        L[i] = make([][]int, n+1)\n        for j := 0; j <= n; j++ {\n            L[i][j] = make([]int, o+1)\n        }\n    }\n    for i := 0; i <= m; i++ {\n        for j := 0; j <= n; j++ {\n            for k := 0; k <= o; k++ {\n                if i == 0 || j == 0 || k == 0 {\n                    L[i][j][k] = 0\n                } else if X[i-1] == Y[j-1] && X[i-1] == Z[k-1] {\n                    L[i][j][k] = L[i-1][j-1][k-1] + 1\n                } else {\n                    L[i][j][k] = max(L[i-1][j][k], L[i][j-1][k], L[i][j][k-1])\n                }\n            }\n        }\n    }\n    return L[m][n][o]\n}\n",
    "    m := len(X)\n    n := len(Y)\n    o := len(Z)\n    L := make([][][]int, m+1)\n    for i := 0; i <= m; i++ {\n        L[i] = make([][]int, n+1)\n        for j := 0; j <= n; j++ {\n            L[i][j] = make([]int, o+1)\n        }\n    }\n    for i := 0; i <= m; i++ {\n        for j := 0; j <= n; j++ {\n            for k := 0; k <= o; k++ {\n                if i == 0 || j == 0 || k == 0 {\n                    L[i][j][k] = 0\n                } else if X[i-1] == Y[j-1] && X[i-1] == Z[k-1] {\n                    L[i][j][k] = L[i-1][j-1][k-1] + 1\n                } else {\n                    L[i][j][k] = max(L[i-1][j][k], L[i][j-1][k], L[i][j][k-1])\n                }\n            }\n        }\n    }\n    return L[m][n][o]\n}\n"
  ]
}