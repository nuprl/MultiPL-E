{
  "name": "mbpp_463_max_subarray_product",
  "language": "go_test.go",
  "prompt": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_463_max_subarray_product.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_so_far := arr[0]\n    min_so_far := arr[0]\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_ending_here = max(arr[i], max_ending_here * arr[i])\n            min_ending_here = min(arr[i], min_ending_here * arr[i])\n        } else {\n            max_ending_here = max(arr[i], min_ending_here * arr[i])\n            min_ending_here = min(arr[i], max_ending_here * arr[i])\n        }\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpopexp527_test.go:19:31: undefined: max\n/tmp/tmpopexp527_test.go:20:31: undefined: min\n/tmp/tmpopexp527_test.go:22:31: undefined: max\n/tmp/tmpopexp527_test.go:23:31: undefined: min\n/tmp/tmpopexp527_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = tmp * v\n        }\n\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvf9ibx4x_test.go:21:31: undefined: min\n/tmp/tmpvf9ibx4x_test.go:27:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0r751o6n_test.go:20:23: undefined: max\n/tmp/tmp0r751o6n_test.go:21:23: undefined: min\n/tmp/tmp0r751o6n_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    max := arr[0]\n    min := arr[0]\n    max_product := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max = max * arr[i]\n            min = min * arr[i]\n        } else {\n            tmp := max\n            max = min * arr[i]\n            min = tmp * arr[i]\n        }\n        if max > max_product {\n            max_product = max\n        }\n        if min > max_product {\n            max_product = min\n        }\n        if max < 0 {\n            max = 0\n        }\n        if min > 0 {\n            min = 0\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "--- FAIL: TestMax_Subarray_Product (0.00s)\n    --- FAIL: TestMax_Subarray_Product/test_num__0 (0.00s)\n        tmp08bch_nb_test.go:53: expected '%!s(int=112)', got '%!s(int=6)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpml0z4gtf_test.go:23:23: undefined: max\n/tmp/tmpml0z4gtf_test.go:24:23: undefined: min\n/tmp/tmpml0z4gtf_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            temp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = temp * v\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd2304jhe_test.go:16:31: undefined: min\n/tmp/tmpd2304jhe_test.go:22:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0r751o6n_test.go:20:23: undefined: max\n/tmp/tmp0r751o6n_test.go:21:23: undefined: min\n/tmp/tmp0r751o6n_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0r751o6n_test.go:20:23: undefined: max\n/tmp/tmp0r751o6n_test.go:21:23: undefined: min\n/tmp/tmp0r751o6n_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp716yhhil_test.go:19:23: undefined: max\n/tmp/tmp716yhhil_test.go:20:23: undefined: min\n/tmp/tmp716yhhil_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp716yhhil_test.go:19:23: undefined: max\n/tmp/tmp716yhhil_test.go:20:23: undefined: min\n/tmp/tmp716yhhil_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    max := arr[0]\n    min := arr[0]\n    result := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max, min = min, max\n        }\n        max = max_int(arr[i], max * arr[i])\n        min = min_int(arr[i], min * arr[i])\n        result = max_int(result, max)\n    }\n    return result\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkytkrlhp_test.go:17:15: undefined: max_int\n/tmp/tmpkytkrlhp_test.go:18:15: undefined: min_int\n/tmp/tmpkytkrlhp_test.go:19:18: undefined: max_int\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    result := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        result = max(result, max_product)\n    }\n\n    return result\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeqdi84tg_test.go:23:23: undefined: max\n/tmp/tmpeqdi84tg_test.go:24:23: undefined: min\n/tmp/tmpeqdi84tg_test.go:26:18: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0r751o6n_test.go:20:23: undefined: max\n/tmp/tmp0r751o6n_test.go:21:23: undefined: min\n/tmp/tmp0r751o6n_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpatvyzo16_test.go:20:23: undefined: max\n/tmp/tmpatvyzo16_test.go:21:23: undefined: min\n/tmp/tmpatvyzo16_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpatvyzo16_test.go:20:23: undefined: max\n/tmp/tmpatvyzo16_test.go:21:23: undefined: min\n/tmp/tmpatvyzo16_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_so_far := arr[0]\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_ending_here = max(arr[i], max_ending_here * arr[i])\n            min_ending_here = min(arr[i], min_ending_here * arr[i])\n        } else {\n            max_ending_here = max(arr[i], min_ending_here * arr[i])\n            min_ending_here = min(arr[i], max_ending_here * arr[i])\n        }\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmk78jgff_test.go:18:31: undefined: max\n/tmp/tmpmk78jgff_test.go:19:31: undefined: min\n/tmp/tmpmk78jgff_test.go:21:31: undefined: max\n/tmp/tmpmk78jgff_test.go:22:31: undefined: min\n/tmp/tmpmk78jgff_test.go:24:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9udk9rka_test.go:23:23: undefined: max\n/tmp/tmp9udk9rka_test.go:24:23: undefined: min\n/tmp/tmp9udk9rka_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0r751o6n_test.go:20:23: undefined: max\n/tmp/tmp0r751o6n_test.go:21:23: undefined: min\n/tmp/tmp0r751o6n_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    max_so_far := 1\n    min_so_far := 1\n    max_ending_here := 1\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_ending_here = max_ending_here * arr[i]\n            min_so_far = min(min_so_far * arr[i], 1)\n        } else if arr[i] == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            temp := max_ending_here\n            max_ending_here = max(min_so_far * arr[i], 1)\n            min_so_far = temp * arr[i]\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpunbx9ufo_test.go:16:26: undefined: min\n/tmp/tmpunbx9ufo_test.go:22:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_so_far := arr[0]\n    min_so_far := arr[0]\n    max_product := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_so_far, min_so_far = min_so_far, max_so_far\n        }\n\n        max_so_far = max(arr[i], max_so_far * arr[i])\n        min_so_far = min(arr[i], min_so_far * arr[i])\n\n        max_product = max(max_product, max_so_far)\n    }\n\n    return max_product\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplqbo9bey_test.go:23:22: undefined: max\n/tmp/tmplqbo9bey_test.go:24:22: undefined: min\n/tmp/tmplqbo9bey_test.go:26:23: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp716yhhil_test.go:19:23: undefined: max\n/tmp/tmp716yhhil_test.go:20:23: undefined: min\n/tmp/tmp716yhhil_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here *= v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = tmp * v\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjzvsvfho_test.go:16:31: undefined: min\n/tmp/tmpjzvsvfho_test.go:22:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_ending_here = max(max_ending_here * arr[i], arr[i])\n            min_ending_here = min(min_ending_here * arr[i], arr[i])\n        } else {\n            temp := max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], arr[i])\n            min_ending_here = min(temp * arr[i], arr[i])\n        }\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsu8cc0al_test.go:18:31: undefined: max\n/tmp/tmpsu8cc0al_test.go:19:31: undefined: min\n/tmp/tmpsu8cc0al_test.go:22:31: undefined: max\n/tmp/tmpsu8cc0al_test.go:23:31: undefined: min\n/tmp/tmpsu8cc0al_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_product = max(max_product * arr[i], arr[i])\n            min_product = min(min_product * arr[i], arr[i])\n        } else {\n            tmp := max_product\n            max_product = max(min_product * arr[i], arr[i])\n            min_product = min(tmp * arr[i], arr[i])\n        }\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyj98b83c_test.go:16:27: undefined: max\n/tmp/tmpyj98b83c_test.go:17:27: undefined: min\n/tmp/tmpyj98b83c_test.go:20:27: undefined: max\n/tmp/tmpyj98b83c_test.go:21:27: undefined: min\n/tmp/tmpyj98b83c_test.go:23:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max := arr[0]\n    min := arr[0]\n    result := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max, min = min, max\n        }\n\n        max = max_int(arr[i], max * arr[i])\n        min = min_int(arr[i], min * arr[i])\n\n        result = max_int(result, max)\n    }\n\n    return result\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu0xju1ri_test.go:23:15: undefined: max_int\n/tmp/tmpu0xju1ri_test.go:24:15: undefined: min_int\n/tmp/tmpu0xju1ri_test.go:26:18: undefined: max_int\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_so_far := arr[0]\n    min_so_far := arr[0]\n    max_product := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_so_far, min_so_far = min_so_far, max_so_far\n        }\n\n        max_so_far = max(arr[i], max_so_far * arr[i])\n        min_so_far = min(arr[i], min_so_far * arr[i])\n\n        max_product = max(max_product, max_so_far)\n    }\n\n    return max_product\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplqbo9bey_test.go:23:22: undefined: max\n/tmp/tmplqbo9bey_test.go:24:22: undefined: min\n/tmp/tmplqbo9bey_test.go:26:23: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_so_far := arr[0]\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_ending_here, min_ending_here = min_ending_here, max_ending_here\n        }\n        max_ending_here = max(arr[i], max_ending_here * arr[i])\n        min_ending_here = min(arr[i], min_ending_here * arr[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1fuql3eh_test.go:20:27: undefined: max\n/tmp/tmp1fuql3eh_test.go:21:27: undefined: min\n/tmp/tmp1fuql3eh_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    n := len(arr)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return arr[0]\n    }\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < n; i++ {\n        if arr[i] > 0 {\n            max_ending_here = max(max_ending_here * arr[i], arr[i])\n            min_ending_here = min(min_ending_here * arr[i], arr[i])\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * arr[i], arr[i])\n            min_ending_here = min(tmp * arr[i], arr[i])\n        }\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpww3t31s1_test.go:22:31: undefined: max\n/tmp/tmpww3t31s1_test.go:23:31: undefined: min\n/tmp/tmpww3t31s1_test.go:26:31: undefined: max\n/tmp/tmpww3t31s1_test.go:27:31: undefined: min\n/tmp/tmpww3t31s1_test.go:29:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpatvyzo16_test.go:20:23: undefined: max\n/tmp/tmpatvyzo16_test.go:21:23: undefined: min\n/tmp/tmpatvyzo16_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_so_far := arr[0]\n    min_so_far := arr[0]\n    max_product := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_so_far, min_so_far = min_so_far, max_so_far\n        }\n\n        max_so_far = max(max_so_far * arr[i], arr[i])\n        min_so_far = min(min_so_far * arr[i], arr[i])\n\n        max_product = max(max_product, max_so_far)\n    }\n\n    return max_product\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk_yebj40_test.go:23:22: undefined: max\n/tmp/tmpk_yebj40_test.go:24:22: undefined: min\n/tmp/tmpk_yebj40_test.go:26:23: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnfpojsyc_test.go:23:23: undefined: max\n/tmp/tmpnfpojsyc_test.go:24:23: undefined: min\n/tmp/tmpnfpojsyc_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0r751o6n_test.go:20:23: undefined: max\n/tmp/tmp0r751o6n_test.go:21:23: undefined: min\n/tmp/tmp0r751o6n_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0r751o6n_test.go:20:23: undefined: max\n/tmp/tmp0r751o6n_test.go:21:23: undefined: min\n/tmp/tmp0r751o6n_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0r751o6n_test.go:20:23: undefined: max\n/tmp/tmp0r751o6n_test.go:21:23: undefined: min\n/tmp/tmp0r751o6n_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            temp := max_product\n            max_product = min_product\n            min_product = temp\n        }\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp33gcj5ek_test.go:22:23: undefined: max\n/tmp/tmp33gcj5ek_test.go:23:23: undefined: min\n/tmp/tmp33gcj5ek_test.go:24:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnfpojsyc_test.go:23:23: undefined: max\n/tmp/tmpnfpojsyc_test.go:24:23: undefined: min\n/tmp/tmpnfpojsyc_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_product = max(max_product * arr[i], arr[i])\n            min_product = min(min_product * arr[i], arr[i])\n        } else {\n            temp := max_product\n            max_product = max(min_product * arr[i], arr[i])\n            min_product = min(temp * arr[i], arr[i])\n        }\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcqa0xm4t_test.go:21:27: undefined: max\n/tmp/tmpcqa0xm4t_test.go:22:27: undefined: min\n/tmp/tmpcqa0xm4t_test.go:25:27: undefined: max\n/tmp/tmpcqa0xm4t_test.go:26:27: undefined: min\n/tmp/tmpcqa0xm4t_test.go:28:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0r751o6n_test.go:20:23: undefined: max\n/tmp/tmp0r751o6n_test.go:21:23: undefined: min\n/tmp/tmp0r751o6n_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpatvyzo16_test.go:20:23: undefined: max\n/tmp/tmpatvyzo16_test.go:21:23: undefined: min\n/tmp/tmpatvyzo16_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0r751o6n_test.go:20:23: undefined: max\n/tmp/tmp0r751o6n_test.go:21:23: undefined: min\n/tmp/tmp0r751o6n_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    result := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        result = max(result, max_product)\n    }\n\n    return result\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy9ujhg84_test.go:22:23: undefined: max\n/tmp/tmpy9ujhg84_test.go:23:23: undefined: min\n/tmp/tmpy9ujhg84_test.go:25:18: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_product = max(max_product * arr[i], arr[i])\n            min_product = min(min_product * arr[i], arr[i])\n        } else {\n            temp := max_product\n            max_product = max(min_product * arr[i], arr[i])\n            min_product = min(temp * arr[i], arr[i])\n        }\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcqa0xm4t_test.go:21:27: undefined: max\n/tmp/tmpcqa0xm4t_test.go:22:27: undefined: min\n/tmp/tmpcqa0xm4t_test.go:25:27: undefined: max\n/tmp/tmpcqa0xm4t_test.go:26:27: undefined: min\n/tmp/tmpcqa0xm4t_test.go:28:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwg1x35bi_test.go:17:23: undefined: max\n/tmp/tmpwg1x35bi_test.go:18:23: undefined: min\n/tmp/tmpwg1x35bi_test.go:19:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    max := arr[0]\n    min := arr[0]\n    res := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max, min = min, max\n        }\n        max = max2(arr[i], max * arr[i])\n        min = min2(arr[i], min * arr[i])\n        res = max2(res, max)\n    }\n    return res\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu4jnpq6e_test.go:17:15: undefined: max2\n/tmp/tmpu4jnpq6e_test.go:18:15: undefined: min2\n/tmp/tmpu4jnpq6e_test.go:19:15: undefined: max2\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max := arr[0]\n    min := arr[0]\n    result := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max, min = min, max\n        }\n        max = max_int(arr[i], max * arr[i])\n        min = min_int(arr[i], min * arr[i])\n        result = max_int(result, max)\n    }\n    return result\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1vqc6gkf_test.go:23:15: undefined: max_int\n/tmp/tmp1vqc6gkf_test.go:24:15: undefined: min_int\n/tmp/tmp1vqc6gkf_test.go:25:18: undefined: max_int\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max := arr[0]\n    min := arr[0]\n    result := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max, min = min, max\n        }\n        max = max_int(arr[i], max * arr[i])\n        min = min_int(arr[i], min * arr[i])\n        result = max_int(result, max)\n    }\n    return result\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1vqc6gkf_test.go:23:15: undefined: max_int\n/tmp/tmp1vqc6gkf_test.go:24:15: undefined: min_int\n/tmp/tmp1vqc6gkf_test.go:25:18: undefined: max_int\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0r751o6n_test.go:20:23: undefined: max\n/tmp/tmp0r751o6n_test.go:21:23: undefined: min\n/tmp/tmp0r751o6n_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0r751o6n_test.go:20:23: undefined: max\n/tmp/tmp0r751o6n_test.go:21:23: undefined: min\n/tmp/tmp0r751o6n_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp716yhhil_test.go:19:23: undefined: max\n/tmp/tmp716yhhil_test.go:20:23: undefined: min\n/tmp/tmp716yhhil_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0r751o6n_test.go:20:23: undefined: max\n/tmp/tmp0r751o6n_test.go:21:23: undefined: min\n/tmp/tmp0r751o6n_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9udk9rka_test.go:23:23: undefined: max\n/tmp/tmp9udk9rka_test.go:24:23: undefined: min\n/tmp/tmp9udk9rka_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        max_product, min_product = max(arr[i], arr[i] * max_product, arr[i] * min_product), min(arr[i], arr[i] * max_product, arr[i] * min_product)\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx52hclod_test.go:19:36: undefined: max\n/tmp/tmpx52hclod_test.go:19:93: undefined: min\n/tmp/tmpx52hclod_test.go:20:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5z0o6qb7_test.go:25:23: undefined: max\n/tmp/tmp5z0o6qb7_test.go:26:23: undefined: min\n/tmp/tmp5z0o6qb7_test.go:27:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjxl8oidf_test.go:26:23: undefined: max\n/tmp/tmpjxl8oidf_test.go:27:23: undefined: min\n/tmp/tmpjxl8oidf_test.go:29:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpatvyzo16_test.go:20:23: undefined: max\n/tmp/tmpatvyzo16_test.go:21:23: undefined: min\n/tmp/tmpatvyzo16_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    result := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        result = max(result, max_product)\n    }\n\n    return result\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeqdi84tg_test.go:23:23: undefined: max\n/tmp/tmpeqdi84tg_test.go:24:23: undefined: min\n/tmp/tmpeqdi84tg_test.go:26:18: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = tmp * v\n        }\n\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvf9ibx4x_test.go:21:31: undefined: min\n/tmp/tmpvf9ibx4x_test.go:27:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    max := arr[0]\n    min := arr[0]\n    max_product := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max, min = min, max\n        }\n        max = max2(arr[i], max * arr[i])\n        min = min2(arr[i], min * arr[i])\n        max_product = max2(max_product, max)\n    }\n    return max_product\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq9u91pn1_test.go:17:15: undefined: max2\n/tmp/tmpq9u91pn1_test.go:18:15: undefined: min2\n/tmp/tmpq9u91pn1_test.go:19:23: undefined: max2\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    max_product := 1\n    min_product := 1\n    max_so_far := 1\n    for _, v := range arr {\n        if v > 0 {\n            max_product = max_product * v\n            min_product = min(min_product * v, 1)\n        } else if v == 0 {\n            max_product = 1\n            min_product = 1\n        } else {\n            temp := max_product\n            max_product = max(min_product * v, 1)\n            min_product = temp * v\n        }\n        if max_so_far < max_product {\n            max_so_far = max_product\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc7_6bh5g_test.go:16:27: undefined: min\n/tmp/tmpc7_6bh5g_test.go:22:27: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_so_far := arr[0]\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_ending_here, min_ending_here = min_ending_here, max_ending_here\n        }\n        max_ending_here = max(arr[i], max_ending_here * arr[i])\n        min_ending_here = min(arr[i], min_ending_here * arr[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1fuql3eh_test.go:20:27: undefined: max\n/tmp/tmp1fuql3eh_test.go:21:27: undefined: min\n/tmp/tmp1fuql3eh_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5z0o6qb7_test.go:25:23: undefined: max\n/tmp/tmp5z0o6qb7_test.go:26:23: undefined: min\n/tmp/tmp5z0o6qb7_test.go:27:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_so_far := arr[0]\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_ending_here = max(arr[i], max_ending_here * arr[i])\n            min_ending_here = min(arr[i], min_ending_here * arr[i])\n        } else {\n            max_ending_here = max(arr[i], min_ending_here * arr[i])\n            min_ending_here = min(arr[i], max_ending_here * arr[i])\n        }\n\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123147,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyulbsj2z_test.go:20:31: undefined: max\n/tmp/tmpyulbsj2z_test.go:21:31: undefined: min\n/tmp/tmpyulbsj2z_test.go:23:31: undefined: max\n/tmp/tmpyulbsj2z_test.go:24:31: undefined: min\n/tmp/tmpyulbsj2z_test.go:27:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwg1x35bi_test.go:17:23: undefined: max\n/tmp/tmpwg1x35bi_test.go:18:23: undefined: min\n/tmp/tmpwg1x35bi_test.go:19:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123147,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7f3p4e5b_test.go:17:23: undefined: max\n/tmp/tmp7f3p4e5b_test.go:18:23: undefined: min\n/tmp/tmp7f3p4e5b_test.go:19:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    max := arr[0]\n    min := arr[0]\n    result := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max, min = min, max\n        }\n        max = max2(arr[i], max * arr[i])\n        min = min2(arr[i], min * arr[i])\n        result = max2(result, max)\n    }\n    return result\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123147,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdl_rg548_test.go:17:15: undefined: max2\n/tmp/tmpdl_rg548_test.go:18:15: undefined: min2\n/tmp/tmpdl_rg548_test.go:19:18: undefined: max2\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_so_far := arr[0]\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_ending_here, min_ending_here = min_ending_here, max_ending_here\n        }\n        max_ending_here = max(arr[i], max_ending_here * arr[i])\n        min_ending_here = min(arr[i], min_ending_here * arr[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1fuql3eh_test.go:20:27: undefined: max\n/tmp/tmp1fuql3eh_test.go:21:27: undefined: min\n/tmp/tmp1fuql3eh_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0r751o6n_test.go:20:23: undefined: max\n/tmp/tmp0r751o6n_test.go:21:23: undefined: min\n/tmp/tmp0r751o6n_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_so_far := arr[0]\n    min_so_far := arr[0]\n    max_ending_here := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_ending_here = max(arr[i], max_ending_here * arr[i])\n            min_so_far = min(arr[i], min_so_far * arr[i])\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(arr[i], min_so_far * arr[i])\n            min_so_far = min(arr[i], tmp * arr[i])\n        }\n\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123147,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgbs93zlu_test.go:20:31: undefined: max\n/tmp/tmpgbs93zlu_test.go:21:26: undefined: min\n/tmp/tmpgbs93zlu_test.go:24:31: undefined: max\n/tmp/tmpgbs93zlu_test.go:25:26: undefined: min\n/tmp/tmpgbs93zlu_test.go:28:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5z0o6qb7_test.go:25:23: undefined: max\n/tmp/tmp5z0o6qb7_test.go:26:23: undefined: min\n/tmp/tmp5z0o6qb7_test.go:27:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = tmp * v\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123147,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpao362xy9_test.go:19:31: undefined: min\n/tmp/tmpao362xy9_test.go:25:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123147,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb29mf3h3_test.go:18:23: undefined: max\n/tmp/tmpb29mf3h3_test.go:19:23: undefined: min\n/tmp/tmpb29mf3h3_test.go:20:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_product = max(max_product * arr[i], arr[i])\n            min_product = min(min_product * arr[i], arr[i])\n        } else {\n            temp := max_product\n            max_product = max(min_product * arr[i], arr[i])\n            min_product = min(temp * arr[i], arr[i])\n        }\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcqa0xm4t_test.go:21:27: undefined: max\n/tmp/tmpcqa0xm4t_test.go:22:27: undefined: min\n/tmp/tmpcqa0xm4t_test.go:25:27: undefined: max\n/tmp/tmpcqa0xm4t_test.go:26:27: undefined: min\n/tmp/tmpcqa0xm4t_test.go:28:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0r751o6n_test.go:20:23: undefined: max\n/tmp/tmp0r751o6n_test.go:21:23: undefined: min\n/tmp/tmp0r751o6n_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9udk9rka_test.go:23:23: undefined: max\n/tmp/tmp9udk9rka_test.go:24:23: undefined: min\n/tmp/tmp9udk9rka_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwg1x35bi_test.go:17:23: undefined: max\n/tmp/tmpwg1x35bi_test.go:18:23: undefined: min\n/tmp/tmpwg1x35bi_test.go:19:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0r751o6n_test.go:20:23: undefined: max\n/tmp/tmp0r751o6n_test.go:21:23: undefined: min\n/tmp/tmp0r751o6n_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max := arr[0]\n    min := arr[0]\n    res := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max, min = min, max\n        }\n\n        max = max2(arr[i], max * arr[i])\n        min = min2(arr[i], min * arr[i])\n\n        res = max2(res, max)\n    }\n\n    return res\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123147,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn1nwtu6c_test.go:23:15: undefined: max2\n/tmp/tmpn1nwtu6c_test.go:24:15: undefined: min2\n/tmp/tmpn1nwtu6c_test.go:26:15: undefined: max2\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpml0z4gtf_test.go:23:23: undefined: max\n/tmp/tmpml0z4gtf_test.go:24:23: undefined: min\n/tmp/tmpml0z4gtf_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    max_product := 1\n    min_product := 1\n    max_so_far := 1\n    for _, v := range arr {\n        if v > 0 {\n            max_product *= v\n            min_product = min(min_product * v, 1)\n        } else if v == 0 {\n            max_product = 1\n            min_product = 1\n        } else {\n            temp := max_product\n            max_product = max(min_product * v, 1)\n            min_product = temp * v\n        }\n        if max_so_far < max_product {\n            max_so_far = max_product\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123147,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0dh5h6pt_test.go:16:27: undefined: min\n/tmp/tmp0dh5h6pt_test.go:22:27: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_so_far := arr[0]\n    min_so_far := arr[0]\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_ending_here = max(arr[i], max_ending_here * arr[i])\n            min_ending_here = min(arr[i], min_ending_here * arr[i])\n        } else {\n            max_ending_here = max(arr[i], min_ending_here * arr[i])\n            min_ending_here = min(arr[i], max_ending_here * arr[i])\n        }\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpopexp527_test.go:19:31: undefined: max\n/tmp/tmpopexp527_test.go:20:31: undefined: min\n/tmp/tmpopexp527_test.go:22:31: undefined: max\n/tmp/tmpopexp527_test.go:23:31: undefined: min\n/tmp/tmpopexp527_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = tmp * v\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123147,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpao362xy9_test.go:19:31: undefined: min\n/tmp/tmpao362xy9_test.go:25:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpatvyzo16_test.go:20:23: undefined: max\n/tmp/tmpatvyzo16_test.go:21:23: undefined: min\n/tmp/tmpatvyzo16_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_so_far := arr[0]\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_ending_here, min_ending_here = min_ending_here, max_ending_here\n        }\n        max_ending_here = max(arr[i], max_ending_here * arr[i])\n        min_ending_here = min(arr[i], min_ending_here * arr[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123147,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqdtt4vpt_test.go:23:27: undefined: max\n/tmp/tmpqdtt4vpt_test.go:24:27: undefined: min\n/tmp/tmpqdtt4vpt_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_so_far := arr[0]\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_ending_here = max(max_ending_here * arr[i], arr[i])\n            min_ending_here = min(min_ending_here * arr[i], arr[i])\n        } else {\n            max_ending_here = max(min_ending_here * arr[i], arr[i])\n            min_ending_here = min(max_ending_here * arr[i], arr[i])\n        }\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123147,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx64lcu47_test.go:21:31: undefined: max\n/tmp/tmpx64lcu47_test.go:22:31: undefined: min\n/tmp/tmpx64lcu47_test.go:24:31: undefined: max\n/tmp/tmpx64lcu47_test.go:25:31: undefined: min\n/tmp/tmpx64lcu47_test.go:27:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_product = max(max_product * arr[i], arr[i])\n            min_product = min(min_product * arr[i], arr[i])\n        } else {\n            tmp := max_product\n            max_product = max(min_product * arr[i], arr[i])\n            min_product = min(tmp * arr[i], arr[i])\n        }\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123147,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_ydtdwrx_test.go:22:27: undefined: max\n/tmp/tmp_ydtdwrx_test.go:23:27: undefined: min\n/tmp/tmp_ydtdwrx_test.go:26:27: undefined: max\n/tmp/tmp_ydtdwrx_test.go:27:27: undefined: min\n/tmp/tmp_ydtdwrx_test.go:29:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max := arr[0]\n    min := arr[0]\n    res := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max, min = min, max\n        }\n\n        max = max_int(arr[i], max * arr[i])\n        min = min_int(arr[i], min * arr[i])\n\n        res = max_int(res, max)\n    }\n\n    return res\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123147,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_qdezcre_test.go:23:15: undefined: max_int\n/tmp/tmp_qdezcre_test.go:24:15: undefined: min_int\n/tmp/tmp_qdezcre_test.go:26:15: undefined: max_int\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    result := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        result = max(max_product, result)\n    }\n    return result\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123147,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpavah30bp_test.go:20:23: undefined: max\n/tmp/tmpavah30bp_test.go:21:23: undefined: min\n/tmp/tmpavah30bp_test.go:22:18: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjxl8oidf_test.go:26:23: undefined: max\n/tmp/tmpjxl8oidf_test.go:27:23: undefined: min\n/tmp/tmpjxl8oidf_test.go:29:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    result := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        result = max(result, max_product)\n    }\n\n    return result\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeqdi84tg_test.go:23:23: undefined: max\n/tmp/tmpeqdi84tg_test.go:24:23: undefined: min\n/tmp/tmpeqdi84tg_test.go:26:18: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max := arr[0]\n    min := arr[0]\n    result := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max, min = min, max\n        }\n\n        max = max_int(arr[i], max * arr[i])\n        min = min_int(arr[i], min * arr[i])\n\n        result = max_int(result, max)\n    }\n\n    return result\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu0xju1ri_test.go:23:15: undefined: max_int\n/tmp/tmpu0xju1ri_test.go:24:15: undefined: min_int\n/tmp/tmpu0xju1ri_test.go:26:18: undefined: max_int\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_so_far := arr[0]\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_ending_here = max(max_ending_here * arr[i], arr[i])\n            min_ending_here = min(min_ending_here * arr[i], arr[i])\n        } else {\n            max_ending_here = max(min_ending_here * arr[i], arr[i])\n            min_ending_here = min(max_ending_here * arr[i], arr[i])\n        }\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123147,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx64lcu47_test.go:21:31: undefined: max\n/tmp/tmpx64lcu47_test.go:22:31: undefined: min\n/tmp/tmpx64lcu47_test.go:24:31: undefined: max\n/tmp/tmpx64lcu47_test.go:25:31: undefined: min\n/tmp/tmpx64lcu47_test.go:27:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpml0z4gtf_test.go:23:23: undefined: max\n/tmp/tmpml0z4gtf_test.go:24:23: undefined: min\n/tmp/tmpml0z4gtf_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0r751o6n_test.go:20:23: undefined: max\n/tmp/tmp0r751o6n_test.go:21:23: undefined: min\n/tmp/tmp0r751o6n_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpatvyzo16_test.go:20:23: undefined: max\n/tmp/tmpatvyzo16_test.go:21:23: undefined: min\n/tmp/tmpatvyzo16_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0r751o6n_test.go:20:23: undefined: max\n/tmp/tmp0r751o6n_test.go:21:23: undefined: min\n/tmp/tmp0r751o6n_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpml0z4gtf_test.go:23:23: undefined: max\n/tmp/tmpml0z4gtf_test.go:24:23: undefined: min\n/tmp/tmpml0z4gtf_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    max_so_far := 1\n    min_so_far := 1\n    max_ending_here := 1\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_so_far = min(min_so_far * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_so_far = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_so_far * v, 1)\n            min_so_far = tmp * v\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123147,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn4mfplox_test.go:16:26: undefined: min\n/tmp/tmpn4mfplox_test.go:22:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_product = max(max_product * arr[i], arr[i])\n            min_product = min(min_product * arr[i], arr[i])\n        } else {\n            temp := max_product\n            max_product = max(min_product * arr[i], arr[i])\n            min_product = min(temp * arr[i], arr[i])\n        }\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123147,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp18hovfqi_test.go:23:27: undefined: max\n/tmp/tmp18hovfqi_test.go:24:27: undefined: min\n/tmp/tmp18hovfqi_test.go:27:27: undefined: max\n/tmp/tmp18hovfqi_test.go:28:27: undefined: min\n/tmp/tmp18hovfqi_test.go:30:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwg1x35bi_test.go:17:23: undefined: max\n/tmp/tmpwg1x35bi_test.go:18:23: undefined: min\n/tmp/tmpwg1x35bi_test.go:19:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0r751o6n_test.go:20:23: undefined: max\n/tmp/tmp0r751o6n_test.go:21:23: undefined: min\n/tmp/tmp0r751o6n_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_so_far := arr[0]\n    min_so_far := arr[0]\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_ending_here = max(arr[i], max_ending_here * arr[i])\n            min_ending_here = min(arr[i], min_ending_here * arr[i])\n        } else {\n            max_ending_here = max(arr[i], min_ending_here * arr[i])\n            min_ending_here = min(arr[i], max_ending_here * arr[i])\n        }\n\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123147,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqd55d_9u_test.go:21:31: undefined: max\n/tmp/tmpqd55d_9u_test.go:22:31: undefined: min\n/tmp/tmpqd55d_9u_test.go:24:31: undefined: max\n/tmp/tmpqd55d_9u_test.go:25:31: undefined: min\n/tmp/tmpqd55d_9u_test.go:28:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0r751o6n_test.go:20:23: undefined: max\n/tmp/tmp0r751o6n_test.go:21:23: undefined: min\n/tmp/tmp0r751o6n_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_so_far := arr[0]\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_ending_here, min_ending_here = min_ending_here, max_ending_here\n        }\n        max_ending_here = max(arr[i], max_ending_here * arr[i])\n        min_ending_here = min(arr[i], min_ending_here * arr[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1fuql3eh_test.go:20:27: undefined: max\n/tmp/tmp1fuql3eh_test.go:21:27: undefined: min\n/tmp/tmp1fuql3eh_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_so_far := arr[0]\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_ending_here = max(max_ending_here * arr[i], arr[i])\n            min_ending_here = min(min_ending_here * arr[i], arr[i])\n        } else {\n            max_ending_here = max(min_ending_here * arr[i], arr[i])\n            min_ending_here = min(max_ending_here * arr[i], arr[i])\n        }\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123147,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7ea2851r_test.go:18:31: undefined: max\n/tmp/tmp7ea2851r_test.go:19:31: undefined: min\n/tmp/tmp7ea2851r_test.go:21:31: undefined: max\n/tmp/tmp7ea2851r_test.go:22:31: undefined: min\n/tmp/tmp7ea2851r_test.go:24:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0r751o6n_test.go:20:23: undefined: max\n/tmp/tmp0r751o6n_test.go:21:23: undefined: min\n/tmp/tmp0r751o6n_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max := arr[0]\n    min := arr[0]\n    res := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max, min = min, max\n        }\n        max = max_int(arr[i], max * arr[i])\n        min = min_int(arr[i], min * arr[i])\n        res = max_int(res, max)\n    }\n    return res\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123147,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpntnzevj0_test.go:20:15: undefined: max_int\n/tmp/tmpntnzevj0_test.go:21:15: undefined: min_int\n/tmp/tmpntnzevj0_test.go:22:15: undefined: max_int\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpml0z4gtf_test.go:23:23: undefined: max\n/tmp/tmpml0z4gtf_test.go:24:23: undefined: min\n/tmp/tmpml0z4gtf_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0r751o6n_test.go:20:23: undefined: max\n/tmp/tmp0r751o6n_test.go:21:23: undefined: min\n/tmp/tmp0r751o6n_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = tmp * v\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123147,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpao362xy9_test.go:19:31: undefined: min\n/tmp/tmpao362xy9_test.go:25:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            min_product, max_product = max_product, min_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123147,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe_ejsjf__test.go:20:23: undefined: max\n/tmp/tmpe_ejsjf__test.go:21:23: undefined: min\n/tmp/tmpe_ejsjf__test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    max := arr[0]\n    min := arr[0]\n    res := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max, min = min, max\n        }\n        max = max_int(arr[i], max * arr[i])\n        min = min_int(arr[i], min * arr[i])\n        res = max_int(res, max)\n    }\n    return res\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123147,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptdjjxql7_test.go:17:15: undefined: max_int\n/tmp/tmptdjjxql7_test.go:18:15: undefined: min_int\n/tmp/tmptdjjxql7_test.go:19:15: undefined: max_int\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjxl8oidf_test.go:26:23: undefined: max\n/tmp/tmpjxl8oidf_test.go:27:23: undefined: min\n/tmp/tmpjxl8oidf_test.go:29:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9udk9rka_test.go:23:23: undefined: max\n/tmp/tmp9udk9rka_test.go:24:23: undefined: min\n/tmp/tmp9udk9rka_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    result := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        result = max(result, max_product)\n    }\n\n    return result\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeqdi84tg_test.go:23:23: undefined: max\n/tmp/tmpeqdi84tg_test.go:24:23: undefined: min\n/tmp/tmpeqdi84tg_test.go:26:18: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_so_far := arr[0]\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_ending_here = max(arr[i], max_ending_here * arr[i])\n            min_ending_here = min(arr[i], min_ending_here * arr[i])\n        } else {\n            max_ending_here = max(arr[i], min_ending_here * arr[i])\n            min_ending_here = min(arr[i], max_ending_here * arr[i])\n        }\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmk78jgff_test.go:18:31: undefined: max\n/tmp/tmpmk78jgff_test.go:19:31: undefined: min\n/tmp/tmpmk78jgff_test.go:21:31: undefined: max\n/tmp/tmpmk78jgff_test.go:22:31: undefined: min\n/tmp/tmpmk78jgff_test.go:24:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_product = max(max_product * arr[i], arr[i])\n            min_product = min(min_product * arr[i], arr[i])\n        } else {\n            tmp := max_product\n            max_product = max(min_product * arr[i], arr[i])\n            min_product = min(tmp * arr[i], arr[i])\n        }\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123147,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps41yro38_test.go:23:27: undefined: max\n/tmp/tmps41yro38_test.go:24:27: undefined: min\n/tmp/tmps41yro38_test.go:27:27: undefined: max\n/tmp/tmps41yro38_test.go:28:27: undefined: min\n/tmp/tmps41yro38_test.go:30:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product, min_product, result := arr[0], arr[0], arr[0]\n    for i := 1; i < len(arr); i++ {\n        a := max_product * arr[i]\n        b := min_product * arr[i]\n        max_product = max(max(a, b), arr[i])\n        min_product = min(min(a, b), arr[i])\n        result = max(max_product, result)\n    }\n    return result\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123147,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpiwoy8qu7_test.go:18:23: undefined: max\n/tmp/tmpiwoy8qu7_test.go:19:23: undefined: min\n/tmp/tmpiwoy8qu7_test.go:20:18: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpml0z4gtf_test.go:23:23: undefined: max\n/tmp/tmpml0z4gtf_test.go:24:23: undefined: min\n/tmp/tmpml0z4gtf_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    max := arr[0]\n    min := arr[0]\n    max_product := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max = max * arr[i]\n            min = min * arr[i]\n        } else {\n            max = min * arr[i]\n            min = max * arr[i]\n        }\n        if max > max_product {\n            max_product = max\n        }\n        if min > max_product {\n            max_product = min\n        }\n        if max < 0 {\n            max = 0\n        }\n        if min > 0 {\n            min = 0\n        }\n    }\n    return max_product\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123148,
      "stdout": "--- FAIL: TestMax_Subarray_Product (0.00s)\n    --- FAIL: TestMax_Subarray_Product/test_num__0 (0.00s)\n        tmpktzyeibb_test.go:52: expected '%!s(int=112)', got '%!s(int=4)'\n    --- FAIL: TestMax_Subarray_Product/test_num__1 (0.00s)\n        tmpktzyeibb_test.go:52: expected '%!s(int=180)', got '%!s(int=54)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnfpojsyc_test.go:23:23: undefined: max\n/tmp/tmpnfpojsyc_test.go:24:23: undefined: min\n/tmp/tmpnfpojsyc_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product, min_product, max_so_far := arr[0], arr[0], arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123149,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd40t5qnm_test.go:18:23: undefined: max\n/tmp/tmpd40t5qnm_test.go:19:23: undefined: min\n/tmp/tmpd40t5qnm_test.go:20:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    result := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        result = max(result, max_product)\n    }\n    return result\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123149,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphptcq1ts_test.go:20:23: undefined: max\n/tmp/tmphptcq1ts_test.go:21:23: undefined: min\n/tmp/tmphptcq1ts_test.go:22:18: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], arr[i] * max_product)\n        min_product = min(arr[i], arr[i] * min_product)\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123149,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprlcxztpm_test.go:23:23: undefined: max\n/tmp/tmprlcxztpm_test.go:24:23: undefined: min\n/tmp/tmprlcxztpm_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5z0o6qb7_test.go:25:23: undefined: max\n/tmp/tmp5z0o6qb7_test.go:26:23: undefined: min\n/tmp/tmp5z0o6qb7_test.go:27:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123149,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpz0agmx0l_test.go:26:23: undefined: max\n/tmp/tmpz0agmx0l_test.go:27:23: undefined: min\n/tmp/tmpz0agmx0l_test.go:29:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product, min_product, max_so_far := arr[0], arr[0], arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123149,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd40t5qnm_test.go:18:23: undefined: max\n/tmp/tmpd40t5qnm_test.go:19:23: undefined: min\n/tmp/tmpd40t5qnm_test.go:20:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0r751o6n_test.go:20:23: undefined: max\n/tmp/tmp0r751o6n_test.go:21:23: undefined: min\n/tmp/tmp0r751o6n_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    max_product := 1\n    min_product := 1\n    max_so_far := 1\n    for _, v := range arr {\n        if v > 0 {\n            max_product = max_product * v\n            min_product = min(min_product * v, 1)\n        } else if v == 0 {\n            max_product = 1\n            min_product = 1\n        } else {\n            tmp := max_product\n            max_product = max(min_product * v, 1)\n            min_product = tmp * v\n        }\n        if max_so_far < max_product {\n            max_so_far = max_product\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123149,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbxufbr8k_test.go:16:27: undefined: min\n/tmp/tmpbxufbr8k_test.go:22:27: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_so_far := arr[0]\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_ending_here, min_ending_here = min_ending_here, max_ending_here\n        }\n        max_ending_here = max(arr[i], max_ending_here * arr[i])\n        min_ending_here = min(arr[i], min_ending_here * arr[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1fuql3eh_test.go:20:27: undefined: max\n/tmp/tmp1fuql3eh_test.go:21:27: undefined: min\n/tmp/tmp1fuql3eh_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0r751o6n_test.go:20:23: undefined: max\n/tmp/tmp0r751o6n_test.go:21:23: undefined: min\n/tmp/tmp0r751o6n_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    max := arr[0]\n    min := arr[0]\n    max_product := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max, min = min, max\n        }\n        max = max2(arr[i], max * arr[i])\n        min = min2(arr[i], min * arr[i])\n        max_product = max2(max_product, max)\n    }\n    return max_product\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq9u91pn1_test.go:17:15: undefined: max2\n/tmp/tmpq9u91pn1_test.go:18:15: undefined: min2\n/tmp/tmpq9u91pn1_test.go:19:23: undefined: max2\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            temp := max_product\n            max_product = min_product\n            min_product = temp\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123149,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfnj81buv_test.go:25:23: undefined: max\n/tmp/tmpfnj81buv_test.go:26:23: undefined: min\n/tmp/tmpfnj81buv_test.go:27:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpml0z4gtf_test.go:23:23: undefined: max\n/tmp/tmpml0z4gtf_test.go:24:23: undefined: min\n/tmp/tmpml0z4gtf_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_ending_here := 1\n    min_ending_here := 1\n    max_so_far := 1\n    for _, v := range arr {\n        if v > 0 {\n            max_ending_here = max_ending_here * v\n            min_ending_here = min(min_ending_here * v, 1)\n        } else if v == 0 {\n            max_ending_here = 1\n            min_ending_here = 1\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_ending_here * v, 1)\n            min_ending_here = tmp * v\n        }\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123147,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpao362xy9_test.go:19:31: undefined: min\n/tmp/tmpao362xy9_test.go:25:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpml0z4gtf_test.go:23:23: undefined: max\n/tmp/tmpml0z4gtf_test.go:24:23: undefined: min\n/tmp/tmpml0z4gtf_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpml0z4gtf_test.go:23:23: undefined: max\n/tmp/tmpml0z4gtf_test.go:24:23: undefined: min\n/tmp/tmpml0z4gtf_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    result := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n\n        result = max(result, max_product)\n    }\n\n    return result\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123149,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzfhg5gso_test.go:23:23: undefined: max\n/tmp/tmpzfhg5gso_test.go:24:23: undefined: min\n/tmp/tmpzfhg5gso_test.go:26:18: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123149,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2yyg2oul_test.go:27:23: undefined: max\n/tmp/tmp2yyg2oul_test.go:28:23: undefined: min\n/tmp/tmp2yyg2oul_test.go:29:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            min_product, max_product = max_product, min_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123149,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptkt62aqz_test.go:26:23: undefined: max\n/tmp/tmptkt62aqz_test.go:27:23: undefined: min\n/tmp/tmptkt62aqz_test.go:29:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpml0z4gtf_test.go:23:23: undefined: max\n/tmp/tmpml0z4gtf_test.go:24:23: undefined: min\n/tmp/tmpml0z4gtf_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    result := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        result = max(result, max_product)\n    }\n    return result\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123149,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphptcq1ts_test.go:20:23: undefined: max\n/tmp/tmphptcq1ts_test.go:21:23: undefined: min\n/tmp/tmphptcq1ts_test.go:22:18: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0r751o6n_test.go:20:23: undefined: max\n/tmp/tmp0r751o6n_test.go:21:23: undefined: min\n/tmp/tmp0r751o6n_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0r751o6n_test.go:20:23: undefined: max\n/tmp/tmp0r751o6n_test.go:21:23: undefined: min\n/tmp/tmp0r751o6n_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max, min, res := arr[0], arr[0], arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max, min = min, max\n        }\n        max = max_int(max * arr[i], arr[i])\n        min = min_int(min * arr[i], arr[i])\n        res = max_int(res, max)\n    }\n    return res\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123149,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpesy2gv3u_test.go:18:15: undefined: max_int\n/tmp/tmpesy2gv3u_test.go:19:15: undefined: min_int\n/tmp/tmpesy2gv3u_test.go:20:15: undefined: max_int\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    result := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        result = max(result, max_product)\n    }\n\n    return result\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeqdi84tg_test.go:23:23: undefined: max\n/tmp/tmpeqdi84tg_test.go:24:23: undefined: min\n/tmp/tmpeqdi84tg_test.go:26:18: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123149,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7163ygdm_test.go:25:23: undefined: max\n/tmp/tmp7163ygdm_test.go:26:23: undefined: min\n/tmp/tmp7163ygdm_test.go:27:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_so_far := arr[0]\n    min_so_far := arr[0]\n    max_ending_here := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_ending_here = max(max_ending_here * arr[i], arr[i])\n            min_so_far = min(min_so_far * arr[i], arr[i])\n        } else {\n            tmp := max_ending_here\n            max_ending_here = max(min_so_far * arr[i], arr[i])\n            min_so_far = min(tmp * arr[i], arr[i])\n        }\n\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123149,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp52imdt63_test.go:20:31: undefined: max\n/tmp/tmp52imdt63_test.go:21:26: undefined: min\n/tmp/tmp52imdt63_test.go:24:31: undefined: max\n/tmp/tmp52imdt63_test.go:25:26: undefined: min\n/tmp/tmp52imdt63_test.go:28:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    max_product := 1\n    min_product := 1\n    max_so_far := 1\n    for _, v := range arr {\n        if v > 0 {\n            max_product *= v\n            min_product = min(min_product * v, 1)\n        } else if v == 0 {\n            max_product = 1\n            min_product = 1\n        } else {\n            temp := max_product\n            max_product = max(min_product * v, 1)\n            min_product = temp * v\n        }\n        if max_so_far < max_product {\n            max_so_far = max_product\n        }\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123147,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0dh5h6pt_test.go:16:27: undefined: min\n/tmp/tmp0dh5h6pt_test.go:22:27: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123149,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpz0agmx0l_test.go:26:23: undefined: max\n/tmp/tmpz0agmx0l_test.go:27:23: undefined: min\n/tmp/tmpz0agmx0l_test.go:29:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp716yhhil_test.go:19:23: undefined: max\n/tmp/tmp716yhhil_test.go:20:23: undefined: min\n/tmp/tmp716yhhil_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_so_far, min_so_far, max_ending_here := arr[0], arr[0], arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_so_far, min_so_far = min_so_far, max_so_far\n        }\n        max_ending_here = max(arr[i], max_ending_here * arr[i])\n        min_so_far = min(min_so_far * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123149,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpz97erml__test.go:18:27: undefined: max\n/tmp/tmpz97erml__test.go:19:22: undefined: min\n/tmp/tmpz97erml__test.go:20:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123149,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprv7u_7d7_test.go:27:23: undefined: max\n/tmp/tmprv7u_7d7_test.go:28:23: undefined: min\n/tmp/tmprv7u_7d7_test.go:29:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpml0z4gtf_test.go:23:23: undefined: max\n/tmp/tmpml0z4gtf_test.go:24:23: undefined: min\n/tmp/tmpml0z4gtf_test.go:25:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123149,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7163ygdm_test.go:25:23: undefined: max\n/tmp/tmp7163ygdm_test.go:26:23: undefined: min\n/tmp/tmp7163ygdm_test.go:27:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(max_product * arr[i], arr[i])\n        min_product = min(min_product * arr[i], arr[i])\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpatvyzo16_test.go:20:23: undefined: max\n/tmp/tmpatvyzo16_test.go:21:23: undefined: min\n/tmp/tmpatvyzo16_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n        max_product = max(arr[i], arr[i] * max_product)\n        min_product = min(arr[i], arr[i] * min_product)\n        max_so_far = max(max_so_far, max_product)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123149,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcjma3bvd_test.go:17:23: undefined: max\n/tmp/tmpcjma3bvd_test.go:18:23: undefined: min\n/tmp/tmpcjma3bvd_test.go:19:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjxl8oidf_test.go:26:23: undefined: max\n/tmp/tmpjxl8oidf_test.go:27:23: undefined: min\n/tmp/tmpjxl8oidf_test.go:29:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_product := arr[0]\n    min_product := arr[0]\n    max_so_far := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_product, min_product = min_product, max_product\n        }\n\n        max_product = max(arr[i], max_product * arr[i])\n        min_product = min(arr[i], min_product * arr[i])\n\n        max_so_far = max(max_so_far, max_product)\n    }\n\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510247,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd8kbbq15_test.go:23:23: undefined: max\n/tmp/tmpd8kbbq15_test.go:24:23: undefined: min\n/tmp/tmpd8kbbq15_test.go:26:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_so_far := arr[0]\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_ending_here, min_ending_here = min_ending_here, max_ending_here\n        }\n        max_ending_here = max(arr[i], max_ending_here * arr[i])\n        min_ending_here = min(arr[i], min_ending_here * arr[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1fuql3eh_test.go:20:27: undefined: max\n/tmp/tmp1fuql3eh_test.go:21:27: undefined: min\n/tmp/tmp1fuql3eh_test.go:22:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_so_far := arr[0]\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_ending_here = max(max_ending_here * arr[i], arr[i])\n            min_ending_here = min(min_ending_here * arr[i], arr[i])\n        } else {\n            max_ending_here = max(min_ending_here * arr[i], arr[i])\n            min_ending_here = min(max_ending_here * arr[i], arr[i])\n        }\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123147,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7ea2851r_test.go:18:31: undefined: max\n/tmp/tmp7ea2851r_test.go:19:31: undefined: min\n/tmp/tmp7ea2851r_test.go:21:31: undefined: max\n/tmp/tmp7ea2851r_test.go:22:31: undefined: min\n/tmp/tmp7ea2851r_test.go:24:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    max_so_far := arr[0]\n    max_ending_here := arr[0]\n    min_ending_here := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > 0 {\n            max_ending_here = max(arr[i], max_ending_here * arr[i])\n            min_ending_here = min(arr[i], min_ending_here * arr[i])\n        } else {\n            max_ending_here = max(arr[i], min_ending_here * arr[i])\n            min_ending_here = min(arr[i], max_ending_here * arr[i])\n        }\n        max_so_far = max(max_so_far, max_ending_here)\n    }\n    return max_so_far\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123145,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmk78jgff_test.go:18:31: undefined: max\n/tmp/tmpmk78jgff_test.go:19:31: undefined: min\n/tmp/tmpmk78jgff_test.go:21:31: undefined: max\n/tmp/tmpmk78jgff_test.go:22:31: undefined: min\n/tmp/tmpmk78jgff_test.go:24:22: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n\n    max_so_far := arr[0]\n    min_so_far := arr[0]\n    result := arr[0]\n\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max_so_far, min_so_far = min_so_far, max_so_far\n        }\n\n        max_so_far = max(arr[i], max_so_far * arr[i])\n        min_so_far = min(arr[i], min_so_far * arr[i])\n\n        result = max(result, max_so_far)\n    }\n\n    return result\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123149,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2g_x3_n__test.go:23:22: undefined: max\n/tmp/tmp2g_x3_n__test.go:24:22: undefined: min\n/tmp/tmp2g_x3_n__test.go:26:18: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_subarray_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr) == 1 {\n        return arr[0]\n    }\n    max := arr[0]\n    min := arr[0]\n    res := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < 0 {\n            max, min = min, max\n        }\n        max = max_int(arr[i], arr[i] * max)\n        min = min_int(arr[i], arr[i] * min)\n        res = max_int(res, max)\n    }\n    return res\n}\n\nfunc TestMax_Subarray_Product(t *testing.T) {\n  candidate := max_subarray_product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, -2, -3, 0, 7, -8, -2}), expected: 112 },\n     { actual: candidate([]int{6, -3, -10, 0, 2}), expected: 180 },\n     { actual: candidate([]int{-2, -40, 0, -2, -3}), expected: 80 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123149,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpf0sb5hra_test.go:23:15: undefined: max_int\n/tmp/tmpf0sb5hra_test.go:24:15: undefined: min_int\n/tmp/tmpf0sb5hra_test.go:25:15: undefined: max_int\n",
      "exit_code": 2,
      "status": "SyntaxError"
    }
  ]
}