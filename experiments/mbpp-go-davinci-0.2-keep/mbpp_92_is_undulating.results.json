{
  "name": "mbpp_92_is_undulating",
  "language": "go_test.go",
  "prompt": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_92_is_undulating.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n\n    var last_digit int\n    var last_diff int\n    for n > 0 {\n        digit := n % 10\n        n /= 10\n        if last_digit != 0 {\n            diff := digit - last_digit\n            if last_diff != 0 && diff != last_diff {\n                return false\n            }\n            last_diff = diff\n        }\n        last_digit = digit\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510018,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpor3pdscb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpor3pdscb_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    prev := n % 10\n    n /= 10\n    curr := n % 10\n    n /= 10\n    for n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var last_digit int\n    var current_digit int\n    var is_undulating bool = true\n    var is_increasing bool = true\n    var is_decreasing bool = true\n\n    for n > 0 {\n        last_digit = current_digit\n        current_digit = n % 10\n        if last_digit > 0 {\n            if is_increasing {\n                is_increasing = current_digit > last_digit\n            }\n            if is_decreasing {\n                is_decreasing = current_digit < last_digit\n            }\n        }\n        n /= 10\n    }\n    is_undulating = is_increasing || is_decreasing\n    return is_undulating\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510018,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpm8h6nfzh_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpm8h6nfzh_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 0; i < len(s) - 2; i++ {\n        if s[i] == s[i+1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510018,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    for n > 99 {\n        if n % 10 != (n / 10) % 10 {\n            return false\n        }\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510018,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpyb7cznsf_test.go:37: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpyb7cznsf_test.go:37: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    var prev, curr, next int\n    prev = n % 10\n    n /= 10\n    curr = n % 10\n    n /= 10\n    for n > 0 {\n        next = n % 10\n        if prev != curr && curr != next && prev != next {\n            return false\n        }\n        prev = curr\n        curr = next\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__1 (0.00s)\n        tmpj91ua59b_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    var prev_digit, curr_digit int\n    for n > 0 {\n        curr_digit = n % 10\n        if prev_digit != 0 {\n            if prev_digit == curr_digit {\n                return false\n            }\n        }\n        prev_digit = curr_digit\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var last_digit int\n    var current_digit int\n    var is_increasing bool\n    var is_decreasing bool\n    var is_undulating bool\n\n    last_digit = n % 10\n    n = n / 10\n    current_digit = n % 10\n    n = n / 10\n\n    if last_digit > current_digit {\n        is_increasing = true\n    } else if last_digit < current_digit {\n        is_decreasing = true\n    }\n\n    for n > 0 {\n        last_digit = current_digit\n        current_digit = n % 10\n        n = n / 10\n\n        if is_increasing {\n            if last_digit < current_digit {\n                return false\n            } else if last_digit > current_digit {\n                is_increasing = false\n                is_decreasing = true\n            }\n        } else if is_decreasing {\n            if last_digit > current_digit {\n                return false\n            } else if last_digit < current_digit {\n                is_decreasing = false\n                is_increasing = true\n            }\n        }\n    }\n\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510017,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpj48iblsa_test.go:14:9: is_undulating declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    var prev_digit, cur_digit int\n    for n > 0 {\n        cur_digit = n % 10\n        if prev_digit != 0 {\n            if prev_digit != cur_digit {\n                return false\n            }\n        }\n        prev_digit = cur_digit\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510018,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpec6643nr_test.go:42: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpec6643nr_test.go:42: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var last_digit, current_digit int\n    for n > 0 {\n        current_digit = n % 10\n        if last_digit != 0 {\n            if last_digit != current_digit {\n                return false\n            }\n        }\n        last_digit = current_digit\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510018,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpcsvym08n_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpcsvym08n_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n == 100 {\n        return true\n    }\n    if n % 10 == 0 {\n        return false\n    }\n    if n % 100 == 0 {\n        return true\n    }\n    if n % 1000 == 0 {\n        return false\n    }\n    if n % 10000 == 0 {\n        return true\n    }\n    if n % 100000 == 0 {\n        return false\n    }\n    if n % 1000000 == 0 {\n        return true\n    }\n    if n % 10000000 == 0 {\n        return false\n    }\n    if n % 100000000 == 0 {\n        return true\n    }\n    if n % 1000000000 == 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510018,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__1 (0.00s)\n        tmpo889y2qf_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    var last_digit, current_digit int\n    for n > 0 {\n        current_digit = n % 10\n        if last_digit != 0 && current_digit != 0 && last_digit != current_digit {\n            return false\n        }\n        last_digit = current_digit\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510018,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmp_5nfrmhe_test.go:40: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmp_5nfrmhe_test.go:40: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 1; i < len(s) - 1; i++ {\n        if s[i-1] == s[i+1] {\n            return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510018,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n == 100 {\n        return true\n    }\n    if n % 10 == 0 {\n        return false\n    }\n    var last_digit int\n    var second_last_digit int\n    for n > 0 {\n        last_digit = n % 10\n        n = n / 10\n        second_last_digit = n % 10\n        if last_digit == second_last_digit {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510018,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n == 1000 {\n        return false\n    }\n    if n == 10000 {\n        return false\n    }\n    if n == 100000 {\n        return false\n    }\n    if n == 1000000 {\n        return false\n    }\n    if n == 10000000 {\n        return false\n    }\n    if n == 100000000 {\n        return false\n    }\n    if n == 1000000000 {\n        return false\n    }\n    if n == 10000000000 {\n        return false\n    }\n    if n == 100000000000 {\n        return false\n    }\n    if n == 1000000000000 {\n        return false\n    }\n    if n == 10000000000000 {\n        return false\n    }\n    if n == 100000000000000 {\n        return false\n    }\n    if n == 1000000000000000 {\n        return false\n    }\n    if n == 10000000000000000 {\n        return false\n    }\n    if n == 100000000000000000 {\n        return false\n    }\n    if n == 1000000000000000000 {\n        return false\n    }\n    if n == 10000000000000000000 {\n        return false\n    }\n    if n == 100000000000000000000 {\n        return false\n    }\n    if n == 1000000000000000000000 {\n        return false\n    }\n    if n == 10000000000000000000000 {\n        return false\n    }\n    if n == 100000000000000000000000 {\n        return false\n    }\n    if n == 1000000000000000000000000 {\n        return false\n    }\n    if n == 10000000000000000000000000 {\n        return false\n    }\n    if n == 100000000000000000000000000 {\n        return false\n    }\n    if n == 1000000000000000000000000000 {\n        return false\n    }\n    if n == 10000000000000000000000000000 {\n        return false\n    }\n    if n == 100000000000000000000000000000 {\n        return false\n    }\n    if n == 1000000000000000000000000000000 {\n        return false\n    }\n    if n == 10000000000000000000000000000000 {\n        return false\n    }\n    if n == 100000000000000000000000000000000 {\n        return false\n    }\n    if n == 1000000000000000000000000000000000 {\n        return false\n    }\n    if n ==\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510017,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcu8dvbtx_test.go:107:6: expected '(', found TestIs_Undulating\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n == 100 {\n        return true\n    }\n    if n % 10 == 0 {\n        return false\n    }\n    if n % 100 == 0 {\n        return true\n    }\n    if n % 1000 == 0 {\n        return false\n    }\n    if n % 10000 == 0 {\n        return true\n    }\n    return false\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510018,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpyinn4dxy_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpyinn4dxy_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n\n    var last_digit int\n    var current_digit int\n    var next_digit int\n\n    for n > 0 {\n        last_digit = current_digit\n        current_digit = next_digit\n        next_digit = n % 10\n\n        if last_digit == next_digit {\n            return true\n        }\n\n        n /= 10\n    }\n\n    return false\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510018,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    for n > 0 {\n        if n % 10 == (n / 10) % 10 {\n            return false\n        }\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510018,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 0; i < len(s) - 2; i++ {\n        if s[i] == s[i + 1] || s[i + 1] == s[i + 2] || s[i] == s[i + 2] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510018,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpj_4ohgm9_test.go:34: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpj_4ohgm9_test.go:34: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 0; i < len(s) - 2; i++ {\n        if s[i] == s[i + 1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510018,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    prev := n % 10\n    n /= 10\n    curr := n % 10\n    n /= 10\n    for n > 0 {\n        if prev != curr {\n            prev = curr\n            curr = n % 10\n            n /= 10\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122564,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    // your code here\n    return false\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122568,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpiyibjpgx_test.go:29: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpiyibjpgx_test.go:29: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.014s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n\n    var last_digit, curr_digit int\n    last_digit = n % 10\n    n /= 10\n    curr_digit = n % 10\n\n    for n > 0 {\n        if last_digit == curr_digit {\n            return false\n        }\n\n        last_digit = curr_digit\n        n /= 10\n        curr_digit = n % 10\n    }\n\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122568,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    prev_digit := n % 10\n    n /= 10\n    curr_digit := n % 10\n    n /= 10\n    for n > 0 {\n        next_digit := n % 10\n        if (prev_digit - curr_digit) * (curr_digit - next_digit) <= 0 {\n            return false\n        }\n        prev_digit = curr_digit\n        curr_digit = next_digit\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122568,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpn6dbnt67_test.go:44: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpn6dbnt67_test.go:44: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var last_digit int\n    var last_diff int\n    for n > 0 {\n        digit := n % 10\n        n /= 10\n        if n > 0 {\n            diff := digit - n % 10\n            if last_diff != 0 && diff != last_diff {\n                return false\n            }\n            last_diff = diff\n        }\n        last_digit = digit\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122568,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuwg8z3uv_test.go:10:9: last_digit declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    var prev_digit, curr_digit int\n    for n > 0 {\n        curr_digit = n % 10\n        if prev_digit == 0 {\n            prev_digit = curr_digit\n        } else if prev_digit == curr_digit {\n            return false\n        } else {\n            prev_digit = curr_digit\n        }\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122568,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 10 {\n        return false\n    }\n    var last_digit, current_digit int\n    for n > 0 {\n        current_digit = n % 10\n        if current_digit == last_digit {\n            return false\n        }\n        last_digit = current_digit\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122568,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 0; i < len(s) - 2; i++ {\n        if s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122559,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpdl2aibzt_test.go:37: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpdl2aibzt_test.go:37: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 0; i < len(s) - 2; i++ {\n        if (s[i] - s[i+1]) * (s[i+1] - s[i+2]) < 0 {\n            return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122568,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmppvotq806_test.go:34: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmppvotq806_test.go:34: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n < 1000 {\n        return n % 10 == (n / 10) % 10\n    }\n    if n < 10000 {\n        return n % 10 == (n / 100) % 10\n    }\n    if n < 100000 {\n        return n % 10 == (n / 1000) % 10\n    }\n    if n < 1000000 {\n        return n % 10 == (n / 10000) % 10\n    }\n    if n < 10000000 {\n        return n % 10 == (n / 100000) % 10\n    }\n    if n < 100000000 {\n        return n % 10 == (n / 1000000) % 10\n    }\n    if n < 1000000000 {\n        return n % 10 == (n / 10000000) % 10\n    }\n    return n % 10 == (n / 100000000) % 10\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122568,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpd13v2us3_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpd13v2us3_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    prev := n % 10\n    n /= 10\n    curr := n % 10\n    n /= 10\n    for n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var last_digit int\n    var current_digit int\n    var is_increasing bool\n    var is_decreasing bool\n\n    for n > 0 {\n        last_digit = current_digit\n        current_digit = n % 10\n        if last_digit == current_digit {\n            return false\n        }\n        if last_digit > current_digit {\n            is_decreasing = true\n        } else {\n            is_increasing = true\n        }\n        if is_increasing && is_decreasing {\n            return false\n        }\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122568,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpnu73_ecz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpnu73_ecz_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    prev := n % 10\n    n /= 10\n    curr := n % 10\n    n /= 10\n    for n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 0; i < len(s) - 2; i++ {\n        if s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122559,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpdl2aibzt_test.go:37: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpdl2aibzt_test.go:37: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var prev, curr int\n    for n > 0 {\n        curr = n % 10\n        if prev != 0 && prev != curr {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122559,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpowu70w6s_test.go:37: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpowu70w6s_test.go:37: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var s string = fmt.Sprintf(\"%d\", n)\n    var l int = len(s)\n    var i int = 0\n    var j int = 1\n    var k int = 2\n    for i < l-2 {\n        if s[i] == s[j] || s[j] == s[k] || s[i] == s[k] {\n            return false\n        }\n        i++\n        j++\n        k++\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122568,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpbhwc4u9b_test.go:41: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpbhwc4u9b_test.go:41: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    prev_digit := n % 10\n    n /= 10\n    curr_digit := n % 10\n    n /= 10\n    for n > 0 {\n        next_digit := n % 10\n        if prev_digit == curr_digit {\n            return false\n        }\n        prev_digit = curr_digit\n        curr_digit = next_digit\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122561,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var last_digit int\n    var current_digit int\n    var next_digit int\n    var is_undulating bool = true\n    var is_increasing bool = true\n    var is_decreasing bool = true\n\n    if n < 10 {\n        return false\n    }\n\n    last_digit = n % 10\n    n = n / 10\n    current_digit = n % 10\n    n = n / 10\n\n    for n > 0 {\n        next_digit = n % 10\n        if next_digit > current_digit {\n            is_decreasing = false\n        } else if next_digit < current_digit {\n            is_increasing = false\n        }\n        if !is_increasing && !is_decreasing {\n            is_undulating = false\n            break\n        }\n        last_digit = current_digit\n        current_digit = next_digit\n        n = n / 10\n    }\n\n    if is_undulating {\n        if last_digit == current_digit {\n            is_undulating = false\n        }\n    }\n\n    return is_undulating\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122568,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmp9y7xz18v_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__1 (0.00s)\n        tmp9y7xz18v_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var prev_digit int\n    var curr_digit int\n    var next_digit int\n    var is_undulating bool = true\n    var is_increasing bool = true\n    var is_decreasing bool = true\n\n    if n < 100 {\n        return false\n    }\n\n    for n > 0 {\n        prev_digit = curr_digit\n        curr_digit = next_digit\n        next_digit = n % 10\n\n        if prev_digit == 0 {\n            continue\n        }\n\n        if is_increasing {\n            if curr_digit > next_digit {\n                is_increasing = false\n            }\n        }\n\n        if is_decreasing {\n            if curr_digit < next_digit {\n                is_decreasing = false\n            }\n        }\n\n        if !is_increasing && !is_decreasing {\n            is_undulating = false\n            break\n        }\n\n        n /= 10\n    }\n\n    return is_undulating\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122568,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpf2kv94xq_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpf2kv94xq_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n == 101 {\n        return true\n    }\n    if n % 10 == 0 {\n        return false\n    }\n    if n % 100 == 0 {\n        return false\n    }\n    if n % 1000 == 0 {\n        return false\n    }\n    if n % 10000 == 0 {\n        return false\n    }\n    if n % 100000 == 0 {\n        return false\n    }\n    if n % 1000000 == 0 {\n        return false\n    }\n    if n % 10000000 == 0 {\n        return false\n    }\n    if n % 100000000 == 0 {\n        return false\n    }\n    if n % 1000000000 == 0 {\n        return false\n    }\n    if n % 10000000000 == 0 {\n        return false\n    }\n    if n % 100000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000000000000 == 0\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122555,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpho1mof7j_test.go:98:6: expected '(', found TestIs_Undulating\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    last_digit := n % 10\n    n = n / 10\n    current_digit := n % 10\n    n = n / 10\n    for n > 0 {\n        next_digit := n % 10\n        if (current_digit - last_digit) * (current_digit - next_digit) >= 0 {\n            return false\n        }\n        last_digit = current_digit\n        current_digit = next_digit\n        n = n / 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122568,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpqxi2ry6o_test.go:44: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpqxi2ry6o_test.go:44: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.011s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    var prev, curr, next int\n    prev = n % 10\n    n /= 10\n    curr = n % 10\n    n /= 10\n    for n > 0 {\n        next = n % 10\n        if prev != curr && curr != next && prev != next {\n            return false\n        }\n        prev = curr\n        curr = next\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__1 (0.00s)\n        tmpj91ua59b_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    prev_digit := n % 10\n    n /= 10\n    curr_digit := n % 10\n    n /= 10\n    for n > 0 {\n        if prev_digit == curr_digit {\n            return false\n        }\n        prev_digit = curr_digit\n        curr_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122561,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n == 1000 {\n        return false\n    }\n    if n == 100 {\n        return true\n    }\n    if n % 10 == 0 {\n        return false\n    }\n    if n % 100 == 0 {\n        return false\n    }\n    if n % 1000 == 0 {\n        return false\n    }\n    if n % 10000 == 0 {\n        return false\n    }\n    if n % 100000 == 0 {\n        return false\n    }\n    if n % 1000000 == 0 {\n        return false\n    }\n    if n % 10000000 == 0 {\n        return false\n    }\n    if n % 100000000 == 0 {\n        return false\n    }\n    if n % 1000000000 == 0 {\n        return false\n    }\n    if n % 10000000000 == 0 {\n        return false\n    }\n    if n % 100000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000000000 == 0 {\n        return false\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122567,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmk3j39po_test.go:99:6: expected '(', found TestIs_Undulating\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var last, current int\n    for n > 0 {\n        current = n % 10\n        if last != 0 {\n            if last != current {\n                return false\n            }\n        }\n        last = current\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122568,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmp_5uuc_nh_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmp_5uuc_nh_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    prev := n % 10\n    n /= 10\n    curr := n % 10\n    n /= 10\n    for n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    var last_digit, current_digit int\n    for n > 0 {\n        current_digit = n % 10\n        if current_digit == last_digit {\n            return false\n        }\n        last_digit = current_digit\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122568,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var last_digit int\n    var current_digit int\n    var is_undulating bool = true\n\n    for n > 0 {\n        current_digit = n % 10\n        if last_digit != 0 {\n            if last_digit == current_digit {\n                is_undulating = false\n                break\n            }\n        }\n        last_digit = current_digit\n        n /= 10\n    }\n\n    return is_undulating\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122568,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    var last_digit, second_last_digit int\n    for n > 0 {\n        last_digit = n % 10\n        n /= 10\n        second_last_digit = n % 10\n        if last_digit == second_last_digit {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122568,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n\n    var prev, curr, next int\n    prev = n % 10\n    n /= 10\n    curr = n % 10\n    n /= 10\n    next = n % 10\n\n    if prev == curr {\n        return false\n    }\n\n    for n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = next\n        next = n % 10\n        n /= 10\n    }\n\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122568,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpqz104a29_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 0; i < len(s) - 2; i++ {\n        if s[i] == s[i + 1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510018,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 0; i < len(s) - 2; i++ {\n        if s[i] == s[i+1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510018,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    prev := n % 10\n    n /= 10\n    curr := n % 10\n    n /= 10\n    for n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var last_digit, current_digit int\n    for n > 0 {\n        current_digit = n % 10\n        if last_digit != 0 && last_digit != current_digit {\n            return false\n        }\n        last_digit = current_digit\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122568,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmp5flk8h_6_test.go:37: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmp5flk8h_6_test.go:37: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    prev := n % 10\n    n /= 10\n    curr := n % 10\n    n /= 10\n    for n > 0 {\n        next := n % 10\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = next\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122561,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    prev := n % 10\n    n /= 10\n    curr := n % 10\n    n /= 10\n    for n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 0; i < len(s) - 2; i++ {\n        if s[i] == s[i + 1] || s[i + 1] == s[i + 2] || s[i] == s[i + 2] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510018,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpj_4ohgm9_test.go:34: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpj_4ohgm9_test.go:34: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 10 {\n        return false\n    }\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 1; i < len(s); i++ {\n        if s[i] == s[i-1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122568,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    prev := n % 10\n    n /= 10\n    curr := n % 10\n    n /= 10\n    for n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n\n    var prev_digit, curr_digit, next_digit int\n    prev_digit = n % 10\n    n /= 10\n    curr_digit = n % 10\n    n /= 10\n    next_digit = n % 10\n\n    if prev_digit == curr_digit {\n        return false\n    }\n\n    for n > 0 {\n        if prev_digit == curr_digit || curr_digit == next_digit {\n            return false\n        }\n\n        prev_digit = curr_digit\n        curr_digit = next_digit\n        n /= 10\n        next_digit = n % 10\n    }\n\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122568,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 0; i < len(s) - 2; i++ {\n        if s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmp9p6chkvr_test.go:34: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmp9p6chkvr_test.go:34: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 0; i < len(s) - 2; i++ {\n        if s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmp9p6chkvr_test.go:34: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmp9p6chkvr_test.go:34: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    prev_digit := n % 10\n    n /= 10\n    curr_digit := n % 10\n    n /= 10\n    for n > 0 {\n        if prev_digit == curr_digit {\n            return false\n        }\n        prev_digit = curr_digit\n        curr_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122561,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 10 {\n        return false\n    }\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 1; i < len(s); i++ {\n        if s[i] == s[i-1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122568,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var last_digit, current_digit int\n    for n > 0 {\n        current_digit = n % 10\n        if last_digit != 0 && last_digit != current_digit {\n            return false\n        }\n        last_digit = current_digit\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122568,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmp5flk8h_6_test.go:37: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmp5flk8h_6_test.go:37: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n\n    previous_digit := n % 10\n    n /= 10\n    current_digit := n % 10\n    n /= 10\n\n    for n > 0 {\n        if previous_digit == current_digit {\n            return false\n        }\n\n        previous_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n    }\n\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122568,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    var last_digit int\n    var last_last_digit int\n    for n > 0 {\n        last_last_digit = last_digit\n        last_digit = n % 10\n        n /= 10\n        if n % 10 != last_digit + last_last_digit {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122569,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpswmgxr_n_test.go:41: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpswmgxr_n_test.go:41: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 10 {\n        return false\n    }\n    var last_digit, curr_digit int\n    for n > 0 {\n        curr_digit = n % 10\n        if curr_digit == last_digit {\n            return false\n        }\n        last_digit = curr_digit\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122569,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    var prev_digit, curr_digit int\n    for n > 0 {\n        curr_digit = n % 10\n        if prev_digit != 0 {\n            if prev_digit == curr_digit {\n                return false\n            }\n        }\n        prev_digit = curr_digit\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    var prev_diff int\n    var curr_diff int\n    prev_diff = n % 10 - (n / 10) % 10\n    for n > 0 {\n        curr_diff = n % 10 - (n / 10) % 10\n        if prev_diff * curr_diff >= 0 {\n            return false\n        }\n        prev_diff = curr_diff\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122570,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmp6nnp99fq_test.go:42: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmp6nnp99fq_test.go:42: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    var last_digit int\n    var last_last_digit int\n    for n > 0 {\n        last_last_digit = last_digit\n        last_digit = n % 10\n        n /= 10\n        if last_digit == last_last_digit {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122570,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var last_digit int\n    var last_diff int\n    for n > 0 {\n        digit := n % 10\n        n /= 10\n        if last_digit != 0 {\n            diff := digit - last_digit\n            if last_diff != 0 && diff != last_diff {\n                return false\n            }\n            last_diff = diff\n        }\n        last_digit = digit\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122570,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpenoslpto_test.go:42: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpenoslpto_test.go:42: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n == 1000 {\n        return false\n    }\n    if n == 10000 {\n        return false\n    }\n    if n == 100000 {\n        return false\n    }\n    if n == 1000000 {\n        return false\n    }\n    if n == 10000000 {\n        return false\n    }\n    if n == 100000000 {\n        return false\n    }\n    if n == 1000000000 {\n        return false\n    }\n    if n == 10000000000 {\n        return false\n    }\n    if n == 100000000000 {\n        return false\n    }\n    if n == 1000000000000 {\n        return false\n    }\n    if n == 10000000000000 {\n        return false\n    }\n    if n == 100000000000000 {\n        return false\n    }\n    if n == 1000000000000000 {\n        return false\n    }\n    if n == 10000000000000000 {\n        return false\n    }\n    if n == 100000000000000000 {\n        return false\n    }\n    if n == 1000000000000000000 {\n        return false\n    }\n    if n == 10000000000000000000 {\n        return false\n    }\n    if n == 100000000000000000000 {\n        return false\n    }\n    if n == 1000000000000000000000 {\n        return false\n    }\n    if n == 10000000000000000000000 {\n        return false\n    }\n    if n == 100000000000000000000000 {\n        return false\n    }\n    if n == 1000000000000000000000000 {\n        return false\n    }\n    if n == 10000000000000000000000000 {\n        return false\n    }\n    if n == 100000000000000000000000000 {\n        return false\n    }\n    if n == 1000000000000000000000000000 {\n        return false\n    }\n    if n == 10000000000000000000000000000 {\n        return false\n    }\n    if n == 100000000000000000000000000000 {\n        return false\n    }\n    if n == 1000000000000000000000000000000 {\n        return false\n    }\n    if n == 10000000000000000000000000000000 {\n        return false\n    }\n    if n == 100000000000000000000000000000000 {\n        return false\n    }\n    if n == 1000000000000000000000000000000000 {\n        return false\n    }\n    if n ==\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510017,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcu8dvbtx_test.go:107:6: expected '(', found TestIs_Undulating\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var last_digit int\n    var current_digit int\n    var is_increasing bool\n    var is_decreasing bool\n    var is_undulating bool\n\n    for n > 0 {\n        last_digit = current_digit\n        current_digit = n % 10\n        n /= 10\n        if last_digit == current_digit {\n            continue\n        }\n        if last_digit > current_digit {\n            is_decreasing = true\n        } else {\n            is_increasing = true\n        }\n        if is_increasing && is_decreasing {\n            is_undulating = true\n            break\n        }\n    }\n    return is_undulating\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122570,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__1 (0.00s)\n        tmpvbhfow15_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 1; i < len(s) - 1; i++ {\n        if s[i] == s[i-1] || s[i] == s[i+1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122570,
      "stdout": "ok  \tcommand-line-arguments\t0.007s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n < 1000 {\n        return n % 10 == n / 100\n    }\n    if n < 10000 {\n        return n % 10 == n / 1000\n    }\n    if n < 100000 {\n        return n % 10 == n / 10000\n    }\n    if n < 1000000 {\n        return n % 10 == n / 100000\n    }\n    if n < 10000000 {\n        return n % 10 == n / 1000000\n    }\n    if n < 100000000 {\n        return n % 10 == n / 10000000\n    }\n    if n < 1000000000 {\n        return n % 10 == n / 100000000\n    }\n    if n < 10000000000 {\n        return n % 10 == n / 1000000000\n    }\n    if n < 100000000000 {\n        return n % 10 == n / 10000000000\n    }\n    if n < 1000000000000 {\n        return n % 10 == n / 100000000000\n    }\n    if n < 10000000000000 {\n        return n % 10 == n / 1000000000000\n    }\n    if n < 100000000000000 {\n        return n % 10 == n / 10000000000000\n    }\n    if n < 1000000000000000 {\n        return n % 10 == n / 100000000000000\n    }\n    if n < 10000000000000000 {\n        return n % 10 == n / 1000000000000000\n    }\n    if n < 100000000000000000 {\n        return n % 10 == n / 10000000000000000\n    }\n    if n < 1000000000000000000 {\n        return n % 10 == n / 100000000000000000\n    }\n    return false\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122570,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__1 (0.00s)\n        tmpzu0b053u_test.go:79: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n == 100 {\n        return true\n    }\n    if n % 10 == 0 {\n        return false\n    }\n    prev := n % 10\n    n /= 10\n    curr := n % 10\n    n /= 10\n    for n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122570,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n == 1000 {\n        return false\n    }\n    if n % 10 == 0 {\n        return false\n    }\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 0; i < len(s) - 2; i++ {\n        if s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122570,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpvnh6xc6m_test.go:43: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpvnh6xc6m_test.go:43: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    prev := n % 10\n    n /= 10\n    curr := n % 10\n    n /= 10\n    for n > 0 {\n        next := n % 10\n        if (prev > curr && curr < next) || (prev < curr && curr > next) {\n            prev = curr\n            curr = next\n            n /= 10\n        } else {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122570,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n == 1000 {\n        return false\n    }\n    if n % 10 == 0 {\n        return false\n    }\n    last_digit := n % 10\n    n /= 10\n    last_digit_diff := n % 10 - last_digit\n    last_digit = n % 10\n    n /= 10\n    for n > 0 {\n        if n % 10 - last_digit != last_digit_diff {\n            return false\n        }\n        last_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122570,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpmiczvidl_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpmiczvidl_test.go:49: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 10 {\n        return false\n    }\n    last := n % 10\n    n /= 10\n    for n > 0 {\n        cur := n % 10\n        if cur == last {\n            return false\n        }\n        last = cur\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122561,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    prev := n % 10\n    n /= 10\n    curr := n % 10\n    n /= 10\n    for n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    digits := []int{}\n    for n > 0 {\n        digits = append(digits, n % 10)\n        n /= 10\n    }\n    for i := 0; i < len(digits) - 2; i++ {\n        if digits[i] == digits[i+1] || digits[i+1] == digits[i+2] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122570,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    var (\n        prev_digit int\n        curr_digit int\n        next_digit int\n        prev_diff int\n        curr_diff int\n    )\n    for n > 0 {\n        prev_digit = curr_digit\n        curr_digit = next_digit\n        next_digit = n % 10\n        n /= 10\n        if prev_digit == 0 {\n            continue\n        }\n        prev_diff = curr_digit - prev_digit\n        curr_diff = next_digit - curr_digit\n        if prev_diff * curr_diff >= 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122570,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    prev := n % 10\n    n /= 10\n    curr := n % 10\n    n /= 10\n    for n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n < 1000 {\n        return n % 10 == (n / 10) % 10\n    }\n    if n < 10000 {\n        return n % 10 == (n / 100) % 10\n    }\n    if n < 100000 {\n        return n % 10 == (n / 1000) % 10\n    }\n    if n < 1000000 {\n        return n % 10 == (n / 10000) % 10\n    }\n    if n < 10000000 {\n        return n % 10 == (n / 100000) % 10\n    }\n    if n < 100000000 {\n        return n % 10 == (n / 1000000) % 10\n    }\n    if n < 1000000000 {\n        return n % 10 == (n / 10000000) % 10\n    }\n    return n % 10 == (n / 100000000) % 10\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122568,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpd13v2us3_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpd13v2us3_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 0; i < len(s) - 2; i++ {\n        if (s[i] - s[i+1]) * (s[i+1] - s[i+2]) < 0 {\n            return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122568,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmppvotq806_test.go:34: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmppvotq806_test.go:34: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var last_digit int\n    var current_digit int\n    var next_digit int\n    var is_undulating bool\n\n    if n < 100 {\n        return false\n    }\n\n    last_digit = n % 10\n    n /= 10\n    current_digit = n % 10\n    n /= 10\n    next_digit = n % 10\n\n    is_undulating = (last_digit == current_digit + 1) || (last_digit == current_digit - 1)\n\n    for n > 0 {\n        last_digit = current_digit\n        current_digit = next_digit\n        next_digit = n % 10\n        n /= 10\n\n        if (last_digit == current_digit + 1) || (last_digit == current_digit - 1) {\n            if is_undulating {\n                return false\n            }\n            is_undulating = true\n        } else {\n            if !is_undulating {\n                return false\n            }\n            is_undulating = false\n        }\n    }\n\n    return is_undulating\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122570,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpket6i5aq_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpket6i5aq_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    var prev, curr int\n    for n > 0 {\n        curr = n % 10\n        if prev != 0 && prev != curr {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122559,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpca5c1hi2_test.go:40: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpca5c1hi2_test.go:40: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    prev_digit := n % 10\n    n /= 10\n    curr_digit := n % 10\n    n /= 10\n    for n > 0 {\n        if prev_digit == curr_digit {\n            return false\n        }\n        prev_digit = curr_digit\n        curr_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122561,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 10 {\n        return false\n    }\n    var last_digit, current_digit int\n    for n > 0 {\n        current_digit = n % 10\n        if last_digit != 0 && last_digit != current_digit {\n            return false\n        }\n        last_digit = current_digit\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122570,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmp4e5obdsb_test.go:40: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmp4e5obdsb_test.go:40: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 10 {\n        return false\n    }\n    last_digit := n % 10\n    n /= 10\n    last_diff := 0\n    for n > 0 {\n        digit := n % 10\n        diff := digit - last_digit\n        if diff == 0 {\n            return false\n        }\n        if last_diff != 0 && diff != last_diff {\n            return false\n        }\n        last_diff = diff\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122570,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpa1_q8h5h_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpa1_q8h5h_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n\n    var prev_digit, curr_digit, next_digit int\n    prev_digit = n % 10\n    n /= 10\n    curr_digit = n % 10\n    n /= 10\n    next_digit = n % 10\n\n    for n > 0 {\n        if prev_digit == curr_digit || curr_digit == next_digit {\n            return false\n        }\n\n        prev_digit = curr_digit\n        curr_digit = next_digit\n        n /= 10\n        next_digit = n % 10\n    }\n\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122570,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    last := n % 10\n    n /= 10\n    for n > 0 {\n        if n % 10 == last {\n            return false\n        }\n        last = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122570,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    prev := n % 10\n    n /= 10\n    curr := n % 10\n    n /= 10\n    for n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n\n    var last_digit int\n    var last_last_digit int\n    for n > 0 {\n        last_last_digit = last_digit\n        last_digit = n % 10\n        n /= 10\n        if last_digit == last_last_digit {\n            return false\n        }\n    }\n\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122570,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var prev, curr int\n    for n > 0 {\n        curr = n % 10\n        if prev != 0 && prev != curr {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122559,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpowu70w6s_test.go:37: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpowu70w6s_test.go:37: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    prev := n % 10\n    n /= 10\n    cur := n % 10\n    n /= 10\n    for n > 0 {\n        if prev == cur {\n            return false\n        }\n        prev = cur\n        cur = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 10 {\n        return false\n    }\n    var prev, curr int\n    for n > 0 {\n        prev = curr\n        curr = n % 10\n        if prev == curr {\n            return false\n        }\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122570,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var last_digit int\n    var current_digit int\n    var is_increasing bool\n    var is_decreasing bool\n    var is_undulating bool\n\n    last_digit = n % 10\n    n = n / 10\n    current_digit = n % 10\n    n = n / 10\n\n    if last_digit > current_digit {\n        is_increasing = true\n    } else if last_digit < current_digit {\n        is_decreasing = true\n    }\n\n    for n > 0 {\n        last_digit = current_digit\n        current_digit = n % 10\n        n = n / 10\n\n        if is_increasing && current_digit > last_digit {\n            is_undulating = true\n            break\n        } else if is_decreasing && current_digit < last_digit {\n            is_undulating = true\n            break\n        }\n    }\n\n    return is_undulating\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122570,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__1 (0.00s)\n        tmpcerrs8e5_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    var prev, curr int\n    for n > 0 {\n        curr = n % 10\n        n /= 10\n        if curr == prev {\n            return false\n        }\n        prev = curr\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122570,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n\n    prev_d := n % 10\n    n /= 10\n    d := n % 10\n    n /= 10\n\n    if d > prev_d {\n        for n > 0 {\n            prev_d = d\n            d = n % 10\n            n /= 10\n\n            if d > prev_d {\n                return false\n            }\n        }\n    } else {\n        for n > 0 {\n            prev_d = d\n            d = n % 10\n            n /= 10\n\n            if d < prev_d {\n                return false\n            }\n        }\n    }\n\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122571,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmp2b5mj010_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__1 (0.00s)\n        tmp2b5mj010_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n == 1000 {\n        return false\n    }\n    if n % 10 == 0 {\n        return false\n    }\n    if n % 100 == 0 {\n        return false\n    }\n    if n % 1000 == 0 {\n        return false\n    }\n    if n % 10000 == 0 {\n        return false\n    }\n    if n % 100000 == 0 {\n        return false\n    }\n    if n % 1000000 == 0 {\n        return false\n    }\n    if n % 10000000 == 0 {\n        return false\n    }\n    if n % 100000000 == 0 {\n        return false\n    }\n    if n % 1000000000 == 0 {\n        return false\n    }\n    if n % 10000000000 == 0 {\n        return false\n    }\n    if n % 100000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000000000000 == 0\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122555,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxsdcx82b_test.go:98:6: expected '(', found TestIs_Undulating\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var last_digit int\n    var current_digit int\n    var is_increasing bool\n    var is_decreasing bool\n    var is_undulating bool\n\n    last_digit = n % 10\n    n = n / 10\n    current_digit = n % 10\n\n    if last_digit > current_digit {\n        is_decreasing = true\n    } else if last_digit < current_digit {\n        is_increasing = true\n    }\n\n    for n > 0 {\n        last_digit = current_digit\n        n = n / 10\n        current_digit = n % 10\n\n        if last_digit > current_digit {\n            if is_decreasing {\n                return false\n            }\n            is_increasing = false\n            is_decreasing = true\n        } else if last_digit < current_digit {\n            if is_increasing {\n                return false\n            }\n            is_decreasing = false\n            is_increasing = true\n        }\n    }\n\n    if is_increasing || is_decreasing {\n        is_undulating = true\n    }\n\n    return is_undulating\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122571,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmp1ceht8kp_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmp1ceht8kp_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    digits := []int{}\n    for n > 0 {\n        digits = append(digits, n % 10)\n        n /= 10\n    }\n    for i := 0; i < len(digits) - 2; i++ {\n        if digits[i] == digits[i + 1] || digits[i + 1] == digits[i + 2] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122572,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var last_digit int\n    var current_digit int\n    var is_increasing bool\n    var is_decreasing bool\n    var is_undulating bool\n\n    if n < 10 {\n        return false\n    }\n\n    last_digit = n % 10\n    n = n / 10\n    current_digit = n % 10\n    is_increasing = current_digit > last_digit\n    is_decreasing = current_digit < last_digit\n    is_undulating = is_increasing || is_decreasing\n\n    for n > 0 {\n        last_digit = current_digit\n        n = n / 10\n        current_digit = n % 10\n\n        if is_increasing && current_digit < last_digit {\n            is_increasing = false\n            is_decreasing = true\n        } else if is_decreasing && current_digit > last_digit {\n            is_decreasing = false\n            is_increasing = true\n        } else if !is_increasing && !is_decreasing {\n            return false\n        }\n    }\n\n    return is_undulating\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122572,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__1 (0.00s)\n        tmp4oq74ct7_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.009s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    prev := n % 10\n    n /= 10\n    curr := n % 10\n    n /= 10\n    for n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    var prev_digit, curr_digit int\n    for n > 0 {\n        curr_digit = n % 10\n        if prev_digit == curr_digit {\n            return false\n        }\n        prev_digit = curr_digit\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122572,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 0; i < len(s) - 2; i++ {\n        if s[i] == s[i + 1] || s[i + 1] == s[i + 2] || s[i] == s[i + 2] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510018,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpj_4ohgm9_test.go:34: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpj_4ohgm9_test.go:34: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    prev := n % 10\n    n /= 10\n    curr := n % 10\n    n /= 10\n    for n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n == 1000 {\n        return false\n    }\n    if n % 10 == 0 {\n        return false\n    }\n    if n % 100 == 0 {\n        return false\n    }\n    if n % 1000 == 0 {\n        return false\n    }\n    if n % 10000 == 0 {\n        return false\n    }\n    if n % 100000 == 0 {\n        return false\n    }\n    if n % 1000000 == 0 {\n        return false\n    }\n    if n % 10000000 == 0 {\n        return false\n    }\n    if n % 100000000 == 0 {\n        return false\n    }\n    if n % 1000000000 == 0 {\n        return false\n    }\n    if n % 10000000000 == 0 {\n        return false\n    }\n    if n % 100000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000000000000 == 0\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122555,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxsdcx82b_test.go:98:6: expected '(', found TestIs_Undulating\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    last := n % 10\n    n /= 10\n    for n > 0 {\n        if n % 10 == last {\n            return false\n        }\n        last = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122570,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var last_digit int\n    var last_digit_type int\n    for n > 0 {\n        digit := n % 10\n        if last_digit != 0 {\n            if last_digit_type == 0 {\n                if last_digit > digit {\n                    last_digit_type = 1\n                } else if last_digit < digit {\n                    last_digit_type = -1\n                } else {\n                    return false\n                }\n            } else if last_digit_type == 1 {\n                if last_digit < digit {\n                    last_digit_type = -1\n                } else if last_digit == digit {\n                    return false\n                }\n            } else if last_digit_type == -1 {\n                if last_digit > digit {\n                    last_digit_type = 1\n                } else if last_digit == digit {\n                    return false\n                }\n            }\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122572,
      "stdout": "ok  \tcommand-line-arguments\t0.012s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    var prev, curr, next int\n    prev = n % 10\n    n /= 10\n    curr = n % 10\n    n /= 10\n    for n > 0 {\n        next = n % 10\n        if prev != curr && curr != next && prev != next {\n            return false\n        }\n        prev = curr\n        curr = next\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__1 (0.00s)\n        tmpj91ua59b_test.go:45: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n == 1000 {\n        return false\n    }\n    if n == 100 {\n        return true\n    }\n    if n % 10 == 0 {\n        return false\n    }\n    if n % 100 == 0 {\n        return false\n    }\n    if n % 1000 == 0 {\n        return false\n    }\n    if n % 10000 == 0 {\n        return false\n    }\n    if n % 100000 == 0 {\n        return false\n    }\n    if n % 1000000 == 0 {\n        return false\n    }\n    if n % 10000000 == 0 {\n        return false\n    }\n    if n % 100000000 == 0 {\n        return false\n    }\n    if n % 1000000000 == 0 {\n        return false\n    }\n    if n % 10000000000 == 0 {\n        return false\n    }\n    if n % 100000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000000000 == 0 {\n        return false\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122567,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmk3j39po_test.go:99:6: expected '(', found TestIs_Undulating\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n\n    var prev, curr, next int\n    for n > 0 {\n        next = n % 10\n        n /= 10\n        curr = n % 10\n        n /= 10\n        prev = n % 10\n        n /= 10\n\n        if prev == curr || curr == next {\n            return false\n        }\n    }\n\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122572,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpj6ezwwie_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    digits := []int{}\n    for n > 0 {\n        digits = append(digits, n % 10)\n        n /= 10\n    }\n    for i := 0; i < len(digits) - 2; i++ {\n        if digits[i] == digits[i + 2] {\n            return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122559,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var prev, curr, next int\n    for n > 0 {\n        prev = curr\n        curr = next\n        next = n % 10\n        if prev != 0 && curr != 0 && next != 0 {\n            if (curr > prev && curr > next) || (curr < prev && curr < next) {\n                return true\n            }\n        }\n        n /= 10\n    }\n    return false\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122572,
      "stdout": "ok  \tcommand-line-arguments\t0.019s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n == 100 {\n        return true\n    }\n    if n % 10 == 0 {\n        return false\n    }\n    if n % 100 == 0 {\n        return true\n    }\n    if n % 1000 == 0 {\n        return false\n    }\n    if n % 10000 == 0 {\n        return true\n    }\n    if n % 100000 == 0 {\n        return false\n    }\n    if n % 1000000 == 0 {\n        return true\n    }\n    if n % 10000000 == 0 {\n        return false\n    }\n    if n % 100000000 == 0 {\n        return true\n    }\n    if n % 1000000000 == 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510018,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__1 (0.00s)\n        tmpo889y2qf_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 0; i < len(s) - 2; i++ {\n        if s[i] == s[i + 1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122572,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    var prev_digit, digit, prev_diff int\n    for n > 0 {\n        digit = n % 10\n        if prev_digit != 0 {\n            diff := digit - prev_digit\n            if prev_diff != 0 && diff != prev_diff {\n                return false\n            }\n            prev_diff = diff\n        }\n        prev_digit = digit\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122572,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpntllnf1v_test.go:44: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpntllnf1v_test.go:44: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n == 101 {\n        return true\n    }\n    if n % 10 == 0 {\n        return false\n    }\n    if n % 100 == 0 {\n        return false\n    }\n    if n % 1000 == 0 {\n        return false\n    }\n    if n % 10000 == 0 {\n        return false\n    }\n    if n % 100000 == 0 {\n        return false\n    }\n    if n % 1000000 == 0 {\n        return false\n    }\n    if n % 10000000 == 0 {\n        return false\n    }\n    if n % 100000000 == 0 {\n        return false\n    }\n    if n % 1000000000 == 0 {\n        return false\n    }\n    if n % 10000000000 == 0 {\n        return false\n    }\n    if n % 100000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000000000000 == 0\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122555,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpho1mof7j_test.go:98:6: expected '(', found TestIs_Undulating\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 0; i < len(s) - 2; i++ {\n        if s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122559,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpdl2aibzt_test.go:37: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpdl2aibzt_test.go:37: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    n_str := fmt.Sprintf(\"%d\", n)\n    for i := 0; i < len(n_str)-1; i++ {\n        if n_str[i] == n_str[i+1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122572,
      "stdout": "ok  \tcommand-line-arguments\t0.009s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    s := fmt.Sprintf(\"%d\", n)\n    if len(s) < 3 {\n        return false\n    }\n    for i := 0; i < len(s) - 2; i++ {\n        if s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122572,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpphqjwvni_test.go:37: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpphqjwvni_test.go:37: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    last_digit := n % 10\n    n /= 10\n    second_last_digit := n % 10\n    n /= 10\n    for n > 0 {\n        if (last_digit - second_last_digit) * (second_last_digit - n % 10) < 0 {\n            return false\n        }\n        last_digit = second_last_digit\n        second_last_digit = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122572,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpbv9sj_n5_test.go:43: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__1 (0.00s)\n        tmpbv9sj_n5_test.go:43: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpbv9sj_n5_test.go:43: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 1; i < len(s) - 1; i++ {\n        if s[i] == s[i - 1] || s[i] == s[i + 1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122561,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    prev := n % 10\n    n /= 10\n    curr := n % 10\n    n /= 10\n    for n > 0 {\n        if curr == prev {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122559,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n % 10 == n / 10 % 10 {\n        return false\n    }\n    for n /= 10; n > 0; n /= 10 {\n        if n % 10 == n / 10 % 10 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122572,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var prev, curr int\n    for n > 0 {\n        curr = n % 10\n        if prev != 0 && prev != curr {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122559,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpowu70w6s_test.go:37: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpowu70w6s_test.go:37: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n == 100 {\n        return true\n    }\n    if n % 10 == 0 {\n        return false\n    }\n    if n % 100 == 0 {\n        return false\n    }\n    if n % 1000 == 0 {\n        return false\n    }\n    if n % 10000 == 0 {\n        return false\n    }\n    if n % 100000 == 0 {\n        return false\n    }\n    if n % 1000000 == 0 {\n        return false\n    }\n    if n % 10000000 == 0 {\n        return false\n    }\n    if n % 100000000 == 0 {\n        return false\n    }\n    if n % 1000000000 == 0 {\n        return false\n    }\n    if n % 10000000000 == 0 {\n        return false\n    }\n    if n % 100000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000000000000 == 0\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptbmursnb_test.go:98:6: expected '(', found TestIs_Undulating\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    var prev_digit, curr_digit int\n    for n > 0 {\n        curr_digit = n % 10\n        if curr_digit == prev_digit {\n            return false\n        }\n        prev_digit = curr_digit\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122572,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    d1 := n % 10\n    n /= 10\n    d2 := n % 10\n    n /= 10\n    for n > 0 {\n        if d1 != d2 {\n            return false\n        }\n        d1 = d2\n        d2 = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122572,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpszg6j907_test.go:43: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpszg6j907_test.go:43: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n < 1000 {\n        return n % 10 == (n / 10) % 10\n    }\n    if n < 10000 {\n        return n % 10 == (n / 100) % 10\n    }\n    if n < 100000 {\n        return n % 10 == (n / 1000) % 10\n    }\n    if n < 1000000 {\n        return n % 10 == (n / 10000) % 10\n    }\n    if n < 10000000 {\n        return n % 10 == (n / 100000) % 10\n    }\n    if n < 100000000 {\n        return n % 10 == (n / 1000000) % 10\n    }\n    if n < 1000000000 {\n        return n % 10 == (n / 10000000) % 10\n    }\n    return n % 10 == (n / 100000000) % 10\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122568,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpd13v2us3_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpd13v2us3_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 10 {\n        return false\n    }\n    var prev, curr int\n    prev = n % 10\n    n /= 10\n    curr = n % 10\n    n /= 10\n    for n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122572,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 0; i < len(s) - 2; i++ {\n        if s[i] == s[i+1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510018,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    prev := n % 10\n    n /= 10\n    curr := n % 10\n    n /= 10\n    for n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 10 {\n        return false\n    }\n    last_digit := n % 10\n    n /= 10\n    for n > 0 {\n        digit := n % 10\n        if digit == last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122557,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 10 {\n        return false\n    }\n    var prev_digit, curr_digit int\n    for n > 0 {\n        curr_digit = n % 10\n        if prev_digit != 0 && prev_digit != curr_digit {\n            return false\n        }\n        prev_digit = curr_digit\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122572,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpgcez8ct5_test.go:40: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpgcez8ct5_test.go:40: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var prev, curr int\n    for n > 0 {\n        curr = n % 10\n        if prev != 0 && prev != curr {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122559,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpowu70w6s_test.go:37: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpowu70w6s_test.go:37: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var last_digit int\n    var current_digit int\n    var is_increasing bool\n    var is_decreasing bool\n    var is_undulating bool\n\n    last_digit = n % 10\n    n = n / 10\n\n    for n > 0 {\n        current_digit = n % 10\n\n        if current_digit > last_digit {\n            is_increasing = true\n        } else if current_digit < last_digit {\n            is_decreasing = true\n        }\n\n        if is_increasing && is_decreasing {\n            is_undulating = true\n            break\n        }\n\n        last_digit = current_digit\n        n = n / 10\n    }\n\n    return is_undulating\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122572,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__1 (0.00s)\n        tmp_ms_hbob_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 10 {\n        return false\n    }\n    var prev, curr int\n    for n > 0 {\n        prev = curr\n        curr = n % 10\n        if prev == curr {\n            return false\n        }\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122570,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n\n    digits := []int{}\n    for n > 0 {\n        digits = append(digits, n % 10)\n        n /= 10\n    }\n\n    for i := 0; i < len(digits) - 2; i++ {\n        if digits[i] == digits[i + 1] || digits[i + 1] == digits[i + 2] {\n            return false\n        }\n    }\n\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122572,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 0; i < len(s) - 2; i++ {\n        if s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmp9p6chkvr_test.go:34: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmp9p6chkvr_test.go:34: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    prev_digit := n % 10\n    n /= 10\n    curr_digit := n % 10\n    n /= 10\n    for n > 0 {\n        next_digit := n % 10\n        if prev_digit == curr_digit {\n            return false\n        }\n        prev_digit = curr_digit\n        curr_digit = next_digit\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122561,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 0; i < len(s) - 2; i++ {\n        if s[i] == s[i+1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510018,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n\n    prev_digit := n % 10\n    n /= 10\n    curr_digit := n % 10\n    n /= 10\n\n    for n > 0 {\n        if prev_digit == curr_digit {\n            return false\n        }\n\n        prev_digit = curr_digit\n        curr_digit = n % 10\n        n /= 10\n    }\n\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122572,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n < 1000 {\n        return n % 10 == (n / 10) % 10\n    }\n    if n < 10000 {\n        return n % 10 == (n / 100) % 10\n    }\n    if n < 100000 {\n        return n % 10 == (n / 1000) % 10\n    }\n    if n < 1000000 {\n        return n % 10 == (n / 10000) % 10\n    }\n    if n < 10000000 {\n        return n % 10 == (n / 100000) % 10\n    }\n    if n < 100000000 {\n        return n % 10 == (n / 1000000) % 10\n    }\n    if n < 1000000000 {\n        return n % 10 == (n / 10000000) % 10\n    }\n    return n % 10 == (n / 100000000) % 10\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122568,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpd13v2us3_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpd13v2us3_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    prev := n % 10\n    n /= 10\n    curr := n % 10\n    n /= 10\n    for n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    var last_digit int\n    var current_digit int\n    var next_digit int\n    for n > 0 {\n        last_digit = current_digit\n        current_digit = next_digit\n        next_digit = n % 10\n        n /= 10\n        if last_digit != 0 && current_digit != next_digit {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122572,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpr5hgywwv_test.go:43: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpr5hgywwv_test.go:43: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n\n    // convert to string\n    s := fmt.Sprintf(\"%d\", n)\n\n    // check if the string is undulating\n    for i := 0; i < len(s) - 2; i++ {\n        if s[i] != s[i+2] {\n            return false\n        }\n    }\n\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122572,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 10 {\n        return false\n    }\n    last := n % 10\n    n /= 10\n    for n > 0 {\n        cur := n % 10\n        if cur == last {\n            return false\n        }\n        last = cur\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122561,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    s := fmt.Sprintf(\"%d\", n)\n    if len(s) < 3 {\n        return false\n    }\n    for i := 1; i < len(s) - 1; i++ {\n        if (s[i-1] < s[i] && s[i] > s[i+1]) || (s[i-1] > s[i] && s[i] < s[i+1]) {\n            return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122573,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 0 {\n        return false\n    }\n    if n < 10 {\n        return true\n    }\n    var last_digit int\n    var last_last_digit int\n    for n > 0 {\n        last_last_digit = last_digit\n        last_digit = n % 10\n        if last_digit == last_last_digit {\n            return false\n        }\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122573,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 10 {\n        return false\n    }\n    prev := n % 10\n    n /= 10\n    cur := n % 10\n    n /= 10\n    for n > 0 {\n        next := n % 10\n        if (prev > cur && cur < next) || (prev < cur && cur > next) {\n            prev = cur\n            cur = next\n            n /= 10\n            continue\n        }\n        return false\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122575,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 0; i < len(s) - 2; i++ {\n        if s[i] != s[i+2] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122575,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n == 101 {\n        return true\n    }\n    if n == 111 {\n        return true\n    }\n    if n == 121 {\n        return true\n    }\n    if n == 131 {\n        return true\n    }\n    if n == 141 {\n        return true\n    }\n    if n == 151 {\n        return true\n    }\n    if n == 161 {\n        return true\n    }\n    if n == 171 {\n        return true\n    }\n    if n == 181 {\n        return true\n    }\n    if n == 191 {\n        return true\n    }\n    if n == 202 {\n        return true\n    }\n    if n == 212 {\n        return true\n    }\n    if n == 222 {\n        return true\n    }\n    if n == 232 {\n        return true\n    }\n    if n == 242 {\n        return true\n    }\n    if n == 252 {\n        return true\n    }\n    if n == 262 {\n        return true\n    }\n    if n == 272 {\n        return true\n    }\n    if n == 282 {\n        return true\n    }\n    if n == 292 {\n        return true\n    }\n    if n == 303 {\n        return true\n    }\n    if n == 313 {\n        return true\n    }\n    if n == 323 {\n        return true\n    }\n    if n == 333 {\n        return true\n    }\n    if n == 343 {\n        return true\n    }\n    if n == 353 {\n        return true\n    }\n    if n == 363 {\n        return true\n    }\n    if n == 373 {\n        return true\n    }\n    if n == 383 {\n        return true\n    }\n    if n == 393 {\n        return true\n    }\n    if n == 404 {\n        return true\n    }\n    if n == 414 {\n        return true\n    }\n    if n == 424 {\n        return true\n    }\n    if n == 434 {\n        return true\n    }\n    if n == 444 {\n        return true\n    }\n    if n == 4\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122574,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnzyrlphx_test.go:119:6: expected '(', found TestIs_Undulating\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var prev_digit, curr_digit int\n    for n > 0 {\n        curr_digit = n % 10\n        if curr_digit == prev_digit {\n            return false\n        }\n        prev_digit = curr_digit\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122575,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var prev, curr, next int\n    for n > 0 {\n        prev = curr\n        curr = next\n        next = n % 10\n        if prev != 0 && curr != 0 && next != 0 &&\n            (curr > prev && curr > next || curr < prev && curr < next) {\n            return false\n        }\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122575,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpisi_khfx_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__1 (0.00s)\n        tmpisi_khfx_test.go:39: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpisi_khfx_test.go:39: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 10 {\n        return false\n    }\n    var last_digit int\n    var last_diff int\n    for n > 0 {\n        digit := n % 10\n        if last_digit != 0 {\n            diff := digit - last_digit\n            if last_diff != 0 && diff != last_diff {\n                return false\n            }\n            last_diff = diff\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122575,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmppiuqdz6i_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmppiuqdz6i_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n == 1000 {\n        return false\n    }\n    if n == 100 {\n        return true\n    }\n    if n % 10 == 0 {\n        return false\n    }\n    if n % 100 == 0 {\n        return false\n    }\n    if n % 1000 == 0 {\n        return false\n    }\n    if n % 10000 == 0 {\n        return false\n    }\n    if n % 100000 == 0 {\n        return false\n    }\n    if n % 1000000 == 0 {\n        return false\n    }\n    if n % 10000000 == 0 {\n        return false\n    }\n    if n % 100000000 == 0 {\n        return false\n    }\n    if n % 1000000000 == 0 {\n        return false\n    }\n    if n % 10000000000 == 0 {\n        return false\n    }\n    if n % 100000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000000000 == 0 {\n        return false\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122567,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmk3j39po_test.go:99:6: expected '(', found TestIs_Undulating\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    var prev, curr int\n    for n > 0 {\n        prev = curr\n        curr = n % 10\n        n /= 10\n        if prev == curr {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122575,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n == 1000 {\n        return false\n    }\n    if n % 10 == 0 {\n        return false\n    }\n    prev := n % 10\n    n /= 10\n    cur := n % 10\n    n /= 10\n    for n > 0 {\n        if cur == prev {\n            return false\n        }\n        prev = cur\n        cur = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122575,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 0; i < len(s) - 2; i++ {\n        if s[i] == s[i+1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510018,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 10 {\n        return false\n    }\n    var prev_digit, cur_digit int\n    for n > 0 {\n        cur_digit = n % 10\n        if prev_digit != 0 && prev_digit != cur_digit {\n            return false\n        }\n        prev_digit = cur_digit\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122575,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmp6fz7j1_p_test.go:40: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmp6fz7j1_p_test.go:40: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 0; i < len(s) - 2; i++ {\n        if s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmp9p6chkvr_test.go:34: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmp9p6chkvr_test.go:34: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n == 1000 {\n        return false\n    }\n    if n % 10 == 0 {\n        return false\n    }\n    if n % 100 == 0 {\n        return false\n    }\n    if n % 1000 == 0 {\n        return false\n    }\n    if n % 10000 == 0 {\n        return false\n    }\n    if n % 100000 == 0 {\n        return false\n    }\n    if n % 1000000 == 0 {\n        return false\n    }\n    if n % 10000000 == 0 {\n        return false\n    }\n    if n % 100000000 == 0 {\n        return false\n    }\n    if n % 1000000000 == 0 {\n        return false\n    }\n    if n % 10000000000 == 0 {\n        return false\n    }\n    if n % 100000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000000000000 == 0\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122555,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxsdcx82b_test.go:98:6: expected '(', found TestIs_Undulating\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n == 100 {\n        return true\n    }\n    if n % 10 == 0 {\n        return false\n    }\n    return is_undulating(n / 10)\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122575,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpc9539q82_test.go:37: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpc9539q82_test.go:37: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.011s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 0; i < len(s) - 2; i++ {\n        if s[i] == s[i+1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510018,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n == 1000 {\n        return false\n    }\n    if n % 10 == 0 {\n        return false\n    }\n    if n % 100 == 0 {\n        return false\n    }\n    if n % 1000 == 0 {\n        return false\n    }\n    if n % 10000 == 0 {\n        return false\n    }\n    if n % 100000 == 0 {\n        return false\n    }\n    if n % 1000000 == 0 {\n        return false\n    }\n    if n % 10000000 == 0 {\n        return false\n    }\n    if n % 100000000 == 0 {\n        return false\n    }\n    if n % 1000000000 == 0 {\n        return false\n    }\n    if n % 10000000000 == 0 {\n        return false\n    }\n    if n % 100000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 100000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 1000000000000000000000000000 == 0 {\n        return false\n    }\n    if n % 10000000000000000000000000000 == 0\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122555,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxsdcx82b_test.go:98:6: expected '(', found TestIs_Undulating\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n\n    var last_digit int\n    var last_diff int\n    var diff int\n\n    for n > 0 {\n        digit := n % 10\n        n /= 10\n\n        if last_digit != 0 {\n            diff = digit - last_digit\n            if last_diff != 0 && diff != last_diff {\n                return false\n            }\n            last_diff = diff\n        }\n        last_digit = digit\n    }\n\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122575,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpioscgce7_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpioscgce7_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n\n    var prev_diff int\n    var curr_diff int\n    var prev_digit int\n    var curr_digit int\n\n    for n > 0 {\n        curr_digit = n % 10\n        n = n / 10\n\n        if prev_digit != 0 {\n            curr_diff = curr_digit - prev_digit\n            if prev_diff != 0 && curr_diff != prev_diff {\n                return false\n            }\n            prev_diff = curr_diff\n        }\n\n        prev_digit = curr_digit\n    }\n\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122575,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmp61c79gc9_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmp61c79gc9_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    prev := n % 10\n    n /= 10\n    curr := n % 10\n    n /= 10\n    for n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var last_digit int\n    var current_digit int\n    var next_digit int\n    var is_undulating bool = true\n    var is_increasing bool = true\n\n    last_digit = n % 10\n    n = n / 10\n    current_digit = n % 10\n    n = n / 10\n\n    for n > 0 {\n        next_digit = n % 10\n        n = n / 10\n\n        if is_increasing {\n            if current_digit > next_digit {\n                is_increasing = false\n            } else if current_digit < next_digit {\n                is_undulating = false\n                break\n            }\n        } else {\n            if current_digit < next_digit {\n                is_increasing = true\n            } else if current_digit > next_digit {\n                is_undulating = false\n                break\n            }\n        }\n\n        last_digit = current_digit\n        current_digit = next_digit\n    }\n\n    if is_increasing {\n        if current_digit > last_digit {\n            is_undulating = false\n        }\n    } else {\n        if current_digit < last_digit {\n            is_undulating = false\n        }\n    }\n\n    return is_undulating\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122575,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmp82ai66sp_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmp82ai66sp_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    prev := n % 10\n    n /= 10\n    curr := n % 10\n    n /= 10\n    for n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    for n > 0 {\n        a, b, c := n % 10, (n / 10) % 10, (n / 100) % 10\n        if a != b && b != c && c != a {\n            return false\n        }\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122575,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpx81qk_d5_test.go:38: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpx81qk_d5_test.go:38: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n == 100 {\n        return true\n    }\n    if n % 10 == 0 {\n        return false\n    }\n    if n % 100 == 0 {\n        return false\n    }\n    var last_digit int\n    var last_last_digit int\n    for n > 0 {\n        last_last_digit = last_digit\n        last_digit = n % 10\n        n /= 10\n    }\n    return last_digit - last_last_digit == 0\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122575,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmp_w31ojwm_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmp_w31ojwm_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    if n == 100 {\n        return true\n    }\n    if n % 10 == 0 {\n        return false\n    }\n    if n % 100 == 0 {\n        return true\n    }\n    if n % 1000 == 0 {\n        return false\n    }\n    if n % 10000 == 0 {\n        return true\n    }\n    return false\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510018,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpyinn4dxy_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpyinn4dxy_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 0; i < len(s) - 2; i++ {\n        if s[i] == s[i + 2] {\n            return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122557,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 0; i < len(s) - 2; i++ {\n        if s[i] == s[i+1] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510018,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    var prev, curr int\n    for n > 0 {\n        curr = n % 10\n        n /= 10\n        if prev != 0 && prev != curr {\n            return false\n        }\n        prev = curr\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122575,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpzl0l54r1_test.go:40: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpzl0l54r1_test.go:40: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n\n    var prev_digit, curr_digit int\n\n    for n > 0 {\n        curr_digit = n % 10\n        n /= 10\n\n        if prev_digit == curr_digit {\n            return false\n        }\n\n        prev_digit = curr_digit\n    }\n\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122575,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var last_digit int\n    var current_digit int\n    var next_digit int\n    var is_increasing bool\n    var is_decreasing bool\n\n    if n < 100 {\n        return false\n    }\n\n    last_digit = n % 10\n    n /= 10\n    current_digit = n % 10\n    n /= 10\n    next_digit = n % 10\n\n    if current_digit > last_digit {\n        is_increasing = true\n    } else if current_digit < last_digit {\n        is_decreasing = true\n    } else {\n        return false\n    }\n\n    for n > 0 {\n        last_digit = current_digit\n        current_digit = next_digit\n        n /= 10\n        next_digit = n % 10\n\n        if is_increasing {\n            if current_digit < last_digit {\n                is_increasing = false\n                is_decreasing = true\n            } else if current_digit > last_digit {\n                return false\n            }\n        } else if is_decreasing {\n            if current_digit > last_digit {\n                is_decreasing = false\n                is_increasing = true\n            } else if current_digit < last_digit {\n                return false\n            }\n        }\n    }\n\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122575,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__1 (0.00s)\n        tmp3t5qb2c0_test.go:75: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n\n    var last_digit, current_digit int\n    for n > 0 {\n        current_digit = n % 10\n        if last_digit == current_digit {\n            return false\n        }\n        last_digit = current_digit\n        n /= 10\n    }\n\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122575,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    var last, curr int\n    for n > 0 {\n        curr = n % 10\n        if curr == last {\n            return false\n        }\n        last = curr\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 10 {\n        return false\n    }\n    var prev_digit, curr_digit int\n    for n > 0 {\n        curr_digit = n % 10\n        if prev_digit == 0 {\n            prev_digit = curr_digit\n        } else {\n            if prev_digit == curr_digit {\n                return false\n            }\n            prev_digit = curr_digit\n        }\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122575,
      "stdout": "ok  \tcommand-line-arguments\t0.006s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 10 {\n        return false\n    }\n    prev := n % 10\n    n /= 10\n    cur := n % 10\n    n /= 10\n    for n > 0 {\n        if (prev - cur) * (cur - n % 10) < 0 {\n            return false\n        }\n        prev = cur\n        cur = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122575,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpgi_qpbjl_test.go:43: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__1 (0.00s)\n        tmpgi_qpbjl_test.go:43: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpgi_qpbjl_test.go:43: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    var prev, curr int\n    for n > 0 {\n        curr = n % 10\n        if prev != 0 && prev != curr {\n            return false\n        }\n        prev = curr\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122559,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpowu70w6s_test.go:37: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpowu70w6s_test.go:37: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 10 {\n        return false\n    }\n    var last_digit int\n    var last_diff int\n    for n > 0 {\n        digit := n % 10\n        if last_digit != 0 {\n            diff := digit - last_digit\n            if last_diff != 0 && diff != last_diff {\n                return false\n            }\n            last_diff = diff\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122575,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmppiuqdz6i_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmppiuqdz6i_test.go:45: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    last_digit := n % 10\n    n /= 10\n    last_digit_2 := n % 10\n    n /= 10\n    for n > 0 {\n        digit := n % 10\n        if digit != last_digit && digit != last_digit_2 {\n            return false\n        }\n        last_digit_2 = last_digit\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122575,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpsau8vwps_test.go:44: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__1 (0.00s)\n        tmpsau8vwps_test.go:44: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    s := fmt.Sprintf(\"%d\", n)\n    for i := 0; i < len(s) - 2; i++ {\n        if s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122559,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpdl2aibzt_test.go:37: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpdl2aibzt_test.go:37: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    var prev_diff int\n    for n > 0 {\n        digit1 := n % 10\n        n /= 10\n        digit2 := n % 10\n        n /= 10\n        diff := digit1 - digit2\n        if prev_diff != 0 && prev_diff != diff {\n            return false\n        }\n        prev_diff = diff\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122575,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpjh9mezia_test.go:43: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpjh9mezia_test.go:43: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n\n    var last_digit int\n    var last_last_digit int\n    for n > 0 {\n        last_digit = n % 10\n        n /= 10\n        if n == 0 {\n            break\n        }\n        last_last_digit = n % 10\n        if last_digit == last_last_digit {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122575,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    prev := n % 10\n    n /= 10\n    curr := n % 10\n    n /= 10\n    for n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    var prev, curr int\n    for n > 0 {\n        prev = curr\n        curr = n % 10\n        if prev == curr {\n            return false\n        }\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122559,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    digits := []int{}\n    for n > 0 {\n        digits = append(digits, n % 10)\n        n /= 10\n    }\n    for i := 0; i < len(digits) - 2; i++ {\n        if digits[i] == digits[i + 2] {\n            return true\n        }\n    }\n    return false\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122576,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    prev := n % 10\n    n /= 10\n    curr := n % 10\n    n /= 10\n    for n > 0 {\n        if prev == curr {\n            return false\n        }\n        prev = curr\n        curr = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510015,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    return false\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122576,
      "stdout": "--- FAIL: TestIs_Undulating (0.00s)\n    --- FAIL: TestIs_Undulating/test_num__0 (0.00s)\n        tmpdk27u5wt_test.go:28: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestIs_Undulating/test_num__2 (0.00s)\n        tmpdk27u5wt_test.go:28: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    last_digit := n % 10\n    n /= 10\n    for n > 0 {\n        digit := n % 10\n        if digit == last_digit {\n            return false\n        }\n        last_digit = digit\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122559,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package is_undulating_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n int) bool {\n    if n < 100 {\n        return false\n    }\n    last := n % 10\n    n /= 10\n    cur := n % 10\n    n /= 10\n    for n > 0 {\n        if last == cur {\n            return false\n        }\n        last = cur\n        cur = n % 10\n        n /= 10\n    }\n    return true\n}\n\nfunc TestIs_Undulating(t *testing.T) {\n  candidate := is_undulating\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(1212121), expected: true },\n     { actual: candidate(1991), expected: false },\n     { actual: candidate(121), expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122576,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    }
  ]
}