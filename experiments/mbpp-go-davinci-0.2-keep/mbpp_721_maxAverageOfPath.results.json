{
  "name": "mbpp_721_maxAverageOfPath",
  "language": "go_test.go",
  "prompt": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_721_maxAverageOfPath.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] means the max average of path from (0, 0) to (i, j)\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509922,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfk3s8uin_test.go:24:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509922,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptfbup2gn_test.go:31:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509922,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqjr6fu6j_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0.0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509922,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpp7p6iwo3_test.go:25:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n\n    n := len(cost)\n    m := len(cost[0])\n\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[n-1][m-1] / float64(n+m-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509922,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpp8yhf5cp_test.go:32:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    for i := 1; i < len(cost); i++ {\n        cost[i][0] += cost[i-1][0]\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        cost[0][j] += cost[0][j-1]\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            cost[i][j] += max(cost[i-1][j], cost[i][j-1])\n        }\n    }\n    return float64(cost[len(cost)-1][len(cost[0])-1]) / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509922,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjv30x4qv_test.go:27:27: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509922,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbhts8b7o_test.go:30:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return float64(cost[0][0])\n    }\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6is3mnf9_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var sum float64\n    for i := 0; i < len(cost); i++ {\n        for j := 0; j < len(cost[0]); j++ {\n            if i == 0 && j == 0 {\n                continue\n            }\n            if i == 0 {\n                cost[i][j] += cost[i][j-1]\n            } else if j == 0 {\n                cost[i][j] += cost[i-1][j]\n            } else {\n                cost[i][j] += max(cost[i-1][j], cost[i][j-1])\n            }\n            sum += float64(cost[i][j])\n        }\n    }\n    return sum / float64(len(cost) * len(cost[0]))\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509922,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp18v159et_test.go:30:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509922,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqjr6fu6j_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    if n == 0 {\n        return 0\n    }\n    m := len(cost[0])\n    if m == 0 {\n        return 0\n    }\n    if n == 1 && m == 1 {\n        return float64(cost[0][0])\n    }\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][m-1] / float64(n+m-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509922,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmwj0kojh_test.go:34:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509922,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphdlzw48n_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509922,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphdlzw48n_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509922,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpakoeq2hq_test.go:35:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var sum float64 = 0\n    var count int = 0\n    var max float64 = 0\n    var maxCount int = 0\n    var maxSum float64 = 0\n    var maxAvg float64 = 0\n    var avg float64 = 0\n    var dfs func(int, int)\n    dfs = func(i, j int) {\n        if i == len(cost) - 1 && j == len(cost[0]) - 1 {\n            sum += float64(cost[i][j])\n            count++\n            avg = sum / float64(count)\n            if avg > maxAvg {\n                maxAvg = avg\n                maxSum = sum\n                maxCount = count\n            }\n            sum -= float64(cost[i][j])\n            count--\n            return\n        }\n        sum += float64(cost[i][j])\n        count++\n        if i < len(cost) - 1 {\n            dfs(i + 1, j)\n        }\n        if j < len(cost[0]) - 1 {\n            dfs(i, j + 1)\n        }\n        sum -= float64(cost[i][j])\n        count--\n    }\n    dfs(0, 0)\n    fmt.Println(maxAvg, maxSum, maxCount)\n    return maxAvg\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509922,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdu8khq7__test.go:21:9: max declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509922,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkmmsxhxb_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    m := len(cost[0])\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[n-1][m-1] / float64(n + m - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509922,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2g69ni94_test.go:28:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509922,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkmmsxhxb_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124111,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc83muy3i_test.go:30:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    if n == 0 {\n        return 0\n    }\n    m := len(cost[0])\n    if m == 0 {\n        return 0\n    }\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][m-1] / float64(n+m-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaybx6qw5_test.go:31:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[0][0] = cost[0][0]\n    // dp[i][0] = dp[i-1][0] + cost[i][0]\n    // dp[0][j] = dp[0][j-1] + cost[0][j]\n    // dp[n-1][n-1] = max(dp[n-1][n-2], dp[n-2][n-1]) + cost[n-1][n-1]\n    // return dp[n-1][n-1] / (n + n - 1)\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(n + n - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124111,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt9bc59ur_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m + n - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzod2vovg_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    if n == 0 {\n        return 0\n    }\n    m := len(cost[0])\n    if m == 0 {\n        return 0\n    }\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][m-1] / float64(n+m-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaybx6qw5_test.go:31:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) +\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509920,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4d2242dv_test.go:24:6: expected '(', found TestMaxaverageofpath\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[0][0] = cost[0][0]\n    // dp[i][0] = dp[i-1][0] + cost[i][0]\n    // dp[0][j] = dp[0][j-1] + cost[0][j]\n    // dp[n-1][n-1] = max(dp[n-2][n-1], dp[n-1][n-2]) + cost[n-1][n-1]\n    // dp[n-1][j] = max(dp[n-2][j], dp[n-1][j-1]) + cost[n-1][j]\n    // dp[i][n-1] = max(dp[i-1][n-1], dp[i][n-2]) + cost[i][n-1]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j]\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124110,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2fe8phjz_test.go:25:6: expected '(', found TestMaxaverageofpath\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) +\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509920,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4d2242dv_test.go:24:6: expected '(', found TestMaxaverageofpath\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] means the max average of path from (0,0) to (i,j)\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124111,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuoj21te9_test.go:26:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    row := len(cost)\n    col := len(cost[0])\n    dp := make([][]float64, row)\n    for i := 0; i < row; i++ {\n        dp[i] = make([]float64, col)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < row; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < col; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < row; i++ {\n        for j := 1; j < col; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[row-1][col-1] / float64(row + col - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124111,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnfyskc1k_test.go:31:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd2kexsn__test.go:25:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509922,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphdlzw48n_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // write your code in Go 1.4\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var max float64\n    var maxPath [][]int\n    var path [][]int\n    var sum int\n    var avg float64\n    for i := 0; i < len(cost); i++ {\n        for j := 0; j < len(cost[0]); j++ {\n            path = make([][]int, 0)\n            sum = 0\n            avg = 0\n            findPath(cost, i, j, &path, &sum, &avg)\n            if avg > max {\n                max = avg\n                maxPath = path\n            }\n        }\n    }\n    fmt.Println(maxPath)\n    return max\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124111,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk3frhpic_test.go:30:13: undefined: findPath\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m + n - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124111,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplcxz9acy_test.go:30:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    // dp[i][j] means the max average of path from (0, 0) to (i, j)\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i - 1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j - 1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost) - 1][len(cost[0]) - 1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124111,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc9hdcoxg_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124104,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp227vuos2_test.go:22:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    for i := 1; i < len(cost); i++ {\n        cost[i][0] += cost[i-1][0]\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        cost[0][j] += cost[0][j-1]\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            cost[i][j] += max(cost[i-1][j], cost[i][j-1])\n        }\n    }\n    return float64(cost[len(cost)-1][len(cost[0])-1]) / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509922,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjv30x4qv_test.go:27:27: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[0][0] = cost[0][0]\n    // dp[0][j] = dp[0][j-1] + cost[0][j]\n    // dp[i][0] = dp[i-1][0] + cost[i][0]\n    // dp[n-1][n-1] = max(dp[n-2][n-1], dp[n-1][n-2]) + cost[n-1][n-1]\n    // dp[n-1][j] = max(dp[n-2][j], dp[n-1][j-1]) + cost[n-1][j]\n    // dp[i][n-1] = max(dp[i-1][n-1], dp[i][n-2]) + cost[i][n-1]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j]\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124110,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpgra48770_test.go:25:6: expected '(', found TestMaxaverageofpath\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    for i := 1; i < len(cost); i++ {\n        cost[i][0] += cost[i-1][0]\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        cost[0][j] += cost[0][j-1]\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            cost[i][j] += max(cost[i-1][j], cost[i][j-1])\n        }\n    }\n    return float64(cost[len(cost)-1][len(cost[0])-1]) / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509922,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjv30x4qv_test.go:27:27: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvswezcn2_test.go:25:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    m := len(cost)\n    n := len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124111,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdgkv2i5k_test.go:28:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) +\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509920,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4d2242dv_test.go:24:6: expected '(', found TestMaxaverageofpath\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(n*2-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124111,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpiy5f5mhw_test.go:31:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // write your code in Go 1.4\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124111,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9zow5de6_test.go:30:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    // dp[i][j] means the max average of path from (0, 0) to (i, j)\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124111,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcc1yi8iz_test.go:30:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509922,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqjr6fu6j_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i - 1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j - 1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m - 1][n - 1] / float64(m + n - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124111,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwkgqmwj4_test.go:30:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    m := len(cost[0])\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < m; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][m-1] / float64(n+m-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124111,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwxf31r58_test.go:31:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    m := len(cost)\n    n := len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124111,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqd2t89zv_test.go:31:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124111,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpw1il0vlk_test.go:37:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    row := len(cost)\n    col := len(cost[0])\n    dp := make([][]float64, row)\n    for i := 0; i < row; i++ {\n        dp[i] = make([]float64, col)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < row; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < col; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < row; i++ {\n        for j := 1; j < col; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[row-1][col-1] / float64(row + col - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124111,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6wk00b_2_test.go:31:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m + n - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzod2vovg_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(n*n)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124111,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2ra907to_test.go:22:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp66eg_z71_test.go:27:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m + n - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzod2vovg_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp66eg_z71_test.go:27:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc2isqmi2_test.go:22:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := range dp {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124111,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt3lb_5c2_test.go:25:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509922,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphdlzw48n_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp66eg_z71_test.go:27:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m + n - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzod2vovg_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp85awzzgr_test.go:30:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) +\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509920,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4d2242dv_test.go:24:6: expected '(', found TestMaxaverageofpath\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var maxAvg float64\n    for i := 0; i < len(cost); i++ {\n        for j := 0; j < len(cost[0]); j++ {\n            if i == 0 && j == 0 {\n                continue\n            }\n            if i == 0 {\n                cost[i][j] += cost[i][j-1]\n            } else if j == 0 {\n                cost[i][j] += cost[i-1][j]\n            } else {\n                cost[i][j] += max(cost[i-1][j], cost[i][j-1])\n            }\n            if i == len(cost)-1 && j == len(cost[0])-1 {\n                maxAvg = float64(cost[i][j]) / float64(i+j+1)\n            }\n        }\n    }\n    return maxAvg\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124111,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5gpm8axs_test.go:30:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd2kexsn__test.go:25:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max average of path from (0, 0) to (i, j)\n    // dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j]\n    // dp[0][0] = cost[0][0]\n    // dp[i][0] = dp[i - 1][0] + cost[i][0]\n    // dp[0][j] = dp[0][j - 1] + cost[0][j]\n    // return dp[n - 1][n - 1] / (n * n)\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i - 1][0] + float64(cost[i][0])\n        dp[0][i] = dp[0][i - 1] + float64(cost[0][i])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n - 1][n - 1] / float64(n * n)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124111,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjirf6hd3_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[0][0] = cost[0][0]\n    // dp[i][0] = dp[i-1][0] + cost[i][0]\n    // dp[0][j] = dp[0][j-1] + cost[0][j]\n    // return dp[n-1][n-1] / (2*n-1)\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124111,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9_rx_uya_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124105,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3kkdvlax_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    dp := make([][]float64, len(cost))\n    for i := range dp {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124112,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk3358p15_test.go:32:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptza8ehb8_test.go:29:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509922,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbhts8b7o_test.go:30:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(n * 2 - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124112,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpha8fynr8_test.go:25:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124113,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpj8_e9c07_test.go:29:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(n*n)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124113,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpadv53h4n_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    if n == 0 {\n        return 0\n    }\n    m := len(cost[0])\n    if m == 0 {\n        return 0\n    }\n    var dp [][]float64\n    for i := 0; i < n; i++ {\n        dp = append(dp, make([]float64, m))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][m-1] / float64(n+m-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124113,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpelf0y4t1_test.go:31:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpflao6squ_test.go:25:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n\n    var max float64\n    var dfs func(int, int, int, float64)\n    dfs = func(i, j, n int, sum float64) {\n        if i == n - 1 && j == n - 1 {\n            if sum / float64(n) > max {\n                max = sum / float64(n)\n            }\n            return\n        }\n        if i < n - 1 {\n            dfs(i + 1, j, n, sum + float64(cost[i + 1][j]))\n        }\n        if j < n - 1 {\n            dfs(i, j + 1, n, sum + float64(cost[i][j + 1]))\n        }\n    }\n    dfs(0, 0, len(cost), float64(cost[0][0]))\n    return max\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124113,
      "stdout": "--- FAIL: TestMaxaverageofpath (0.00s)\n    --- FAIL: TestMaxaverageofpath/test_num__0 (0.00s)\n        tmp5z24m894_test.go:56: expected '%!s(float64=5.2)', got '%!s(float64=8.666666666666666)'\n    --- FAIL: TestMaxaverageofpath/test_num__1 (0.00s)\n        tmp5z24m894_test.go:56: expected '%!s(float64=6.2)', got '%!s(float64=10.333333333333334)'\n    --- FAIL: TestMaxaverageofpath/test_num__2 (0.00s)\n        tmp5z24m894_test.go:56: expected '%!s(float64=7.2)', got '%!s(float64=12)'\n    --- FAIL: TestMaxaverageofpath/test_num__3 (0.00s)\n        tmp5z24m894_test.go:56: expected '%!s(float64=5.8)', got '%!s(float64=9.666666666666666)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) +\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509920,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4d2242dv_test.go:24:6: expected '(', found TestMaxaverageofpath\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    dp := make([][]float64, len(cost))\n    for i := range dp {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124113,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpauy0oi7x_test.go:32:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n\n    n := len(cost)\n    m := len(cost[0])\n\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[n-1][m-1] / float64(n+m-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124113,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp69q2dv4a_test.go:35:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124113,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1h0868uz_test.go:26:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt4o440gf_test.go:33:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124113,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa87lxdtu_test.go:26:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // write your code in Go 1.4\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    for i := 1; i < len(cost); i++ {\n        cost[i][0] += cost[i-1][0]\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        cost[0][i] += cost[0][i-1]\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            cost[i][j] += max(cost[i-1][j], cost[i][j-1])\n        }\n    }\n    return float64(cost[len(cost)-1][len(cost[0])-1]) / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124113,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7p87jvoi_test.go:28:27: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[n-1][n-1] / float64(n*n)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124104,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpitn7305q_test.go:25:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[0][0] = cost[0][0]\n    // dp[0][j] = dp[0][j-1] + cost[0][j]\n    // dp[i][0] = dp[i-1][0] + cost[i][0]\n    // return dp[n-1][n-1] / (n + n - 1)\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2 * n - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124113,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6_5b4k3p_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    // dp[i][j] is the max average of path from (0, 0) to (i, j)\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124113,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptqumhj_7_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var max float64\n    for i := 0; i < len(cost); i++ {\n        for j := 0; j < len(cost[0]); j++ {\n            if i == 0 && j == 0 {\n                continue\n            }\n            var left, up float64\n            if i == 0 {\n                left = float64(cost[i][j-1])\n            } else if j == 0 {\n                up = float64(cost[i-1][j])\n            } else {\n                left = float64(cost[i][j-1])\n                up = float64(cost[i-1][j])\n            }\n            cost[i][j] += int(maxFloat64(left, up))\n            if i == len(cost) - 1 && j == len(cost[0]) - 1 {\n                max = float64(cost[i][j])\n            }\n        }\n    }\n    return max / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124113,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvxepkmcw_test.go:34:31: undefined: maxFloat64\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m + n - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124111,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplcxz9acy_test.go:30:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var max float64\n    var sum float64\n    var count int\n    var dfs func(int, int)\n    dfs = func(i, j int) {\n        if i == len(cost)-1 && j == len(cost[0])-1 {\n            sum += float64(cost[i][j])\n            count++\n            if sum/float64(count) > max {\n                max = sum/float64(count)\n            }\n            return\n        }\n        sum += float64(cost[i][j])\n        count++\n        if i < len(cost)-1 {\n            dfs(i+1, j)\n        }\n        if j < len(cost[0])-1 {\n            dfs(i, j+1)\n        }\n        sum -= float64(cost[i][j])\n        count--\n    }\n    dfs(0, 0)\n    return max\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124113,
      "stdout": "--- FAIL: TestMaxaverageofpath (0.00s)\n    --- FAIL: TestMaxaverageofpath/test_num__0 (0.00s)\n        tmp2j7c1t96_test.go:63: expected '%!s(float64=5.2)', got '%!s(float64=6.4)'\n    --- FAIL: TestMaxaverageofpath/test_num__1 (0.00s)\n        tmp2j7c1t96_test.go:63: expected '%!s(float64=6.2)', got '%!s(float64=7.4)'\n    --- FAIL: TestMaxaverageofpath/test_num__2 (0.00s)\n        tmp2j7c1t96_test.go:63: expected '%!s(float64=7.2)', got '%!s(float64=8.4)'\n    --- FAIL: TestMaxaverageofpath/test_num__3 (0.00s)\n        tmp2j7c1t96_test.go:63: expected '%!s(float64=5.8)', got '%!s(float64=6.6)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc2isqmi2_test.go:22:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp85awzzgr_test.go:30:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    var (\n        m = len(cost)\n        n = len(cost[0])\n        dp = make([][]float64, m)\n    )\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124113,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6ooze9ge_test.go:33:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(n * n)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124113,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvn9m3bi9_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkr5c71_h_test.go:34:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] is the max average of path from (0, 0) to (i, j)\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124113,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu_3yfwng_test.go:24:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := range dp {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124113,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp805ulkao_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    var max float64 = 0\n    var dp [][]float64 = make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = maxFloat64(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    max = dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n    return max\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124113,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp91nz_1_q_test.go:30:24: undefined: maxFloat64\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] means the max average of path from (0,0) to (i,j)\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[0][0] = cost[0][0]\n    // dp[i][0] = dp[i-1][0] + cost[i][0]\n    // dp[0][j] = dp[0][j-1] + cost[0][j]\n    // dp[n-1][n-1] / (n-1) + 1\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(n-1) + 1\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124113,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpp346ygmm_test.go:30:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124105,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3kkdvlax_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n\n    row := len(cost)\n    col := len(cost[0])\n\n    dp := make([][]float64, row)\n    for i := 0; i < row; i++ {\n        dp[i] = make([]float64, col)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < row; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < col; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n\n    for i := 1; i < row; i++ {\n        for j := 1; j < col; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[row-1][col-1] / float64(row + col - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124113,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfjbdvz7i_test.go:32:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    if n == 0 {\n        return 0\n    }\n    m := len(cost[0])\n    if m == 0 {\n        return 0\n    }\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][m-1] / float64(n + m - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0dohvenb_test.go:31:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n\n    dp := make([][]float64, len(cost))\n    for i := range dp {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124113,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpucvg0ho9_test.go:32:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124111,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc83muy3i_test.go:30:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvswezcn2_test.go:25:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    row, col := len(cost), len(cost[0])\n    dp := make([][]float64, row)\n    for i := 0; i < row; i++ {\n        dp[i] = make([]float64, col)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < row; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < col; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < row; i++ {\n        for j := 1; j < col; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[row-1][col-1] / float64(row + col - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzy_xwrq0_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] means the max average of path from (0, 0) to (i, j)\n    dp := make([][]float64, len(cost))\n    for i := range dp {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124114,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsbrw_spr_test.go:24:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124113,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa87lxdtu_test.go:26:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    var sum float64\n    var count int\n    var max float64\n    var dfs func(int, int)\n    dfs = func(i, j int) {\n        if i == len(cost) - 1 && j == len(cost[0]) - 1 {\n            if sum / float64(count) > max {\n                max = sum / float64(count)\n            }\n            return\n        }\n        if i < len(cost) - 1 {\n            sum += float64(cost[i + 1][j])\n            count++\n            dfs(i + 1, j)\n            sum -= float64(cost[i + 1][j])\n            count--\n        }\n        if j < len(cost[0]) - 1 {\n            sum += float64(cost[i][j + 1])\n            count++\n            dfs(i, j + 1)\n            sum -= float64(cost[i][j + 1])\n            count--\n        }\n    }\n    dfs(0, 0)\n    return max\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124114,
      "stdout": "--- FAIL: TestMaxaverageofpath (0.00s)\n    --- FAIL: TestMaxaverageofpath/test_num__0 (0.00s)\n        tmp1zl6mx2l_test.go:62: expected '%!s(float64=5.2)', got '%!s(float64=6.25)'\n    --- FAIL: TestMaxaverageofpath/test_num__1 (0.00s)\n        tmp1zl6mx2l_test.go:62: expected '%!s(float64=6.2)', got '%!s(float64=7.25)'\n    --- FAIL: TestMaxaverageofpath/test_num__2 (0.00s)\n        tmp1zl6mx2l_test.go:62: expected '%!s(float64=7.2)', got '%!s(float64=8.25)'\n    --- FAIL: TestMaxaverageofpath/test_num__3 (0.00s)\n        tmp1zl6mx2l_test.go:62: expected '%!s(float64=5.8)', got '%!s(float64=7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa06qbrru_test.go:32:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // write your code in Go 1.4\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var maxAvg float64\n    var maxAvgPath [][]int\n    var maxAvgPathSum int\n    var maxAvgPathLen int\n    var maxAvgPathLenSum int\n    var maxAvgPathLenSumPath [][]int\n    var maxAvgPathLenSumPathSum int\n    var maxAvgPathLenSumPathLen int\n    var maxAvgPathLenSumPathLenPath [][]int\n    var maxAvgPathLenSumPathLenPathSum int\n    var maxAvgPathLenSumPathLenPathLen int\n    var maxAvgPathLenSumPathLenPathLenPath [][]int\n    var maxAvgPathLenSumPathLenPathLenPathSum int\n    var maxAvgPathLenSumPathLenPathLenPathLen int\n    var maxAvgPathLenSumPathLenPathLenPathLenPath [][]int\n    var maxAvgPathLenSumPathLenPathLenPathLenPathSum int\n    var maxAvgPathLenSumPathLenPathLenPathLenPathLen int\n    var maxAvgPathLenSumPathLenPathLenPathLenPathLenPath [][]int\n    var maxAvgPathLenSumPathLenPathLenPathLenPathLenPathSum int\n    var maxAvgPathLenSumPathLenPathLenPathLenPathLenPathLen int\n    var maxAvgPathLenSumPathLenPathLenPathLenPathLenPathLenPath [][]int\n    var maxAvgPathLenSumPathLenPathLenPathLenPathLenPathLenPathSum int\n    var maxAvgPathLenSumPathLenPathLenPathLenPathLenPathLenPathLen int\n    var maxAvgPathLenSumPathLenPathLenPathLenPathLenPathLenPathLenPath [][]int\n    var maxAvgPathLenSumPathLenPathLenPathLenPathLenPathLenPathLenPathSum int\n    var maxAvgPathLenSumPathLenPathLenPathLenPathLenPathLenPathLenPathLen int\n    var maxAvgPathLenSumPathLenPathLenPathLenPathLenPathLenPath\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124114,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp57wch0ot_test.go:46:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[0][0] = cost[0][0]\n    // dp[0][j] = dp[0][j-1] + cost[0][j]\n    // dp[i][0] = dp[i-1][0] + cost[i][0]\n    // return dp[n-1][n-1] / (2*n-1)\n    n := len(cost)\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    dp[0][0] = cost[0][0]\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + cost[0][i]\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n        }\n    }\n    return float64(dp[n-1][n-1]) / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124115,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjbeo30uy_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost)))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost); j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[len(cost)-1][len(cost)-1] / float64(len(cost) * len(cost))\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124115,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpql7i_rep_test.go:27:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc2isqmi2_test.go:22:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    row := len(cost)\n    col := len(cost[0])\n    dp := make([][]float64, row)\n    for i := 0; i < row; i++ {\n        dp[i] = make([]float64, col)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < row; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < col; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < row; i++ {\n        for j := 1; j < col; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[row-1][col-1] / float64(row + col - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124115,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpppr7ggym_test.go:28:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124115,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa9e0t7po_test.go:33:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    row := len(cost)\n    col := len(cost[0])\n    dp := make([][]float64, row)\n    for i := 0; i < row; i++ {\n        dp[i] = make([]float64, col)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < row; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < col; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < row; i++ {\n        for j := 1; j < col; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[row-1][col-1] / float64(row + col - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124115,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp33exq0xe_test.go:34:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n\n    // dp[i][j] means the max average of path from (0, 0) to (i, j)\n    dp := make([][]float64, len(cost))\n    for i := range dp {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = float64(cost[i][0]) + dp[i-1][0]\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = float64(cost[0][j]) + dp[0][j-1]\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124115,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjp253un9_test.go:34:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    if n == 0 {\n        return 0\n    }\n    m := len(cost[0])\n    if m == 0 {\n        return 0\n    }\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][m-1] / float64(n+m-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaybx6qw5_test.go:31:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return float64(cost[0][0])\n    }\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6is3mnf9_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124115,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4ixu262a_test.go:30:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    var dp [][]float64 = make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124115,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkmsymm8b_test.go:29:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    row := len(cost)\n    col := len(cost[0])\n    dp := make([][]float64, row)\n    for i := 0; i < row; i++ {\n        dp[i] = make([]float64, col)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < row; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < col; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < row; i++ {\n        for j := 1; j < col; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[row-1][col-1] / float64(row + col - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124115,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmk9ks7q7_test.go:28:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124115,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkw1axc_2_test.go:32:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var (\n        m = len(cost)\n        n = len(cost[0])\n        dp = make([][]float64, m)\n    )\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[m-1][n-1] / float64(m + n - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124115,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx5mb3uc3_test.go:36:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[0][0] = cost[0][0]\n    // dp[0][j] = dp[0][j-1] + cost[0][j]\n    // dp[i][0] = dp[i-1][0] + cost[i][0]\n    // return dp[n-1][n-1] / (n + n - 1)\n\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(n + n - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124115,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpj3qs93p__test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpflao6squ_test.go:25:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i - 1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j - 1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return dp[len(cost) - 1][len(cost[0]) - 1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124115,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjpfx0wtn_test.go:29:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    m := len(cost)\n    n := len(cost[0])\n    dp := make([][]float64, m)\n    for i := range dp {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124115,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9ea4yd42_test.go:25:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptz24hy7s_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124113,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1h0868uz_test.go:26:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n\n    var maxAvg float64\n    var dfs func(int, int, int, float64)\n    dfs = func(i, j, cnt int, sum float64) {\n        if i == len(cost) - 1 && j == len(cost[0]) - 1 {\n            avg := sum / float64(cnt)\n            if avg > maxAvg {\n                maxAvg = avg\n            }\n            return\n        }\n\n        if i < len(cost) - 1 {\n            dfs(i + 1, j, cnt + 1, sum + float64(cost[i + 1][j]))\n        }\n        if j < len(cost[0]) - 1 {\n            dfs(i, j + 1, cnt + 1, sum + float64(cost[i][j + 1]))\n        }\n    }\n\n    dfs(0, 0, 1, float64(cost[0][0]))\n    return maxAvg\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124115,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var max float64\n    for i := 0; i < len(cost); i++ {\n        for j := 0; j < len(cost[0]); j++ {\n            if i == 0 && j == 0 {\n                continue\n            }\n            if i == 0 {\n                cost[i][j] += cost[i][j-1]\n            } else if j == 0 {\n                cost[i][j] += cost[i-1][j]\n            } else {\n                cost[i][j] += maxInt(cost[i-1][j], cost[i][j-1])\n            }\n            if i == len(cost)-1 && j == len(cost[0])-1 {\n                max = float64(cost[i][j]) / float64(i+j+1)\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124115,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3eehgajn_test.go:30:31: undefined: maxInt\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppk8dwttc_test.go:35:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // write your code in Go 1.4\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var sum [][]float64\n    for i := 0; i < len(cost); i++ {\n        sum = append(sum, make([]float64, len(cost[0])))\n    }\n    sum[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        sum[i][0] = sum[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        sum[0][i] = sum[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            sum[i][j] = float64(cost[i][j]) + max(sum[i-1][j], sum[i][j-1])\n        }\n    }\n    return sum[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124115,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx485va37_test.go:33:47: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var max float64\n    var sum float64\n    var count int\n    var dfs func(int, int)\n    dfs = func(i, j int) {\n        if i == len(cost) - 1 && j == len(cost[0]) - 1 {\n            avg := sum / float64(count)\n            if avg > max {\n                max = avg\n            }\n            return\n        }\n        if i < len(cost) - 1 {\n            sum += float64(cost[i + 1][j])\n            count++\n            dfs(i + 1, j)\n            sum -= float64(cost[i + 1][j])\n            count--\n        }\n        if j < len(cost[0]) - 1 {\n            sum += float64(cost[i][j + 1])\n            count++\n            dfs(i, j + 1)\n            sum -= float64(cost[i][j + 1])\n            count--\n        }\n    }\n    dfs(0, 0)\n    return max\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124115,
      "stdout": "--- FAIL: TestMaxaverageofpath (0.00s)\n    --- FAIL: TestMaxaverageofpath/test_num__0 (0.00s)\n        tmpu6ykeinx_test.go:66: expected '%!s(float64=5.2)', got '%!s(float64=6.25)'\n    --- FAIL: TestMaxaverageofpath/test_num__1 (0.00s)\n        tmpu6ykeinx_test.go:66: expected '%!s(float64=6.2)', got '%!s(float64=7.25)'\n    --- FAIL: TestMaxaverageofpath/test_num__2 (0.00s)\n        tmpu6ykeinx_test.go:66: expected '%!s(float64=7.2)', got '%!s(float64=8.25)'\n    --- FAIL: TestMaxaverageofpath/test_num__3 (0.00s)\n        tmpu6ykeinx_test.go:66: expected '%!s(float64=5.8)', got '%!s(float64=7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124115,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_bgf6diu_test.go:35:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvswezcn2_test.go:25:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    if n == 0 {\n        return 0\n    }\n    m := len(cost[0])\n    if m == 0 {\n        return 0\n    }\n\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[n-1][m-1] / float64(n+m-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124115,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx09qf44b_test.go:34:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509922,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphdlzw48n_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvswezcn2_test.go:25:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt4o440gf_test.go:33:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    var m, n int = len(cost), len(cost[0])\n    var dp [][]float64 = make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124116,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1xc0eb60_test.go:30:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd2kexsn__test.go:25:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    m := len(cost[0])\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[n-1][m-1] / float64(n+m-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124116,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyermm0qs_test.go:31:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa06qbrru_test.go:32:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509922,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbhts8b7o_test.go:30:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n\n    var max float64\n    var maxPath [][]int\n    var maxPathSum int\n    var maxPathLen int\n    var maxPathAvg float64\n    var path [][]int\n    var pathSum int\n    var pathLen int\n    var pathAvg float64\n\n    for i := 0; i < len(cost); i++ {\n        for j := 0; j < len(cost[i]); j++ {\n            path = make([][]int, 0)\n            pathSum = 0\n            pathLen = 0\n            pathAvg = 0\n\n            maxPath = make([][]int, 0)\n            maxPathSum = 0\n            maxPathLen = 0\n            maxPathAvg = 0\n\n            findPath(cost, i, j, &path, &pathSum, &pathLen, &pathAvg, &maxPath, &maxPathSum, &maxPathLen, &maxPathAvg)\n            if pathAvg > max {\n                max = pathAvg\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124117,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptqp94dkk_test.go:42:13: undefined: findPath\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124117,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpamfitw3s_test.go:25:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := range dp {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124117,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp69qrai73_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    if n == 0 {\n        return 0\n    }\n\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[n-1][n-1] / float64(n*n)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124117,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjbu52kb__test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(n * 2 - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124117,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6bpdnma1_test.go:31:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var maxAverage float64\n    for i := 0; i < len(cost); i++ {\n        for j := 0; j < len(cost[0]); j++ {\n            if i == 0 && j == 0 {\n                continue\n            }\n            if i == 0 {\n                cost[i][j] += cost[i][j-1]\n            } else if j == 0 {\n                cost[i][j] += cost[i-1][j]\n            } else {\n                cost[i][j] += max(cost[i-1][j], cost[i][j-1])\n            }\n        }\n    }\n    maxAverage = float64(cost[len(cost)-1][len(cost[0])-1]) / float64(len(cost) + len(cost[0]) - 1)\n    return maxAverage\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124117,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1dt7n2tp_test.go:30:31: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124117,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoolylanz_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    // dp[i][j] means the max average of path from (0, 0) to (i, j)\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124117,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdccht__1_test.go:30:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n\n    n := len(cost)\n    m := len(cost[0])\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[n-1][m-1] / float64(n+m-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124117,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpext1fse__test.go:34:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var max float64 = 0\n    var dfs func(int, int, int, float64)\n    dfs = func(i, j, n int, sum float64) {\n        if i == n - 1 && j == n - 1 {\n            if sum / float64(n) > max {\n                max = sum / float64(n)\n            }\n            return\n        }\n        if i < n - 1 {\n            dfs(i + 1, j, n, sum + float64(cost[i + 1][j]))\n        }\n        if j < n - 1 {\n            dfs(i, j + 1, n, sum + float64(cost[i][j + 1]))\n        }\n    }\n    dfs(0, 0, len(cost), float64(cost[0][0]))\n    return max\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124117,
      "stdout": "--- FAIL: TestMaxaverageofpath (0.00s)\n    --- FAIL: TestMaxaverageofpath/test_num__0 (0.00s)\n        tmp7puy0cv5_test.go:55: expected '%!s(float64=5.2)', got '%!s(float64=8.666666666666666)'\n    --- FAIL: TestMaxaverageofpath/test_num__1 (0.00s)\n        tmp7puy0cv5_test.go:55: expected '%!s(float64=6.2)', got '%!s(float64=10.333333333333334)'\n    --- FAIL: TestMaxaverageofpath/test_num__2 (0.00s)\n        tmp7puy0cv5_test.go:55: expected '%!s(float64=7.2)', got '%!s(float64=12)'\n    --- FAIL: TestMaxaverageofpath/test_num__3 (0.00s)\n        tmp7puy0cv5_test.go:55: expected '%!s(float64=5.8)', got '%!s(float64=9.666666666666666)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[n-1][n-1] / float64(n * n)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124117,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe5_is1b8_test.go:25:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124117,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsqqhto81_test.go:25:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m + n - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzod2vovg_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // Write your code here\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    var dp [][]float64 = make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = float64(cost[i][0]) + dp[i-1][0]\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = float64(cost[0][j]) + dp[0][j-1]\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124117,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpptc41_cq_test.go:30:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    if n == 0 {\n        return 0\n    }\n    m := len(cost[0])\n    if m == 0 {\n        return 0\n    }\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][m-1] / float64(n + m - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0dohvenb_test.go:31:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var maxAvg float64\n    var dfs func(int, int, int, float64)\n    dfs = func(i, j, count int, avg float64) {\n        if i == len(cost) - 1 && j == len(cost[0]) - 1 {\n            if avg > maxAvg {\n                maxAvg = avg\n            }\n            return\n        }\n        if i + 1 < len(cost) {\n            dfs(i + 1, j, count + 1, (avg * float64(count) + float64(cost[i + 1][j])) / float64(count + 1))\n        }\n        if j + 1 < len(cost[0]) {\n            dfs(i, j + 1, count + 1, (avg * float64(count) + float64(cost[i][j + 1])) / float64(count + 1))\n        }\n    }\n    dfs(0, 0, 1, float64(cost[0][0]))\n    return maxAvg\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124117,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[0][0] = cost[0][0]\n    // dp[i][0] = dp[i-1][0] + cost[i][0]\n    // dp[0][j] = dp[0][j-1] + cost[0][j]\n    // dp[n-1][n-1] = max(dp[n-2][n-1], dp[n-1][n-2]) + cost[n-1][n-1]\n    // dp[n-1][n-1] / (n + n - 1)\n    n := len(cost)\n    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int, n)\n    }\n    dp[0][0] = cost[0][0]\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n        dp[0][i] = dp[0][i-1] + cost[0][i]\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n        }\n    }\n    return float64(dp[n-1][n-1]) / float64(2 * n - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124117,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptnnosdho_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i - 1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j - 1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i - 1][j], dp[i][j - 1])\n        }\n    }\n    return dp[len(cost) - 1][len(cost[0]) - 1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124117,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmper1y4i3k_test.go:29:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    // dp[i][j] means the max average of path from (0,0) to (i,j)\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = float64(cost[i][0]) + dp[i-1][0]\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = float64(cost[0][j]) + dp[0][j-1]\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124117,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpapklw4rx_test.go:33:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var max float64\n    for i := 0; i < len(cost); i++ {\n        for j := 0; j < len(cost[0]); j++ {\n            if i == 0 && j == 0 {\n                continue\n            }\n            if i == 0 {\n                cost[i][j] += cost[i][j-1]\n            } else if j == 0 {\n                cost[i][j] += cost[i-1][j]\n            } else {\n                cost[i][j] += maxInt(cost[i-1][j], cost[i][j-1])\n            }\n            if i == len(cost)-1 && j == len(cost[0])-1 {\n                max = float64(cost[i][j])\n            }\n        }\n    }\n    return max / float64(len(cost)+len(cost[0])-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124117,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2av42ukh_test.go:30:31: undefined: maxInt\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var max float64 = 0\n    var sum float64 = 0\n    var count int = 0\n    var dfs func(i, j int)\n    dfs = func(i, j int) {\n        if i == len(cost) - 1 && j == len(cost[0]) - 1 {\n            if sum / float64(count) > max {\n                max = sum / float64(count)\n            }\n            return\n        }\n        if i + 1 < len(cost) {\n            sum += float64(cost[i + 1][j])\n            count++\n            dfs(i + 1, j)\n            sum -= float64(cost[i + 1][j])\n            count--\n        }\n        if j + 1 < len(cost[0]) {\n            sum += float64(cost[i][j + 1])\n            count++\n            dfs(i, j + 1)\n            sum -= float64(cost[i][j + 1])\n            count--\n        }\n    }\n    dfs(0, 0)\n    return max\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124117,
      "stdout": "--- FAIL: TestMaxaverageofpath (0.00s)\n    --- FAIL: TestMaxaverageofpath/test_num__0 (0.00s)\n        tmpumtk3g9v_test.go:65: expected '%!s(float64=5.2)', got '%!s(float64=6.25)'\n    --- FAIL: TestMaxaverageofpath/test_num__1 (0.00s)\n        tmpumtk3g9v_test.go:65: expected '%!s(float64=6.2)', got '%!s(float64=7.25)'\n    --- FAIL: TestMaxaverageofpath/test_num__2 (0.00s)\n        tmpumtk3g9v_test.go:65: expected '%!s(float64=7.2)', got '%!s(float64=8.25)'\n    --- FAIL: TestMaxaverageofpath/test_num__3 (0.00s)\n        tmpumtk3g9v_test.go:65: expected '%!s(float64=5.8)', got '%!s(float64=7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n\n    row := len(cost)\n    col := len(cost[0])\n\n    dp := make([][]float64, row)\n    for i := 0; i < row; i++ {\n        dp[i] = make([]float64, col)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n\n    for i := 1; i < row; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n\n    for j := 1; j < col; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n\n    for i := 1; i < row; i++ {\n        for j := 1; j < col; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[row-1][col-1] / float64(row + col - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124117,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpriv61mkv_test.go:34:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    var dp [][]float64 = make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124104,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_zc5c7so_test.go:29:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var max float64\n    var maxPath func(int, int, float64)\n    maxPath = func(i, j int, sum float64) {\n        if i == len(cost) - 1 && j == len(cost[0]) - 1 {\n            if sum / float64(i + j + 1) > max {\n                max = sum / float64(i + j + 1)\n            }\n            return\n        }\n        if i < len(cost) - 1 {\n            maxPath(i + 1, j, sum + float64(cost[i][j]))\n        }\n        if j < len(cost[0]) - 1 {\n            maxPath(i, j + 1, sum + float64(cost[i][j]))\n        }\n    }\n    maxPath(0, 0, 0)\n    return max\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124117,
      "stdout": "--- FAIL: TestMaxaverageofpath (0.00s)\n    --- FAIL: TestMaxaverageofpath/test_num__0 (0.00s)\n        tmpxz0gd8m8_test.go:55: expected '%!s(float64=5.2)', got '%!s(float64=3.4)'\n    --- FAIL: TestMaxaverageofpath/test_num__1 (0.00s)\n        tmpxz0gd8m8_test.go:55: expected '%!s(float64=6.2)', got '%!s(float64=4.2)'\n    --- FAIL: TestMaxaverageofpath/test_num__2 (0.00s)\n        tmpxz0gd8m8_test.go:55: expected '%!s(float64=7.2)', got '%!s(float64=5)'\n    --- FAIL: TestMaxaverageofpath/test_num__3 (0.00s)\n        tmpxz0gd8m8_test.go:55: expected '%!s(float64=5.8)', got '%!s(float64=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    for i := 1; i < len(cost); i++ {\n        cost[i][0] += cost[i - 1][0]\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        cost[0][i] += cost[0][i - 1]\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            cost[i][j] += max(cost[i - 1][j], cost[i][j - 1])\n        }\n    }\n    return float64(cost[len(cost) - 1][len(cost[0]) - 1]) / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124117,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7s75x2w6_test.go:27:27: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n\n    dp := make([][]float64, len(cost))\n    for i := range dp {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124117,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl9cvx8cp_test.go:29:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var max float64\n    var dfs func(int, int, int, float64)\n    dfs = func(i, j, count int, sum float64) {\n        if i == len(cost) - 1 && j == len(cost[0]) - 1 {\n            avg := sum / float64(count)\n            if avg > max {\n                max = avg\n            }\n            return\n        }\n        if i < len(cost) - 1 {\n            dfs(i + 1, j, count + 1, sum + float64(cost[i + 1][j]))\n        }\n        if j < len(cost[0]) - 1 {\n            dfs(i, j + 1, count + 1, sum + float64(cost[i][j + 1]))\n        }\n    }\n    dfs(0, 0, 1, float64(cost[0][0]))\n    return max\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124107,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124105,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3kkdvlax_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i - 1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j - 1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m - 1][n - 1] / float64(m + n - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124108,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmponp1x71a_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124115,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkw1axc_2_test.go:32:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkr5c71_h_test.go:34:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124101,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpflao6squ_test.go:25:46: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) +\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509920,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4d2242dv_test.go:24:6: expected '(', found TestMaxaverageofpath\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd2kexsn__test.go:25:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_73d6c83_test.go:27:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    if n == 0 {\n        return 0\n    }\n    m := len(cost[0])\n    if m == 0 {\n        return 0\n    }\n    // dp[i][j] means the max average of path from (0, 0) to (i, j)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][m-1] / float64(n + m - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124108,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsms66hsi_test.go:32:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124098,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd2kexsn__test.go:25:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] is the max average of path from (0, 0) to (i, j)\n    dp := make([][]float64, len(cost))\n    for i := range dp {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124118,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpshamj5e2_test.go:26:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    if len(cost) == 0 {\n        return 0\n    }\n\n    n := len(cost)\n    m := len(cost[0])\n\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[n-1][m-1] / float64(n+m-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124118,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsedqgk6b_test.go:32:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[0][0] = cost[0][0]\n    // dp[0][j] = dp[0][j-1] + cost[0][j]\n    // dp[i][0] = dp[i-1][0] + cost[i][0]\n    // max(dp[n-1][j])\n    // max(dp[i][n-1])\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    max := 0.0\n    for i := 0; i < n; i++ {\n        if dp[n-1][i] > max {\n            max = dp[n-1][i]\n        }\n        if dp[i][n-1] > max {\n            max = dp[i][n-1]\n        }\n    }\n    return max / float64(n)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124118,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8d0q3y_3_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    n := len(cost)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return float64(cost[0][0])\n    }\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509921,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6is3mnf9_test.go:28:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n    // dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j]\n    // dp[0][0] = cost[0][0]\n    // dp[i][0] = dp[i-1][0] + cost[i][0]\n    // dp[0][j] = dp[0][j-1] + cost[0][j]\n    // dp[n-1][n-1] = max(dp[n-2][n-1], dp[n-1][n-2]) + cost[n-1][n-1]\n\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n\nfunc TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666124118,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwum6q1k__test.go:30:24: undefined: max\n",
      "exit_code": 2,
      "status": "SyntaxError"
    }
  ]
}