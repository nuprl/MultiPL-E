{
  "name": "mbpp_615_average_tuple",
  "language": "go_test.go",
  "prompt": "package average_tuple_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function which takes a tuple of tuples and returns the average value for each tuple as a list.\nfunc average_tuple(nums []interface{}) []float64 {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_615_average_tuple.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestAverage_Tuple(t *testing.T) {\n  candidate := average_tuple\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{[]interface{}{10, 10, 10, 12}, []interface{}{30, 45, 56, 45}, []interface{}{81, 80, 39, 32}, []interface{}{1, 2, 3, 4}}), expected: []float64{30.5, 34.25, 27.0, 23.25} },\n     { actual: candidate([]interface{}{[]interface{}{1, 1, -5}, []interface{}{30, -15, 56}, []interface{}{81, -60, -39}, []interface{}{-10, 2, 3}}), expected: []float64{25.5, -18.0, 3.75} },\n     { actual: candidate([]interface{}{[]interface{}{100, 100, 100, 120}, []interface{}{300, 450, 560, 450}, []interface{}{810, 800, 390, 320}, []interface{}{10, 20, 30, 40}}), expected: []float64{305.0, 342.5, 270.0, 232.5} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    var result []float64\n    for _, v := range nums {\n        var sum float64\n        for _, v2 := range v.([]interface{}) {\n            sum += v2.(float64)\n        }\n        result = append(result, sum/float64(len(v.([]interface{}))))\n    }\n    return result\n}\n",
    "    var result []float64\n    for _, num := range nums {\n        var sum float64\n        switch num.(type) {\n        case []int:\n            for _, value := range num.([]int) {\n                sum += float64(value)\n            }\n            result = append(result, sum / float64(len(num.([]int))))\n        case []float64:\n            for _, value := range num.([]float64) {\n                sum += value\n            }\n            result = append(result, sum / float64(len(num.([]float64))))\n        }\n    }\n    return result\n}\n",
    "    var result []float64\n    for _, num := range nums {\n        switch num.(type) {\n        case []interface{}:\n            var sum float64\n            for _, n := range num.([]interface{}) {\n                sum += n.(float64)\n            }\n            result = append(result, sum / float64(len(num.([]interface{}))))\n        }\n    }\n    return result\n}\n",
    "    var result []float64\n    for _, v := range nums {\n        var sum float64\n        var count float64\n        for _, v2 := range v.([]int) {\n            sum += float64(v2)\n            count++\n        }\n        result = append(result, sum/count)\n    }\n    return result\n}\n",
    "    var result []float64\n    for _, num := range nums {\n        var sum float64\n        switch num.(type) {\n        case []int:\n            for _, v := range num.([]int) {\n                sum += float64(v)\n            }\n            result = append(result, sum / float64(len(num.([]int))))\n        case []float64:\n            for _, v := range num.([]float64) {\n                sum += v\n            }\n            result = append(result, sum / float64(len(num.([]float64))))\n        }\n    }\n    return result\n}\n",
    "    var result []float64\n    for _, v := range nums {\n        var sum float64\n        for _, num := range v.([]interface{}) {\n            sum += num.(float64)\n        }\n        result = append(result, sum / float64(len(v.([]interface{}))))\n    }\n    return result\n}\n",
    "    var result []float64\n    for _, v := range nums {\n        var sum float64\n        var count float64\n        for _, v2 := range v.([]interface{}) {\n            sum += v2.(float64)\n            count++\n        }\n        result = append(result, sum/count)\n    }\n    return result\n}\n",
    "    var result []float64\n    for _, v := range nums {\n        var sum float64\n        for _, v2 := range v.([]int) {\n            sum += float64(v2)\n        }\n        result = append(result, sum / float64(len(v.([]int))))\n    }\n    return result\n}\n",
    "    var result []float64\n    for _, num := range nums {\n        var sum float64 = 0\n        for _, n := range num.([]interface{}) {\n            sum += n.(float64)\n        }\n        result = append(result, sum / float64(len(num.([]interface{}))))\n    }\n    return result\n}\n",
    "    var result []float64\n    for _, v := range nums {\n        var sum float64\n        var count int\n        for _, v2 := range v.([]interface{}) {\n            sum += v2.(float64)\n            count++\n        }\n        result = append(result, sum / float64(count))\n    }\n    return result\n}\n",
    "    var result []float64\n    for _, num := range nums {\n        var sum float64\n        switch num.(type) {\n        case []int:\n            for _, v := range num.([]int) {\n                sum += float64(v)\n            }\n        case []float64:\n            for _, v := range num.([]float64) {\n                sum += v\n            }\n        }\n        result = append(result, sum / float64(len(num.([]int))))\n    }\n    return result\n}\n",
    "    var result []float64\n    for _, v := range nums {\n        var sum float64\n        for _, v2 := range v.([]interface{}) {\n            sum += v2.(float64)\n        }\n        result = append(result, sum / float64(len(v.([]interface{}))))\n    }\n    return result\n}\n",
    "    var result []float64\n    for _, tuple := range nums {\n        var sum float64\n        for _, num := range tuple.([]interface{}) {\n            sum += num.(float64)\n        }\n        result = append(result, sum / float64(len(tuple.([]interface{}))))\n    }\n    return result\n}\n",
    "    var result []float64\n    for _, v := range nums {\n        var sum float64\n        for _, v2 := range v.([]interface{}) {\n            sum += v2.(float64)\n        }\n        result = append(result, sum / float64(len(v.([]interface{}))))\n    }\n    return result\n}\n",
    "    var result []float64\n    for _, num := range nums {\n        var sum float64\n        switch num.(type) {\n        case []int:\n            for _, n := range num.([]int) {\n                sum += float64(n)\n            }\n            result = append(result, sum/float64(len(num.([]int))))\n        case []float64:\n            for _, n := range num.([]float64) {\n                sum += n\n            }\n            result = append(result, sum/float64(len(num.([]float64))))\n        }\n    }\n    return result\n}\n",
    "    var result []float64\n    for _, v := range nums {\n        var sum float64\n        for _, v2 := range v.([]interface{}) {\n            sum += v2.(float64)\n        }\n        result = append(result, sum / float64(len(v.([]interface{}))))\n    }\n    return result\n}\n",
    "    var result []float64\n    for _, num := range nums {\n        var sum float64\n        switch num.(type) {\n        case []int:\n            for _, n := range num.([]int) {\n                sum += float64(n)\n            }\n            result = append(result, sum/float64(len(num.([]int))))\n        case []float64:\n            for _, n := range num.([]float64) {\n                sum += n\n            }\n            result = append(result, sum/float64(len(num.([]float64))))\n        }\n    }\n    return result\n}\n",
    "    var result []float64\n    for _, num := range nums {\n        switch num.(type) {\n        case []int:\n            var sum int\n            for _, n := range num.([]int) {\n                sum += n\n            }\n            result = append(result, float64(sum) / float64(len(num.([]int))))\n        case []float64:\n            var sum float64\n            for _, n := range num.([]float64) {\n                sum += n\n            }\n            result = append(result, sum / float64(len(num.([]float64))))\n        }\n    }\n    return result\n}\n",
    "    var result []float64\n    for _, num := range nums {\n        var sum float64\n        for _, n := range num.([]interface{}) {\n            sum += n.(float64)\n        }\n        result = append(result, sum / float64(len(num.([]interface{}))))\n    }\n    return result\n}\n",
    "    var result []float64\n    for _, num := range nums {\n        var sum float64\n        for _, n := range num.([]interface{}) {\n            sum += n.(float64)\n        }\n        result = append(result, sum / float64(len(num.([]interface{}))))\n    }\n    return result\n}\n"
  ]
}