{
  "name": "mbpp_428_shell_sort",
  "language": "go_test.go",
  "prompt": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_428_shell_sort.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    n := len(my_list)\n    gap := n / 2\n    for gap > 0 {\n        for i := gap; i < n; i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    var gap int = len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    var gap int = len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    length := len(my_list)\n    gap := length / 2\n\n    for gap > 0 {\n        for i := gap; i < length; i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    length := len(my_list)\n    gap := length / 2\n\n    for gap > 0 {\n        for i := gap; i < length; i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        for i := gap; i < len(my_list); i++ {\n            for j := i - gap; j >= 0 && my_list[j] > my_list[j+gap]; j -= gap {\n                my_list[j], my_list[j+gap] = my_list[j+gap], my_list[j]\n            }\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    length := len(my_list)\n    gap := length / 2\n\n    for gap > 0 {\n        for i := gap; i < length; i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    gap := len(my_list) / 2\n    for gap > 0 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n        // reduce the gap\n        gap /= 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.008s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    n := len(my_list)\n    gap := n / 2\n    for gap > 0 {\n        for i := gap; i < n; i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        for i := gap; i < len(my_list); i++ {\n            for j := i - gap; j >= 0 && my_list[j] > my_list[j + gap]; j -= gap {\n                my_list[j], my_list[j + gap] = my_list[j + gap], my_list[j]\n            }\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Your code goes here\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "--- FAIL: TestShell_Sort (0.00s)\n    --- FAIL: TestShell_Sort/test_num__0 (0.00s)\n        tmp6fmoqjd5_test.go:29: expected '[%!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=12) %!s(int=12) %!s(int=23) %!s(int=56) %!s(int=81) %!s(int=95)]', got '[%!s(int=12) %!s(int=23) %!s(int=4) %!s(int=5) %!s(int=3) %!s(int=2) %!s(int=12) %!s(int=81) %!s(int=56) %!s(int=95)]'\n    --- FAIL: TestShell_Sort/test_num__1 (0.00s)\n        tmp6fmoqjd5_test.go:29: expected '[%!s(int=22) %!s(int=24) %!s(int=34) %!s(int=39) %!s(int=68) %!s(int=73) %!s(int=87)]', got '[%!s(int=24) %!s(int=22) %!s(int=39) %!s(int=34) %!s(int=87) %!s(int=73) %!s(int=68)]'\n    --- FAIL: TestShell_Sort/test_num__2 (0.00s)\n        tmp6fmoqjd5_test.go:29: expected '[%!s(int=16) %!s(int=30) %!s(int=32) %!s(int=74) %!s(int=82) %!s(int=83) %!s(int=96)]', got '[%!s(int=32) %!s(int=30) %!s(int=16) %!s(int=96) %!s(int=82) %!s(int=83) %!s(int=74)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            for j := i; j >= gap && my_list[j-gap] > temp; j -= gap {\n                my_list[j] = my_list[j-gap]\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwsa4en19_test.go:26:21: undefined: j\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            for j := i; j >= gap && my_list[j-gap] > temp; j -= gap {\n                my_list[j] = my_list[j-gap]\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwsa4en19_test.go:26:21: undefined: j\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            for j := i; j >= gap && my_list[j-gap] > temp; j -= gap {\n                my_list[j] = my_list[j-gap]\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwsa4en19_test.go:26:21: undefined: j\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Set the gap value to half of the array length.\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // TODO - Add your code here\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "--- FAIL: TestShell_Sort (0.00s)\n    --- FAIL: TestShell_Sort/test_num__0 (0.00s)\n        tmpknv898to_test.go:29: expected '[%!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=12) %!s(int=12) %!s(int=23) %!s(int=56) %!s(int=81) %!s(int=95)]', got '[%!s(int=12) %!s(int=23) %!s(int=4) %!s(int=5) %!s(int=3) %!s(int=2) %!s(int=12) %!s(int=81) %!s(int=56) %!s(int=95)]'\n    --- FAIL: TestShell_Sort/test_num__1 (0.00s)\n        tmpknv898to_test.go:29: expected '[%!s(int=22) %!s(int=24) %!s(int=34) %!s(int=39) %!s(int=68) %!s(int=73) %!s(int=87)]', got '[%!s(int=24) %!s(int=22) %!s(int=39) %!s(int=34) %!s(int=87) %!s(int=73) %!s(int=68)]'\n    --- FAIL: TestShell_Sort/test_num__2 (0.00s)\n        tmpknv898to_test.go:29: expected '[%!s(int=16) %!s(int=30) %!s(int=32) %!s(int=74) %!s(int=82) %!s(int=83) %!s(int=96)]', got '[%!s(int=32) %!s(int=30) %!s(int=16) %!s(int=96) %!s(int=82) %!s(int=83) %!s(int=74)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    var gap int = len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    length := len(my_list)\n    gap := length / 2\n\n    for gap > 0 {\n        for i := gap; i < length; i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        for i := gap; i < len(my_list); i++ {\n            for j := i; j >= gap && my_list[j - gap] > my_list[j]; j -= gap {\n                my_list[j], my_list[j - gap] = my_list[j - gap], my_list[j]\n            }\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        for i := gap; i < len(my_list); i++ {\n            for j := i; j >= gap && my_list[j - gap] > my_list[j]; j -= gap {\n                my_list[j], my_list[j - gap] = my_list[j - gap], my_list[j]\n            }\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    var gap int = len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            for j := i; j >= gap && my_list[j - gap] > temp; j -= gap {\n                my_list[j] = my_list[j - gap]\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk7ryy8qy_test.go:25:21: undefined: j\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    length := len(my_list)\n    gap := length / 2\n    for gap > 0 {\n        for i := gap; i < length; i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        for i := gap; i < len(my_list); i++ {\n            for j := i - gap; j >= 0 && my_list[j] > my_list[j + gap]; j -= gap {\n                my_list[j], my_list[j + gap] = my_list[j + gap], my_list[j]\n            }\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    var gap int = len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            for j := i; j >= gap && my_list[j - gap] > temp; j -= gap {\n                my_list[j] = my_list[j - gap]\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjnjo646x_test.go:24:21: undefined: j\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    n := len(my_list)\n    gap := n / 2\n\n    for gap > 0 {\n        for i := gap; i < n; i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    var gap int = len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            for j := i; j >= gap && my_list[j-gap] > temp; j -= gap {\n                my_list[j] = my_list[j-gap]\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwsa4en19_test.go:26:21: undefined: j\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    var gap int = len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            for j := i; j >= gap && my_list[j-gap] > temp; j -= gap {\n                my_list[j] = my_list[j-gap]\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwsa4en19_test.go:26:21: undefined: j\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            for j := i; j >= gap && my_list[j-gap] > temp; j -= gap {\n                my_list[j] = my_list[j-gap]\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwsa4en19_test.go:26:21: undefined: j\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    var gap int = len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            for j := i; j >= gap && my_list[j - gap] > temp; j -= gap {\n                my_list[j] = my_list[j - gap]\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk7ryy8qy_test.go:25:21: undefined: j\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    gap := len(my_list) / 2\n    for gap > 0 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n        // reduce the gap for the next element\n        gap /= 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.006s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    var n = len(my_list)\n    var gap = n / 2\n    for gap > 0 {\n        for i := gap; i < n; i++ {\n            var temp = my_list[i]\n            var j = i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    gap := len(my_list) / 2\n    for gap > 0 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n        // reduce the gap\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap = gap / 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i++ {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j = j - gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    length := len(my_list)\n    gap := length / 2\n    for gap > 0 {\n        for i := gap; i < length; i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    var gap int = len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    var n = len(my_list)\n    var gap = n / 2\n\n    for gap > 0 {\n        for i := gap; i < n; i++ {\n            var temp = my_list[i]\n            var j = i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    var gap int = len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    var gap int = len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            for j := i; j >= gap && my_list[j - gap] > temp; j -= gap {\n                my_list[j] = my_list[j - gap]\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk7ryy8qy_test.go:25:21: undefined: j\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            for j := i; j >= gap && my_list[j - gap] > temp; j -= gap {\n                my_list[j] = my_list[j - gap]\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk7ryy8qy_test.go:25:21: undefined: j\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        for i := gap; i < len(my_list); i++ {\n            for j := i - gap; j >= 0; j -= gap {\n                if my_list[j] > my_list[j + gap] {\n                    my_list[j], my_list[j + gap] = my_list[j + gap], my_list[j]\n                }\n            }\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Your code goes here\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "--- FAIL: TestShell_Sort (0.00s)\n    --- FAIL: TestShell_Sort/test_num__0 (0.00s)\n        tmp6fmoqjd5_test.go:29: expected '[%!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=12) %!s(int=12) %!s(int=23) %!s(int=56) %!s(int=81) %!s(int=95)]', got '[%!s(int=12) %!s(int=23) %!s(int=4) %!s(int=5) %!s(int=3) %!s(int=2) %!s(int=12) %!s(int=81) %!s(int=56) %!s(int=95)]'\n    --- FAIL: TestShell_Sort/test_num__1 (0.00s)\n        tmp6fmoqjd5_test.go:29: expected '[%!s(int=22) %!s(int=24) %!s(int=34) %!s(int=39) %!s(int=68) %!s(int=73) %!s(int=87)]', got '[%!s(int=24) %!s(int=22) %!s(int=39) %!s(int=34) %!s(int=87) %!s(int=73) %!s(int=68)]'\n    --- FAIL: TestShell_Sort/test_num__2 (0.00s)\n        tmp6fmoqjd5_test.go:29: expected '[%!s(int=16) %!s(int=30) %!s(int=32) %!s(int=74) %!s(int=82) %!s(int=83) %!s(int=96)]', got '[%!s(int=32) %!s(int=30) %!s(int=16) %!s(int=96) %!s(int=82) %!s(int=83) %!s(int=74)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            for j := i; j >= gap && my_list[j-gap] > temp; j -= gap {\n                my_list[j] = my_list[j-gap]\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwsa4en19_test.go:26:21: undefined: j\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for ; j >= gap && my_list[j - gap] > temp; j -= gap {\n                my_list[j] = my_list[j - gap]\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    gap := len(my_list) / 2\n    for gap > 0 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n        // reduce the gap\n        gap /= 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.008s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for ; j >= gap && my_list[j - gap] > temp; j -= gap {\n                my_list[j] = my_list[j - gap]\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122550,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is\n        // gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            j := i\n            for j >= gap && my_list[j-gap] > temp {\n                my_list[j] = my_list[j-gap]\n                j -= gap\n            }\n\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    // Start with a big gap, then reduce the gap\n    for gap := len(my_list) / 2; gap > 0; gap /= 2 {\n        // Do a gapped insertion sort for this gap size.\n        // The first gap elements a[0..gap-1] are already in gapped order\n        // keep adding one more element until the entire array is gap sorted\n        for i := gap; i < len(my_list); i += 1 {\n            // add a[i] to the elements that have been gap sorted\n            // save a[i] in temp and make a hole at position i\n            temp := my_list[i]\n            // shift earlier gap-sorted elements up until the correct\n            // location for a[i] is found\n            for j := i; j >= gap && my_list[j - gap] > temp; j -= gap {\n                my_list[j] = my_list[j - gap]\n            }\n            // put temp (the original a[i]) in its correct location\n            my_list[j] = temp\n        }\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk7ryy8qy_test.go:25:21: undefined: j\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            }\n            my_list[j] = temp\n        }\n        gap /= 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package shell_sort_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list []int) []int {\n    gap := len(my_list) / 2\n    for gap > 0 {\n        for i := gap; i < len(my_list); i++ {\n            temp := my_list[i]\n            j := i\n            for j >= gap && my_list[j - gap] > temp {\n                my_list[j] = my_list[j - gap]\n                j = j - gap\n            }\n            my_list[j] = temp\n        }\n        gap = gap / 2\n    }\n    return my_list\n}\n\nfunc TestShell_Sort(t *testing.T) {\n  candidate := shell_sort\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{12, 23, 4, 5, 3, 2, 12, 81, 56, 95}), expected: []int{2, 3, 4, 5, 12, 12, 23, 56, 81, 95} },\n     { actual: candidate([]int{24, 22, 39, 34, 87, 73, 68}), expected: []int{22, 24, 34, 39, 68, 73, 87} },\n     { actual: candidate([]int{32, 30, 16, 96, 82, 83, 74}), expected: []int{16, 30, 32, 74, 82, 83, 96} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510117,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    }
  ]
}