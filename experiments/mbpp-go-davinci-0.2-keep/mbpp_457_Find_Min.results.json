{
  "name": "mbpp_457_Find_Min",
  "language": "go_test.go",
  "prompt": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_457_Find_Min.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzui7ya1n_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n                min_len = len(v.([]interface{}))\n            } else {\n                if len(v.([]interface{})) < min_len {\n                    min = v\n                    min_len = len(v.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprr9aw5gm_test.go:40:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            lst_lst := lst.([]interface{})\n            min_lst := lst_lst[0]\n            for _, lst := range lst_lst {\n                if len(lst.([]interface{})) < len(min_lst.([]interface{})) {\n                    min_lst = lst\n                }\n            }\n            return min_lst\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe73b3alo_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        lst := lst.([]int)\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case []string:\n        lst := lst.([]string)\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case [][]int:\n        lst := lst.([][]int)\n        min := lst[0]\n        for _, v := range lst {\n            if len(v) < len(min) {\n                min = v\n            }\n        }\n        return min\n    case [][]string:\n        lst := lst.([][]string)\n        min := lst[0]\n        for _, v := range lst {\n            if len(v) < len(min) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqe0dod8k_test.go:61:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []int:\n            return Find_Min_int(lst.([]int))\n        case []string:\n            return Find_Min_string(lst.([]string))\n        case []interface{}:\n            return Find_Min_interface(lst.([]interface{}))\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkj2_108w_test.go:12:20: undefined: Find_Min_int\n/tmp/tmpkj2_108w_test.go:14:20: undefined: Find_Min_string\n/tmp/tmpkj2_108w_test.go:16:20: undefined: Find_Min_interface\n/tmp/tmpkj2_108w_test.go:31:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_lst := lst.([]interface{})\n        min_lst := lst_lst[0]\n        for _, lst := range lst_lst {\n            if len(lst.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = lst\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpki8wb_p7_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, item := range lst.([]interface{}) {\n            if len(item.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = item\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppoil82jf_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min_len := len(lst.([]interface{}))\n        for _, item := range lst.([]interface{}) {\n            if len(item.([]interface{})) < min_len {\n                min = item\n                min_len = len(item.([]interface{}))\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpldr16ge4_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min_len := len(lst.([]interface{}))\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < min_len {\n                min = v\n                min_len = len(v.([]interface{}))\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2h4dv89y_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case []float64:\n        return Find_Min_float64(lst.([]float64))\n    case []interface{}:\n        return Find_Min_interface(lst.([]interface{}))\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510638,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyfpkyb9b_test.go:12:16: undefined: Find_Min_int\n/tmp/tmpyfpkyb9b_test.go:14:16: undefined: Find_Min_string\n/tmp/tmpyfpkyb9b_test.go:16:16: undefined: Find_Min_float64\n/tmp/tmpyfpkyb9b_test.go:18:16: undefined: Find_Min_interface\n/tmp/tmpyfpkyb9b_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        min_int := lst_int[0]\n        for _, v := range lst_int {\n            if v < min_int {\n                min_int = v\n            }\n        }\n        return min_int\n    case []string:\n        lst_str := lst.([]string)\n        min_str := lst_str[0]\n        for _, v := range lst_str {\n            if v < min_str {\n                min_str = v\n            }\n        }\n        return min_str\n    case [][]int:\n        lst_lst := lst.([][]int)\n        min_lst := lst_lst[0]\n        for _, v := range lst_lst {\n            if len(v) < len(min_lst) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzuv5yezs_test.go:52:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpm6pa5t3j_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min_len := len(lst.([]interface{}))\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < min_len {\n                min = v\n                min_len = len(v.([]interface{}))\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2h4dv89y_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min_len := len(lst.([]interface{}))\n        for _, v := range lst.([]interface{}) {\n            if v_len := len(Find_Min(v).([]interface{})); v_len < min_len {\n                min = v\n                min_len = v_len\n            }\n        }\n        return min\n    case int:\n        return lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6mxjiq2r_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    var min_lst interface{}\n    min_len := len(lst.([]interface{}))\n    for _, item := range lst.([]interface{}) {\n        if len(item.([]interface{})) < min_len {\n            min_lst = item\n            min_len = len(item.([]interface{}))\n        }\n    }\n    return min_lst\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfe83f4vx_test.go:30:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        var min_lst []int\n        var min_len int\n        for _, v := range lst.([]int) {\n            if min_len == 0 || len(v) < min_len {\n                min_lst = v\n                min_len = len(v)\n            }\n        }\n        return min_lst\n    case []string:\n        var min_lst []string\n        var min_len int\n        for _, v := range lst.([]string) {\n            if min_len == 0 || len(v) < min_len {\n                min_lst = v\n                min_len = len(v)\n            }\n        }\n        return min_lst\n    case []interface{}:\n        var min_lst []interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min_len == 0 || len(v) < min_len {\n                min_lst = v\n                min_len = len(v)\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0ymyzvv5_test.go:15:35: invalid argument v (type int) for len\n/tmp/tmp0ymyzvv5_test.go:16:25: cannot use v (type int) as type []int in assignment\n/tmp/tmp0ymyzvv5_test.go:17:30: invalid argument v (type int) for len\n/tmp/tmp0ymyzvv5_test.go:26:25: cannot use v (type string) as type []string in assignment\n/tmp/tmp0ymyzvv5_test.go:35:35: invalid argument v (type interface {}) for len\n/tmp/tmp0ymyzvv5_test.go:36:25: cannot use v (type interface {}) as type []interface {} in assignment: need type assertion\n/tmp/tmp0ymyzvv5_test.go:37:30: invalid argument v (type interface {}) for len\n/tmp/tmp0ymyzvv5_test.go:55:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch v := lst.(type) {\n    case []interface{}:\n        min := v[0]\n        for _, i := range v {\n            if len(i.([]interface{})) < len(min.([]interface{})) {\n                min = i\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprwaajg4b_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return lst\n        }\n        min_lst := lst.([]interface{})[0]\n        for _, item := range lst.([]interface{}) {\n            if len(Find_Min(item).([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = item\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{lst}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4nhy47fl_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            lst_lst := lst.([]interface{})\n            min_lst := lst_lst[0]\n            for _, lst := range lst_lst {\n                if len(lst.([]interface{})) < len(min_lst.([]interface{})) {\n                    min_lst = lst\n                }\n            }\n            return min_lst\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe73b3alo_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_lst := lst.([]interface{})\n        min_lst := lst_lst[0]\n        for _, lst := range lst_lst {\n            if len(lst.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = lst\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpki8wb_p7_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    var min interface{}\n    switch lst.(type) {\n    case []int:\n        min = lst.([]int)[0]\n        for _, v := range lst.([]int) {\n            if v < min.(int) {\n                min = v\n            }\n        }\n    case []string:\n        min = lst.([]string)[0]\n        for _, v := range lst.([]string) {\n            if v < min.(string) {\n                min = v\n            }\n        }\n    case []float64:\n        min = lst.([]float64)[0]\n        for _, v := range lst.([]float64) {\n            if v < min.(float64) {\n                min = v\n            }\n        }\n    }\n    return min\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx4dmrrcw_test.go:46:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_lst := lst.([]interface{})\n        min_lst := lst_lst[0]\n        for _, lst := range lst_lst {\n            if len(lst.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = lst\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpki8wb_p7_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case [][]int:\n        return Find_Min_int_slice(lst.([][]int))\n    case [][]string:\n        return Find_Min_string_slice(lst.([][]string))\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx4l5e92a_test.go:12:16: undefined: Find_Min_int\n/tmp/tmpx4l5e92a_test.go:14:16: undefined: Find_Min_string\n/tmp/tmpx4l5e92a_test.go:16:16: undefined: Find_Min_int_slice\n/tmp/tmpx4l5e92a_test.go:18:16: undefined: Find_Min_string_slice\n/tmp/tmpx4l5e92a_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return []interface{}{}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9_yjkgxi_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int = len(lst.([]interface{}))\n        for _, v := range lst.([]interface{}) {\n            if v_len := len(Find_Min(v).([]interface{})); v_len < min_len {\n                min = v\n                min_len = v_len\n            }\n        }\n        return min\n    default:\n        return []interface{}{lst}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmporbglnvv_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        min := lst.([]int)[0]\n        for _, v := range lst.([]int) {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case []string:\n        min := lst.([]string)[0]\n        for _, v := range lst.([]string) {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case [][]int:\n        min := lst.([][]int)[0]\n        for _, v := range lst.([][]int) {\n            if len(v) < len(min) {\n                min = v\n            }\n        }\n        return min\n    case [][]string:\n        min := lst.([][]string)[0]\n        for _, v := range lst.([][]string) {\n            if len(v) < len(min) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0g6h6mz7_test.go:57:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(min_lst.([]interface{})) > len(v.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb1pwu_e9_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{lst}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_11_mjdu_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return lst\n        }\n        min_len := lst_len\n        min_lst := lst\n        for _, item := range lst.([]interface{}) {\n            sub_lst := Find_Min(item)\n            sub_lst_len := len(sub_lst.([]interface{}))\n            if sub_lst_len < min_len {\n                min_len = sub_lst_len\n                min_lst = sub_lst\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplgkyfg3i_test.go:41:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            lst_lst := lst.([]interface{})\n            min_lst := lst_lst[0]\n            for _, lst := range lst_lst {\n                if len(lst.([]interface{})) < len(min_lst.([]interface{})) {\n                    min_lst = lst\n                }\n            }\n            return min_lst\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe73b3alo_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        min := lst.([]int)[0]\n        for _, v := range lst.([]int) {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case []string:\n        min := lst.([]string)[0]\n        for _, v := range lst.([]string) {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case [][]int:\n        min := lst.([][]int)[0]\n        for _, v := range lst.([][]int) {\n            if len(v) < len(min) {\n                min = v\n            }\n        }\n        return min\n    case [][]string:\n        min := lst.([][]string)[0]\n        for _, v := range lst.([][]string) {\n            if len(v) < len(min) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0g6h6mz7_test.go:57:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_ := lst.([]interface{})\n        min_ := lst_[0]\n        for _, v := range lst_ {\n            if len(v.([]interface{})) < len(min_.([]interface{})) {\n                min_ = v\n            }\n        }\n        return min_\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6er7jh4z_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        min_int := lst_int[0]\n        for _, v := range lst_int {\n            if v < min_int {\n                min_int = v\n            }\n        }\n        return min_int\n    case []string:\n        lst_string := lst.([]string)\n        min_string := lst_string[0]\n        for _, v := range lst_string {\n            if v < min_string {\n                min_string = v\n            }\n        }\n        return min_string\n    case []float64:\n        lst_float := lst.([]float64)\n        min_float := lst_float[0]\n        for _, v := range lst_float {\n            if v < min_float {\n                min_float = v\n            }\n        }\n        return min_float\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbc4y2qjg_test.go:52:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        lst := lst.([]int)\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case [][]int:\n        lst := lst.([][]int)\n        min := lst[0]\n        for _, v := range lst {\n            if len(v) < len(min) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu7ahi8c5_test.go:43:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{} = lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi3y0g7t__test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return lst\n        }\n        min_lst := lst.([]interface{})[0]\n        for _, item := range lst.([]interface{}) {\n            if len(Find_Min(item).([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = item\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{lst}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4nhy47fl_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n                min_len = len(v.([]interface{}))\n            } else if len(v.([]interface{})) < min_len {\n                min = v\n                min_len = len(v.([]interface{}))\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpssyyrr9y_test.go:38:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return nil\n        }\n        min_lst := lst.([]interface{})[0]\n        for i := 1; i < lst_len; i++ {\n            if len(Find_Min(lst.([]interface{})[i]).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                min_lst = lst.([]interface{})[i]\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1afdgbyw_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        min := l[0]\n        for _, v := range l {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv05t1p3n_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy3gb0i5__test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []int:\n            var min int = len(lst.([]int))\n            var sublist []int\n            for _, v := range lst.([]int) {\n                if len(v) < min {\n                    min = len(v)\n                    sublist = v\n                }\n            }\n            return sublist\n        case []string:\n            var min int = len(lst.([]string))\n            var sublist []string\n            for _, v := range lst.([]string) {\n                if len(v) < min {\n                    min = len(v)\n                    sublist = v\n                }\n            }\n            return sublist\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa2qq1fvw_test.go:15:23: invalid argument v (type int) for len\n/tmp/tmpa2qq1fvw_test.go:16:30: invalid argument v (type int) for len\n/tmp/tmpa2qq1fvw_test.go:17:29: cannot use v (type int) as type []int in assignment\n/tmp/tmpa2qq1fvw_test.go:27:29: cannot use v (type string) as type []string in assignment\n/tmp/tmpa2qq1fvw_test.go:45:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{}\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return []interface{}{}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnc8by0vr_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case []float64:\n        return Find_Min_float64(lst.([]float64))\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjcnbh46r_test.go:12:16: undefined: Find_Min_int\n/tmp/tmpjcnbh46r_test.go:14:16: undefined: Find_Min_string\n/tmp/tmpjcnbh46r_test.go:16:16: undefined: Find_Min_float64\n/tmp/tmpjcnbh46r_test.go:31:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_len := -1\n        for _, v := range lst.([]interface{}) {\n            if min_len == -1 || len(v.([]interface{})) < min_len {\n                min_lst = v\n                min_len = len(v.([]interface{}))\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps01_8m4s_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzui7ya1n_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    // TODO: Implement me!\n    return nil\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2yq4tdtt_test.go:23:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []int:\n            var min_lst []int\n            for _, v := range lst.([]int) {\n                if len(min_lst) == 0 || len(v) < len(min_lst) {\n                    min_lst = v\n                }\n            }\n            return min_lst\n        case []string:\n            var min_lst []string\n            for _, v := range lst.([]string) {\n                if len(min_lst) == 0 || len(v) < len(min_lst) {\n                    min_lst = v\n                }\n            }\n            return min_lst\n        case []float64:\n            var min_lst []float64\n            for _, v := range lst.([]float64) {\n                if len(min_lst) == 0 || len(v) < len(min_lst) {\n                    min_lst = v\n                }\n            }\n            return min_lst\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5dyhcesp_test.go:14:44: invalid argument v (type int) for len\n/tmp/tmp5dyhcesp_test.go:15:29: cannot use v (type int) as type []int in assignment\n/tmp/tmp5dyhcesp_test.go:23:29: cannot use v (type string) as type []string in assignment\n/tmp/tmp5dyhcesp_test.go:30:44: invalid argument v (type float64) for len\n/tmp/tmp5dyhcesp_test.go:31:29: cannot use v (type float64) as type []float64 in assignment\n/tmp/tmp5dyhcesp_test.go:49:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, item := range lst.([]interface{}) {\n            if min == nil {\n                min = item\n                min_len = len(item.([]interface{}))\n            } else {\n                if len(item.([]interface{})) < min_len {\n                    min = item\n                    min_len = len(item.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2x8t8_vu_test.go:40:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        lst := lst.([]int)\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case [][]int:\n        lst := lst.([][]int)\n        min := len(lst[0])\n        for _, v := range lst {\n            if len(v) < min {\n                min = len(v)\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpagzgixdq_test.go:43:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy3gb0i5__test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            min := lst.([]interface{})[0]\n            for _, v := range lst.([]interface{}) {\n                if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                    min = v\n                }\n            }\n            return min\n        default:\n            return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp21vjuls0_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    if lst == nil {\n        return nil\n    }\n    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case []interface{}:\n        return Find_Min_interface(lst.([]interface{}))\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd7ope4lb_test.go:15:16: undefined: Find_Min_int\n/tmp/tmpd7ope4lb_test.go:17:16: undefined: Find_Min_string\n/tmp/tmpd7ope4lb_test.go:19:16: undefined: Find_Min_interface\n/tmp/tmpd7ope4lb_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        min_int := lst_int[0]\n        for _, v := range lst_int {\n            if v < min_int {\n                min_int = v\n            }\n        }\n        return min_int\n    case []string:\n        lst_str := lst.([]string)\n        min_str := lst_str[0]\n        for _, v := range lst_str {\n            if v < min_str {\n                min_str = v\n            }\n        }\n        return min_str\n    case []float64:\n        lst_float := lst.([]float64)\n        min_float := lst_float[0]\n        for _, v := range lst_float {\n            if v < min_float {\n                min_float = v\n            }\n        }\n        return min_float\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0dc3qd7q_test.go:52:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            var min_lst interface{} = lst\n            for _, v := range lst.([]interface{}) {\n                if len(Find_Min(v).([]interface{})) < len(min_lst.([]interface{})) {\n                    min_lst = v\n                }\n            }\n            return min_lst\n        default:\n            return []interface{}{lst}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa3ukub8h_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy7ub2xbl_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            var min_lst interface{}\n            min_len := len(lst.([]interface{}))\n            for _, item := range lst.([]interface{}) {\n                if len(item.([]interface{})) < min_len {\n                    min_len = len(item.([]interface{}))\n                    min_lst = item\n                }\n            }\n            return min_lst\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk1j0qggl_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n                min_len = len(v.([]interface{}))\n            } else {\n                if len(v.([]interface{})) < min_len {\n                    min = v\n                    min_len = len(v.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprr9aw5gm_test.go:40:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_ := lst.([]interface{})\n        if len(lst_) == 0 {\n            return nil\n        }\n        min_ := lst_[0]\n        for _, v := range lst_ {\n            if len(v.([]interface{})) < len(min_.([]interface{})) {\n                min_ = v\n            }\n        }\n        return min_\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwxg4_9_b_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        return lst.([]int)\n    case [][]int:\n        return lst.([][]int)\n    case []string:\n        return lst.([]string)\n    case [][]string:\n        return lst.([][]string)\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe0vwdjfd_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            var min interface{}\n            min_len := len(lst.([]interface{}))\n            for _, v := range lst.([]interface{}) {\n                if v_len := len(v.([]interface{})); v_len < min_len {\n                    min = v\n                    min_len = v_len\n                }\n            }\n            return min\n        default:\n            return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpktn1in9w_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            min_lst := lst.([]interface{})\n            for _, v := range lst.([]interface{}) {\n                if len(v.([]interface{})) < len(min_lst) {\n                    min_lst = v.([]interface{})\n                }\n            }\n            return min_lst\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpm0am9knu_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            if len(lst.([]interface{})) == 0 {\n                return nil\n            }\n            min_lst := lst.([]interface{})[0]\n            for _, item := range lst.([]interface{}) {\n                if len(Find_Min(item).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                    min_lst = item\n                }\n            }\n            return min_lst\n        case int:\n            return []interface{}{lst}\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppb824pe4_test.go:38:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        return []int{}\n    case [][]int:\n        return [][]int{}\n    case []string:\n        return []string{}\n    case [][]string:\n        return [][]string{}\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8nhyfwns_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        min := lst.([]int)[0]\n        for _, v := range lst.([]int) {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case [][]int:\n        min := lst.([][]int)[0]\n        for _, v := range lst.([][]int) {\n            if len(v) < len(min) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpowyrvf81_test.go:41:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            var min interface{}\n            var min_len int\n            for _, v := range lst.([]interface{}) {\n                if min == nil {\n                    min = v\n                    min_len = len(v.([]interface{}))\n                } else {\n                    if len(v.([]interface{})) < min_len {\n                        min = v\n                        min_len = len(v.([]interface{}))\n                    }\n                }\n            }\n            return min\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2uvw6zeh_test.go:40:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_ := lst.([]interface{})\n        min_ := lst_[0]\n        for _, v := range lst_ {\n            if len(v.([]interface{})) < len(min_.([]interface{})) {\n                min_ = v\n            }\n        }\n        return min_\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6er7jh4z_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return nil\n        }\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1fztxce9_test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    var min interface{}\n    switch lst.(type) {\n    case []interface{}:\n        min = lst\n        for _, item := range lst.([]interface{}) {\n            if len(Find_Min(item).([]interface{})) < len(min.([]interface{})) {\n                min = item\n            }\n        }\n    default:\n        min = []interface{}{}\n    }\n    return min\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxcwco43q_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n            } else if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zfyg_pl_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_lst := lst.([]interface{})\n        min_lst := lst_lst[0]\n        for _, lst := range lst_lst {\n            if len(lst.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = lst\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpki8wb_p7_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    var min interface{}\n    switch lst.(type) {\n    case []interface{}:\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n    default:\n        min = []interface{}{}\n    }\n    return min\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmputd_trkc_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int = len(lst.([]interface{}))\n        for _, v := range lst.([]interface{}) {\n            if v_len := len(Find_Min(v).([]interface{})); v_len < min_len {\n                min_len = v_len\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpf4wgp254_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, v := range lst {\n            min = Find_Min([]interface{}{min, v})\n        }\n        return min\n    case string:\n        return lst.(string)\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbe5zbyu3_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl4p5bgf2_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpve2d06vg_test.go:12:16: undefined: Find_Min_int\n/tmp/tmpve2d06vg_test.go:14:16: undefined: Find_Min_string\n/tmp/tmpve2d06vg_test.go:29:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n                min_len = len(v.([]interface{}))\n            } else {\n                if len(v.([]interface{})) < min_len {\n                    min = v\n                    min_len = len(v.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprr9aw5gm_test.go:40:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min_len := len(lst.([]interface{}))\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < min_len {\n                min = v\n                min_len = len(v.([]interface{}))\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2h4dv89y_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return nil\n        }\n        min_lst := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp24u_539h_test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{lst}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_11_mjdu_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n                min_len = len(v.([]interface{}))\n            } else {\n                if len(v.([]interface{})) < min_len {\n                    min = v\n                    min_len = len(v.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprr9aw5gm_test.go:40:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, item := range lst.([]interface{}) {\n            if len(item.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = item\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppoil82jf_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            lst_len := len(lst.([]interface{}))\n            if lst_len == 0 {\n                return nil\n            }\n            min_lst := lst.([]interface{})[0]\n            for _, v := range lst.([]interface{}) {\n                if len(Find_Min(v).([]interface{})) < len(min_lst.([]interface{})) {\n                    min_lst = v\n                }\n            }\n            return min_lst\n        default:\n            return []interface{}{}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp05z66a7o_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_lst = lst\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr5uj7iat_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy3gb0i5__test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            min := lst.([]interface{})[0]\n            for _, item := range lst.([]interface{}) {\n                if len(Find_Min(item).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                    min = item\n                }\n            }\n            return min\n        default:\n            return []interface{}{lst}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4f2u3hmm_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_lst := lst.([]interface{})\n        if len(lst_lst) == 0 {\n            return nil\n        }\n        min_lst := lst_lst[0]\n        for _, lst := range lst_lst {\n            if len(lst.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = lst\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0edi0o4h_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_ := lst.([]interface{})\n        if len(lst_) == 0 {\n            return nil\n        }\n        min_ := lst_[0]\n        for _, v := range lst_[1:] {\n            if len(v.([]interface{})) < len(min_.([]interface{})) {\n                min_ = v\n            }\n        }\n        return min_\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0ya999wg_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpve2d06vg_test.go:12:16: undefined: Find_Min_int\n/tmp/tmpve2d06vg_test.go:14:16: undefined: Find_Min_string\n/tmp/tmpve2d06vg_test.go:29:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        min_int := lst_int[0]\n        for _, v := range lst_int {\n            if v < min_int {\n                min_int = v\n            }\n        }\n        return min_int\n    case []string:\n        lst_string := lst.([]string)\n        min_string := lst_string[0]\n        for _, v := range lst_string {\n            if len(v) < len(min_string) {\n                min_string = v\n            }\n        }\n        return min_string\n    case []float64:\n        lst_float := lst.([]float64)\n        min_float := lst_float[0]\n        for _, v := range lst_float {\n            if v < min_float {\n                min_float = v\n            }\n        }\n        return min_float\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_8ybp1tg_test.go:52:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        var min_lst []int\n        min_lst = lst.([]int)\n        for _, v := range lst.([]int) {\n            if len(v) < len(min_lst) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    case []string:\n        var min_lst []string\n        min_lst = lst.([]string)\n        for _, v := range lst.([]string) {\n            if len(v) < len(min_lst) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdoriao_u_test.go:15:19: invalid argument v (type int) for len\n/tmp/tmpdoriao_u_test.go:16:25: cannot use v (type int) as type []int in assignment\n/tmp/tmpdoriao_u_test.go:25:25: cannot use v (type string) as type []string in assignment\n/tmp/tmpdoriao_u_test.go:43:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return nil\n        }\n        min_len := lst_len\n        min_lst := lst\n        for _, v := range lst.([]interface{}) {\n            if v_len := len(Find_Min(v).([]interface{})); v_len < min_len {\n                min_len = v_len\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{lst}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphze8j3bj_test.go:39:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case [][]int:\n        return Find_Min_int_slice(lst.([][]int))\n    case [][]string:\n        return Find_Min_string_slice(lst.([][]string))\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx4l5e92a_test.go:12:16: undefined: Find_Min_int\n/tmp/tmpx4l5e92a_test.go:14:16: undefined: Find_Min_string\n/tmp/tmpx4l5e92a_test.go:16:16: undefined: Find_Min_int_slice\n/tmp/tmpx4l5e92a_test.go:18:16: undefined: Find_Min_string_slice\n/tmp/tmpx4l5e92a_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_lst = lst\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{lst}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqei9a7np_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, item := range lst.([]interface{}) {\n            if len(item.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = item\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppoil82jf_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    if lst == nil {\n        return nil\n    }\n    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_len := len(lst.([]interface{}))\n        for _, item := range lst.([]interface{}) {\n            if item == nil {\n                continue\n            }\n            switch item.(type) {\n            case []interface{}:\n                if len(item.([]interface{})) < min_len {\n                    min_lst = item\n                    min_len = len(item.([]interface{}))\n                }\n            case int:\n                if min_lst == nil {\n                    min_lst = item\n                    min_len = 1\n                }\n            }\n        }\n        return min_lst\n    case int:\n        return lst\n    }\n    return nil\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2f3k473p_test.go:50:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        min_int := lst_int[0]\n        for _, v := range lst_int {\n            if v < min_int {\n                min_int = v\n            }\n        }\n        return min_int\n    case []string:\n        lst_str := lst.([]string)\n        min_str := lst_str[0]\n        for _, v := range lst_str {\n            if v < min_str {\n                min_str = v\n            }\n        }\n        return min_str\n    case []float64:\n        lst_float := lst.([]float64)\n        min_float := lst_float[0]\n        for _, v := range lst_float {\n            if v < min_float {\n                min_float = v\n            }\n        }\n        return min_float\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0dc3qd7q_test.go:52:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        lst := lst.([]int)\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case [][]int:\n        lst := lst.([][]int)\n        min := lst[0]\n        for _, v := range lst {\n            if len(v) < len(min) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu7ahi8c5_test.go:43:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        var min_lst []int\n        for _, v := range lst.([]int) {\n            if len(min_lst) == 0 {\n                min_lst = append(min_lst, v)\n            } else if len(min_lst) > 0 && len(min_lst) > len(v) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    case []string:\n        var min_lst []string\n        for _, v := range lst.([]string) {\n            if len(min_lst) == 0 {\n                min_lst = append(min_lst, v)\n            } else if len(min_lst) > 0 && len(min_lst) > len(v) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    case []interface{}:\n        var min_lst []interface{}\n        for _, v := range lst.([]interface{}) {\n            if len(min_lst) == 0 {\n                min_lst = append(min_lst, v)\n            } else if len(min_lst) > 0 && len(min_lst) > len(v) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzli_o0rv_test.go:16:61: invalid argument v (type int) for len\n/tmp/tmpzli_o0rv_test.go:17:25: cannot use v (type int) as type []int in assignment\n/tmp/tmpzli_o0rv_test.go:27:25: cannot use v (type string) as type []string in assignment\n/tmp/tmpzli_o0rv_test.go:36:61: invalid argument v (type interface {}) for len\n/tmp/tmpzli_o0rv_test.go:37:25: cannot use v (type interface {}) as type []interface {} in assignment: need type assertion\n/tmp/tmpzli_o0rv_test.go:55:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        min_lst := lst[0]\n        min_len := len(min_lst.([]interface{}))\n        for _, item := range lst {\n            if len(item.([]interface{})) < min_len {\n                min_lst = item\n                min_len = len(item.([]interface{}))\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp499vz0s7_test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            var min interface{}\n            min = lst\n            for _, v := range lst.([]interface{}) {\n                if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n            return min\n        default:\n            return []interface{}{lst}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi8ap2qre_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_len := len(lst.([]interface{}))\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < min_len {\n                min_len = len(v.([]interface{}))\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnuvqcsjr_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []int:\n            return Find_Min_int(lst.([]int))\n        case []string:\n            return Find_Min_string(lst.([]string))\n        case []interface{}:\n            return Find_Min_interface(lst.([]interface{}))\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkj2_108w_test.go:12:20: undefined: Find_Min_int\n/tmp/tmpkj2_108w_test.go:14:20: undefined: Find_Min_string\n/tmp/tmpkj2_108w_test.go:16:20: undefined: Find_Min_interface\n/tmp/tmpkj2_108w_test.go:31:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_lst := lst.([]interface{})\n        min_lst := lst_lst[0]\n        for _, sub_lst := range lst_lst[1:] {\n            if len(sub_lst.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = sub_lst\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphwmas4l2_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        return find_min_int(lst.([]int))\n    case []string:\n        return find_min_string(lst.([]string))\n    case [][]int:\n        return find_min_int_slice(lst.([][]int))\n    case [][]string:\n        return find_min_string_slice(lst.([][]string))\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp83gftrx3_test.go:12:16: undefined: find_min_int\n/tmp/tmp83gftrx3_test.go:14:16: undefined: find_min_string\n/tmp/tmp83gftrx3_test.go:16:16: undefined: find_min_int_slice\n/tmp/tmp83gftrx3_test.go:18:16: undefined: find_min_string_slice\n/tmp/tmp83gftrx3_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        min_int := lst_int[0]\n        for _, v := range lst_int {\n            if v < min_int {\n                min_int = v\n            }\n        }\n        return min_int\n    case []string:\n        lst_str := lst.([]string)\n        min_str := lst_str[0]\n        for _, v := range lst_str {\n            if len(v) < len(min_str) {\n                min_str = v\n            }\n        }\n        return min_str\n    case [][]int:\n        lst_lst := lst.([][]int)\n        min_lst := lst_lst[0]\n        for _, v := range lst_lst {\n            if len(v) < len(min_lst) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvzc1alkt_test.go:52:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})\n        for _, item := range lst.([]interface{}) {\n            if len(Find_Min(item).([]interface{})) < len(min_lst) {\n                min_lst = Find_Min(item).([]interface{})\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{lst}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzg2uyyxn_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, item := range lst.([]interface{}) {\n            if len(Find_Min(item).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                min_lst = item\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{lst}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuzs8kuuq_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        min := lst_int[0]\n        for _, v := range lst_int {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case []string:\n        lst_str := lst.([]string)\n        min := lst_str[0]\n        for _, v := range lst_str {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case [][]int:\n        lst_lst := lst.([][]int)\n        min := len(lst_lst[0])\n        for _, v := range lst_lst {\n            if len(v) < min {\n                min = len(v)\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb2z76nll_test.go:52:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case [][]int:\n        return Find_Min_int_slice(lst.([][]int))\n    case [][]string:\n        return Find_Min_string_slice(lst.([][]string))\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx4l5e92a_test.go:12:16: undefined: Find_Min_int\n/tmp/tmpx4l5e92a_test.go:14:16: undefined: Find_Min_string\n/tmp/tmpx4l5e92a_test.go:16:16: undefined: Find_Min_int_slice\n/tmp/tmpx4l5e92a_test.go:18:16: undefined: Find_Min_string_slice\n/tmp/tmpx4l5e92a_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return []interface{}{lst}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps8l2unii_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case [][]int:\n        return Find_Min_int_slice(lst.([][]int))\n    case [][]string:\n        return Find_Min_string_slice(lst.([][]string))\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx4l5e92a_test.go:12:16: undefined: Find_Min_int\n/tmp/tmpx4l5e92a_test.go:14:16: undefined: Find_Min_string\n/tmp/tmpx4l5e92a_test.go:16:16: undefined: Find_Min_int_slice\n/tmp/tmpx4l5e92a_test.go:18:16: undefined: Find_Min_string_slice\n/tmp/tmpx4l5e92a_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n                min_len = len(v.([]interface{}))\n            } else {\n                if len(v.([]interface{})) < min_len {\n                    min = v\n                    min_len = len(v.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprr9aw5gm_test.go:40:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case [][]int:\n        return Find_Min_int_slice(lst.([][]int))\n    case [][]string:\n        return Find_Min_string_slice(lst.([][]string))\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx4l5e92a_test.go:12:16: undefined: Find_Min_int\n/tmp/tmpx4l5e92a_test.go:14:16: undefined: Find_Min_string\n/tmp/tmpx4l5e92a_test.go:16:16: undefined: Find_Min_int_slice\n/tmp/tmpx4l5e92a_test.go:18:16: undefined: Find_Min_string_slice\n/tmp/tmpx4l5e92a_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzui7ya1n_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min_len == 0 {\n                min = v\n                min_len = len(v.([]interface{}))\n            } else {\n                if len(v.([]interface{})) < min_len {\n                    min = v\n                    min_len = len(v.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzgx34mmz_test.go:40:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min_len == 0 {\n                min = v\n                min_len = len(v.([]interface{}))\n            } else {\n                if len(v.([]interface{})) < min_len {\n                    min = v\n                    min_len = len(v.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzgx34mmz_test.go:40:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        min_int := lst_int[0]\n        for _, v := range lst_int {\n            if v < min_int {\n                min_int = v\n            }\n        }\n        return min_int\n    case []string:\n        lst_str := lst.([]string)\n        min_str := lst_str[0]\n        for _, v := range lst_str {\n            if v < min_str {\n                min_str = v\n            }\n        }\n        return min_str\n    case [][]int:\n        lst_lst := lst.([][]int)\n        min_lst := lst_lst[0]\n        for _, v := range lst_lst {\n            if len(v) < len(min_lst) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzuv5yezs_test.go:52:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})\n        for _, item := range lst.([]interface{}) {\n            if len(Find_Min(item).([]interface{})) < len(min_lst) {\n                min_lst = Find_Min(item).([]interface{})\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{lst}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzg2uyyxn_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []int:\n            return Find_Min_int(lst.([]int))\n        case []string:\n            return Find_Min_string(lst.([]string))\n        case []interface{}:\n            return Find_Min_interface(lst.([]interface{}))\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkj2_108w_test.go:12:20: undefined: Find_Min_int\n/tmp/tmpkj2_108w_test.go:14:20: undefined: Find_Min_string\n/tmp/tmpkj2_108w_test.go:16:20: undefined: Find_Min_interface\n/tmp/tmpkj2_108w_test.go:31:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return []interface{}{}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9_yjkgxi_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        min_lst := lst[0]\n        for _, v := range lst {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{lst}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123704,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqsoeh2bt_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy3gb0i5__test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_ := lst.([]interface{})\n        min_ := lst_[0]\n        for _, v := range lst_ {\n            if len(v.([]interface{})) < len(min_.([]interface{})) {\n                min_ = v\n            }\n        }\n        return min_\n    }\n    return nil\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123704,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqrnh6djh_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return []interface{}{lst}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps8l2unii_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min_len int = len(lst.([]interface{}))\n        var min_lst interface{} = lst\n        for _, v := range lst.([]interface{}) {\n            if v_len := len(Find_Min(v).([]interface{})); v_len < min_len {\n                min_len = v_len\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123704,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgxliqpw1_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    case int:\n        return lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123704,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp02zzx5sd_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_lst = lst\n        for _, item := range lst.([]interface{}) {\n            if len(item.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = item\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123704,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfl33txpd_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        min_lst := lst.([]int)\n        for _, l := range lst.([]int) {\n            if len(l) < len(min_lst) {\n                min_lst = l\n            }\n        }\n        return min_lst\n    case []string:\n        min_lst := lst.([]string)\n        for _, l := range lst.([]string) {\n            if len(l) < len(min_lst) {\n                min_lst = l\n            }\n        }\n        return min_lst\n    case []float64:\n        min_lst := lst.([]float64)\n        for _, l := range lst.([]float64) {\n            if len(l) < len(min_lst) {\n                min_lst = l\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123704,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp67l8vhb3_test.go:14:19: invalid argument l (type int) for len\n/tmp/tmp67l8vhb3_test.go:15:25: cannot use l (type int) as type []int in assignment\n/tmp/tmp67l8vhb3_test.go:23:25: cannot use l (type string) as type []string in assignment\n/tmp/tmp67l8vhb3_test.go:30:19: invalid argument l (type float64) for len\n/tmp/tmp67l8vhb3_test.go:31:25: cannot use l (type float64) as type []float64 in assignment\n/tmp/tmp67l8vhb3_test.go:49:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            var min interface{}\n            min_len := len(lst.([]interface{}))\n            for _, v := range lst.([]interface{}) {\n                if len(v.([]interface{})) < min_len {\n                    min = v\n                    min_len = len(v.([]interface{}))\n                }\n            }\n            return min\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123704,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpky36zyux_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        var min_lst []int\n        for _, v := range lst.([]int) {\n            if len(min_lst) == 0 {\n                min_lst = append(min_lst, v)\n            } else if len(min_lst) > len(v) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    case []string:\n        var min_lst []string\n        for _, v := range lst.([]string) {\n            if len(min_lst) == 0 {\n                min_lst = append(min_lst, v)\n            } else if len(min_lst) > len(v) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123704,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptm7v4w_y_test.go:16:41: invalid argument v (type int) for len\n/tmp/tmptm7v4w_y_test.go:17:25: cannot use v (type int) as type []int in assignment\n/tmp/tmptm7v4w_y_test.go:27:25: cannot use v (type string) as type []string in assignment\n/tmp/tmptm7v4w_y_test.go:45:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min_sublist interface{}\n        min_sublist = lst\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min_sublist.([]interface{})) {\n                min_sublist = v\n            }\n        }\n        return min_sublist\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123704,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqh7kgu0v_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_len := len(lst.([]interface{}))\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < min_len {\n                min_lst = v\n                min_len = len(v.([]interface{}))\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123704,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3vp06yzy_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123704,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqi11j8ka_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        return Find_Min_Int(lst.([]int))\n    case []string:\n        return Find_Min_String(lst.([]string))\n    case []float64:\n        return Find_Min_Float64(lst.([]float64))\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123704,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpimfczrxy_test.go:12:16: undefined: Find_Min_Int\n/tmp/tmpimfczrxy_test.go:14:16: undefined: Find_Min_String\n/tmp/tmpimfczrxy_test.go:16:16: undefined: Find_Min_Float64\n/tmp/tmpimfczrxy_test.go:31:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123704,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpo884ho2z_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    var min interface{}\n    switch lst.(type) {\n    case []interface{}:\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n    }\n    return min\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123704,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpakx6qv_4_test.go:32:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            min := lst.([]interface{})[0]\n            for _, v := range lst.([]interface{}) {\n                if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                    min = v\n                }\n            }\n            return min\n        default:\n            return []interface{}{}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123704,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4e762dp1_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_len := len(lst.([]interface{}))\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < min_len {\n                min_len = len(v.([]interface{}))\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnuvqcsjr_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        min_lst := lst[0]\n        for _, item := range lst {\n            min_lst = Find_Min(min_lst).([]interface{})\n            item = Find_Min(item).([]interface{})\n            if len(item) < len(min_lst) {\n                min_lst = item\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123704,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphpra1de3_test.go:17:19: invalid argument item (type interface {}) for len\n/tmp/tmphpra1de3_test.go:17:31: invalid argument min_lst (type interface {}) for len\n/tmp/tmphpra1de3_test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n            } else {\n                if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123704,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsaq21jqh_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case [][]int:\n        return Find_Min_int_slice(lst.([][]int))\n    case [][]string:\n        return Find_Min_string_slice(lst.([][]string))\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx4l5e92a_test.go:12:16: undefined: Find_Min_int\n/tmp/tmpx4l5e92a_test.go:14:16: undefined: Find_Min_string\n/tmp/tmpx4l5e92a_test.go:16:16: undefined: Find_Min_int_slice\n/tmp/tmpx4l5e92a_test.go:18:16: undefined: Find_Min_string_slice\n/tmp/tmpx4l5e92a_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        }\n        min_lst := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{lst}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123704,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprr3w9qp2_test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            var min interface{}\n            min_len := len(lst.([]interface{}))\n            for _, item := range lst.([]interface{}) {\n                if len(item.([]interface{})) < min_len {\n                    min = item\n                    min_len = len(item.([]interface{}))\n                }\n            }\n            return min\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123704,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8mmb2n13_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        min := lst.([]int)[0]\n        for _, v := range lst.([]int) {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case []string:\n        min := lst.([]string)[0]\n        for _, v := range lst.([]string) {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case [][]int:\n        min := lst.([][]int)[0]\n        for _, v := range lst.([][]int) {\n            if len(v) < len(min) {\n                min = v\n            }\n        }\n        return min\n    case [][]string:\n        min := lst.([][]string)[0]\n        for _, v := range lst.([][]string) {\n            if len(v) < len(min) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0g6h6mz7_test.go:57:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123704,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpo884ho2z_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_lst = lst\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr5uj7iat_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy3gb0i5__test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            lst_l := lst.([]interface{})\n            min_l := lst_l[0]\n            for _, v := range lst_l {\n                if len(v.([]interface{})) < len(min_l.([]interface{})) {\n                    min_l = v\n                }\n            }\n            return min_l\n        default:\n            return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123704,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphz5eszjp_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n            } else {\n                if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123704,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsaq21jqh_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []int:\n            return lst.([]int)\n        case []string:\n            return lst.([]string)\n        case [][]int:\n            return lst.([][]int)\n        case [][]string:\n            return lst.([][]string)\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123704,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwiliopk3_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        var min_lst []int\n        var min_len = len(lst.([]int))\n        for _, v := range lst.([]int) {\n            if len(v) < min_len {\n                min_lst = v\n                min_len = len(v)\n            }\n        }\n        return min_lst\n    case []string:\n        var min_lst []string\n        var min_len = len(lst.([]string))\n        for _, v := range lst.([]string) {\n            if len(v) < min_len {\n                min_lst = v\n                min_len = len(v)\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123704,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_n892i3z_test.go:15:19: invalid argument v (type int) for len\n/tmp/tmp_n892i3z_test.go:16:25: cannot use v (type int) as type []int in assignment\n/tmp/tmp_n892i3z_test.go:17:30: invalid argument v (type int) for len\n/tmp/tmp_n892i3z_test.go:26:25: cannot use v (type string) as type []string in assignment\n/tmp/tmp_n892i3z_test.go:45:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []int:\n            lst_int := lst.([]int)\n            min_int := lst_int[0]\n            for _, v := range lst_int {\n                if v < min_int {\n                    min_int = v\n                }\n            }\n            return min_int\n        case []string:\n            lst_string := lst.([]string)\n            min_string := lst_string[0]\n            for _, v := range lst_string {\n                if v < min_string {\n                    min_string = v\n                }\n            }\n            return min_string\n        case []float64:\n            lst_float := lst.([]float64)\n            min_float := lst_float[0]\n            for _, v := range lst_float {\n                if v < min_float {\n                    min_float = v\n                }\n            }\n            return min_float\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123704,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjv7enj03_test.go:52:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            min_lst := lst.([]interface{})\n            for _, v := range lst.([]interface{}) {\n                if len(v.([]interface{})) < len(min_lst) {\n                    min_lst = v.([]interface{})\n                }\n            }\n            return min_lst\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpm0am9knu_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n                min_len = len(v.([]interface{}))\n            } else {\n                if len(v.([]interface{})) < min_len {\n                    min = v\n                    min_len = len(v.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123707,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkfr8wawp_test.go:40:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    var min_len int = len(lst.([]interface{}))\n    var min_lst interface{} = lst\n    for _, item := range lst.([]interface{}) {\n        if len(item.([]interface{})) < min_len {\n            min_len = len(item.([]interface{}))\n            min_lst = item\n        }\n    }\n    return min_lst\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123707,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpf806r4zj_test.go:30:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        lst := lst.([]int)\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case []string:\n        lst := lst.([]string)\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case [][]int:\n        lst := lst.([][]int)\n        min := lst[0]\n        for _, v := range lst {\n            if len(v) < len(min) {\n                min = v\n            }\n        }\n        return min\n    case [][]string:\n        lst := lst.([][]string)\n        min := lst[0]\n        for _, v := range lst {\n            if len(v) < len(min) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqe0dod8k_test.go:61:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy7ub2xbl_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl4p5bgf2_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_lst = lst\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123707,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp534h34oz_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    var min interface{}\n    min = lst\n    switch lst.(type) {\n    case []interface{}:\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n    case [][]interface{}:\n        for _, v := range lst.([][]interface{}) {\n            if len(v) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n    }\n    return min\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123707,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv9gkfnd1_test.go:38:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return nil\n        }\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1fztxce9_test.go:36:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case [][]int:\n        return Find_Min_int_slice(lst.([][]int))\n    case [][]string:\n        return Find_Min_string_slice(lst.([][]string))\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx4l5e92a_test.go:12:16: undefined: Find_Min_int\n/tmp/tmpx4l5e92a_test.go:14:16: undefined: Find_Min_string\n/tmp/tmpx4l5e92a_test.go:16:16: undefined: Find_Min_int_slice\n/tmp/tmpx4l5e92a_test.go:18:16: undefined: Find_Min_string_slice\n/tmp/tmpx4l5e92a_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy7ub2xbl_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, item := range lst.([]interface{}) {\n            if len(Find_Min(item).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                min_lst = item\n            }\n        }\n        return min_lst\n    case int:\n        return []interface{}{lst}\n    default:\n        return []interface{}{}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123707,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvfpe28rd_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n                min_len = len(v.([]interface{}))\n            } else {\n                if len(v.([]interface{})) < min_len {\n                    min = v\n                    min_len = len(v.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprr9aw5gm_test.go:40:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_lst := lst.([]interface{})\n        min_lst := lst_lst[0]\n        for _, lst := range lst_lst {\n            if len(lst.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = lst\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpki8wb_p7_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min_len int = len(lst.([]interface{}))\n        var min_lst interface{} = lst\n        for _, v := range lst.([]interface{}) {\n            if v_lst := Find_Min(v); v_lst != nil {\n                if v_len := len(v_lst.([]interface{})); v_len < min_len {\n                    min_len = v_len\n                    min_lst = v_lst\n                }\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123707,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqixzp401_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min_len := len(lst.([]interface{}))\n        for _, item := range lst.([]interface{}) {\n            if len(item.([]interface{})) < min_len {\n                min = item\n                min_len = len(item.([]interface{}))\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpldr16ge4_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_l := lst.([]interface{})\n        min_l := lst_l[0]\n        for _, v := range lst_l {\n            if len(v.([]interface{})) < len(min_l.([]interface{})) {\n                min_l = v\n            }\n        }\n        return min_l\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123707,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuj4irxs3_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case [][]int:\n        return Find_Min_int_slice(lst.([][]int))\n    case [][]string:\n        return Find_Min_string_slice(lst.([][]string))\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx4l5e92a_test.go:12:16: undefined: Find_Min_int\n/tmp/tmpx4l5e92a_test.go:14:16: undefined: Find_Min_string\n/tmp/tmpx4l5e92a_test.go:16:16: undefined: Find_Min_int_slice\n/tmp/tmpx4l5e92a_test.go:18:16: undefined: Find_Min_string_slice\n/tmp/tmpx4l5e92a_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n            } else {\n                if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123704,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsaq21jqh_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        } else {\n            return Find_Min(lst.([]interface{})[0])\n        }\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123707,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9z4z5sx9_test.go:31:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n            } else {\n                if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123704,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsaq21jqh_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case []float64:\n        return Find_Min_float64(lst.([]float64))\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjcnbh46r_test.go:12:16: undefined: Find_Min_int\n/tmp/tmpjcnbh46r_test.go:14:16: undefined: Find_Min_string\n/tmp/tmpjcnbh46r_test.go:16:16: undefined: Find_Min_float64\n/tmp/tmpjcnbh46r_test.go:31:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpm6pa5t3j_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return []interface{}{lst}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps8l2unii_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int = len(lst.([]interface{}))\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < min_len {\n                min = v\n                min_len = len(v.([]interface{}))\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123707,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpm_2ru3xk_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123707,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpo_08mpja_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            min_lst := lst.([]interface{})[0]\n            for _, v := range lst.([]interface{}) {\n                if len(Find_Min(v).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                    min_lst = v\n                }\n            }\n            return min_lst\n        default:\n            return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123707,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5w8fngpg_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            min_len := len(lst.([]interface{}))\n            min_lst := lst.([]interface{})\n            for _, v := range lst.([]interface{}) {\n                if len(v.([]interface{})) < min_len {\n                    min_len = len(v.([]interface{}))\n                    min_lst = v.([]interface{})\n                }\n            }\n            return min_lst\n        default:\n            return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123707,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpm4406zv2_test.go:35:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n            } else {\n                if len(min.([]interface{})) > len(v.([]interface{})) {\n                    min = v\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123707,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe4_3hjlr_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    var min interface{}\n    min = lst\n    switch lst.(type) {\n    case []interface{}:\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n    }\n    return min\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123707,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv92h6ml3_test.go:32:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n            } else {\n                if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123704,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsaq21jqh_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        var min_lst []int\n        min_lst_len := len(lst.([]int))\n        for _, v := range lst.([]int) {\n            if len(v) < min_lst_len {\n                min_lst = v\n                min_lst_len = len(v)\n            }\n        }\n        return min_lst\n    case []string:\n        var min_lst []string\n        min_lst_len := len(lst.([]string))\n        for _, v := range lst.([]string) {\n            if len(v) < min_lst_len {\n                min_lst = v\n                min_lst_len = len(v)\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123707,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4z4jisfc_test.go:15:19: invalid argument v (type int) for len\n/tmp/tmp4z4jisfc_test.go:16:25: cannot use v (type int) as type []int in assignment\n/tmp/tmp4z4jisfc_test.go:17:34: invalid argument v (type int) for len\n/tmp/tmp4z4jisfc_test.go:26:25: cannot use v (type string) as type []string in assignment\n/tmp/tmp4z4jisfc_test.go:45:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzui7ya1n_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []int:\n            lst_int := lst.([]int)\n            min_int := lst_int[0]\n            for _, val := range lst_int {\n                if val < min_int {\n                    min_int = val\n                }\n            }\n            return min_int\n        case []string:\n            lst_str := lst.([]string)\n            min_str := lst_str[0]\n            for _, val := range lst_str {\n                if len(val) < len(min_str) {\n                    min_str = val\n                }\n            }\n            return min_str\n        case []float64:\n            lst_float := lst.([]float64)\n            min_float := lst_float[0]\n            for _, val := range lst_float {\n                if val < min_float {\n                    min_float = val\n                }\n            }\n            return min_float\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123707,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8dm745cx_test.go:52:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        min_lst := lst.([]int)\n        for _, v := range lst.([]int) {\n            if len(v) < len(min_lst) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    case []string:\n        min_lst := lst.([]string)\n        for _, v := range lst.([]string) {\n            if len(v) < len(min_lst) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123707,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9u5_ndie_test.go:14:19: invalid argument v (type int) for len\n/tmp/tmp9u5_ndie_test.go:15:25: cannot use v (type int) as type []int in assignment\n/tmp/tmp9u5_ndie_test.go:23:25: cannot use v (type string) as type []string in assignment\n/tmp/tmp9u5_ndie_test.go:41:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{lst}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_11_mjdu_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return nil\n        }\n        min_lst := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123707,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5zd081ap_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        min_lst := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123707,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk4m5xszu_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123698,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy7ub2xbl_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})\n        for _, item := range lst.([]interface{}) {\n            if len(Find_Min(item).([]interface{})) < len(min_lst) {\n                min_lst = Find_Min(item).([]interface{})\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{lst}\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123701,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzg2uyyxn_test.go:33:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []int:\n            lst_int := lst.([]int)\n            min_int := lst_int[0]\n            for _, v := range lst_int {\n                if v < min_int {\n                    min_int = v\n                }\n            }\n            return min_int\n        case []string:\n            lst_str := lst.([]string)\n            min_str := lst_str[0]\n            for _, v := range lst_str {\n                if len(v) < len(min_str) {\n                    min_str = v\n                }\n            }\n            return min_str\n        case []interface{}:\n            lst_interface := lst.([]interface{})\n            min_interface := lst_interface[0]\n            for _, v := range lst_interface {\n                if len(v.([]interface{})) < len(min_interface.([]interface{})) {\n                    min_interface = v\n                }\n            }\n            return min_interface\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123707,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpz702gamf_test.go:52:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst_ := lst.([]interface{})\n        min_ := lst_[0]\n        for _, v := range lst_ {\n            if len(v.([]interface{})) < len(min_.([]interface{})) {\n                min_ = v\n            }\n        }\n        return min_\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6er7jh4z_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_lst = lst\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123707,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzqzton6n_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n                min_len = len(v.([]interface{}))\n            } else {\n                if len(v.([]interface{})) < min_len {\n                    min = v\n                    min_len = len(v.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprr9aw5gm_test.go:40:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n        case []interface{}:\n            var min_len int\n            var min_lst interface{}\n            for _, v := range lst.([]interface{}) {\n                if min_lst == nil {\n                    min_lst = v\n                    min_len = len(v.([]interface{}))\n                } else {\n                    if len(v.([]interface{})) < min_len {\n                        min_lst = v\n                        min_len = len(v.([]interface{}))\n                    }\n                }\n            }\n            return min_lst\n        default:\n            return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123707,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn7anwegh_test.go:40:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case []float64:\n        return Find_Min_float64(lst.([]float64))\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123695,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjcnbh46r_test.go:12:16: undefined: Find_Min_int\n/tmp/tmpjcnbh46r_test.go:14:16: undefined: Find_Min_string\n/tmp/tmpjcnbh46r_test.go:16:16: undefined: Find_Min_float64\n/tmp/tmpjcnbh46r_test.go:31:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return nil\n        }\n        min_lst := l[0]\n        for _, v := range l {\n            if len(v.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123707,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpryyx5t3r_test.go:37:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n\nfunc TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510637,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzui7ya1n_test.go:34:42: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    }
  ]
}