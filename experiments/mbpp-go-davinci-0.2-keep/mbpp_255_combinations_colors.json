{
  "name": "mbpp_255_combinations_colors",
  "language": "go_test.go",
  "prompt": "package combinations_colors_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a list and length n, and generates all combinations (with repetition) of the elements of the list and returns a list with a tuple for each combination.\nfunc combinations_colors(l []string, n int) [][]interface{} {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_255_combinations_colors.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestCombinations_Colors(t *testing.T) {\n  candidate := combinations_colors\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"Red\", \"Green\", \"Blue\"}, 1), expected: [][]int{[]interface{}{\"Red\"}, []interface{}{\"Green\"}, []interface{}{\"Blue\"}} },\n     { actual: candidate([]string{\"Red\", \"Green\", \"Blue\"}, 2), expected: [][]int{[]interface{}{\"Red\", \"Red\"}, []interface{}{\"Red\", \"Green\"}, []interface{}{\"Red\", \"Blue\"}, []interface{}{\"Green\", \"Green\"}, []interface{}{\"Green\", \"Blue\"}, []interface{}{\"Blue\", \"Blue\"}} },\n     { actual: candidate([]string{\"Red\", \"Green\", \"Blue\"}, 3), expected: [][]int{[]interface{}{\"Red\", \"Red\", \"Red\"}, []interface{}{\"Red\", \"Red\", \"Green\"}, []interface{}{\"Red\", \"Red\", \"Blue\"}, []interface{}{\"Red\", \"Green\", \"Green\"}, []interface{}{\"Red\", \"Green\", \"Blue\"}, []interface{}{\"Red\", \"Blue\", \"Blue\"}, []interface{}{\"Green\", \"Green\", \"Green\"}, []interface{}{\"Green\", \"Green\", \"Blue\"}, []interface{}{\"Green\", \"Blue\", \"Blue\"}, []interface{}{\"Blue\", \"Blue\", \"Blue\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i, v := range l {\n        for _, v2 := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{v}, v2...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var recurse func(int, []interface{})\n    recurse = func(i int, comb []interface{}) {\n        if i == n {\n            result = append(result, comb)\n            return\n        }\n        for _, v := range l {\n            recurse(i+1, append(comb, v))\n        }\n    }\n    recurse(0, []interface{}{})\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        }\n        for i := 0; i < len(l); i++ {\n            helper(append(arr, l[i]), n-1)\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    if n == 1 {\n        var res [][]interface{}\n        for _, v := range l {\n            res = append(res, []interface{}{v})\n        }\n        return res\n    }\n    var res [][]interface{}\n    for i, v := range l {\n        for _, vv := range combinations_colors(l[i:], n - 1) {\n            res = append(res, append([]interface{}{v}, vv...))\n        }\n    }\n    return res\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append(sub_result[j], l[i])\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i, v := range l {\n        for _, w := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{v}, w...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i, v := range l {\n        for _, r := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{v}, r...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) == 1 {\n        return [][]interface{}{[]interface{}{l[0]}}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    if n == 1 {\n        var result [][]interface{}\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    var result [][]interface{}\n    for _, v := range l {\n        for _, v2 := range combinations_colors(l, n - 1) {\n            result = append(result, append([]interface{}{v}, v2...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n\n    var result [][]interface{}\n    for _, v := range l {\n        for _, c := range combinations_colors(l, n - 1) {\n            result = append(result, append(c, v))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i, v := range l {\n        for _, v2 := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{v}, v2...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        }\n        for i := 0; i < len(l); i++ {\n            helper(append(arr, l[i]), n - 1)\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]string, int, int)\n    helper = func(l []string, n int, i int) {\n        if n == 0 {\n            result = append(result, []interface{}{})\n            return\n        }\n        for j := i; j < len(l); j++ {\n            helper(l, n-1, j)\n            for _, v := range result {\n                if len(v) == n {\n                    result = append(result, append(v, l[j]))\n                }\n            }\n        }\n    }\n    helper(l, n, 0)\n    return result\n}\n",
    "    var result [][]interface{}\n    var combinations func([]string, int, int, []interface{})\n    combinations = func(l []string, n int, i int, c []interface{}) {\n        if n == 0 {\n            result = append(result, c)\n            return\n        }\n        for j := i; j < len(l); j++ {\n            combinations(l, n - 1, j, append(c, l[j]))\n        }\n    }\n    combinations(l, n, 0, []interface{}{})\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n - 1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int)\n    helper = func(offset int) {\n        if len(combination) == n {\n            result = append(result, append([]interface{}{}, combination...))\n            return\n        }\n        for i := offset; i < len(l); i++ {\n            combination = append(combination, l[i])\n            helper(i)\n            combination = combination[:len(combination)-1]\n        }\n    }\n    helper(0)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) < n {\n        return [][]interface{}{}\n    }\n    if len(l) == n {\n        return [][]interface{}{{l}}\n    }\n    if n == 1 {\n        var result [][]interface{}\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for _, v := range sub_result {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    result := [][]interface{}{}\n    for _, v := range l {\n        for _, c := range combinations_colors(l, n-1) {\n            result = append(result, append([]interface{}{v}, c...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    var result [][]interface{}\n    for _, v := range l {\n        for _, v2 := range combinations_colors(l, n-1) {\n            result = append(result, append([]interface{}{v}, v2...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int, int)\n    helper = func(start int, k int) {\n        if k == 0 {\n            result = append(result, combination)\n            return\n        }\n        for i := start; i <= len(l) - k; i++ {\n            combination = append(combination, l[i])\n            helper(i, k - 1)\n            combination = combination[:len(combination) - 1]\n        }\n    }\n    helper(0, n)\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        }\n        for i := 0; i < len(l); i++ {\n            helper(append(arr, l[i]), n - 1)\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    var combinations [][]interface{}\n    var combination []interface{}\n    var recurse func(int, int)\n    recurse = func(start, depth int) {\n        if depth == 0 {\n            combinations = append(combinations, append([]interface{}{}, combination...))\n            return\n        }\n        for i := start; i <= len(l) - depth; i++ {\n            combination = append(combination, l[i])\n            recurse(i, depth - 1)\n            combination = combination[:len(combination) - 1]\n        }\n    }\n    recurse(0, n)\n    return combinations\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append([]interface{}{l[i]}, sub_result[j]...)\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, x := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, x...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    result := [][]interface{}{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var recurse func(int, []interface{})\n    recurse = func(i int, current []interface{}) {\n        if i == n {\n            result = append(result, current)\n            return\n        }\n        for _, v := range l {\n            recurse(i+1, append(current, v))\n        }\n    }\n    recurse(0, []interface{}{})\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, e := range l {\n            result = append(result, []interface{}{e})\n        }\n        return result\n    }\n    for i, e := range l {\n        for _, c := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{e}, c...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{}\n    }\n    if n == 1 {\n        var r [][]interface{}\n        for _, e := range l {\n            r = append(r, []interface{}{e})\n        }\n        return r\n    }\n    var r [][]interface{}\n    for i, e := range l {\n        for _, c := range combinations_colors(l[i:], n-1) {\n            r = append(r, append([]interface{}{e}, c...))\n        }\n    }\n    return r\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) < n {\n        return [][]interface{}{}\n    }\n    if len(l) == n {\n        return [][]interface{}{{l}}\n    }\n    combinations := combinations_colors(l[1:], n)\n    for _, combination := range combinations_colors(l[1:], n-1) {\n        combination = append(combination, l[0])\n        combinations = append(combinations, combination)\n    }\n    return combinations\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        }\n        for _, v := range l {\n            helper(append(arr, v), n-1)\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i, v := range l {\n        for _, v2 := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{v}, v2...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        }\n        for i := 0; i < len(l); i++ {\n            helper(append(arr, l[i]), n - 1)\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{}\n    }\n    if n == 1 {\n        res := [][]interface{}{}\n        for _, e := range l {\n            res = append(res, []interface{}{e})\n        }\n        return res\n    }\n    res := [][]interface{}{}\n    for i := 0; i < len(l); i++ {\n        sub_res := combinations_colors(l[i:], n-1)\n        for _, e := range sub_res {\n            res = append(res, append([]interface{}{l[i]}, e...))\n        }\n    }\n    return res\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) < n {\n        return [][]interface{}{}\n    }\n    if len(l) == n {\n        return [][]interface{}{[]interface{}{l}}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        sub_result := combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append([]interface{}{l[i]}, sub_result[j]...)\n        }\n        result = append(result, sub_result...)\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]string, int, int, []interface{})\n    helper = func(l []string, start int, n int, curr []interface{}) {\n        if n == 0 {\n            result = append(result, curr)\n            return\n        }\n        for i := start; i < len(l); i++ {\n            helper(l, i, n - 1, append(curr, l[i]))\n        }\n    }\n    helper(l, 0, n, []interface{}{})\n    return result\n}\n",
    "    if n == 1 {\n        var res [][]interface{}\n        for _, v := range l {\n            res = append(res, []interface{}{v})\n        }\n        return res\n    }\n    var res [][]interface{}\n    for i, v := range l {\n        for _, v2 := range combinations_colors(l[i:], n-1) {\n            res = append(res, append([]interface{}{v}, v2...))\n        }\n    }\n    return res\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var res [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, comb := range combinations_colors(l[i+1:], n-1) {\n            res = append(res, append([]interface{}{l[i]}, comb...))\n        }\n    }\n    return res\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append(sub_result[j], l[i])\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) == 1 {\n        return [][]interface{}{[]interface{}{l[0]}}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        sub_result := combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append([]interface{}{l[i]}, sub_result[j]...)\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{}\n    }\n    if n == 1 {\n        var result [][]interface{}\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n - 1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        }\n        for i := 0; i < len(l); i++ {\n            helper(append(arr, l[i]), n - 1)\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        } else {\n            for i := 0; i < len(l); i++ {\n                helper(append(arr, l[i]), n - 1)\n            }\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int)\n    helper = func(i int) {\n        if i == n {\n            result = append(result, append([]interface{}{}, combination...))\n            return\n        }\n        for _, v := range l {\n            combination = append(combination, v)\n            helper(i + 1)\n            combination = combination[:len(combination) - 1]\n        }\n    }\n    helper(0)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var current []interface{}\n    var helper func(int, int)\n    helper = func(start, depth int) {\n        if depth == 0 {\n            result = append(result, append([]interface{}{}, current...))\n            return\n        }\n        for i := start; i < len(l); i++ {\n            current = append(current, l[i])\n            helper(i, depth - 1)\n            current = current[:len(current) - 1]\n        }\n    }\n    helper(0, n)\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, combination := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, combination...))\n        }\n    }\n    return result\n}\n",
    "    if n == 1 {\n        var r [][]interface{}\n        for _, v := range l {\n            r = append(r, []interface{}{v})\n        }\n        return r\n    }\n    var r [][]interface{}\n    for i, v := range l {\n        for _, w := range combinations_colors(l[i:], n-1) {\n            r = append(r, append([]interface{}{v}, w...))\n        }\n    }\n    return r\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int, int)\n    helper = func(start int, k int) {\n        if k == 0 {\n            result = append(result, combination)\n            return\n        }\n        for i := start; i <= len(l) - k; i++ {\n            combination = append(combination, l[i])\n            helper(i, k - 1)\n            combination = combination[:len(combination) - 1]\n        }\n    }\n    helper(0, n)\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i, v := range l {\n        for _, vv := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{v}, vv...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        }\n        for _, e := range l {\n            helper(append(arr, e), n-1)\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    var combinations [][]interface{}\n    var combination []interface{}\n    var helper func(int)\n    helper = func(i int) {\n        if i == n {\n            combinations = append(combinations, combination)\n            return\n        }\n        for _, v := range l {\n            combination = append(combination, v)\n            helper(i + 1)\n            combination = combination[:len(combination) - 1]\n        }\n    }\n    helper(0)\n    return combinations\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var helper func(int, int)\n    helper = func(start int, n int) {\n        if n == 0 {\n            result = append(result, temp)\n            return\n        }\n        for i := start; i < len(l); i++ {\n            temp = append(temp, l[i])\n            helper(i, n - 1)\n            temp = temp[:len(temp) - 1]\n        }\n    }\n    helper(0, n)\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int, int)\n    helper = func(start, depth int) {\n        if depth == n {\n            result = append(result, append([]interface{}{}, combination...))\n            return\n        }\n        for i := start; i < len(l); i++ {\n            combination = append(combination, l[i])\n            helper(i, depth + 1)\n            combination = combination[:len(combination) - 1]\n        }\n    }\n    helper(0, 0)\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        }\n        for i := 0; i < len(l); i++ {\n            helper(append(arr, l[i]), n - 1)\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{}\n    }\n    if n == 1 {\n        return [][]interface{}{{l[0]}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        }\n        for i := 0; i < len(l); i++ {\n            helper(append(arr, l[i]), n - 1)\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int, int)\n    helper = func(start, end int) {\n        if len(combination) == n {\n            result = append(result, append([]interface{}{}, combination...))\n            return\n        }\n        for i := start; i < end; i++ {\n            combination = append(combination, l[i])\n            helper(i, end)\n            combination = combination[:len(combination) - 1]\n        }\n    }\n    helper(0, len(l))\n    return result\n}\n",
    "    if n == 1 {\n        var res [][]interface{}\n        for _, v := range l {\n            res = append(res, []interface{}{v})\n        }\n        return res\n    }\n    var res [][]interface{}\n    for i, v := range l {\n        for _, c := range combinations_colors(l[i:], n-1) {\n            res = append(res, append([]interface{}{v}, c...))\n        }\n    }\n    return res\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append([]interface{}{l[i]}, sub_result[j]...)\n        }\n        result = append(result, sub_result...)\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]string, int, int, []interface{})\n    helper = func(l []string, start int, n int, curr []interface{}) {\n        if n == 0 {\n            result = append(result, curr)\n            return\n        }\n\n        for i := start; i < len(l); i++ {\n            helper(l, i, n-1, append(curr, l[i]))\n        }\n    }\n\n    helper(l, 0, n, []interface{}{})\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    result := [][]interface{}{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]string, int, []interface{})\n    helper = func(l []string, n int, curr []interface{}) {\n        if n == 0 {\n            result = append(result, curr)\n            return\n        }\n        for i := 0; i < len(l); i++ {\n            helper(l, n-1, append(curr, l[i]))\n        }\n    }\n    helper(l, n, []interface{}{})\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) < n {\n        return [][]interface{}{}\n    }\n    if len(l) == n {\n        return [][]interface{}{{l}}\n    }\n    if n == 1 {\n        var res [][]interface{}\n        for _, v := range l {\n            res = append(res, []interface{}{v})\n        }\n        return res\n    }\n    var res [][]interface{}\n    for i, v := range l {\n        for _, vv := range combinations_colors(l[i+1:], n-1) {\n            res = append(res, append([]interface{}{v}, vv...))\n        }\n    }\n    return res\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n\n    result := [][]interface{}{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) < n {\n        return [][]interface{}{}\n    }\n    if len(l) == n {\n        return [][]interface{}{{l}}\n    }\n    if n == 1 {\n        var result [][]interface{}\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i, v := range l {\n        for _, v2 := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{v}, v2...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) == 1 {\n        return [][]interface{}{[]interface{}{l[0]}}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        sub_result := combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            result = append(result, append([]interface{}{l[i]}, sub_result[j]...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i := 0; i <= len(l) - n; i++ {\n        for _, v := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var comb []interface{}\n    var helper func(int, int)\n    helper = func(offset, k int) {\n        if k == 0 {\n            result = append(result, append([]interface{}{}, comb...))\n            return\n        }\n        for i := offset; i <= len(l)-k; i++ {\n            comb = append(comb, l[i])\n            helper(i, k-1)\n            comb = comb[:len(comb)-1]\n        }\n    }\n    helper(0, n)\n    return result\n}\n",
    "    var results [][]interface{}\n    var result []interface{}\n    var recurse func(int)\n    recurse = func(i int) {\n        if len(result) == n {\n            results = append(results, result)\n            return\n        }\n        for j := i; j < len(l); j++ {\n            result = append(result, l[j])\n            recurse(j)\n            result = result[:len(result)-1]\n        }\n    }\n    recurse(0)\n    return results\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        }\n        for i := 0; i < len(l); i++ {\n            helper(append(arr, l[i]), n - 1)\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        }\n        for i := 0; i < len(l); i++ {\n            helper(append(arr, l[i]), n - 1)\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{}\n    }\n    if n == 1 {\n        var result [][]interface{}\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n\n    result := [][]interface{}{}\n    for _, e := range l {\n        for _, c := range combinations_colors(l, n-1) {\n            result = append(result, append([]interface{}{e}, c...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{}\n    }\n    if n == 1 {\n        var result [][]interface{}\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]string, int, int, []interface{})\n    helper = func(l []string, start, n int, curr []interface{}) {\n        if n == 0 {\n            result = append(result, curr)\n            return\n        }\n        for i := start; i < len(l); i++ {\n            helper(l, i, n-1, append(curr, l[i]))\n        }\n    }\n    helper(l, 0, n, []interface{}{})\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for _, v := range l {\n        for _, v2 := range combinations_colors(l, n-1) {\n            result = append(result, append([]interface{}{v}, v2...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append(sub_result[j], l[i])\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{}\n    }\n    if n == 1 {\n        var res [][]interface{}\n        for _, v := range l {\n            res = append(res, []interface{}{v})\n        }\n        return res\n    }\n    var res [][]interface{}\n    for i, v := range l {\n        for _, c := range combinations_colors(l[i:], n-1) {\n            res = append(res, append([]interface{}{v}, c...))\n        }\n    }\n    return res\n}\n",
    "    var result [][]interface{}\n    var recurse func(int, []interface{})\n    recurse = func(i int, comb []interface{}) {\n        if i == n {\n            result = append(result, comb)\n            return\n        }\n        for _, v := range l {\n            recurse(i+1, append(comb, v))\n        }\n    }\n    recurse(0, []interface{}{})\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i, v := range l {\n        for _, v2 := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{v}, v2...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]string, int, int)\n    helper = func(l []string, n int, i int) {\n        if n == 0 {\n            result = append(result, []interface{}{})\n            return\n        }\n        for j := i; j < len(l); j++ {\n            helper(l, n-1, j)\n            for _, r := range result {\n                if len(r) == n {\n                    result = append(result, append(r, l[j]))\n                }\n            }\n        }\n    }\n    helper(l, n, 0)\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{}\n    }\n    if n == 1 {\n        return [][]interface{}{{l[0]}, {l[1]}, {l[2]}}\n    }\n    var result [][]interface{}\n    for _, v := range l {\n        for _, v2 := range combinations_colors(l, n-1) {\n            result = append(result, append([]interface{}{v}, v2...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int)\n    helper = func(start int) {\n        if len(combination) == n {\n            result = append(result, combination)\n            return\n        }\n        for i := start; i < len(l); i++ {\n            combination = append(combination, l[i])\n            helper(i)\n            combination = combination[:len(combination)-1]\n        }\n    }\n    helper(0)\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i, v := range l {\n        for _, c := range combinations_colors(l[i:], n - 1) {\n            result = append(result, append([]interface{}{v}, c...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]string, int, int)\n    helper = func(l []string, n int, i int) {\n        if n == 0 {\n            result = append(result, []interface{}{})\n            return\n        }\n        for j := i; j < len(l); j++ {\n            helper(l, n-1, j)\n            for _, r := range result {\n                if len(r) == n {\n                    result = append(result, append([]interface{}{l[j]}, r...))\n                }\n            }\n        }\n    }\n    helper(l, n, 0)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        sub_result := combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            result = append(result, append([]interface{}{l[i]}, sub_result[j]...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) < n {\n        return [][]interface{}{}\n    }\n    if n == 1 {\n        var result [][]interface{}\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for _, v := range sub_result {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append([]interface{}{l[i]}, sub_result[j]...)\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    var res [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            res = append(res, []interface{}{v})\n        }\n        return res\n    }\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n - 1) {\n            res = append(res, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return res\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        } else {\n            for i := 0; i < len(l); i++ {\n                helper(append(arr, l[i]), n-1)\n            }\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    if n == 1 {\n        var r [][]interface{}\n        for _, v := range l {\n            r = append(r, []interface{}{v})\n        }\n        return r\n    }\n    var r [][]interface{}\n    for _, v := range l {\n        for _, vv := range combinations_colors(l, n-1) {\n            r = append(r, append([]interface{}{v}, vv...))\n        }\n    }\n    return r\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        }\n        for _, v := range l {\n            helper(append(arr, v), n-1)\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]string, int, int, []interface{})\n    helper = func(l []string, start int, n int, curr []interface{}) {\n        if n == 0 {\n            result = append(result, curr)\n            return\n        }\n        for i := start; i < len(l); i++ {\n            helper(l, i, n-1, append(curr, l[i]))\n        }\n    }\n    helper(l, 0, n, []interface{}{})\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int, int)\n    helper = func(start int, n int) {\n        if n == 0 {\n            result = append(result, append([]interface{}{}, combination...))\n            return\n        }\n        for i := start; i < len(l); i++ {\n            combination = append(combination, l[i])\n            helper(i, n - 1)\n            combination = combination[:len(combination) - 1]\n        }\n    }\n    helper(0, n)\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n    } else {\n        for _, v := range l {\n            for _, v2 := range combinations_colors(l, n - 1) {\n                result = append(result, append([]interface{}{v}, v2...))\n            }\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    if n == 1 {\n        var res [][]interface{}\n        for _, v := range l {\n            res = append(res, []interface{}{v})\n        }\n        return res\n    }\n    var res [][]interface{}\n    for i, v := range l {\n        for _, v2 := range combinations_colors(l[i:], n-1) {\n            res = append(res, append([]interface{}{v}, v2...))\n        }\n    }\n    return res\n}\n",
    "    if n == 0 {\n        return [][]interface{}{}\n    }\n    if n == 1 {\n        var r [][]interface{}\n        for _, v := range l {\n            r = append(r, []interface{}{v})\n        }\n        return r\n    }\n    var r [][]interface{}\n    for i, v := range l {\n        for _, vv := range combinations_colors(l[i:], n-1) {\n            r = append(r, append([]interface{}{v}, vv...))\n        }\n    }\n    return r\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int)\n    helper = func(i int) {\n        if i == n {\n            result = append(result, combination)\n            return\n        }\n        for _, v := range l {\n            combination = append(combination, v)\n            helper(i+1)\n            combination = combination[:len(combination)-1]\n        }\n    }\n    helper(0)\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var recurse func(int, int)\n    recurse = func(start, num int) {\n        if num == 0 {\n            result = append(result, temp)\n            return\n        }\n        for i := start; i <= len(l) - num; i++ {\n            temp = append(temp, l[i])\n            recurse(i, num - 1)\n            temp = temp[:len(temp) - 1]\n        }\n    }\n    recurse(0, n)\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        } else {\n            for i := 0; i < len(l); i++ {\n                helper(append(arr, l[i]), n - 1)\n            }\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        } else {\n            for i := 0; i < len(l); i++ {\n                helper(append(arr, l[i]), n - 1)\n            }\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) == 1 {\n        return [][]interface{}{[]interface{}{l[0]}}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append([]interface{}{l[i]}, sub_result[j]...)\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) < n {\n        return [][]interface{}{}\n    }\n    if len(l) == n {\n        return [][]interface{}{{l}}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{}\n    }\n    if n == 1 {\n        res := [][]interface{}{}\n        for _, v := range l {\n            res = append(res, []interface{}{v})\n        }\n        return res\n    }\n    res := [][]interface{}{}\n    for i := 0; i < len(l); i++ {\n        sub_res := combinations_colors(l[i:], n-1)\n        for _, v := range sub_res {\n            res = append(res, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return res\n}\n",
    "    var result [][]interface{}\n    var helper func(int, []interface{})\n    helper = func(offset int, curr []interface{}) {\n        if len(curr) == n {\n            result = append(result, curr)\n            return\n        }\n        for i := offset; i < len(l); i++ {\n            helper(i, append(curr, l[i]))\n        }\n    }\n    helper(0, []interface{}{})\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) == 1 {\n        return [][]interface{}{[]interface{}{l[0]}}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var inner []interface{}\n    var helper func(int, int)\n    helper = func(start, end int) {\n        if end == n {\n            result = append(result, inner)\n            return\n        }\n        for i := start; i < len(l); i++ {\n            inner = append(inner, l[i])\n            helper(i, end + 1)\n            inner = inner[:len(inner) - 1]\n        }\n    }\n    helper(0, 0)\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        }\n        for _, v := range l {\n            helper(append(arr, v), n-1)\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    if n == 1 {\n        var res [][]interface{}\n        for _, v := range l {\n            res = append(res, []interface{}{v})\n        }\n        return res\n    }\n    var res [][]interface{}\n    for i, v := range l {\n        for _, v2 := range combinations_colors(l[i:], n-1) {\n            res = append(res, append([]interface{}{v}, v2...))\n        }\n    }\n    return res\n}\n",
    "    var result [][]interface{}\n    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]string, int, int, []interface{})\n    helper = func(l []string, start, n int, curr []interface{}) {\n        if n == 0 {\n            result = append(result, curr)\n            return\n        }\n        for i := start; i < len(l); i++ {\n            helper(l, i, n-1, append(curr, l[i]))\n        }\n    }\n    helper(l, 0, n, []interface{}{})\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        } else {\n            for i := 0; i < len(l); i++ {\n                helper(append(arr, l[i]), n - 1)\n            }\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    var result [][]interface{}\n    var comb []interface{}\n    var helper func(int, int)\n    helper = func(start, k int) {\n        if k == 0 {\n            result = append(result, append([]interface{}{}, comb...))\n            return\n        }\n        for i := start; i < len(l); i++ {\n            comb = append(comb, l[i])\n            helper(i, k - 1)\n            comb = comb[:len(comb) - 1]\n        }\n    }\n    helper(0, n)\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    result := [][]interface{}{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l, n - 1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    for i := 0; i < len(l); i++ {\n        for _, r := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, r...))\n        }\n    }\n    return result\n}\n",
    "    if n == 1 {\n        var combinations [][]interface{}\n        for _, v := range l {\n            combinations = append(combinations, []interface{}{v})\n        }\n        return combinations\n    }\n    var combinations [][]interface{}\n    for i, v := range l {\n        for _, w := range combinations_colors(l[i:], n-1) {\n            combinations = append(combinations, append([]interface{}{v}, w...))\n        }\n    }\n    return combinations\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append([]interface{}{l[i]}, sub_result[j]...)\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int)\n    helper = func(i int) {\n        if len(combination) == n {\n            result = append(result, combination)\n            return\n        }\n        for j := i; j < len(l); j++ {\n            combination = append(combination, l[j])\n            helper(j)\n            combination = combination[:len(combination)-1]\n        }\n    }\n    helper(0)\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n    } else {\n        for _, v := range l {\n            for _, v2 := range combinations_colors(l, n-1) {\n                result = append(result, append([]interface{}{v}, v2...))\n            }\n        }\n    }\n    return result\n}\n",
    "    if n == 1 {\n        var res [][]interface{}\n        for _, v := range l {\n            res = append(res, []interface{}{v})\n        }\n        return res\n    }\n    var res [][]interface{}\n    for _, v := range l {\n        for _, vv := range combinations_colors(l, n-1) {\n            res = append(res, append([]interface{}{v}, vv...))\n        }\n    }\n    return res\n}\n",
    "    var result [][]interface{}\n    var helper func([]string, int, int, []interface{})\n    helper = func(l []string, start int, n int, curr []interface{}) {\n        if n == 0 {\n            result = append(result, append([]interface{}{}, curr...))\n            return\n        }\n        for i := start; i < len(l); i++ {\n            curr = append(curr, l[i])\n            helper(l, i, n - 1, curr)\n            curr = curr[:len(curr) - 1]\n        }\n    }\n    helper(l, 0, n, []interface{}{})\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        }\n        for _, v := range l {\n            helper(append(arr, v), n-1)\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) == 1 {\n        return [][]interface{}{[]interface{}{l[0]}}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        sub_result := combinations_colors(l[i+1:], n-1)\n        for _, sub_result_item := range sub_result {\n            result = append(result, append([]interface{}{l[i]}, sub_result_item...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    result := [][]interface{}{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{}\n    }\n    if n == 1 {\n        var result [][]interface{}\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    var result [][]interface{}\n    for i, v := range l {\n        for _, r := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{v}, r...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{}\n    }\n    if n == 1 {\n        res := [][]interface{}{}\n        for _, v := range l {\n            res = append(res, []interface{}{v})\n        }\n        return res\n    }\n    res := [][]interface{}{}\n    for i, v := range l {\n        for _, c := range combinations_colors(l[i:], n-1) {\n            res = append(res, append([]interface{}{v}, c...))\n        }\n    }\n    return res\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i, v := range l {\n        for _, w := range combinations_colors(l[i:], n - 1) {\n            result = append(result, append([]interface{}{v}, w...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var recurse func([]string, int, []interface{})\n    recurse = func(l []string, n int, prefix []interface{}) {\n        if n == 0 {\n            result = append(result, prefix)\n            return\n        }\n        for i := 0; i < len(l); i++ {\n            recurse(l, n-1, append(prefix, l[i]))\n        }\n    }\n    recurse(l, n, []interface{}{})\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func(int)\n    helper = func(i int) {\n        if i == n {\n            result = append(result, combination)\n            return\n        }\n        for _, v := range l {\n            combination = append(combination, v)\n            helper(i + 1)\n            combination = combination[:len(combination) - 1]\n        }\n    }\n    helper(0)\n    return result\n}\n",
    "    // TODO\n    return nil\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]string, int, int, []interface{})\n    helper = func(l []string, start int, n int, curr []interface{}) {\n        if n == 0 {\n            result = append(result, curr)\n            return\n        }\n        for i := start; i < len(l); i++ {\n            helper(l, i, n - 1, append(curr, l[i]))\n        }\n    }\n    helper(l, 0, n, []interface{}{})\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i := 0; i <= len(l) - n; i++ {\n        for _, v := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var helper func([]string, int, int)\n    helper = func(l []string, start int, n int) {\n        if n == 0 {\n            result = append(result, temp)\n            return\n        }\n        for i := start; i < len(l); i++ {\n            temp = append(temp, l[i])\n            helper(l, i, n - 1)\n            temp = temp[:len(temp) - 1]\n        }\n    }\n    helper(l, 0, n)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if n == 1 {\n        var r [][]interface{}\n        for _, v := range l {\n            r = append(r, []interface{}{v})\n        }\n        return r\n    }\n    var r [][]interface{}\n    for i, v := range l {\n        for _, c := range combinations_colors(l[i:], n - 1) {\n            r = append(r, append([]interface{}{v}, c...))\n        }\n    }\n    return r\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append(sub_result[j], l[i])\n            result = append(result, sub_result[j])\n        }\n    }\n    return result\n}\n",
    "    if n == 1 {\n        var combinations [][]interface{}\n        for _, v := range l {\n            combinations = append(combinations, []interface{}{v})\n        }\n        return combinations\n    }\n    var combinations [][]interface{}\n    for i, v := range l {\n        for _, c := range combinations_colors(l[i:], n - 1) {\n            combinations = append(combinations, append([]interface{}{v}, c...))\n        }\n    }\n    return combinations\n}\n",
    "    if n == 0 {\n        return [][]interface{}{}\n    }\n    if n == 1 {\n        return [][]interface{}{{l[0]}}\n    }\n    if len(l) == 1 {\n        return [][]interface{}{{l[0]}}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append(sub_result[j], l[i])\n        }\n        result = append(result, sub_result...)\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i, v := range l {\n        for _, c := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{v}, c...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i, v := range l {\n        for _, c := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{v}, c...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i, v := range l {\n        for _, v2 := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{v}, v2...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        }\n        for i := 0; i < len(l); i++ {\n            helper(append(arr, l[i]), n - 1)\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        }\n        for _, v := range l {\n            helper(append(arr, v), n-1)\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if n == 1 {\n        result := [][]interface{}{}\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    result := [][]interface{}{}\n    for i := 0; i < len(l); i++ {\n        sub_result := combinations_colors(l[i:], n - 1)\n        for _, v := range sub_result {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    var combinations [][]interface{}\n    var combination []interface{}\n    var helper func(int)\n    helper = func(i int) {\n        if i == n {\n            combinations = append(combinations, combination)\n            return\n        }\n        for _, v := range l {\n            combination = append(combination, v)\n            helper(i + 1)\n            combination = combination[:len(combination) - 1]\n        }\n    }\n    helper(0)\n    return combinations\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i, v := range l {\n        for _, r := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{v}, r...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l, n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    var res [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            res = append(res, []interface{}{v})\n        }\n        return res\n    }\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n-1) {\n            res = append(res, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return res\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for _, v := range l {\n        for _, v2 := range combinations_colors(l, n - 1) {\n            result = append(result, append([]interface{}{v}, v2...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        sub_combinations := combinations_colors(l, n - 1)\n        for _, sub_combination := range sub_combinations {\n            result = append(result, append([]interface{}{l[i]}, sub_combination...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, sub_result := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, sub_result...))\n        }\n    }\n    return result\n}\n",
    "    if n == 1 {\n        var r [][]interface{}\n        for _, e := range l {\n            r = append(r, []interface{}{e})\n        }\n        return r\n    }\n    var r [][]interface{}\n    for i, e := range l {\n        for _, c := range combinations_colors(l[i:], n-1) {\n            r = append(r, append([]interface{}{e}, c...))\n        }\n    }\n    return r\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i, v := range l {\n        for _, c := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{v}, c...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        }\n        for i := 0; i < len(l); i++ {\n            helper(append(arr, l[i]), n - 1)\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{}\n    }\n    if n == 1 {\n        var result [][]interface{}\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        sub_result := combinations_colors(l[i:], n - 1)\n        for _, v := range sub_result {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, c := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, c...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if n == 1 {\n        var res [][]interface{}\n        for _, v := range l {\n            res = append(res, []interface{}{v})\n        }\n        return res\n    }\n    var res [][]interface{}\n    for i, v := range l {\n        for _, vv := range combinations_colors(l[i:], n-1) {\n            res = append(res, append([]interface{}{v}, vv...))\n        }\n    }\n    return res\n}\n",
    "    // TODO - Add your code here\n    return nil\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        }\n        for i := 0; i < len(l); i++ {\n            helper(append(arr, l[i]), n - 1)\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i, v := range l {\n        combinations := combinations_colors(l[i:], n-1)\n        for _, c := range combinations {\n            result = append(result, append([]interface{}{v}, c...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var helper func([]interface{}, int)\n    helper = func(arr []interface{}, n int) {\n        if n == 0 {\n            result = append(result, arr)\n            return\n        } else {\n            for _, e := range l {\n                helper(append(arr, e), n - 1)\n            }\n        }\n    }\n    helper([]interface{}{}, n)\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var sub_result [][]interface{}\n        sub_result = combinations_colors(l[i+1:], n-1)\n        for j := 0; j < len(sub_result); j++ {\n            sub_result[j] = append(sub_result[j], l[i])\n        }\n        result = append(result, sub_result...)\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i, v := range l {\n        for _, v2 := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{v}, v2...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, sub_combination := range combinations_colors(l[i+1:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, sub_combination...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if n == 1 {\n        var result [][]interface{}\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n - 1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{}\n    }\n    if n == 1 {\n        var result [][]interface{}\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{}\n    }\n    if n == 1 {\n        var res [][]interface{}\n        for _, e := range l {\n            res = append(res, []interface{}{e})\n        }\n        return res\n    }\n    var res [][]interface{}\n    for i := 0; i < len(l); i++ {\n        var temp [][]interface{}\n        temp = combinations_colors(l[i+1:], n-1)\n        for _, e := range temp {\n            res = append(res, append([]interface{}{l[i]}, e...))\n        }\n    }\n    return res\n}\n",
    "    if n == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if n == 1 {\n        var combinations [][]interface{}\n        for _, v := range l {\n            combinations = append(combinations, []interface{}{v})\n        }\n        return combinations\n    }\n    var combinations [][]interface{}\n    for i, v := range l {\n        var sub_combinations [][]interface{}\n        sub_combinations = combinations_colors(l[i:], n - 1)\n        for _, sub_combination := range sub_combinations {\n            combination := append([]interface{}{v}, sub_combination...)\n            combinations = append(combinations, combination)\n        }\n    }\n    return combinations\n}\n",
    "    if n == 1 {\n        var ret [][]interface{}\n        for _, v := range l {\n            ret = append(ret, []interface{}{v})\n        }\n        return ret\n    }\n    var ret [][]interface{}\n    for i, v := range l {\n        for _, vv := range combinations_colors(l[i:], n-1) {\n            ret = append(ret, append([]interface{}{v}, vv...))\n        }\n    }\n    return ret\n}\n",
    "    if n == 1 {\n        var res [][]interface{}\n        for _, v := range l {\n            res = append(res, []interface{}{v})\n        }\n        return res\n    }\n    var res [][]interface{}\n    for _, v := range l {\n        for _, vv := range combinations_colors(l, n - 1) {\n            res = append(res, append([]interface{}{v}, vv...))\n        }\n    }\n    return res\n}\n",
    "    if n == 1 {\n        var result [][]interface{}\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    var result [][]interface{}\n    for _, v := range l {\n        for _, w := range combinations_colors(l, n-1) {\n            result = append(result, append([]interface{}{v}, w...))\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var combination []interface{}\n    var helper func([]string, int, int)\n    helper = func(l []string, n int, i int) {\n        if n == 0 {\n            result = append(result, combination)\n            return\n        }\n        for j := i; j < len(l); j++ {\n            combination = append(combination, l[j])\n            helper(l, n-1, j)\n            combination = combination[:len(combination)-1]\n        }\n    }\n    helper(l, n, 0)\n    return result\n}\n",
    "    var res [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            res = append(res, []interface{}{v})\n        }\n        return res\n    }\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n-1) {\n            res = append(res, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return res\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var ret [][]interface{}\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i+1:], n-1) {\n            ret = append(ret, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return ret\n}\n",
    "    var result [][]interface{}\n    if n == 1 {\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    for i := 0; i < len(l); i++ {\n        for _, v := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if n == 1 {\n        var r [][]interface{}\n        for _, e := range l {\n            r = append(r, []interface{}{e})\n        }\n        return r\n    }\n    var r [][]interface{}\n    for i, e := range l {\n        for _, c := range combinations_colors(l[i:], n-1) {\n            r = append(r, append([]interface{}{e}, c...))\n        }\n    }\n    return r\n}\n",
    "    var result [][]interface{}\n    var helper func(int, []interface{})\n    helper = func(offset int, curr []interface{}) {\n        if len(curr) == n {\n            result = append(result, append([]interface{}{}, curr...))\n            return\n        }\n        for i := offset; i < len(l); i++ {\n            helper(i, append(curr, l[i]))\n        }\n    }\n    helper(0, []interface{}{})\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{[]interface{}{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    var result [][]interface{}\n    for i, v := range l {\n        for _, c := range combinations_colors(l[i:], n-1) {\n            result = append(result, append([]interface{}{v}, c...))\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return [][]interface{}{{}}\n    }\n    if len(l) == 0 {\n        return [][]interface{}{}\n    }\n    if len(l) < n {\n        return [][]interface{}{}\n    }\n    if len(l) == n {\n        return [][]interface{}{{l}}\n    }\n    if n == 1 {\n        var result [][]interface{}\n        for _, v := range l {\n            result = append(result, []interface{}{v})\n        }\n        return result\n    }\n    var result [][]interface{}\n    for i := 0; i < len(l); i++ {\n        sub_result := combinations_colors(l[i+1:], n-1)\n        for _, v := range sub_result {\n            result = append(result, append([]interface{}{l[i]}, v...))\n        }\n    }\n    return result\n}\n"
  ]
}