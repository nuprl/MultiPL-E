{
  "name": "mbpp_4_heap_queue_largest",
  "language": "go_test.go",
  "prompt": "package heap_queue_largest_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the n largest integers from a given list of numbers, returned in descending order.\nfunc heap_queue_largest(nums []int, n int) []int {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_4_heap_queue_largest.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestHeap_Queue_Largest(t *testing.T) {\n  candidate := heap_queue_largest\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{25, 35, 22, 85, 14, 65, 75, 22, 58}, 3), expected: []int{85, 75, 65} },\n     { actual: candidate([]int{25, 35, 22, 85, 14, 65, 75, 22, 58}, 2), expected: []int{85, 75} },\n     { actual: candidate([]int{25, 35, 22, 85, 14, 65, 75, 22, 58}, 5), expected: []int{85, 75, 65, 58, 35} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    if n <= 0 {\n        return []int{}\n    }\n\n    if n >= len(nums) {\n        return nums\n    }\n\n    // build max heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    // insert\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    // sort\n    for i := n - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heapify(heap, 0, i)\n    }\n\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n\n    // build a min heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    // insert the rest of the numbers into the heap\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    // sort the heap\n    for i := n-1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heapify(heap, 0, i)\n    }\n\n    return heap\n}\n",
    "    if len(nums) < n {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heap_adjust(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_adjust(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heapify(heap, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heap_queue_largest_heapify(nums, i, len(nums))\n    }\n    // extract the top n elements\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heap_queue_largest_heapify(nums, 0, i)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return nil\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build a max heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop the max n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop the top n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // extract the largest n elements\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n\n    // build a min heap\n    for i := n / 2 - 1; i >= 0; i-- {\n        heap_queue_largest_heapify(nums, n, i)\n    }\n\n    // extract the top n elements\n    for i := n; i < len(nums); i++ {\n        if nums[i] > nums[0] {\n            nums[i], nums[0] = nums[0], nums[i]\n            heap_queue_largest_heapify(nums, n, 0)\n        }\n    }\n\n    return nums[:n]\n}\n",
    "    if n > len(nums) {\n        return nil\n    }\n    // build a max heap\n    for i := len(nums) / 2 - 1; i >= 0; i-- {\n        max_heapify(nums, i)\n    }\n    // extract the top n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - i - 1] = nums[len(nums) - i - 1], nums[0]\n        max_heapify(nums[:len(nums) - i - 1], 0)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if n < 1 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    copy(heap, nums[:n])\n    for i := n/2 - 1; i >= 0; i-- {\n        heap_queue_largest_heapify(heap, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_queue_largest_heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    copy(heap, nums[:n])\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) < n {\n        return nums\n    }\n\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    return heap\n}\n",
    "    if len(nums) == 0 || n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build a max heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-i-1] = nums[len(nums)-i-1], nums[0]\n        heapify(nums, 0, len(nums)-i-1)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if len(nums) < n {\n        return nums\n    }\n\n    // build a min heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // extract the root n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) <= n {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n"
  ]
}