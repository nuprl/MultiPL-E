{
  "name": "mbpp_4_heap_queue_largest",
  "language": "go_test.go",
  "prompt": "package heap_queue_largest_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the n largest integers from a given list of numbers, returned in descending order.\nfunc heap_queue_largest(nums []int, n int) []int {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_4_heap_queue_largest.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestHeap_Queue_Largest(t *testing.T) {\n  candidate := heap_queue_largest\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{25, 35, 22, 85, 14, 65, 75, 22, 58}, 3), expected: []int{85, 75, 65} },\n     { actual: candidate([]int{25, 35, 22, 85, 14, 65, 75, 22, 58}, 2), expected: []int{85, 75} },\n     { actual: candidate([]int{25, 35, 22, 85, 14, 65, 75, 22, 58}, 5), expected: []int{85, 75, 65, 58, 35} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    if n <= 0 {\n        return []int{}\n    }\n\n    if n >= len(nums) {\n        return nums\n    }\n\n    // build max heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    // insert\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    // sort\n    for i := n - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heapify(heap, 0, i)\n    }\n\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n\n    // build a min heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    // insert the rest of the numbers into the heap\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    // sort the heap\n    for i := n-1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heapify(heap, 0, i)\n    }\n\n    return heap\n}\n",
    "    if len(nums) < n {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heap_adjust(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_adjust(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heapify(heap, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heap_queue_largest_heapify(nums, i, len(nums))\n    }\n    // extract the top n elements\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heap_queue_largest_heapify(nums, 0, i)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return nil\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build a max heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop the max n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop the top n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // extract the largest n elements\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n\n    // build a min heap\n    for i := n / 2 - 1; i >= 0; i-- {\n        heap_queue_largest_heapify(nums, n, i)\n    }\n\n    // extract the top n elements\n    for i := n; i < len(nums); i++ {\n        if nums[i] > nums[0] {\n            nums[i], nums[0] = nums[0], nums[i]\n            heap_queue_largest_heapify(nums, n, 0)\n        }\n    }\n\n    return nums[:n]\n}\n",
    "    if n > len(nums) {\n        return nil\n    }\n    // build a max heap\n    for i := len(nums) / 2 - 1; i >= 0; i-- {\n        max_heapify(nums, i)\n    }\n    // extract the top n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - i - 1] = nums[len(nums) - i - 1], nums[0]\n        max_heapify(nums[:len(nums) - i - 1], 0)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if n < 1 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    copy(heap, nums[:n])\n    for i := n/2 - 1; i >= 0; i-- {\n        heap_queue_largest_heapify(heap, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_queue_largest_heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    copy(heap, nums[:n])\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) < n {\n        return nums\n    }\n\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    return heap\n}\n",
    "    if len(nums) == 0 || n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build a max heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-i-1] = nums[len(nums)-i-1], nums[0]\n        heapify(nums, 0, len(nums)-i-1)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if len(nums) < n {\n        return nums\n    }\n\n    // build a min heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // extract the root n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) <= n {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    // create a max heap\n    heap := make([]int, 0)\n    for _, num := range nums {\n        heap = append(heap, num)\n        if len(heap) > n {\n            heap = heap[1:]\n        }\n        heap = heapify(heap)\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n == 1 {\n        max := nums[0]\n        for _, num := range nums {\n            if num > max {\n                max = num\n            }\n        }\n        return []int{max}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build a min-heap\n    for i := n / 2; i >= 0; i-- {\n        heapify(nums, n, i)\n    }\n    // heap sort\n    for i := n - 1; i >= 0; i-- {\n        nums[i], nums[0] = nums[0], nums[i]\n        heapify(nums, i, 0)\n    }\n    return nums[:n]\n}\n",
    "    if n > len(nums) {\n        return nil\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        max_heapify(nums, i)\n    }\n\n    // extract the max n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        max_heapify(nums[:len(nums) - 1 - i], 0)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    var heap []int\n    for _, num := range nums {\n        if len(heap) < n {\n            heap = append(heap, num)\n            if len(heap) == n {\n                build_heap(heap)\n            }\n        } else {\n            if num > heap[0] {\n                heap[0] = num\n                heapify(heap, 0, n)\n            }\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) < n {\n        return nil\n    }\n\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nil\n    }\n\n    // build a max heap\n    build_max_heap(nums)\n\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        max_heapify(nums, 0, len(nums) - 1 - i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    heap := make([]int, 0)\n    for _, num := range nums {\n        if len(heap) < n {\n            heap = append(heap, num)\n        } else {\n            if num > heap[0] {\n                heap[0] = num\n            }\n        }\n        heap = heap_queue_heapify(heap, 0)\n    }\n    return heap\n}\n",
    "    // build a max heap\n    heap := make([]int, 0)\n    for _, num := range nums {\n        heap = append(heap, num)\n        // heapify up\n        i := len(heap) - 1\n        for i > 0 {\n            parent := (i - 1) / 2\n            if heap[i] > heap[parent] {\n                heap[i], heap[parent] = heap[parent], heap[i]\n                i = parent\n            } else {\n                break\n            }\n        }\n    }\n\n    // pop n times\n    res := make([]int, 0)\n    for i := 0; i < n; i++ {\n        res = append(res, heap[0])\n        heap[0] = heap[len(heap) - 1]\n        heap = heap[:len(heap) - 1]\n        // heapify down\n        i := 0\n        for i < len(heap) {\n            left := i * 2 + 1\n            right := i * 2 + 2\n            if left >= len(heap) {\n                break\n            }\n            if right >= len(heap) {\n                if heap[left] > heap[i] {\n                    heap[left], heap[i] = heap[i], heap[left]\n                    i = left\n                } else {\n                    break\n                }\n            } else {\n                if heap[left] > heap[right] {\n                    if heap[left] > heap[i] {\n                        heap[left], heap[i] = heap[i], heap[left]\n                        i = left\n                    } else {\n                        break\n                    }\n                } else {\n                    if heap[right] > heap[i] {\n                        heap[right], heap[i] = heap[i], heap[right]\n                        i = right\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n\n    return res\n}\n",
    "    if len(nums) == 0 || n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build a max heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heap_adjust(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_adjust(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n\n    if n >= len(nums) {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    // heapify\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - i - 1] = nums[len(nums) - i - 1], nums[0]\n        heapify(nums, 0, len(nums) - i - 1)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if n <= 0 || n > len(nums) {\n        return []int{}\n    }\n    // build a max heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop the largest n elements\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build heap\n    for i := n / 2 - 1; i >= 0; i-- {\n        heap_queue_largest_heapify(nums, n, i)\n    }\n    // heap sort\n    for i := n - 1; i >= 0; i-- {\n        nums[i], nums[0] = nums[0], nums[i]\n        heap_queue_largest_heapify(nums, i, 0)\n    }\n    return nums[:n]\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    h := make([]int, n)\n    for i := 0; i < n; i++ {\n        h[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(h, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > h[0] {\n            h[0] = nums[i]\n            heapify(h, 0, n)\n        }\n    }\n    return h\n}\n",
    "    if n <= 0 || len(nums) < n {\n        return nil\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        max_heapify(nums, i, len(nums))\n    }\n\n    // extract the max n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        max_heapify(nums, 0, len(nums)-1-i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n\n    if n >= len(nums) {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - i - 1] = nums[len(nums) - i - 1], nums[0]\n        heapify(nums, 0, len(nums) - i - 1)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return nil\n    }\n\n    if n >= len(nums) {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // swap the first and last element, then heapify the rest\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if len(nums) == 0 || n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build a max heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop the top n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n\n    if n > len(nums) {\n        n = len(nums)\n    }\n\n    // Build a max heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // Extract the max n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-i-1] = nums[len(nums)-i-1], nums[0]\n        heapify(nums, 0, len(nums)-i-1)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build a max heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-i-1] = nums[len(nums)-i-1], nums[0]\n        heapify(nums, 0, len(nums)-i-1)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    var result []int\n    if n > len(nums) {\n        return result\n    }\n    for i := 0; i < n; i++ {\n        result = append(result, nums[i])\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(result, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > result[0] {\n            result[0] = nums[i]\n            heapify(result, 0, n)\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if len(nums) == 0 {\n        return []int{}\n    }\n    if len(nums) <= n {\n        return nums\n    }\n    // create a min heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        min_heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            min_heapify(heap, 0, n)\n        }\n    }\n    // sort the heap\n    for i := n - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        min_heapify(heap, 0, i)\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build a min heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    // insert the rest of the numbers\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    result := make([]int, n)\n    for i := 0; i < n; i++ {\n        result[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heap_queue_largest_heapify(result, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > result[0] {\n            result[0] = nums[i]\n            heap_queue_largest_heapify(result, 0, n)\n        }\n    }\n    return result\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build heap\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(nums, i, n)\n    }\n    // heap sort\n    for i := n; i < len(nums); i++ {\n        if nums[i] > nums[0] {\n            nums[0], nums[i] = nums[i], nums[0]\n            heapify(nums, 0, n)\n        }\n    }\n    return nums[:n]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heap_adjust(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_adjust(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return nil\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heapify(heap, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    // build heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    // insert the rest of the numbers\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    return heap\n}\n",
    "    if n <= 0 || n > len(nums) {\n        return []int{}\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    build_heap(heap)\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build a min heap\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(nums, n, i)\n    }\n    // extract the top n elements\n    for i := n; i < len(nums); i++ {\n        if nums[i] > nums[0] {\n            nums[i], nums[0] = nums[0], nums[i]\n            heapify(nums, n, 0)\n        }\n    }\n    // reverse the result\n    for i, j := 0, n - 1; i < j; i, j = i + 1, j - 1 {\n        nums[i], nums[j] = nums[j], nums[i]\n    }\n    return nums[:n]\n}\n",
    "    if n <= 0 {\n        return nil\n    }\n\n    var result []int\n    for _, num := range nums {\n        if len(result) < n {\n            result = append(result, num)\n        } else {\n            if num > result[0] {\n                result[0] = num\n            }\n        }\n        heapify(result, 0)\n    }\n\n    return result\n}\n",
    "    // init heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heap_adjust(heap, i, n)\n    }\n    // insert\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_adjust(heap, 0, n)\n        }\n    }\n    // sort\n    for i := n - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heap_adjust(heap, 0, i)\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n\n    if n > len(nums) {\n        n = len(nums)\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        max_heapify(nums, i, len(nums))\n    }\n\n    // extract the max element n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        max_heapify(nums, 0, len(nums) - 1 - i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n\n    for i := n / 2; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    result := make([]int, n)\n    for i := 0; i < n; i++ {\n        result[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heapify(result, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > result[0] {\n            result[0] = nums[i]\n            heapify(result, 0, n)\n        }\n    }\n    return result\n}\n",
    "    if n < 1 || len(nums) < n {\n        return nil\n    }\n\n    // build a max heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n\n    if n >= len(nums) {\n        return nums\n    }\n\n    // build heap\n    for i := n / 2; i >= 0; i-- {\n        heapify(nums, i, n)\n    }\n\n    // heap sort\n    for i := n; i < len(nums); i++ {\n        if nums[i] > nums[0] {\n            nums[0], nums[i] = nums[i], nums[0]\n            heapify(nums, 0, n)\n        }\n    }\n\n    return nums[:n]\n}\n",
    "    // build a max heap\n    heap := make([]int, len(nums))\n    for i, num := range nums {\n        heap[i] = num\n        heap_up(heap, i)\n    }\n\n    // pop the top n elements\n    result := make([]int, n)\n    for i := 0; i < n; i++ {\n        result[i] = heap[0]\n        heap[0] = heap[len(heap) - 1]\n        heap = heap[:len(heap) - 1]\n        heap_down(heap, 0)\n    }\n\n    return result\n}\n",
    "    if n > len(nums) {\n        return nil\n    }\n\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n\n    for i := n / 2; i >= 0; i-- {\n        heap_adjust(heap, i, n)\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_adjust(heap, 0, n)\n        }\n    }\n\n    return heap\n}\n",
    "    if len(nums) < n {\n        return nil\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heap_adjust(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_adjust(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    // insert\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    // sort\n    for i := n - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heapify(heap, 0, i)\n    }\n    return heap\n}\n",
    "    if len(nums) < n {\n        return nil\n    }\n\n    // build a heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop n largest\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n\n    // init heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heap_queue_largest_heapify(heap, i, n)\n    }\n\n    // insert\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_queue_largest_heapify(heap, 0, n)\n        }\n    }\n\n    // sort\n    for i := n - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heap_queue_largest_heapify(heap, 0, i)\n    }\n\n    return heap\n}\n",
    "    if len(nums) < n {\n        return nil\n    }\n\n    // build a max heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop n elements from the heap\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-i-1] = nums[len(nums)-i-1], nums[0]\n        heapify(nums, 0, len(nums)-i-1)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n == 1 {\n        return []int{nums[0]}\n    }\n    if n == len(nums) {\n        return nums\n    }\n    if n > len(nums) {\n        return nums\n    }\n    // build a heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := (n - 1) / 2; i >= 0; i-- {\n        heapify(heap, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) == 0 || n <= 0 {\n        return []int{}\n    }\n\n    // build a max heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // extract the top n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-i-1] = nums[len(nums)-i-1], nums[0]\n        heapify(nums, 0, len(nums)-i-1)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if len(nums) <= n {\n        return nums\n    }\n\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i)\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n\n    return heap\n}\n",
    "    if len(nums) == 0 || n == 0 {\n        return []int{}\n    }\n\n    // build a max heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop the largest n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    // init heap\n    h := make([]int, 0)\n    for _, num := range nums {\n        if len(h) < n {\n            h = append(h, num)\n            heapify_up(h)\n        } else if num > h[0] {\n            h[0] = num\n            heapify_down(h)\n        }\n    }\n    return h\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n\n    if n >= len(nums) {\n        return nums\n    }\n\n    // build heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // extract n largest\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heapify(heap, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) == 0 || n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build max heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    // build a heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    // compare the rest of the numbers with the root of the heap\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build a max heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n\n    // Build a max heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // Extract the top n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        max_heapify(nums, i, len(nums))\n    }\n    // extract the top n elements\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        max_heapify(nums, 0, i)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heap_queue_largest_heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_queue_largest_heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop the max n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if len(nums) <= n {\n        return nums\n    }\n\n    // build max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // swap first and last\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heap_queue_largest_heapify(nums, i, len(nums))\n    }\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heap_queue_largest_heapify(nums, 0, len(nums)-1-i)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n\n    if n > len(nums) {\n        n = len(nums)\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // extract the top n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if len(nums) <= n {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // swap the first and last element, and heapify the first n-1 elements\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n\n    if n >= len(nums) {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop the top n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i)\n    }\n    // pop n largest numbers\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums[:i], 0)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if n < 1 || n > len(nums) {\n        return nil\n    }\n\n    heap := make([]int, n)\n    copy(heap, nums[:n])\n    for i := n / 2 - 1; i >= 0; i-- {\n        heap_adjust(heap, i, n)\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_adjust(heap, 0, n)\n        }\n    }\n\n    return heap\n}\n",
    "    if len(nums) < n {\n        return nil\n    }\n    var heap = make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n\n    if n > len(nums) {\n        n = len(nums)\n    }\n\n    // build a heap\n    for i := n/2; i >= 0; i-- {\n        heapify(nums, i, n)\n    }\n\n    // sort the heap\n    for i := n-1; i >= 1; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n\n    return nums[:n]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    heap := nums[:n]\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build a min heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heapify(heap, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build a max heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    // insert the rest of the numbers\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    // sort the heap\n    for i := n - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heapify(heap, 0, i)\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // extract the top n elements\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop the max n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build heap\n    for i := n / 2; i >= 0; i-- {\n        heapify(nums, i, n)\n    }\n    // heap sort\n    for i := n; i < len(nums); i++ {\n        if nums[i] > nums[0] {\n            nums[0], nums[i] = nums[i], nums[0]\n            heapify(nums, 0, n)\n        }\n    }\n    return nums[:n]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i)\n    }\n    // insert\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    // sort\n    for i := n - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heapify(heap[:i], 0)\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build a max heap\n    for i := (len(nums) - 1) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // extract the top n numbers\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n\n    var heap []int\n    for _, num := range nums {\n        heap = append(heap, num)\n        if len(heap) > n {\n            heap = heap[1:]\n        }\n        heap = heapify(heap)\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    var result []int\n    for i := 0; i < n; i++ {\n        result = append(result, nums[i])\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(result, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > result[0] {\n            result[0] = nums[i]\n            heapify(result, 0)\n        }\n    }\n    return result\n}\n",
    "    if len(nums) < n {\n        return nums\n    }\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i)\n    }\n    // pop n largest numbers\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums[:len(nums) - 1 - i], 0)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n\n    if n >= len(nums) {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop the top n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build a heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if n <= 0 || n > len(nums) {\n        return nil\n    }\n\n    heap := make([]int, n)\n    copy(heap, nums[:n])\n    heapify(heap)\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap)\n        }\n    }\n\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n\n    // init heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heapify(heap, i)\n    }\n\n    // insert\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n\n    // sort\n    for i := n - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heapify(heap[:i], 0)\n    }\n\n    return heap\n}\n",
    "    if len(nums) == 0 || n == 0 {\n        return nil\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-i-1] = nums[len(nums)-i-1], nums[0]\n        heapify(nums, 0, len(nums)-i-1)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if n > len(nums) {\n        return nil\n    }\n    // build a max heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // extract the largest n elements\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if n <= 0 {\n        return nil\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    var result []int\n    for i := 0; i < n; i++ {\n        result = append(result, nums[i])\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heap_adjust(result, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > result[0] {\n            result[0] = nums[i]\n            heap_adjust(result, 0, n)\n        }\n    }\n    return result\n}\n",
    "    if len(nums) < n {\n        return nums\n    }\n\n    // build a min heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heap_adjust(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_adjust(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) <= n {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nil\n    }\n\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    return heap\n}\n",
    "    if len(nums) == 0 || n <= 0 {\n        return []int{}\n    }\n\n    // build a max heap\n    heap := build_max_heap(nums)\n\n    // pop n times\n    for i := 0; i < n; i++ {\n        heap = pop_max(heap)\n    }\n\n    // return the result\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heap_queue_largest_heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_queue_largest_heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n\n    var result []int\n    for i := 0; i < n; i++ {\n        result = append(result, nums[i])\n    }\n\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(result, i, n)\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > result[0] {\n            result[0] = nums[i]\n            heapify(result, 0, n)\n        }\n    }\n\n    return result\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build max heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // extract top n elements\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    // make a min heap\n    heap := make([]int, 0)\n    for _, num := range nums {\n        if len(heap) < n {\n            heap = append(heap, num)\n            // bubble up\n            i := len(heap) - 1\n            for i > 0 {\n                if heap[i] < heap[(i-1)/2] {\n                    heap[i], heap[(i-1)/2] = heap[(i-1)/2], heap[i]\n                    i = (i-1)/2\n                } else {\n                    break\n                }\n            }\n        } else {\n            if num > heap[0] {\n                heap[0] = num\n                // bubble down\n                i := 0\n                for i < len(heap) {\n                    if 2*i+1 < len(heap) {\n                        if 2*i+2 < len(heap) {\n                            if heap[2*i+1] < heap[2*i+2] {\n                                if heap[i] > heap[2*i+1] {\n                                    heap[i], heap[2*i+1] = heap[2*i+1], heap[i]\n                                    i = 2*i+1\n                                } else {\n                                    break\n                                }\n                            } else {\n                                if heap[i] > heap[2*i+2] {\n                                    heap[i], heap[2*i+2] = heap[2*i+2], heap[i]\n                                    i = 2*i+2\n                                } else {\n                                    break\n                                }\n                            }\n                        } else {\n                            if heap[i] > heap[2*i+1] {\n                                heap[i], heap[2*i+1] = heap[2*i+1], heap[i]\n                                i = 2*i+1\n                            } else {\n                                break\n                            }\n                        }\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    // pop all elements\n    for i := 0; i < n/2; i",
    "    if n < 1 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // create a max heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    // create a max heap\n    heap := make([]int, 0)\n    for _, num := range nums {\n        heap = append(heap, num)\n        heap = heap_queue_max_heapify(heap)\n    }\n    // extract the largest n numbers\n    result := make([]int, 0)\n    for i := 0; i < n; i++ {\n        result = append(result, heap[0])\n        heap = heap_queue_extract_max(heap)\n    }\n    return result\n}\n",
    "    // heapify\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i)\n    }\n\n    // pop\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - i - 1] = nums[len(nums) - i - 1], nums[0]\n        heapify(nums[:len(nums) - i - 1], 0)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n > len(nums) {\n        return nil\n    }\n    var result []int\n    for i := 0; i < n; i++ {\n        result = append(result, nums[i])\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(result, n, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > result[0] {\n            result[0] = nums[i]\n            heapify(result, n, 0)\n        }\n    }\n    return result\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heapify(heap, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build a max heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heap_queue_largest_heapify(nums, i, len(nums))\n    }\n    // pop the max n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-i-1] = nums[len(nums)-i-1], nums[0]\n        heap_queue_largest_heapify(nums, 0, len(nums)-i-1)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if n < 1 {\n        return []int{}\n    }\n    if n > len(nums) {\n        return nums\n    }\n    // build a max heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop the top n elements\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if n <= 0 || n > len(nums) {\n        return nil\n    }\n\n    // create a max heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    // insert the rest of the numbers into the heap\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    // sort the heap\n    for i := n - 1; i > 0; i-- {\n        heap[i], heap[0] = heap[0], heap[i]\n        heapify(heap, 0, i)\n    }\n\n    return heap\n}\n",
    "    if len(nums) == 0 || n == 0 {\n        return []int{}\n    }\n\n    if n > len(nums) {\n        n = len(nums)\n    }\n\n    // build a min heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    // insert the rest of the numbers into the heap\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    // sort the heap\n    for i := n - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heapify(heap, 0, i)\n    }\n\n    return heap\n}\n",
    "    if n == 0 {\n        return nil\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heap_adjust(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_adjust(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build heap\n    for i := n/2-1; i >= 0; i-- {\n        heapify(nums, i, n)\n    }\n    // heap sort\n    for i := n; i < len(nums); i++ {\n        if nums[i] > nums[0] {\n            nums[0], nums[i] = nums[i], nums[0]\n            heapify(nums, 0, n)\n        }\n    }\n    return nums[:n]\n}\n",
    "    if len(nums) == 0 || n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if len(nums) < n {\n        return nums\n    }\n    // build a heap\n    for i := len(nums)/2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n\n    if len(nums) <= n {\n        return nums\n    }\n\n    // build a max heap\n    heap := nums[:n]\n    for i := n/2; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    return heap\n}\n",
    "    if n <= 0 || n > len(nums) {\n        return nil\n    }\n\n    // build a min heap\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(nums, n, i)\n    }\n\n    // extract the top n elements\n    for i := n; i < len(nums); i++ {\n        if nums[i] > nums[0] {\n            nums[0], nums[i] = nums[i], nums[0]\n            heapify(nums, n, 0)\n        }\n    }\n\n    // reverse the result\n    for i := 0; i < n/2; i++ {\n        nums[i], nums[n-1-i] = nums[n-1-i], nums[i]\n    }\n\n    return nums[:n]\n}\n",
    "    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i)\n    }\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums[:len(nums) - 1 - i], 0)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if len(nums) == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    copy(heap, nums[:n])\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    if n == len(nums) {\n        return heap_queue_sort(nums)\n    }\n    result := make([]int, n)\n    for i := 0; i < n; i++ {\n        result[i] = nums[i]\n    }\n    heap_queue_build(result)\n    for i := n; i < len(nums); i++ {\n        if nums[i] > result[0] {\n            result[0] = nums[i]\n            heap_queue_adjust(result, 0, n)\n        }\n    }\n    return result\n}\n",
    "    if n > len(nums) {\n        return nil\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heap_queue_largest_heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_queue_largest_heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n\n    if n > len(nums) {\n        n = len(nums)\n    }\n\n    // build a max heap\n    build_max_heap(nums)\n\n    // remove the largest n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        max_heapify(nums[:len(nums) - 1 - i], 0)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    nums = append(nums, make([]int, n)...)\n    for i := len(nums) - 1; i >= 0; i-- {\n        nums[i] = nums[i / 2]\n    }\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[i] = nums[0]\n        nums[0] = nums[i]\n        for j := 0; j < i; j++ {\n            nums[j] = nums[j / 2]\n        }\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := nums[:n]\n    for i := n / 2; i >= 0; i-- {\n        heapify(heap, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nil\n    }\n\n    // create a max heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    // insert the rest of the numbers\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    // sort the heap\n    for i := n-1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heapify(heap, 0, i)\n    }\n\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    // build a max heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop the top n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if len(nums) == 0 || n <= 0 {\n        return []int{}\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - i - 1] = nums[len(nums) - i - 1], nums[0]\n        heapify(nums, 0, len(nums) - i - 1)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    // build a min heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i)\n    }\n    // pop the smallest n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums[:len(nums)-1-i], 0)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n\n    if n >= len(nums) {\n        return nums\n    }\n\n    // build a min heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heapify(heap, i)\n    }\n\n    // insert the rest of the numbers into the heap\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n\n    // sort the heap\n    for i := n - 1; i >= 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heapify(heap[:i], 0)\n    }\n\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    var result []int\n    for i := 0; i < n; i++ {\n        result = append(result, nums[i])\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heap_adjust(result, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > result[0] {\n            result[0] = nums[i]\n            heap_adjust(result, 0, n)\n        }\n    }\n    return result\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n\n    if n >= len(nums) {\n        return nums\n    }\n\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n\n    for i := n / 2; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build a max heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heap_adjust(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_adjust(heap, 0, n)\n        }\n    }\n    // sort the heap\n    for i := n - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heap_adjust(heap, 0, i)\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nil\n    }\n\n    // build a heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    return heap\n}\n",
    "    if len(nums) < n {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n\n    if n >= len(nums) {\n        return nums\n    }\n\n    // build a min heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n\n    for i := n / 2; i >= 0; i-- {\n        heapify(heap, i)\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n\n    // build a max heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    // insert the rest of the numbers into the heap\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    // sort the heap\n    for i := n - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heapify(heap, 0, i)\n    }\n\n    return heap\n}\n",
    "    if len(nums) == 0 || n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return nil\n    }\n\n    if n >= len(nums) {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop the top n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        max_heapify(nums, i, len(nums))\n    }\n\n    // extract the top n elements\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        max_heapify(nums, 0, i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    // build a max heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        max_heapify(heap, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            max_heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n < 1 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    copy(heap, nums[:n])\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) < n {\n        return nums\n    }\n\n    heap := make([]int, 0)\n    for _, num := range nums {\n        if len(heap) < n {\n            heap = append(heap, num)\n            if len(heap) == n {\n                build_heap(heap)\n            }\n        } else {\n            if num > heap[0] {\n                heap[0] = num\n                heapify(heap, 0)\n            }\n        }\n    }\n\n    return heap\n}\n",
    "    if len(nums) < n {\n        return nil\n    }\n\n    // build a min heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // extract the top n elements\n    ret := make([]int, n)\n    for i := 0; i < n; i++ {\n        ret[i] = nums[0]\n        nums[0] = nums[len(nums) - 1]\n        nums = nums[:len(nums) - 1]\n        heapify(nums, 0, len(nums))\n    }\n\n    return ret\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop the top n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - i - 1] = nums[len(nums) - i - 1], nums[0]\n        heapify(nums, 0, len(nums) - i - 1)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n\n    if n >= len(nums) {\n        return nums\n    }\n\n    var heap []int\n    for i := 0; i < n; i++ {\n        heap = append(heap, nums[i])\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n\n    return heap\n}\n",
    "    if len(nums) == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heap_adjust(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_adjust(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heap_adjust(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heap_adjust(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return nil\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap_queue_largest_helper(nums, n)\n    for i := n; i < len(nums); i++ {\n        if nums[i] > nums[0] {\n            nums[0] = nums[i]\n            heap_queue_largest_helper(nums[:n], n)\n        }\n    }\n    return nums[:n]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    heap := make([]int, n)\n    copy(heap, nums[:n])\n    for i := n / 2; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums) / 2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // pop the top n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    result := make([]int, n)\n    for i := 0; i < n; i++ {\n        result[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(result, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > result[0] {\n            result[0] = nums[i]\n            heapify(result, 0, n)\n        }\n    }\n    return result\n}\n",
    "    if len(nums) == 0 || n == 0 {\n        return []int{}\n    }\n\n    if n > len(nums) {\n        n = len(nums)\n    }\n\n    // build a min heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    // sort the heap\n    for i := n - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heapify(heap, 0, i)\n    }\n\n    return heap\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n    return heap\n}\n",
    "    if n == 0 {\n        return []int{}\n    }\n    if n == 1 {\n        return []int{nums[0]}\n    }\n    if n == len(nums) {\n        return nums\n    }\n    if n > len(nums) {\n        return nums\n    }\n    // build a max heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    // compare the rest of the numbers with the root of the heap\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if n <= 0 {\n        return nil\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build a min heap\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(nums, i, n)\n    }\n    // heapify the rest\n    for i := n; i < len(nums); i++ {\n        if nums[i] > nums[0] {\n            nums[0] = nums[i]\n            heapify(nums, 0, n)\n        }\n    }\n    // sort the heap\n    for i := n - 1; i > 0; i-- {\n        nums[i], nums[0] = nums[0], nums[i]\n        heapify(nums, 0, i)\n    }\n    return nums[:n]\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    // build a max heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i)\n    }\n    // pop n times\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums[:len(nums)-1-i], 0)\n    }\n    return nums[len(nums)-n:]\n}\n",
    "    if n > len(nums) {\n        return nums\n    }\n    if n == len(nums) {\n        return nums\n    }\n    if n == 1 {\n        return []int{max(nums)}\n    }\n    if n == 0 {\n        return []int{}\n    }\n    result := make([]int, n)\n    result[0] = max(nums)\n    for i := 1; i < n; i++ {\n        result[i] = max(nums[:result[i-1]])\n    }\n    return result\n}\n",
    "    if len(nums) == 0 {\n        return []int{}\n    }\n    if n > len(nums) {\n        n = len(nums)\n    }\n    // build a max heap\n    for i := len(nums) / 2 - 1; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n    // pop the top n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums, 0, len(nums) - 1 - i)\n    }\n    return nums[len(nums) - n:]\n}\n",
    "    if len(nums) == 0 || n <= 0 {\n        return []int{}\n    }\n\n    if n > len(nums) {\n        n = len(nums)\n    }\n\n    heap := make([]int, n)\n    copy(heap, nums[:n])\n\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    return heap\n}\n",
    "    if n <= 0 {\n        return []int{}\n    }\n    if n >= len(nums) {\n        return nums\n    }\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n    return heap\n}\n",
    "    if len(nums) == 0 || n == 0 {\n        return []int{}\n    }\n\n    // build a max heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n / 2 - 1; i >= 0; i-- {\n        heapify(heap, i)\n    }\n\n    // insert the rest of the numbers\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0)\n        }\n    }\n\n    // sort the heap\n    for i := n - 1; i > 0; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heapify(heap[:i], 0)\n    }\n\n    return heap\n}\n",
    "    if len(nums) <= n {\n        return nums\n    }\n\n    // build a heap\n    heap := make([]int, n)\n    for i := 0; i < n; i++ {\n        heap[i] = nums[i]\n    }\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(heap, i, n)\n    }\n\n    // insert the rest of the numbers\n    for i := n; i < len(nums); i++ {\n        if nums[i] > heap[0] {\n            heap[0] = nums[i]\n            heapify(heap, 0, n)\n        }\n    }\n\n    return heap\n}\n",
    "    if len(nums) < n {\n        return nums\n    }\n\n    // build a max heap\n    for i := len(nums)/2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // extract the top n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums)-1-i] = nums[len(nums)-1-i], nums[0]\n        heapify(nums, 0, len(nums)-1-i)\n    }\n\n    return nums[len(nums)-n:]\n}\n",
    "    if len(nums) < n {\n        return nil\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i, len(nums))\n    }\n\n    // extract the top n elements\n    for i := len(nums) - 1; i >= len(nums) - n; i-- {\n        nums[0], nums[i] = nums[i], nums[0]\n        heapify(nums, 0, i)\n    }\n\n    return nums[len(nums) - n:]\n}\n",
    "    if n < 1 {\n        return []int{}\n    }\n\n    if n > len(nums) {\n        n = len(nums)\n    }\n\n    // build a max heap\n    for i := len(nums) / 2; i >= 0; i-- {\n        heapify(nums, i)\n    }\n\n    // pop the largest n elements\n    for i := 0; i < n; i++ {\n        nums[0], nums[len(nums) - 1 - i] = nums[len(nums) - 1 - i], nums[0]\n        heapify(nums[:len(nums) - 1 - i], 0)\n    }\n\n    return nums[len(nums) - n:]\n}\n"
  ]
}