{
  "name": "mbpp_753_min_k",
  "language": "go_test.go",
  "prompt": "package min_k_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find minimum k records from tuple list. https://www.geeksforgeeks.org/python-find-minimum-k-records-from-tuple-list/ - in this case a verbatim copy of test cases\nfunc min_k(test_list [][]interface{}, K int) [][]interface{} {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_753_min_k.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestMin_K(t *testing.T) {\n  candidate := min_k\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Manjeet\", 10}, []interface{}{\"Akshat\", 4}, []interface{}{\"Akash\", 2}, []interface{}{\"Nikhil\", 8}}, 2), expected: [][]int{[]interface{}{\"Akash\", 2}, []interface{}{\"Akshat\", 4}} },\n     { actual: candidate([][]int{[]interface{}{\"Sanjeev\", 11}, []interface{}{\"Angat\", 5}, []interface{}{\"Akash\", 3}, []interface{}{\"Nepin\", 9}}, 3), expected: [][]int{[]interface{}{\"Akash\", 3}, []interface{}{\"Angat\", 5}, []interface{}{\"Nepin\", 9}} },\n     { actual: candidate([][]int{[]interface{}{\"tanmay\", 14}, []interface{}{\"Amer\", 11}, []interface{}{\"Ayesha\", 9}, []interface{}{\"SKD\", 16}}, 1), expected: [][]int{[]interface{}{\"Ayesha\", 9}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // sort the list by the first element\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if test_list[i][0].(int) > test_list[j][0].(int) {\n                test_list[i], test_list[j] = test_list[j], test_list[i]\n            }\n        }\n    }\n    // return the first K elements\n    return test_list[:K]\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    // sort the list by the first item in the tuple\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if test_list[i][0].(int) > test_list[j][0].(int) {\n                test_list[i], test_list[j] = test_list[j], test_list[i]\n            }\n        }\n    }\n    return test_list[:K]\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    return test_list[:K]\n}\n",
    "    // Sort the list by the first element of each tuple\n    test_list = sort_by_first_element(test_list)\n\n    // Return the first k elements\n    return test_list[:K]\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    var min_k_list [][]interface{}\n    for i := 0; i < K; i++ {\n        min_k_list = append(min_k_list, test_list[i])\n    }\n    for i := K; i < len(test_list); i++ {\n        for j := 0; j < K; j++ {\n            if test_list[i][1].(int) < min_k_list[j][1].(int) {\n                min_k_list[j] = test_list[i]\n                break\n            }\n        }\n    }\n    return min_k_list\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    return test_list[:K]\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    return test_list[:K]\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    // sort the list by the first element of each sublist\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list) - 1; j++ {\n            if test_list[j][0].(int) > test_list[j + 1][0].(int) {\n                test_list[j], test_list[j + 1] = test_list[j + 1], test_list[j]\n            }\n        }\n    }\n    return test_list[:K]\n}\n",
    "    // your code here\n    return test_list\n}\n",
    "    var result [][]interface{}\n    for _, v := range test_list {\n        if len(result) < K {\n            result = append(result, v)\n        } else {\n            for i, v2 := range result {\n                if v[1].(int) < v2[1].(int) {\n                    result = append(result[:i], append([][]interface{}{v}, result[i:]...)...)\n                    break\n                }\n            }\n        }\n    }\n    return result\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    var min_k_list [][]interface{}\n    for _, test_case := range test_list {\n        if len(min_k_list) < K {\n            min_k_list = append(min_k_list, test_case)\n        } else {\n            for i, min_k_case := range min_k_list {\n                if test_case[1].(int) < min_k_case[1].(int) {\n                    min_k_list = append(min_k_list[:i], append([][]interface{}{test_case}, min_k_list[i:]...)...)\n                    break\n                }\n            }\n        }\n    }\n    return min_k_list\n}\n",
    "    if len(test_list) <= K {\n        return test_list\n    }\n    var min_k_list [][]interface{}\n    for i := 0; i < K; i++ {\n        min_k_list = append(min_k_list, test_list[i])\n    }\n    for i := K; i < len(test_list); i++ {\n        for j := 0; j < K; j++ {\n            if test_list[i][1].(int) < min_k_list[j][1].(int) {\n                min_k_list[j] = test_list[i]\n                break\n            }\n        }\n    }\n    return min_k_list\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // sort the list by the first element\n    for i := 0; i < len(test_list); i++ {\n        for j := i; j < len(test_list); j++ {\n            if test_list[i][0].(int) > test_list[j][0].(int) {\n                test_list[i], test_list[j] = test_list[j], test_list[i]\n            }\n        }\n    }\n    // return the first K elements\n    return test_list[:K]\n}\n",
    "    // sort the list\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if test_list[i][1].(int) > test_list[j][1].(int) {\n                test_list[i], test_list[j] = test_list[j], test_list[i]\n            }\n        }\n    }\n    return test_list[:K]\n}\n",
    "    var min_list [][]interface{}\n    for _, v := range test_list {\n        if len(min_list) < K {\n            min_list = append(min_list, v)\n        } else {\n            for i, v2 := range min_list {\n                if v[1].(int) < v2[1].(int) {\n                    min_list[i] = v\n                    break\n                }\n            }\n        }\n    }\n    return min_list\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    return test_list[:K]\n}\n",
    "    // We need to sort the list first\n    // We can use the built-in sort package\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to define a custom sort function\n    // We need to",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    var min_k_list [][]interface{}\n    for i := 0; i < K; i++ {\n        min_k_list = append(min_k_list, test_list[i])\n    }\n    for i := K; i < len(test_list); i++ {\n        for j := 0; j < K; j++ {\n            if test_list[i][1].(int) < min_k_list[j][1].(int) {\n                min_k_list[j] = test_list[i]\n                break\n            }\n        }\n    }\n    return min_k_list\n}\n",
    "    var result [][]interface{}\n\n    for _, t := range test_list {\n        if len(result) < K {\n            result = append(result, t)\n        } else {\n            for i, r := range result {\n                if t[1].(int) < r[1].(int) {\n                    result = append(result[:i], append([][]interface{}{t}, result[i:]...)...)\n                    break\n                }\n            }\n        }\n    }\n\n    return result\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    var result [][]interface{}\n    for i := 0; i < K; i++ {\n        result = append(result, test_list[i])\n    }\n    return result\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    var min_k_list [][]interface{}\n    for i := 0; i < K; i++ {\n        min_k_list = append(min_k_list, test_list[i])\n    }\n    for i := K; i < len(test_list); i++ {\n        for j := 0; j < K; j++ {\n            if test_list[i][1].(int) < min_k_list[j][1].(int) {\n                min_k_list[j] = test_list[i]\n                break\n            }\n        }\n    }\n    return min_k_list\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    var result [][]interface{}\n    for i := 0; i < K; i++ {\n        min_index := i\n        for j := i + 1; j < len(test_list); j++ {\n            if test_list[j][1].(int) < test_list[min_index][1].(int) {\n                min_index = j\n            }\n        }\n        result = append(result, test_list[min_index])\n        test_list[min_index], test_list[i] = test_list[i], test_list[min_index]\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    for _, test := range test_list {\n        if len(result) < K {\n            result = append(result, test)\n        } else {\n            for i, res := range result {\n                if test[1].(int) < res[1].(int) {\n                    result = append(result[:i], append([][]interface{}{test}, result[i:]...)...)\n                    result = result[:K]\n                    break\n                }\n            }\n        }\n    }\n    return result\n}\n",
    "    // TODO: Implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // sort the list by the first element of each sublist\n    // then return the first K elements of the list\n    return test_list\n}\n",
    "    if len(test_list) < K {\n        return test_list\n    }\n\n    // sort by first element\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if test_list[i][0].(int) > test_list[j][0].(int) {\n                test_list[i], test_list[j] = test_list[j], test_list[i]\n            }\n        }\n    }\n\n    return test_list[:K]\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    return test_list[:K]\n}\n",
    "    // Your code here\n    return nil\n}\n",
    "    // sort the list by the first element of the tuple\n    // then return the first K elements\n    return test_list\n}\n",
    "    if len(test_list) < K {\n        return test_list\n    }\n    var min_k_list [][]interface{}\n    for i := 0; i < K; i++ {\n        min_k_list = append(min_k_list, test_list[i])\n    }\n    for i := K; i < len(test_list); i++ {\n        for j := 0; j < K; j++ {\n            if test_list[i][1].(int) < min_k_list[j][1].(int) {\n                min_k_list[j] = test_list[i]\n                break\n            }\n        }\n    }\n    return min_k_list\n}\n",
    "    // sort the list by the first element in the tuple\n    // then return the first K elements\n    return test_list\n}\n",
    "    if len(test_list) < K {\n        return test_list\n    }\n    var min_k_list [][]interface{}\n    for i := 0; i < K; i++ {\n        min_k_list = append(min_k_list, test_list[i])\n    }\n    for i := K; i < len(test_list); i++ {\n        for j := 0; j < K; j++ {\n            if test_list[i][1].(int) < min_k_list[j][1].(int) {\n                min_k_list[j] = test_list[i]\n                break\n            }\n        }\n    }\n    return min_k_list\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    if len(test_list) < K {\n        return test_list\n    }\n    // sort the list\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list); j++ {\n            if test_list[i][1].(int) < test_list[j][1].(int) {\n                temp := test_list[i]\n                test_list[i] = test_list[j]\n                test_list[j] = temp\n            }\n        }\n    }\n    // return the first K records\n    return test_list[:K]\n}\n",
    "    var min_list [][]interface{}\n    for i := 0; i < K; i++ {\n        min_list = append(min_list, test_list[i])\n    }\n    for i := K; i < len(test_list); i++ {\n        for j := 0; j < K; j++ {\n            if test_list[i][1].(int) < min_list[j][1].(int) {\n                min_list[j] = test_list[i]\n                break\n            }\n        }\n    }\n    return min_list\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    if K == 0 {\n        return [][]interface{}{}\n    }\n    if K >= len(test_list) {\n        return test_list\n    }\n    // sort the list\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if test_list[i][1].(int) > test_list[j][1].(int) {\n                test_list[i], test_list[j] = test_list[j], test_list[i]\n            }\n        }\n    }\n    return test_list[:K]\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n\n    // sort the list\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if test_list[i][1].(int) > test_list[j][1].(int) {\n                test_list[i], test_list[j] = test_list[j], test_list[i]\n            }\n        }\n    }\n\n    return test_list[:K]\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    if len(test_list) == 0 {\n        return test_list\n    }\n    if K > len(test_list) {\n        return test_list\n    }\n    if K == 0 {\n        return [][]interface{}{}\n    }\n    // TODO: check if K is negative\n    // TODO: check if K is greater than length of list\n    // TODO: check if K is 0\n    // TODO: check if list is empty\n    // TODO: check if list is nil\n    // TODO: check if list is not a list of lists\n    // TODO: check if list is not a list of lists of ints\n    // TODO: check if list is not a list of lists of ints of length 2\n    // TODO: check if list is not a list of lists of ints of length 2 where the first element is the key and the second element is the value\n    // TODO: check if list is not a list of lists of ints of length 2 where the first element is the key and the second element is the value and the key is unique\n    // TODO: check if list is not a list of lists of ints of length 2 where the first element is the key and the second element is the value and the key is unique and the key is sorted\n    // TODO: check if list is not a list of lists of ints of length 2 where the first element is the key and the second element is the value and the key is unique and the key is sorted and the second element is unique\n    // TODO: check if list is not a list of lists of ints of length 2 where the first element is the key and the second element is the value and the key is unique and the key is sorted and the second element is unique and the second element is sorted\n    // TODO: check if list is not a list of lists of ints of length 2 where the first element is the key and the second element is the value and the key is unique and the key is sorted and the second element is unique and the second element is sorted and the second element is sorted in descending order\n    // TODO: check if list is not a list of lists of ints of length 2 where the first element is the key and the second element is the value and the key is unique and the key",
    "    var min_k_list [][]interface{}\n    var min_k_list_index []int\n    for i := 0; i < K; i++ {\n        min_k_list = append(min_k_list, test_list[i])\n        min_k_list_index = append(min_k_list_index, i)\n    }\n    for i := K; i < len(test_list); i++ {\n        for j := 0; j < len(min_k_list); j++ {\n            if test_list[i][1].(int) < min_k_list[j][1].(int) {\n                min_k_list[j] = test_list[i]\n                min_k_list_index[j] = i\n                break\n            }\n        }\n    }\n    return min_k_list\n}\n",
    "    if K >= len(test_list) {\n        return test_list\n    }\n    var min_k_list [][]interface{}\n    for i := 0; i < K; i++ {\n        min_k_list = append(min_k_list, test_list[i])\n    }\n    for i := K; i < len(test_list); i++ {\n        for j := 0; j < K; j++ {\n            if test_list[i][1].(int) < min_k_list[j][1].(int) {\n                min_k_list[j] = test_list[i]\n                break\n            }\n        }\n    }\n    return min_k_list\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    // sort the list\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if test_list[i][1].(int) > test_list[j][1].(int) {\n                test_list[i], test_list[j] = test_list[j], test_list[i]\n            }\n        }\n    }\n    return test_list[:K]\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    return test_list[:K]\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    var min_list [][]interface{}\n    for i := 0; i < K; i++ {\n        min_list = append(min_list, test_list[i])\n    }\n    for i := K; i < len(test_list); i++ {\n        for j := 0; j < K; j++ {\n            if test_list[i][1].(int) < min_list[j][1].(int) {\n                min_list[j] = test_list[i]\n                break\n            }\n        }\n    }\n    return min_list\n}\n",
    "    var result [][]interface{}\n    for _, v := range test_list {\n        if len(result) < K {\n            result = append(result, v)\n        } else {\n            for i, r := range result {\n                if v[1].(int) < r[1].(int) {\n                    result = append(result[:i], append([][]interface{}{v}, result[i:]...)...)\n                    result = result[:K]\n                    break\n                }\n            }\n        }\n    }\n    return result\n}\n",
    "    if len(test_list) < K {\n        return test_list\n    }\n    var result [][]interface{}\n    for i := 0; i < K; i++ {\n        result = append(result, test_list[i])\n    }\n    for i := K; i < len(test_list); i++ {\n        for j := 0; j < K; j++ {\n            if test_list[i][1].(int) < result[j][1].(int) {\n                result[j] = test_list[i]\n                break\n            }\n        }\n    }\n    return result\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n\n    // sort the list\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if test_list[i][0].(int) > test_list[j][0].(int) {\n                test_list[i], test_list[j] = test_list[j], test_list[i]\n            }\n        }\n    }\n\n    return test_list[:K]\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    return test_list[:K]\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return test_list\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    return test_list[:K]\n}\n",
    "    if len(test_list) < K {\n        return test_list\n    }\n    for i := 0; i < K; i++ {\n        for j := 0; j < len(test_list)-i-1; j++ {\n            if test_list[j][1].(int) > test_list[j+1][1].(int) {\n                test_list[j], test_list[j+1] = test_list[j+1], test_list[j]\n            }\n        }\n    }\n    return test_list[:K]\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    return test_list[:K]\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    return test_list[:K]\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    // TODO\n    return [][]interface{}{}\n}\n",
    "    if len(test_list) < K {\n        return test_list\n    }\n    // sort by first element\n    for i := 0; i < len(test_list); i++ {\n        for j := i; j < len(test_list); j++ {\n            if test_list[i][0].(int) > test_list[j][0].(int) {\n                test_list[i], test_list[j] = test_list[j], test_list[i]\n            }\n        }\n    }\n    return test_list[:K]\n}\n",
    "    if len(test_list) < K {\n        return test_list\n    }\n    return test_list[:K]\n}\n",
    "    if len(test_list) < K {\n        return test_list\n    }\n\n    min_k_list := make([][]interface{}, 0)\n    for i := 0; i < K; i++ {\n        min_k_list = append(min_k_list, test_list[i])\n    }\n\n    for i := K; i < len(test_list); i++ {\n        max_index := 0\n        for j := 0; j < K; j++ {\n            if test_list[i][1].(int) > min_k_list[j][1].(int) {\n                max_index = j\n            }\n        }\n        if test_list[i][1].(int) < min_k_list[max_index][1].(int) {\n            min_k_list[max_index] = test_list[i]\n        }\n    }\n\n    return min_k_list\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    if K <= 0 {\n        return [][]interface{}{}\n    }\n    if K >= len(test_list) {\n        return test_list\n    }\n    // sort by first element\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if test_list[i][0].(int) > test_list[j][0].(int) {\n                temp := test_list[i]\n                test_list[i] = test_list[j]\n                test_list[j] = temp\n            }\n        }\n    }\n    return test_list[:K]\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    var result [][]interface{}\n    for i := 0; i < K; i++ {\n        min_index := i\n        for j := i + 1; j < len(test_list); j++ {\n            if test_list[j][1].(int) < test_list[min_index][1].(int) {\n                min_index = j\n            }\n        }\n        result = append(result, test_list[min_index])\n        test_list[min_index], test_list[i] = test_list[i], test_list[min_index]\n    }\n    return result\n}\n",
    "    return nil\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    // sort the list\n    // return the first K elements\n    return test_list\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    return test_list[0:K]\n}\n",
    "    if len(test_list) < K {\n        return test_list\n    }\n    return test_list[:K]\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return test_list\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    // sort the list\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if test_list[i][1].(int) > test_list[j][1].(int) {\n                test_list[i], test_list[j] = test_list[j], test_list[i]\n            }\n        }\n    }\n    return test_list[:K]\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // sort the list\n    // return the first K records\n    return test_list[:K]\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    var min_k_list [][]interface{}\n    for i := 0; i < K; i++ {\n        min_k_list = append(min_k_list, test_list[i])\n    }\n    for i := K; i < len(test_list); i++ {\n        for j := 0; j < K; j++ {\n            if test_list[i][1].(int) < min_k_list[j][1].(int) {\n                min_k_list[j] = test_list[i]\n                break\n            }\n        }\n    }\n    return min_k_list\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    return test_list[:K]\n}\n",
    "    // sort the list by the first element of each tuple\n    // then return the first K elements\n    return test_list[:K]\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    if len(test_list) < K {\n        return test_list\n    }\n    var min_k_list [][]interface{}\n    for i := 0; i < K; i++ {\n        min_k_list = append(min_k_list, test_list[i])\n    }\n    for i := K; i < len(test_list); i++ {\n        for j := 0; j < K; j++ {\n            if test_list[i][1].(int) < min_k_list[j][1].(int) {\n                min_k_list[j] = test_list[i]\n                break\n            }\n        }\n    }\n    return min_k_list\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    return test_list[:K]\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    return test_list[:K]\n}\n",
    "    // TODO\n    return test_list\n}\n",
    "    // your code here\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    if K >= len(test_list) {\n        return test_list\n    }\n\n    // TODO: implement min_k\n    return test_list\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    var min_k_list [][]interface{}\n    for i := 0; i < K; i++ {\n        min_k_list = append(min_k_list, test_list[i])\n    }\n    for i := K; i < len(test_list); i++ {\n        for j := 0; j < K; j++ {\n            if test_list[i][1].(int) < min_k_list[j][1].(int) {\n                min_k_list[j] = test_list[i]\n                break\n            }\n        }\n    }\n    return min_k_list\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    if K == 0 {\n        return [][]interface{}{}\n    }\n    if K > len(test_list) {\n        return test_list\n    }\n    var result [][]interface{}\n    for i := 0; i < K; i++ {\n        result = append(result, test_list[i])\n    }\n    for i := K; i < len(test_list); i++ {\n        for j := 0; j < K; j++ {\n            if test_list[i][1].(int) < result[j][1].(int) {\n                result[j] = test_list[i]\n                break\n            }\n        }\n    }\n    return result\n}\n",
    "    if K == 0 {\n        return [][]interface{}{}\n    }\n    if K > len(test_list) {\n        return test_list\n    }\n    return test_list[:K]\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    return test_list[:K]\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // Sort the list by the first element in each tuple\n    // Then return the first K elements\n    // This is a simple O(n log n) solution\n    // A better solution would be to use a heap\n    // This would be O(n log k)\n    // But I don't want to write a heap right now\n    // So I'm going to do the simple solution\n    // And then I'm going to write a heap\n    // And then I'm going to write a test for the heap\n    // And then I'm going to write a test for the heap\n    // And then I'm going to write a test for the heap\n    // And then I'm going to write a test for the heap\n    // And then I'm going to write a test for the heap\n    // And then I'm going to write a test for the heap\n    // And then I'm going to write a test for the heap\n    // And then I'm going to write a test for the heap\n    // And then I'm going to write a test for the heap\n    // And then I'm going to write a test for the heap\n    // And then I'm going to write a test for the heap\n    // And then I'm going to write a test for the heap\n    // And then I'm going to write a test for the heap\n    // And then I'm going to write a test for the heap\n    // And then I'm going to write a test for the heap\n    // And then I'm going to write a test for the heap\n    // And then I'm going to write a test for the heap\n    // And then I'm going to write a test for the heap\n    // And then I'm going to write a test for the heap\n    // And then I'm going to write a test for the heap\n    // And then I'm going to write a test for the heap\n    // And then I'm going to write a test for the heap\n    // And then I'm going to write a test for the heap\n    // And then I'm going to write a test for the heap\n    // And then I'm going to write a test for the heap\n    // And then I'm going to write a test for the heap\n    // And then I'm going to write a test for the heap\n    // And then I'm going to",
    "    var result [][]interface{}\n    for i := 0; i < K; i++ {\n        min_index := i\n        for j := i + 1; j < len(test_list); j++ {\n            if test_list[j][1].(int) < test_list[min_index][1].(int) {\n                min_index = j\n            }\n        }\n        result = append(result, test_list[min_index])\n        test_list[min_index], test_list[i] = test_list[i], test_list[min_index]\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    for i := 0; i < K; i++ {\n        min_index := i\n        for j := i + 1; j < len(test_list); j++ {\n            if test_list[j][1].(int) < test_list[min_index][1].(int) {\n                min_index = j\n            }\n        }\n        result = append(result, test_list[min_index])\n        test_list[min_index] = test_list[i]\n        test_list[i] = result[i]\n    }\n    return result\n}\n",
    "    // sort the list by the first element of each tuple\n    // then return the first K elements\n    return test_list[:K]\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement this\n    return nil\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    var min_k_list [][]interface{}\n    for _, test_case := range test_list {\n        if len(min_k_list) < K {\n            min_k_list = append(min_k_list, test_case)\n        } else {\n            for i, min_k_case := range min_k_list {\n                if test_case[1].(int) < min_k_case[1].(int) {\n                    min_k_list[i] = test_case\n                    break\n                }\n            }\n        }\n    }\n    return min_k_list\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    if K == 0 {\n        return [][]interface{}{}\n    }\n    if K > len(test_list) {\n        return test_list\n    }\n    // sort the list by the first element of each tuple\n    var sorted_list [][]interface{}\n    for i := 0; i < len(test_list); i++ {\n        for j := i; j < len(test_list); j++ {\n            if test_list[i][0].(int) > test_list[j][0].(int) {\n                test_list[i], test_list[j] = test_list[j], test_list[i]\n            }\n        }\n    }\n    // return the first K elements of the sorted list\n    for i := 0; i < K; i++ {\n        sorted_list = append(sorted_list, test_list[i])\n    }\n    return sorted_list\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    var min_k_list [][]interface{}\n    for i := 0; i < K; i++ {\n        min_k_list = append(min_k_list, test_list[i])\n    }\n    for i := K; i < len(test_list); i++ {\n        for j := 0; j < K; j++ {\n            if test_list[i][1].(int) < min_k_list[j][1].(int) {\n                min_k_list[j] = test_list[i]\n                break\n            }\n        }\n    }\n    return min_k_list\n}\n",
    "    if len(test_list) < K {\n        return test_list\n    }\n    return test_list[:K]\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: Implement\n    return test_list\n}\n",
    "    var result [][]interface{}\n    for i := 0; i < K; i++ {\n        min_index := i\n        for j := i + 1; j < len(test_list); j++ {\n            if test_list[j][1].(int) < test_list[min_index][1].(int) {\n                min_index = j\n            }\n        }\n        result = append(result, test_list[min_index])\n        test_list[min_index], test_list[i] = test_list[i], test_list[min_index]\n    }\n    return result\n}\n",
    "    // TODO: implement\n    return test_list\n}\n",
    "    // TODO: Implement\n    return nil\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    var result [][]interface{}\n    for _, test := range test_list {\n        if len(result) < K {\n            result = append(result, test)\n        } else {\n            for i, r := range result {\n                if test[1].(int) < r[1].(int) {\n                    result = append(result[:i], append([][]interface{}{test}, result[i:]...)...)\n                    break\n                }\n            }\n        }\n    }\n    return result\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    if len(test_list) < K {\n        return test_list\n    }\n    var min_k_list [][]interface{}\n    for i := 0; i < K; i++ {\n        min_k_list = append(min_k_list, test_list[i])\n    }\n    for i := K; i < len(test_list); i++ {\n        for j := 0; j < K; j++ {\n            if test_list[i][1].(int) < min_k_list[j][1].(int) {\n                min_k_list[j] = test_list[i]\n                break\n            }\n        }\n    }\n    return min_k_list\n}\n",
    "    if len(test_list) < K {\n        return test_list\n    }\n\n    // sort the list\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if test_list[i][1].(int) > test_list[j][1].(int) {\n                test_list[i], test_list[j] = test_list[j], test_list[i]\n            }\n        }\n    }\n\n    return test_list[:K]\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    var min_k_list [][]interface{}\n    for i := 0; i < K; i++ {\n        min_k_list = append(min_k_list, test_list[i])\n    }\n    for i := K; i < len(test_list); i++ {\n        min_k_list = min_k_helper(min_k_list, test_list[i])\n    }\n    return min_k_list\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n"
  ]
}