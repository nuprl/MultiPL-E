{
  "name": "mbpp_753_min_k",
  "language": "go_test.go",
  "prompt": "package min_k_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find minimum k records from tuple list. https://www.geeksforgeeks.org/python-find-minimum-k-records-from-tuple-list/ - in this case a verbatim copy of test cases\nfunc min_k(test_list [][]interface{}, K int) [][]interface{} {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_753_min_k.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestMin_K(t *testing.T) {\n  candidate := min_k\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Manjeet\", 10}, []interface{}{\"Akshat\", 4}, []interface{}{\"Akash\", 2}, []interface{}{\"Nikhil\", 8}}, 2), expected: [][]int{[]interface{}{\"Akash\", 2}, []interface{}{\"Akshat\", 4}} },\n     { actual: candidate([][]int{[]interface{}{\"Sanjeev\", 11}, []interface{}{\"Angat\", 5}, []interface{}{\"Akash\", 3}, []interface{}{\"Nepin\", 9}}, 3), expected: [][]int{[]interface{}{\"Akash\", 3}, []interface{}{\"Angat\", 5}, []interface{}{\"Nepin\", 9}} },\n     { actual: candidate([][]int{[]interface{}{\"tanmay\", 14}, []interface{}{\"Amer\", 11}, []interface{}{\"Ayesha\", 9}, []interface{}{\"SKD\", 16}}, 1), expected: [][]int{[]interface{}{\"Ayesha\", 9}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // sort the list by the first element\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if test_list[i][0].(int) > test_list[j][0].(int) {\n                test_list[i], test_list[j] = test_list[j], test_list[i]\n            }\n        }\n    }\n    // return the first K elements\n    return test_list[:K]\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    // sort the list by the first item in the tuple\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if test_list[i][0].(int) > test_list[j][0].(int) {\n                test_list[i], test_list[j] = test_list[j], test_list[i]\n            }\n        }\n    }\n    return test_list[:K]\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    return test_list[:K]\n}\n",
    "    // Sort the list by the first element of each tuple\n    test_list = sort_by_first_element(test_list)\n\n    // Return the first k elements\n    return test_list[:K]\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    var min_k_list [][]interface{}\n    for i := 0; i < K; i++ {\n        min_k_list = append(min_k_list, test_list[i])\n    }\n    for i := K; i < len(test_list); i++ {\n        for j := 0; j < K; j++ {\n            if test_list[i][1].(int) < min_k_list[j][1].(int) {\n                min_k_list[j] = test_list[i]\n                break\n            }\n        }\n    }\n    return min_k_list\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    return test_list[:K]\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    return test_list[:K]\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    // TODO: implement\n    return [][]interface{}{}\n}\n",
    "    if K > len(test_list) {\n        return test_list\n    }\n    // sort the list by the first element of each sublist\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list) - 1; j++ {\n            if test_list[j][0].(int) > test_list[j + 1][0].(int) {\n                test_list[j], test_list[j + 1] = test_list[j + 1], test_list[j]\n            }\n        }\n    }\n    return test_list[:K]\n}\n",
    "    // your code here\n    return test_list\n}\n",
    "    var result [][]interface{}\n    for _, v := range test_list {\n        if len(result) < K {\n            result = append(result, v)\n        } else {\n            for i, v2 := range result {\n                if v[1].(int) < v2[1].(int) {\n                    result = append(result[:i], append([][]interface{}{v}, result[i:]...)...)\n                    break\n                }\n            }\n        }\n    }\n    return result\n}\n"
  ]
}