{
  "name": "mbpp_117_list_to_float",
  "language": "go_test.go",
  "prompt": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_117_list_to_float.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, row := range test_list {\n        for j, col := range row {\n            switch col.(type) {\n            case int:\n                test_list[i][j] = float64(col.(int))\n            case float64:\n                test_list[i][j] = col.(float64)\n            case string:\n                test_list[i][j] = float64(0)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzz3vvqto_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzz3vvqto_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzz3vvqto_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzz3vvqto_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzz3vvqto_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzz3vvqto_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzz3vvqto_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzz3vvqto_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzz3vvqto_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case int8:\n                test_list[i][j] = float64(test_list[i][j].(int8))\n            case int16:\n                test_list[i][j] = float64(test_list[i][j].(int16))\n            case int32:\n                test_list[i][j] = float64(test_list[i][j].(int32))\n            case int64:\n                test_list[i][j] = float64(test_list[i][j].(int64))\n            case uint:\n                test_list[i][j] = float64(test_list[i][j].(uint))\n            case uint8:\n                test_list[i][j] = float64(test_list[i][j].(uint8))\n            case uint16:\n                test_list[i][j] = float64(test_list[i][j].(uint16))\n            case uint32:\n                test_list[i][j] = float64(test_list[i][j].(uint32))\n            case uint64:\n                test_list[i][j] = float64(test_list[i][j].(uint64))\n            case float32:\n                test_list[i][j] = float64(test_list[i][j].(float32))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpz7jhbho5_test.go:50:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpz7jhbho5_test.go:50:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpz7jhbho5_test.go:50:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpz7jhbho5_test.go:51:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpz7jhbho5_test.go:51:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpz7jhbho5_test.go:51:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpz7jhbho5_test.go:52:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpz7jhbho5_test.go:52:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpz7jhbho5_test.go:52:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] == nil {\n                continue\n            }\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpznyr06lu_test.go:19:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpznyr06lu_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpznyr06lu_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:33:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpznyr06lu_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:34:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpznyr06lu_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:35:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:35:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := range test_list {\n        for j := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j]\n            case string:\n                test_list[i][j] = test_list[i][j]\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpm3m0tg33_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpm3m0tg33_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpm3m0tg33_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpm3m0tg33_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpm3m0tg33_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpm3m0tg33_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpm3m0tg33_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpm3m0tg33_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpm3m0tg33_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, sublist := range test_list {\n        var subresult []interface{}\n        for _, element := range sublist {\n            switch element.(type) {\n            case int:\n                subresult = append(subresult, float64(element.(int)))\n            case float64:\n                subresult = append(subresult, element.(float64))\n            default:\n                subresult = append(subresult, element)\n            }\n        }\n        result = append(result, subresult)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpag335w4i_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpag335w4i_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpag335w4i_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpag335w4i_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpag335w4i_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpag335w4i_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpag335w4i_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpag335w4i_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpag335w4i_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = float64(0)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpj5yj8kkv_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpj5yj8kkv_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj5yj8kkv_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj5yj8kkv_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpj5yj8kkv_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj5yj8kkv_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj5yj8kkv_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpj5yj8kkv_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj5yj8kkv_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, v := range test_list {\n        for j, k := range v {\n            switch k.(type) {\n            case int:\n                test_list[i][j] = float64(k.(int))\n            case float64:\n                test_list[i][j] = k.(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppgzpbune_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppgzpbune_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppgzpbune_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppgzpbune_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppgzpbune_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppgzpbune_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppgzpbune_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppgzpbune_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppgzpbune_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var new_list [][]interface{}\n    for _, sublist := range test_list {\n        var new_sublist []interface{}\n        for _, element := range sublist {\n            switch element.(type) {\n            case int:\n                new_sublist = append(new_sublist, float64(element.(int)))\n            case float64:\n                new_sublist = append(new_sublist, element.(float64))\n            default:\n                new_sublist = append(new_sublist, element)\n            }\n        }\n        new_list = append(new_list, new_sublist)\n    }\n    return new_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpscvb4sz9_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpscvb4sz9_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpscvb4sz9_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpscvb4sz9_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpscvb4sz9_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpscvb4sz9_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpscvb4sz9_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpscvb4sz9_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpscvb4sz9_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            default:\n                test_list[i][j] = \"Not a number\"\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7v_nt53k_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7v_nt53k_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7v_nt53k_test.go:34:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7v_nt53k_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7v_nt53k_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7v_nt53k_test.go:35:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7v_nt53k_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7v_nt53k_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7v_nt53k_test.go:36:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j], _ = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9ttlwge1_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9ttlwge1_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9ttlwge1_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9ttlwge1_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9ttlwge1_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9ttlwge1_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9ttlwge1_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9ttlwge1_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9ttlwge1_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j], _ = fmt.Sscanf(test_list[i][j].(string), \"%f\")\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuhxovrti_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpuhxovrti_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpuhxovrti_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpuhxovrti_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpuhxovrti_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpuhxovrti_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpuhxovrti_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpuhxovrti_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpuhxovrti_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, sub_list := range test_list {\n        var new_sub_list []interface{}\n        for _, element := range sub_list {\n            switch element.(type) {\n            case int:\n                new_sub_list = append(new_sub_list, float64(element.(int)))\n            case float64:\n                new_sub_list = append(new_sub_list, element.(float64))\n            case string:\n                if element.(string) == \"NaN\" {\n                    new_sub_list = append(new_sub_list, element.(string))\n                } else {\n                    new_sub_list = append(new_sub_list, element.(string))\n                }\n            default:\n                new_sub_list = append(new_sub_list, element)\n            }\n        }\n        result = append(result, new_sub_list)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0vd7brn4_test.go:41:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0vd7brn4_test.go:41:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0vd7brn4_test.go:41:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0vd7brn4_test.go:42:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0vd7brn4_test.go:42:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0vd7brn4_test.go:42:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0vd7brn4_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0vd7brn4_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0vd7brn4_test.go:43:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := range test_list {\n        for j := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp18grxj12_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmp18grxj12_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb23u8dgn_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = float64(0)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpj5yj8kkv_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpj5yj8kkv_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj5yj8kkv_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj5yj8kkv_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpj5yj8kkv_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj5yj8kkv_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj5yj8kkv_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpj5yj8kkv_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpj5yj8kkv_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            if test_list[i][j] == nil {\n                continue\n            }\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                continue\n            case string:\n                test_list[i][j] = nil\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcp1_c8rt_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcp1_c8rt_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcp1_c8rt_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcp1_c8rt_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcp1_c8rt_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcp1_c8rt_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcp1_c8rt_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcp1_c8rt_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcp1_c8rt_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            if val, ok := test_list[i][j].(float64); ok {\n                test_list[i][j] = val\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcjb4xf8d_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcjb4xf8d_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcjb4xf8d_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcjb4xf8d_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcjb4xf8d_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcjb4xf8d_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcjb4xf8d_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcjb4xf8d_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcjb4xf8d_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        var converted_list []interface{}\n        for _, element := range list {\n            switch element.(type) {\n            case int:\n                converted_list = append(converted_list, float64(element.(int)))\n            case float64:\n                converted_list = append(converted_list, element.(float64))\n            default:\n                converted_list = append(converted_list, element)\n            }\n        }\n        result = append(result, converted_list)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbqdl1f7r_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbqdl1f7r_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbqdl1f7r_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbqdl1f7r_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbqdl1f7r_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbqdl1f7r_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbqdl1f7r_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbqdl1f7r_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbqdl1f7r_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = 0\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpng5yu78u_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpng5yu78u_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpng5yu78u_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpng5yu78u_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpng5yu78u_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpng5yu78u_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpng5yu78u_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpng5yu78u_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpng5yu78u_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case int8:\n                test_list[i][j] = float64(test_list[i][j].(int8))\n            case int16:\n                test_list[i][j] = float64(test_list[i][j].(int16))\n            case int32:\n                test_list[i][j] = float64(test_list[i][j].(int32))\n            case int64:\n                test_list[i][j] = float64(test_list[i][j].(int64))\n            case uint:\n                test_list[i][j] = float64(test_list[i][j].(uint))\n            case uint8:\n                test_list[i][j] = float64(test_list[i][j].(uint8))\n            case uint16:\n                test_list[i][j] = float64(test_list[i][j].(uint16))\n            case uint32:\n                test_list[i][j] = float64(test_list[i][j].(uint32))\n            case uint64:\n                test_list[i][j] = float64(test_list[i][j].(uint64))\n            case float32:\n                test_list[i][j] = float64(test_list[i][j].(float32))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsmxn4q77_test.go:50:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpsmxn4q77_test.go:50:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsmxn4q77_test.go:50:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsmxn4q77_test.go:51:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpsmxn4q77_test.go:51:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsmxn4q77_test.go:51:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsmxn4q77_test.go:52:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpsmxn4q77_test.go:52:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsmxn4q77_test.go:52:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb23u8dgn_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        var new_list []interface{}\n        for _, item := range list {\n            switch item.(type) {\n            case int:\n                new_list = append(new_list, float64(item.(int)))\n            case float64:\n                new_list = append(new_list, item.(float64))\n            case string:\n                new_list = append(new_list, item.(string))\n            }\n        }\n        result = append(result, new_list)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptzlfptb2_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptzlfptb2_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptzlfptb2_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptzlfptb2_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptzlfptb2_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptzlfptb2_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptzlfptb2_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptzlfptb2_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptzlfptb2_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j], _ = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9ttlwge1_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9ttlwge1_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9ttlwge1_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9ttlwge1_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9ttlwge1_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9ttlwge1_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9ttlwge1_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9ttlwge1_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9ttlwge1_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            if test_list[i][j] != nil {\n                switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case float64:\n                    test_list[i][j] = test_list[i][j].(float64)\n                case string:\n                    test_list[i][j], _ = fmt.Sscanf(test_list[i][j].(string), \"%f\", &test_list[i][j])\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4pge_ze4_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4pge_ze4_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4pge_ze4_test.go:34:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4pge_ze4_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4pge_ze4_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4pge_ze4_test.go:35:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4pge_ze4_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4pge_ze4_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4pge_ze4_test.go:36:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = 0.0\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptj_pjscp_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptj_pjscp_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptj_pjscp_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptj_pjscp_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptj_pjscp_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptj_pjscp_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptj_pjscp_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptj_pjscp_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptj_pjscp_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] != nil {\n                switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case string:\n                    test_list[i][j] = float64(test_list[i][j].(string))\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk8iv6jp__test.go:17:46: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpk8iv6jp__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk8iv6jp__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk8iv6jp__test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk8iv6jp__test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:34:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, sublist := range test_list {\n        var new_sublist []interface{}\n        for _, element := range sublist {\n            switch element.(type) {\n            case int:\n                new_sublist = append(new_sublist, float64(element.(int)))\n            case float64:\n                new_sublist = append(new_sublist, element.(float64))\n            default:\n                new_sublist = append(new_sublist, element)\n            }\n        }\n        result = append(result, new_sublist)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp261lel6d_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp261lel6d_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp261lel6d_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp261lel6d_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqjladslw_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqjladslw_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqjladslw_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqjladslw_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqjladslw_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqjladslw_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqjladslw_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqjladslw_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqjladslw_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] == nil {\n                continue\n            }\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                continue\n            case string:\n                if test_list[i][j] == \"\" {\n                    continue\n                }\n                test_list[i][j] = float64(test_list[i][j].(string))\n            default:\n                continue\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqll5rszf_test.go:24:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpqll5rszf_test.go:40:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqll5rszf_test.go:40:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqll5rszf_test.go:40:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqll5rszf_test.go:41:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqll5rszf_test.go:41:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqll5rszf_test.go:41:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqll5rszf_test.go:42:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqll5rszf_test.go:42:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqll5rszf_test.go:42:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqll5rszf_test.go:42:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = 0.0\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptj_pjscp_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptj_pjscp_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptj_pjscp_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptj_pjscp_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptj_pjscp_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptj_pjscp_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptj_pjscp_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptj_pjscp_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptj_pjscp_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            if test_list[i][j] == nil {\n                continue\n            }\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                continue\n            case string:\n                test_list[i][j] = nil\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcp1_c8rt_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcp1_c8rt_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcp1_c8rt_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcp1_c8rt_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcp1_c8rt_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcp1_c8rt_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcp1_c8rt_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcp1_c8rt_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcp1_c8rt_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(len(test_list[i][j].(string)))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzkrsp_v5_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzkrsp_v5_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzkrsp_v5_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzkrsp_v5_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzkrsp_v5_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzkrsp_v5_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzkrsp_v5_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzkrsp_v5_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzkrsp_v5_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for _, list := range test_list {\n        for i, element := range list {\n            if value, ok := element.(int); ok {\n                list[i] = float64(value)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3zny3mqj_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3zny3mqj_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3zny3mqj_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3zny3mqj_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3zny3mqj_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3zny3mqj_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3zny3mqj_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3zny3mqj_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3zny3mqj_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            default:\n                fmt.Println(\"Unsupported type\")\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6sln7wfn_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6sln7wfn_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6sln7wfn_test.go:34:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6sln7wfn_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6sln7wfn_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6sln7wfn_test.go:35:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6sln7wfn_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6sln7wfn_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6sln7wfn_test.go:36:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if v, ok := test_list[i][j].(int); ok {\n                test_list[i][j] = float64(v)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbv06aj4p_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbv06aj4p_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbv06aj4p_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbv06aj4p_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbv06aj4p_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbv06aj4p_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbv06aj4p_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbv06aj4p_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbv06aj4p_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if _, ok := test_list[i][j].(float64); !ok {\n                if _, ok := test_list[i][j].(int); ok {\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5k8tpwhr_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5k8tpwhr_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5k8tpwhr_test.go:29:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5k8tpwhr_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5k8tpwhr_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5k8tpwhr_test.go:30:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5k8tpwhr_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5k8tpwhr_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5k8tpwhr_test.go:31:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, row := range test_list {\n        for j, col := range row {\n            switch col.(type) {\n            case int:\n                test_list[i][j] = float64(col.(int))\n            case float64:\n                test_list[i][j] = col.(float64)\n            case string:\n                if col.(string) == \"nan\" {\n                    test_list[i][j] = col.(string)\n                } else {\n                    fmt.Println(\"Error: string not convertible to float\")\n                }\n            default:\n                fmt.Println(\"Error: type not convertible to float\")\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8r8jml6d_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8r8jml6d_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8r8jml6d_test.go:38:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8r8jml6d_test.go:39:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8r8jml6d_test.go:39:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8r8jml6d_test.go:39:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8r8jml6d_test.go:40:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8r8jml6d_test.go:40:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8r8jml6d_test.go:40:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] == nil {\n                continue\n            }\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            default:\n                test_list[i][j] = nil\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp00yh_s6t_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp00yh_s6t_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp00yh_s6t_test.go:37:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp00yh_s6t_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp00yh_s6t_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp00yh_s6t_test.go:38:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp00yh_s6t_test.go:39:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp00yh_s6t_test.go:39:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp00yh_s6t_test.go:39:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = 0\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpng5yu78u_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpng5yu78u_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpng5yu78u_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpng5yu78u_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpng5yu78u_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpng5yu78u_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpng5yu78u_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpng5yu78u_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpng5yu78u_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            if test_list[i][j] != nil {\n                switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case int8:\n                    test_list[i][j] = float64(test_list[i][j].(int8))\n                case int16:\n                    test_list[i][j] = float64(test_list[i][j].(int16))\n                case int32:\n                    test_list[i][j] = float64(test_list[i][j].(int32))\n                case int64:\n                    test_list[i][j] = float64(test_list[i][j].(int64))\n                case uint:\n                    test_list[i][j] = float64(test_list[i][j].(uint))\n                case uint8:\n                    test_list[i][j] = float64(test_list[i][j].(uint8))\n                case uint16:\n                    test_list[i][j] = float64(test_list[i][j].(uint16))\n                case uint32:\n                    test_list[i][j] = float64(test_list[i][j].(uint32))\n                case uint64:\n                    test_list[i][j] = float64(test_list[i][j].(uint64))\n                case float32:\n                    test_list[i][j] = float64(test_list[i][j].(float32))\n                case float64:\n                    test_list[i][j] = test_list[i][j].(float64)\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqejy54hn_test.go:52:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqejy54hn_test.go:52:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqejy54hn_test.go:52:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqejy54hn_test.go:53:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqejy54hn_test.go:53:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqejy54hn_test.go:53:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqejy54hn_test.go:54:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqejy54hn_test.go:54:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqejy54hn_test.go:54:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := range test_list {\n        for j := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp18grxj12_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmp18grxj12_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb23u8dgn_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpihgbf1ye_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j]\n            case string:\n                test_list[i][j] = test_list[i][j]\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpivyu7t9q_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpivyu7t9q_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpivyu7t9q_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpivyu7t9q_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpivyu7t9q_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpivyu7t9q_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpivyu7t9q_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpivyu7t9q_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpivyu7t9q_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8yalo1a__test.go:18:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmp8yalo1a__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8yalo1a__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8yalo1a__test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8yalo1a__test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8yalo1a__test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8yalo1a__test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8yalo1a__test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8yalo1a__test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8yalo1a__test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8yalo1a__test.go:34:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpihgbf1ye_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, sublist := range test_list {\n        var new_sublist []interface{}\n        for _, item := range sublist {\n            switch item.(type) {\n            case int:\n                new_sublist = append(new_sublist, float64(item.(int)))\n            case float64:\n                new_sublist = append(new_sublist, item.(float64))\n            default:\n                new_sublist = append(new_sublist, item)\n            }\n        }\n        result = append(result, new_sublist)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplmhp3ug6_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplmhp3ug6_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplmhp3ug6_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplmhp3ug6_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplmhp3ug6_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplmhp3ug6_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplmhp3ug6_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplmhp3ug6_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplmhp3ug6_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := range test_list {\n        for j := range test_list[i] {\n            if test_list[i][j] != nil {\n                switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case string:\n                    test_list[i][j] = nil\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgn_rgzqm_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgn_rgzqm_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgn_rgzqm_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgn_rgzqm_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgn_rgzqm_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgn_rgzqm_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgn_rgzqm_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgn_rgzqm_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgn_rgzqm_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqjladslw_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqjladslw_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqjladslw_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqjladslw_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqjladslw_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqjladslw_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqjladslw_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqjladslw_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqjladslw_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, sublist := range test_list {\n        var new_sublist []interface{}\n        for _, item := range sublist {\n            switch item.(type) {\n            case int:\n                new_sublist = append(new_sublist, float64(item.(int)))\n            case string:\n                new_sublist = append(new_sublist, item)\n            case float64:\n                new_sublist = append(new_sublist, item)\n            }\n        }\n        result = append(result, new_sublist)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoh1gz1dv_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpoh1gz1dv_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoh1gz1dv_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoh1gz1dv_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpoh1gz1dv_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoh1gz1dv_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoh1gz1dv_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpoh1gz1dv_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoh1gz1dv_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb23u8dgn_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpihgbf1ye_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for _, list := range test_list {\n        for i, item := range list {\n            if item_float, ok := item.(float64); ok {\n                list[i] = item_float\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjb5za7w2_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpjb5za7w2_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpjb5za7w2_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpjb5za7w2_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpjb5za7w2_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpjb5za7w2_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpjb5za7w2_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpjb5za7w2_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpjb5za7w2_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := range test_list {\n        for j := range test_list[i] {\n            if v, ok := test_list[i][j].(int); ok {\n                test_list[i][j] = float64(v)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfzh8584e_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfzh8584e_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfzh8584e_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfzh8584e_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfzh8584e_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfzh8584e_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfzh8584e_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfzh8584e_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfzh8584e_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] == nil {\n                continue\n            }\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpznyr06lu_test.go:19:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpznyr06lu_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpznyr06lu_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:33:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpznyr06lu_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:34:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpznyr06lu_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:35:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:35:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            if v, ok := test_list[i][j].(float64); ok {\n                test_list[i][j] = v\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeyu_8tvi_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeyu_8tvi_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeyu_8tvi_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeyu_8tvi_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeyu_8tvi_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeyu_8tvi_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeyu_8tvi_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpeyu_8tvi_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpeyu_8tvi_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case int8:\n                test_list[i][j] = float64(test_list[i][j].(int8))\n            case int16:\n                test_list[i][j] = float64(test_list[i][j].(int16))\n            case int32:\n                test_list[i][j] = float64(test_list[i][j].(int32))\n            case int64:\n                test_list[i][j] = float64(test_list[i][j].(int64))\n            case uint:\n                test_list[i][j] = float64(test_list[i][j].(uint))\n            case uint8:\n                test_list[i][j] = float64(test_list[i][j].(uint8))\n            case uint16:\n                test_list[i][j] = float64(test_list[i][j].(uint16))\n            case uint32:\n                test_list[i][j] = float64(test_list[i][j].(uint32))\n            case uint64:\n                test_list[i][j] = float64(test_list[i][j].(uint64))\n            case float32:\n                test_list[i][j] = float64(test_list[i][j].(float32))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsmxn4q77_test.go:50:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpsmxn4q77_test.go:50:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsmxn4q77_test.go:50:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsmxn4q77_test.go:51:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpsmxn4q77_test.go:51:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsmxn4q77_test.go:51:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsmxn4q77_test.go:52:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpsmxn4q77_test.go:52:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsmxn4q77_test.go:52:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j], _ = fmt.Printf(\"%f\", test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb5ypjoy5_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb5ypjoy5_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb5ypjoy5_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb5ypjoy5_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb5ypjoy5_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb5ypjoy5_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb5ypjoy5_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb5ypjoy5_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb5ypjoy5_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] == nil {\n                continue\n            }\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                continue\n            case string:\n                continue\n            default:\n                fmt.Println(\"Unknown type\")\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpglc64p7d_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpglc64p7d_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpglc64p7d_test.go:37:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpglc64p7d_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpglc64p7d_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpglc64p7d_test.go:38:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpglc64p7d_test.go:39:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpglc64p7d_test.go:39:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpglc64p7d_test.go:39:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case int8:\n                test_list[i][j] = float64(test_list[i][j].(int8))\n            case int16:\n                test_list[i][j] = float64(test_list[i][j].(int16))\n            case int32:\n                test_list[i][j] = float64(test_list[i][j].(int32))\n            case int64:\n                test_list[i][j] = float64(test_list[i][j].(int64))\n            case uint:\n                test_list[i][j] = float64(test_list[i][j].(uint))\n            case uint8:\n                test_list[i][j] = float64(test_list[i][j].(uint8))\n            case uint16:\n                test_list[i][j] = float64(test_list[i][j].(uint16))\n            case uint32:\n                test_list[i][j] = float64(test_list[i][j].(uint32))\n            case uint64:\n                test_list[i][j] = float64(test_list[i][j].(uint64))\n            case float32:\n                test_list[i][j] = float64(test_list[i][j].(float32))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_l_jgujs_test.go:48:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_l_jgujs_test.go:48:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_l_jgujs_test.go:48:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_l_jgujs_test.go:49:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_l_jgujs_test.go:49:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_l_jgujs_test.go:49:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_l_jgujs_test.go:50:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_l_jgujs_test.go:50:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_l_jgujs_test.go:50:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            if test_list[i][j] != nil {\n                switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case int8:\n                    test_list[i][j] = float64(test_list[i][j].(int8))\n                case int16:\n                    test_list[i][j] = float64(test_list[i][j].(int16))\n                case int32:\n                    test_list[i][j] = float64(test_list[i][j].(int32))\n                case int64:\n                    test_list[i][j] = float64(test_list[i][j].(int64))\n                case uint:\n                    test_list[i][j] = float64(test_list[i][j].(uint))\n                case uint8:\n                    test_list[i][j] = float64(test_list[i][j].(uint8))\n                case uint16:\n                    test_list[i][j] = float64(test_list[i][j].(uint16))\n                case uint32:\n                    test_list[i][j] = float64(test_list[i][j].(uint32))\n                case uint64:\n                    test_list[i][j] = float64(test_list[i][j].(uint64))\n                case float32:\n                    test_list[i][j] = float64(test_list[i][j].(float32))\n                case float64:\n                    test_list[i][j] = test_list[i][j].(float64)\n                case string:\n                    test_list[i][j] = nil\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzvee__tb_test.go:54:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzvee__tb_test.go:54:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzvee__tb_test.go:54:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzvee__tb_test.go:55:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzvee__tb_test.go:55:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzvee__tb_test.go:55:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzvee__tb_test.go:56:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzvee__tb_test.go:56:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzvee__tb_test.go:56:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            if val, ok := test_list[i][j].(int); ok {\n                test_list[i][j] = float64(val)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123998,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvdthcpl3_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvdthcpl3_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvdthcpl3_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvdthcpl3_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvdthcpl3_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvdthcpl3_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvdthcpl3_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvdthcpl3_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvdthcpl3_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb23u8dgn_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        var new_list []interface{}\n        for _, element := range list {\n            switch element.(type) {\n            case int:\n                new_list = append(new_list, float64(element.(int)))\n            case float64:\n                new_list = append(new_list, element.(float64))\n            case string:\n                new_list = append(new_list, element.(string))\n            }\n        }\n        result = append(result, new_list)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzgq91ql9_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzgq91ql9_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzgq91ql9_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzgq91ql9_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzgq91ql9_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzgq91ql9_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzgq91ql9_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzgq91ql9_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzgq91ql9_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] == nil {\n                continue\n            }\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpznyr06lu_test.go:19:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpznyr06lu_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpznyr06lu_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:33:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpznyr06lu_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:34:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpznyr06lu_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:35:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:35:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpihgbf1ye_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = float64(0)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxsevv5fk_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxsevv5fk_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxsevv5fk_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxsevv5fk_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxsevv5fk_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxsevv5fk_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxsevv5fk_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxsevv5fk_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxsevv5fk_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if v, ok := test_list[i][j].(float64); ok {\n                test_list[i][j] = v\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprzv3b7pp_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprzv3b7pp_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprzv3b7pp_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprzv3b7pp_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            if test_list[i][j] == nil {\n                continue\n            }\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                continue\n            case string:\n                test_list[i][j] = nil\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcp1_c8rt_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcp1_c8rt_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcp1_c8rt_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcp1_c8rt_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcp1_c8rt_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcp1_c8rt_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcp1_c8rt_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcp1_c8rt_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcp1_c8rt_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, sublist := range test_list {\n        var new_sublist []interface{}\n        for _, element := range sublist {\n            switch element.(type) {\n            case int:\n                new_sublist = append(new_sublist, float64(element.(int)))\n            case float64:\n                new_sublist = append(new_sublist, element.(float64))\n            default:\n                new_sublist = append(new_sublist, element)\n            }\n        }\n        result = append(result, new_sublist)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp261lel6d_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp261lel6d_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp261lel6d_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp261lel6d_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := range test_list {\n        for j := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp18grxj12_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmp18grxj12_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := range test_list {\n        for j := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = float64(0)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123998,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp67tqhe7q_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp67tqhe7q_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp67tqhe7q_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp67tqhe7q_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp67tqhe7q_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp67tqhe7q_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp67tqhe7q_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp67tqhe7q_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp67tqhe7q_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            default:\n                fmt.Println(\"Error: Invalid type\")\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123998,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk30cxvpw_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk30cxvpw_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk30cxvpw_test.go:34:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk30cxvpw_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk30cxvpw_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk30cxvpw_test.go:35:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk30cxvpw_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk30cxvpw_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk30cxvpw_test.go:36:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpihgbf1ye_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j]\n            case string:\n                test_list[i][j] = test_list[i][j]\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123998,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpurh4mfx5_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpurh4mfx5_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpurh4mfx5_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpurh4mfx5_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpurh4mfx5_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpurh4mfx5_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpurh4mfx5_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpurh4mfx5_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpurh4mfx5_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j], _ = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9ttlwge1_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9ttlwge1_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9ttlwge1_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9ttlwge1_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9ttlwge1_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9ttlwge1_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9ttlwge1_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9ttlwge1_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9ttlwge1_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if val, ok := test_list[i][j].(int); ok {\n                test_list[i][j] = float64(val)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsll1gi51_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpsll1gi51_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsll1gi51_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsll1gi51_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpsll1gi51_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsll1gi51_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsll1gi51_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpsll1gi51_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsll1gi51_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if val, ok := test_list[i][j].(float64); ok {\n                test_list[i][j] = val\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph611d4cu_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph611d4cu_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph611d4cu_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph611d4cu_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            if test_list[i][j] == nil {\n                continue\n            }\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            case float64:\n                continue\n            default:\n                test_list[i][j] = nil\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123998,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx0hlcb7j_test.go:19:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpx0hlcb7j_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx0hlcb7j_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx0hlcb7j_test.go:37:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx0hlcb7j_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx0hlcb7j_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx0hlcb7j_test.go:38:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx0hlcb7j_test.go:39:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx0hlcb7j_test.go:39:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx0hlcb7j_test.go:39:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx0hlcb7j_test.go:39:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            if value, ok := test_list[i][j].(float64); ok {\n                test_list[i][j] = value\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123998,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpenxssx1q_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpenxssx1q_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpenxssx1q_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpenxssx1q_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpenxssx1q_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpenxssx1q_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpenxssx1q_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpenxssx1q_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpenxssx1q_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            if test_list[i][j] == nil {\n                continue\n            }\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case int8:\n                test_list[i][j] = float64(test_list[i][j].(int8))\n            case int16:\n                test_list[i][j] = float64(test_list[i][j].(int16))\n            case int32:\n                test_list[i][j] = float64(test_list[i][j].(int32))\n            case int64:\n                test_list[i][j] = float64(test_list[i][j].(int64))\n            case uint:\n                test_list[i][j] = float64(test_list[i][j].(uint))\n            case uint8:\n                test_list[i][j] = float64(test_list[i][j].(uint8))\n            case uint16:\n                test_list[i][j] = float64(test_list[i][j].(uint16))\n            case uint32:\n                test_list[i][j] = float64(test_list[i][j].(uint32))\n            case uint64:\n                test_list[i][j] = float64(test_list[i][j].(uint64))\n            case float32:\n                test_list[i][j] = float64(test_list[i][j].(float32))\n            case float64:\n                test_list[i][j] = float64(test_list[i][j].(float64))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123998,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7wl36nee_test.go:53:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7wl36nee_test.go:53:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7wl36nee_test.go:53:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7wl36nee_test.go:54:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7wl36nee_test.go:54:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7wl36nee_test.go:54:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7wl36nee_test.go:55:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7wl36nee_test.go:55:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7wl36nee_test.go:55:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := range test_list {\n        for j := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp18grxj12_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmp18grxj12_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            if test_list[i][j] == nil {\n                continue\n            }\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp41k9b7tg_test.go:19:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmp41k9b7tg_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp41k9b7tg_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp41k9b7tg_test.go:33:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp41k9b7tg_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp41k9b7tg_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp41k9b7tg_test.go:34:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp41k9b7tg_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp41k9b7tg_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp41k9b7tg_test.go:35:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp41k9b7tg_test.go:35:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                if test_list[i][j].(string) == \"NaN\" {\n                    test_list[i][j] = float64(0)\n                } else {\n                    test_list[i][j] = float64(0)\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph3aigu2__test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph3aigu2__test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph3aigu2__test.go:34:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph3aigu2__test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph3aigu2__test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph3aigu2__test.go:35:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph3aigu2__test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph3aigu2__test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph3aigu2__test.go:36:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] != nil {\n                switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case float64:\n                    test_list[i][j] = test_list[i][j].(float64)\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123998,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2hhh80pl_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2hhh80pl_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2hhh80pl_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2hhh80pl_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2hhh80pl_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2hhh80pl_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2hhh80pl_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2hhh80pl_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2hhh80pl_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case int8:\n                test_list[i][j] = float64(test_list[i][j].(int8))\n            case int16:\n                test_list[i][j] = float64(test_list[i][j].(int16))\n            case int32:\n                test_list[i][j] = float64(test_list[i][j].(int32))\n            case int64:\n                test_list[i][j] = float64(test_list[i][j].(int64))\n            case uint:\n                test_list[i][j] = float64(test_list[i][j].(uint))\n            case uint8:\n                test_list[i][j] = float64(test_list[i][j].(uint8))\n            case uint16:\n                test_list[i][j] = float64(test_list[i][j].(uint16))\n            case uint32:\n                test_list[i][j] = float64(test_list[i][j].(uint32))\n            case uint64:\n                test_list[i][j] = float64(test_list[i][j].(uint64))\n            case float32:\n                test_list[i][j] = float64(test_list[i][j].(float32))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsmxn4q77_test.go:50:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpsmxn4q77_test.go:50:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsmxn4q77_test.go:50:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsmxn4q77_test.go:51:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpsmxn4q77_test.go:51:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsmxn4q77_test.go:51:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsmxn4q77_test.go:52:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpsmxn4q77_test.go:52:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsmxn4q77_test.go:52:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, sub_list := range test_list {\n        var temp []interface{}\n        for _, element := range sub_list {\n            switch element.(type) {\n            case int:\n                temp = append(temp, float64(element.(int)))\n            case float64:\n                temp = append(temp, element)\n            default:\n                temp = append(temp, element)\n            }\n        }\n        result = append(result, temp)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123998,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdc2ml7wr_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdc2ml7wr_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdc2ml7wr_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdc2ml7wr_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdc2ml7wr_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdc2ml7wr_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdc2ml7wr_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdc2ml7wr_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdc2ml7wr_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if val, ok := test_list[i][j].(float64); ok {\n                test_list[i][j] = val\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph611d4cu_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph611d4cu_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph611d4cu_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph611d4cu_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            default:\n                fmt.Println(\"Error: Unsupported type!\")\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123998,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1bu28eqr_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1bu28eqr_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1bu28eqr_test.go:34:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1bu28eqr_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1bu28eqr_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1bu28eqr_test.go:35:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1bu28eqr_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1bu28eqr_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1bu28eqr_test.go:36:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, v := range test_list {\n        for j, k := range v {\n            switch k.(type) {\n            case int:\n                test_list[i][j] = float64(k.(int))\n            case float64:\n                test_list[i][j] = k.(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppgzpbune_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppgzpbune_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppgzpbune_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppgzpbune_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppgzpbune_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppgzpbune_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppgzpbune_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppgzpbune_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppgzpbune_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb23u8dgn_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] == nil {\n                continue\n            }\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case int8:\n                test_list[i][j] = float64(test_list[i][j].(int8))\n            case int16:\n                test_list[i][j] = float64(test_list[i][j].(int16))\n            case int32:\n                test_list[i][j] = float64(test_list[i][j].(int32))\n            case int64:\n                test_list[i][j] = float64(test_list[i][j].(int64))\n            case uint:\n                test_list[i][j] = float64(test_list[i][j].(uint))\n            case uint8:\n                test_list[i][j] = float64(test_list[i][j].(uint8))\n            case uint16:\n                test_list[i][j] = float64(test_list[i][j].(uint16))\n            case uint32:\n                test_list[i][j] = float64(test_list[i][j].(uint32))\n            case uint64:\n                test_list[i][j] = float64(test_list[i][j].(uint64))\n            case float32:\n                test_list[i][j] = float64(test_list[i][j].(float32))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123998,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4v2d8w0k_test.go:53:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4v2d8w0k_test.go:53:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4v2d8w0k_test.go:53:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4v2d8w0k_test.go:54:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4v2d8w0k_test.go:54:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4v2d8w0k_test.go:54:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4v2d8w0k_test.go:55:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp4v2d8w0k_test.go:55:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp4v2d8w0k_test.go:55:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if v, ok := test_list[i][j].(float64); ok {\n                test_list[i][j] = v\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprzv3b7pp_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprzv3b7pp_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprzv3b7pp_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprzv3b7pp_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j], _ = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123998,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpocr7nwuy_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpocr7nwuy_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpocr7nwuy_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpocr7nwuy_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpocr7nwuy_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpocr7nwuy_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpocr7nwuy_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpocr7nwuy_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpocr7nwuy_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j], _ = fmt.Sscanf(test_list[i][j].(string), \"%f\")\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuhxovrti_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpuhxovrti_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpuhxovrti_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpuhxovrti_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpuhxovrti_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpuhxovrti_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpuhxovrti_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpuhxovrti_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpuhxovrti_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpihgbf1ye_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb23u8dgn_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb23u8dgn_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa86yu58q_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpa86yu58q_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpa86yu58q_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpa86yu58q_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if value, ok := test_list[i][j].(int); ok {\n                test_list[i][j] = float64(value)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123998,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp89v8fb0d_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp89v8fb0d_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp89v8fb0d_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp89v8fb0d_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp89v8fb0d_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp89v8fb0d_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp89v8fb0d_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp89v8fb0d_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp89v8fb0d_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = float64(test_list[i][j].(float64))\n            case string:\n                fmt.Println(\"String\")\n            default:\n                fmt.Println(\"Default\")\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123998,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplm2egy7z_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplm2egy7z_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplm2egy7z_test.go:34:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplm2egy7z_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplm2egy7z_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplm2egy7z_test.go:35:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplm2egy7z_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplm2egy7z_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplm2egy7z_test.go:36:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] != nil {\n                switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case int8:\n                    test_list[i][j] = float64(test_list[i][j].(int8))\n                case int16:\n                    test_list[i][j] = float64(test_list[i][j].(int16))\n                case int32:\n                    test_list[i][j] = float64(test_list[i][j].(int32))\n                case int64:\n                    test_list[i][j] = float64(test_list[i][j].(int64))\n                case uint:\n                    test_list[i][j] = float64(test_list[i][j].(uint))\n                case uint8:\n                    test_list[i][j] = float64(test_list[i][j].(uint8))\n                case uint16:\n                    test_list[i][j] = float64(test_list[i][j].(uint16))\n                case uint32:\n                    test_list[i][j] = float64(test_list[i][j].(uint32))\n                case uint64:\n                    test_list[i][j] = float64(test_list[i][j].(uint64))\n                case float32:\n                    test_list[i][j] = float64(test_list[i][j].(float32))\n                case float64:\n                    test_list[i][j] = test_list[i][j].(float64)\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123998,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzoqqrny2_test.go:52:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzoqqrny2_test.go:52:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzoqqrny2_test.go:52:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzoqqrny2_test.go:53:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzoqqrny2_test.go:53:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzoqqrny2_test.go:53:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzoqqrny2_test.go:54:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzoqqrny2_test.go:54:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzoqqrny2_test.go:54:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := range test_list {\n        for j := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp18grxj12_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmp18grxj12_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            if test_list[i][j] == nil {\n                continue\n            }\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                continue\n            case string:\n                test_list[i][j] = nil\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcp1_c8rt_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcp1_c8rt_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcp1_c8rt_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcp1_c8rt_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcp1_c8rt_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcp1_c8rt_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcp1_c8rt_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcp1_c8rt_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcp1_c8rt_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb23u8dgn_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb23u8dgn_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = float64(test_list[i][j].(float64))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123998,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpf4q5uk6t_test.go:18:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpf4q5uk6t_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpf4q5uk6t_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpf4q5uk6t_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpf4q5uk6t_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpf4q5uk6t_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpf4q5uk6t_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpf4q5uk6t_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpf4q5uk6t_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpf4q5uk6t_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpf4q5uk6t_test.go:34:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if _, ok := test_list[i][j].(float64); ok {\n                continue\n            }\n            if _, ok := test_list[i][j].(int); ok {\n                test_list[i][j] = float64(test_list[i][j].(int))\n                continue\n            }\n            if _, ok := test_list[i][j].(string); ok {\n                if _, err := fmt.Sscan(test_list[i][j].(string), &test_list[i][j]); err == nil {\n                    test_list[i][j] = float64(test_list[i][j].(float64))\n                    continue\n                }\n            }\n            test_list[i][j] = nil\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123998,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy2z5dmms_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpy2z5dmms_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpy2z5dmms_test.go:38:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpy2z5dmms_test.go:39:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpy2z5dmms_test.go:39:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpy2z5dmms_test.go:39:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpy2z5dmms_test.go:40:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpy2z5dmms_test.go:40:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpy2z5dmms_test.go:40:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpihgbf1ye_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] != nil {\n                switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case string:\n                    if test_list[i][j].(string) == \"\" {\n                        test_list[i][j] = nil\n                    } else {\n                        test_list[i][j] = float64(test_list[i][j].(string))\n                    }\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123998,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu_1lwd6b_test.go:20:50: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpu_1lwd6b_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu_1lwd6b_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu_1lwd6b_test.go:36:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu_1lwd6b_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu_1lwd6b_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu_1lwd6b_test.go:37:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu_1lwd6b_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu_1lwd6b_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu_1lwd6b_test.go:38:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu_1lwd6b_test.go:38:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := range test_list {\n        for j := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp18grxj12_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmp18grxj12_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpihgbf1ye_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(len(test_list[i][j].(string)))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123998,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptq7yoh_m_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptq7yoh_m_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptq7yoh_m_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptq7yoh_m_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptq7yoh_m_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptq7yoh_m_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptq7yoh_m_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptq7yoh_m_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptq7yoh_m_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, sublist := range test_list {\n        var new_sublist []interface{}\n        for _, element := range sublist {\n            switch element.(type) {\n            case int:\n                new_sublist = append(new_sublist, float64(element.(int)))\n            case float64:\n                new_sublist = append(new_sublist, element)\n            case string:\n                new_sublist = append(new_sublist, element)\n            }\n        }\n        result = append(result, new_sublist)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123998,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2rljvw45_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2rljvw45_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2rljvw45_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2rljvw45_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2rljvw45_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2rljvw45_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2rljvw45_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2rljvw45_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2rljvw45_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] != nil {\n                switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case float64:\n                    test_list[i][j] = test_list[i][j].(float64)\n                case string:\n                    if test_list[i][j].(string) == \"\" {\n                        test_list[i][j] = nil\n                    } else {\n                        test_list[i][j] = float64(0)\n                    }\n                default:\n                    test_list[i][j] = nil\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123998,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpszmpuil4_test.go:40:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpszmpuil4_test.go:40:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpszmpuil4_test.go:40:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpszmpuil4_test.go:41:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpszmpuil4_test.go:41:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpszmpuil4_test.go:41:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpszmpuil4_test.go:42:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpszmpuil4_test.go:42:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpszmpuil4_test.go:42:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if _, ok := test_list[i][j].(float64); ok {\n                continue\n            } else if _, ok := test_list[i][j].(int); ok {\n                test_list[i][j] = float64(test_list[i][j].(int))\n            } else if _, ok := test_list[i][j].(string); ok {\n                test_list[i][j] = 0.0\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123998,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9grngl4c_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9grngl4c_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9grngl4c_test.go:31:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9grngl4c_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9grngl4c_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9grngl4c_test.go:32:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9grngl4c_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9grngl4c_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9grngl4c_test.go:33:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if val, ok := test_list[i][j].(float64); ok {\n                test_list[i][j] = val\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph611d4cu_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph611d4cu_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph611d4cu_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph611d4cu_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, sublist := range test_list {\n        var subresult []interface{}\n        for _, item := range sublist {\n            switch item.(type) {\n            case int:\n                subresult = append(subresult, float64(item.(int)))\n            case float64:\n                subresult = append(subresult, item)\n            case string:\n                subresult = append(subresult, item)\n            default:\n                panic(\"Unknown type\")\n            }\n        }\n        result = append(result, subresult)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123998,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwof1h4v1_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpwof1h4v1_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpwof1h4v1_test.go:37:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpwof1h4v1_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpwof1h4v1_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpwof1h4v1_test.go:38:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpwof1h4v1_test.go:39:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpwof1h4v1_test.go:39:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpwof1h4v1_test.go:39:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                if test_list[i][j].(string) == \"NaN\" {\n                    test_list[i][j] = float64(0)\n                } else {\n                    test_list[i][j] = float64(0)\n                }\n            default:\n                test_list[i][j] = float64(0)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123999,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwmipmttj_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpwmipmttj_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpwmipmttj_test.go:38:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpwmipmttj_test.go:39:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpwmipmttj_test.go:39:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpwmipmttj_test.go:39:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpwmipmttj_test.go:40:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpwmipmttj_test.go:40:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpwmipmttj_test.go:40:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, sublist := range test_list {\n        var subresult []interface{}\n        for _, item := range sublist {\n            switch item.(type) {\n            case int:\n                subresult = append(subresult, float64(item.(int)))\n            case float64:\n                subresult = append(subresult, item.(float64))\n            case string:\n                subresult = append(subresult, item.(string))\n            }\n        }\n        result = append(result, subresult)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123999,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxi3tngo5_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxi3tngo5_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxi3tngo5_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxi3tngo5_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxi3tngo5_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxi3tngo5_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxi3tngo5_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxi3tngo5_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxi3tngo5_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if val, ok := test_list[i][j].(float64); ok {\n                test_list[i][j] = val\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123988,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph611d4cu_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph611d4cu_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph611d4cu_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph611d4cu_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph611d4cu_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb23u8dgn_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa86yu58q_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpa86yu58q_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpa86yu58q_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpa86yu58q_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa86yu58q_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] == nil {\n                continue\n            }\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpznyr06lu_test.go:19:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpznyr06lu_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpznyr06lu_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:33:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpznyr06lu_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:34:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpznyr06lu_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:35:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:35:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = 0.0\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123999,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpo19ipdww_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo19ipdww_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo19ipdww_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo19ipdww_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo19ipdww_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo19ipdww_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo19ipdww_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo19ipdww_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo19ipdww_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, v := range test_list {\n        for j, v2 := range v {\n            switch v2.(type) {\n            case int:\n                test_list[i][j] = float64(v2.(int))\n            case float64:\n                test_list[i][j] = v2.(float64)\n            case string:\n                test_list[i][j] = v2.(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123993,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp629q09_3_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp629q09_3_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp629q09_3_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp629q09_3_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp629q09_3_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp629q09_3_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp629q09_3_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp629q09_3_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp629q09_3_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjkxap7__test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpxjkxap7__test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxjkxap7__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxjkxap7__test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, list := range test_list {\n        for j, element := range list {\n            switch element.(type) {\n            case int:\n                test_list[i][j] = float64(element.(int))\n            case float64:\n                test_list[i][j] = element.(float64)\n            case string:\n                test_list[i][j] = element.(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123999,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6pvjlix2_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6pvjlix2_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6pvjlix2_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6pvjlix2_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6pvjlix2_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6pvjlix2_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6pvjlix2_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6pvjlix2_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6pvjlix2_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            if test_list[i][j] != nil {\n                switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case float64:\n                    test_list[i][j] = test_list[i][j].(float64)\n                case string:\n                    if test_list[i][j] == \"NaN\" {\n                        test_list[i][j] = nil\n                    } else {\n                        test_list[i][j] = float64(test_list[i][j].(string))\n                    }\n                default:\n                    test_list[i][j] = nil\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123999,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb6brp1tk_test.go:22:50: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpb6brp1tk_test.go:40:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb6brp1tk_test.go:40:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb6brp1tk_test.go:40:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb6brp1tk_test.go:41:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb6brp1tk_test.go:41:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb6brp1tk_test.go:41:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb6brp1tk_test.go:42:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb6brp1tk_test.go:42:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb6brp1tk_test.go:42:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb6brp1tk_test.go:42:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, list := range test_list {\n        var new_list []interface{}\n        for _, element := range list {\n            switch element.(type) {\n            case int:\n                new_list = append(new_list, float64(element.(int)))\n            case float64:\n                new_list = append(new_list, element.(float64))\n            case string:\n                new_list = append(new_list, element.(string))\n            }\n        }\n        result = append(result, new_list)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzgq91ql9_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzgq91ql9_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzgq91ql9_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzgq91ql9_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzgq91ql9_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzgq91ql9_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzgq91ql9_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzgq91ql9_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzgq91ql9_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j], _ = fmt.Printf(\"%f\", test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123999,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph7sk9vp9_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7sk9vp9_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7sk9vp9_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7sk9vp9_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7sk9vp9_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7sk9vp9_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7sk9vp9_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph7sk9vp9_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph7sk9vp9_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := range test_list {\n        for j := range test_list[i] {\n            if test_list[i][j] == nil {\n                continue\n            }\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                continue\n            case string:\n                test_list[i][j] = nil\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123999,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp97dv1tyg_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp97dv1tyg_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp97dv1tyg_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp97dv1tyg_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp97dv1tyg_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp97dv1tyg_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp97dv1tyg_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp97dv1tyg_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp97dv1tyg_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if v, ok := test_list[i][j].(float64); ok {\n                test_list[i][j] = v\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprzv3b7pp_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprzv3b7pp_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprzv3b7pp_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprzv3b7pp_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprzv3b7pp_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, row := range test_list {\n        for j, item := range row {\n            switch item.(type) {\n            case int:\n                test_list[i][j] = float64(item.(int))\n            case float64:\n                test_list[i][j] = item.(float64)\n            case string:\n                test_list[i][j] = item.(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123999,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpp9wupc0a_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpp9wupc0a_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpp9wupc0a_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpp9wupc0a_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpp9wupc0a_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpp9wupc0a_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpp9wupc0a_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpp9wupc0a_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpp9wupc0a_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := range test_list {\n        for j := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp18grxj12_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmp18grxj12_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := range test_list {\n        for j := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp18grxj12_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmp18grxj12_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp18grxj12_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp18grxj12_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb23u8dgn_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpihgbf1ye_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] == nil {\n                continue\n            }\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpznyr06lu_test.go:19:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpznyr06lu_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpznyr06lu_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:33:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpznyr06lu_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:34:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpznyr06lu_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:35:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpznyr06lu_test.go:35:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for _, list := range test_list {\n        for i, element := range list {\n            switch element.(type) {\n            case int:\n                list[i] = float64(element.(int))\n            case float64:\n                list[i] = element.(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123999,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjwa6tz4e_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpjwa6tz4e_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpjwa6tz4e_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpjwa6tz4e_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpjwa6tz4e_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpjwa6tz4e_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpjwa6tz4e_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpjwa6tz4e_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpjwa6tz4e_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, sublist := range test_list {\n        var new_sublist []interface{}\n        for _, item := range sublist {\n            switch item.(type) {\n            case int:\n                new_sublist = append(new_sublist, float64(item.(int)))\n            case float64:\n                new_sublist = append(new_sublist, item.(float64))\n            default:\n                new_sublist = append(new_sublist, item)\n            }\n        }\n        result = append(result, new_sublist)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplmhp3ug6_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplmhp3ug6_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplmhp3ug6_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplmhp3ug6_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplmhp3ug6_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplmhp3ug6_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplmhp3ug6_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplmhp3ug6_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplmhp3ug6_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpihgbf1ye_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpihgbf1ye_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpihgbf1ye_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, sublist := range test_list {\n        var new_sublist []interface{}\n        for _, element := range sublist {\n            switch element.(type) {\n            case int:\n                new_sublist = append(new_sublist, float64(element.(int)))\n            case float64:\n                new_sublist = append(new_sublist, element.(float64))\n            default:\n                new_sublist = append(new_sublist, element)\n            }\n        }\n        result = append(result, new_sublist)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123990,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp261lel6d_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp261lel6d_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp261lel6d_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp261lel6d_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp261lel6d_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb23u8dgn_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case int8:\n                test_list[i][j] = float64(test_list[i][j].(int8))\n            case int16:\n                test_list[i][j] = float64(test_list[i][j].(int16))\n            case int32:\n                test_list[i][j] = float64(test_list[i][j].(int32))\n            case int64:\n                test_list[i][j] = float64(test_list[i][j].(int64))\n            case uint:\n                test_list[i][j] = float64(test_list[i][j].(uint))\n            case uint8:\n                test_list[i][j] = float64(test_list[i][j].(uint8))\n            case uint16:\n                test_list[i][j] = float64(test_list[i][j].(uint16))\n            case uint32:\n                test_list[i][j] = float64(test_list[i][j].(uint32))\n            case uint64:\n                test_list[i][j] = float64(test_list[i][j].(uint64))\n            case float32:\n                test_list[i][j] = float64(test_list[i][j].(float32))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpz7jhbho5_test.go:50:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpz7jhbho5_test.go:50:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpz7jhbho5_test.go:50:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpz7jhbho5_test.go:51:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpz7jhbho5_test.go:51:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpz7jhbho5_test.go:51:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpz7jhbho5_test.go:52:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpz7jhbho5_test.go:52:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpz7jhbho5_test.go:52:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case int8:\n                test_list[i][j] = float64(test_list[i][j].(int8))\n            case int16:\n                test_list[i][j] = float64(test_list[i][j].(int16))\n            case int32:\n                test_list[i][j] = float64(test_list[i][j].(int32))\n            case int64:\n                test_list[i][j] = float64(test_list[i][j].(int64))\n            case uint:\n                test_list[i][j] = float64(test_list[i][j].(uint))\n            case uint8:\n                test_list[i][j] = float64(test_list[i][j].(uint8))\n            case uint16:\n                test_list[i][j] = float64(test_list[i][j].(uint16))\n            case uint32:\n                test_list[i][j] = float64(test_list[i][j].(uint32))\n            case uint64:\n                test_list[i][j] = float64(test_list[i][j].(uint64))\n            case float32:\n                test_list[i][j] = float64(test_list[i][j].(float32))\n            case float64:\n                test_list[i][j] = float64(test_list[i][j].(float64))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123999,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqe4c10yn_test.go:50:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqe4c10yn_test.go:50:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqe4c10yn_test.go:50:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqe4c10yn_test.go:51:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqe4c10yn_test.go:51:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqe4c10yn_test.go:51:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqe4c10yn_test.go:52:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqe4c10yn_test.go:52:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqe4c10yn_test.go:52:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := range test_list {\n        for j := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123999,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpz3in3mkp_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpz3in3mkp_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpz3in3mkp_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpz3in3mkp_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpz3in3mkp_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpz3in3mkp_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpz3in3mkp_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpz3in3mkp_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpz3in3mkp_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := range test_list {\n        for j := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = float64(0)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123998,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp67tqhe7q_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp67tqhe7q_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp67tqhe7q_test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp67tqhe7q_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp67tqhe7q_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp67tqhe7q_test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp67tqhe7q_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp67tqhe7q_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp67tqhe7q_test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            if v, ok := test_list[i][j].(int); ok {\n                test_list[i][j] = float64(v)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123999,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0qx7an2m_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0qx7an2m_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0qx7an2m_test.go:27:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0qx7an2m_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0qx7an2m_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0qx7an2m_test.go:28:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0qx7an2m_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0qx7an2m_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0qx7an2m_test.go:29:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] == nil {\n                continue\n            }\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                continue\n            case string:\n                test_list[i][j] = nil\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123999,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpf5a8f805_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpf5a8f805_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpf5a8f805_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpf5a8f805_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpf5a8f805_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpf5a8f805_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpf5a8f805_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpf5a8f805_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpf5a8f805_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb23u8dgn_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpb23u8dgn_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpb23u8dgn_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, sublist := range test_list {\n        var new_sublist []interface{}\n        for _, item := range sublist {\n            switch item.(type) {\n            case int:\n                new_sublist = append(new_sublist, float64(item.(int)))\n            case float64:\n                new_sublist = append(new_sublist, item.(float64))\n            default:\n                new_sublist = append(new_sublist, item)\n            }\n        }\n        result = append(result, new_sublist)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123996,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplmhp3ug6_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplmhp3ug6_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplmhp3ug6_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplmhp3ug6_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplmhp3ug6_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplmhp3ug6_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplmhp3ug6_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplmhp3ug6_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplmhp3ug6_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            case string:\n                test_list[i][j] = test_list[i][j].(string)\n            default:\n                test_list[i][j] = nil\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplrl01rz__test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplrl01rz__test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplrl01rz__test.go:34:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplrl01rz__test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplrl01rz__test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplrl01rz__test.go:35:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplrl01rz__test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplrl01rz__test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplrl01rz__test.go:36:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            if test_list[i][j] != nil {\n                switch test_list[i][j].(type) {\n                case int:\n                    test_list[i][j] = float64(test_list[i][j].(int))\n                case string:\n                    test_list[i][j] = float64(test_list[i][j].(string))\n                }\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk8iv6jp__test.go:17:46: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpk8iv6jp__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk8iv6jp__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:32:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk8iv6jp__test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:33:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk8iv6jp__test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:34:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk8iv6jp__test.go:34:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i, _ := range test_list {\n        for j, _ := range test_list[i] {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case string:\n                test_list[i][j] = float64(test_list[i][j].(string))\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517106,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3mocdzb_test.go:16:42: cannot convert test_list[i][j].(string) (type string) to type float64\n/tmp/tmpe3mocdzb_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:30:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:31:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpe3mocdzb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpe3mocdzb_test.go:32:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list[i]); j++ {\n            switch test_list[i][j].(type) {\n            case int:\n                test_list[i][j] = float64(test_list[i][j].(int))\n            case int8:\n                test_list[i][j] = float64(test_list[i][j].(int8))\n            case int16:\n                test_list[i][j] = float64(test_list[i][j].(int16))\n            case int32:\n                test_list[i][j] = float64(test_list[i][j].(int32))\n            case int64:\n                test_list[i][j] = float64(test_list[i][j].(int64))\n            case uint:\n                test_list[i][j] = float64(test_list[i][j].(uint))\n            case uint8:\n                test_list[i][j] = float64(test_list[i][j].(uint8))\n            case uint16:\n                test_list[i][j] = float64(test_list[i][j].(uint16))\n            case uint32:\n                test_list[i][j] = float64(test_list[i][j].(uint32))\n            case uint64:\n                test_list[i][j] = float64(test_list[i][j].(uint64))\n            case float32:\n                test_list[i][j] = float64(test_list[i][j].(float32))\n            case float64:\n                test_list[i][j] = test_list[i][j].(float64)\n            }\n        }\n    }\n    return test_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665517107,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpz7jhbho5_test.go:50:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpz7jhbho5_test.go:50:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpz7jhbho5_test.go:50:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpz7jhbho5_test.go:51:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpz7jhbho5_test.go:51:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpz7jhbho5_test.go:51:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpz7jhbho5_test.go:52:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpz7jhbho5_test.go:52:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpz7jhbho5_test.go:52:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result [][]interface{}\n    for _, sublist := range test_list {\n        var new_sublist []interface{}\n        for _, element := range sublist {\n            switch element.(type) {\n            case int:\n                new_sublist = append(new_sublist, float64(element.(int)))\n            case float64:\n                new_sublist = append(new_sublist, element)\n            default:\n                new_sublist = append(new_sublist, element)\n            }\n        }\n        result = append(result, new_sublist)\n    }\n    return result\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123999,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprx53tceq_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprx53tceq_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprx53tceq_test.go:35:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprx53tceq_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprx53tceq_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprx53tceq_test.go:36:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprx53tceq_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprx53tceq_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprx53tceq_test.go:37:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package list_to_float_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list [][]interface{}) [][]interface{} {\n    var result_list [][]interface{}\n    for _, list := range test_list {\n        var result_sublist []interface{}\n        for _, element := range list {\n            switch element.(type) {\n            case int:\n                result_sublist = append(result_sublist, float64(element.(int)))\n            case float64:\n                result_sublist = append(result_sublist, element.(float64))\n            case string:\n                if value, err := element.(string); err == nil {\n                    if value == \"NaN\" {\n                        result_sublist = append(result_sublist, \"NaN\")\n                    } else {\n                        result_sublist = append(result_sublist, \"NaN\")\n                    }\n                } else {\n                    result_sublist = append(result_sublist, \"NaN\")\n                }\n            default:\n                result_sublist = append(result_sublist, \"NaN\")\n            }\n        }\n        result_list = append(result_list, result_sublist)\n    }\n    return result_list\n}\n\nfunc TestList_To_Float(t *testing.T) {\n  candidate := list_to_float\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"3\", \"4\"}, []interface{}{\"1\", \"26.45\"}, []interface{}{\"7.32\", \"8\"}, []interface{}{\"4\", \"8\"}}), expected: [][]int{[]interface{}{3.0, 4.0}, []interface{}{1.0, 26.45}, []interface{}{7.32, 8.0}, []interface{}{4.0, 8.0}} },\n     { actual: candidate([][]int{[]interface{}{\"4\", \"4\"}, []interface{}{\"2\", \"27\"}, []interface{}{\"4.12\", \"9\"}, []interface{}{\"7\", \"11\"}}), expected: [][]int{[]interface{}{4.0, 4.0}, []interface{}{2.0, 27.0}, []interface{}{4.12, 9.0}, []interface{}{7.0, 11.0}} },\n     { actual: candidate([][]int{[]interface{}{\"6\", \"78\"}, []interface{}{\"5\", \"26.45\"}, []interface{}{\"1.33\", \"4\"}, []interface{}{\"82\", \"13\"}}), expected: [][]int{[]interface{}{6.0, 78.0}, []interface{}{5.0, 26.45}, []interface{}{1.33, 4.0}, []interface{}{82.0, 13.0}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123999,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpm8np91pe_test.go:20:56: invalid operation: err == nil (mismatched types bool and nil)\n/tmp/tmpm8np91pe_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpm8np91pe_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpm8np91pe_test.go:45:174: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpm8np91pe_test.go:46:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpm8np91pe_test.go:46:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpm8np91pe_test.go:46:172: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpm8np91pe_test.go:47:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpm8np91pe_test.go:47:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpm8np91pe_test.go:47:177: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpm8np91pe_test.go:47:177: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    }
  ]
}