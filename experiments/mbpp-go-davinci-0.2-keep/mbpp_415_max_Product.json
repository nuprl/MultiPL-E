{
  "name": "mbpp_415_max_Product",
  "language": "go_test.go",
  "prompt": "package max_Product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find a pair with highest product from a given array of integers.\nfunc max_Product(arr []int) []interface{} {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_415_max_Product.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestMax_Product(t *testing.T) {\n  candidate := max_Product\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 4, 7, 0, 8, 4}), expected: []interface{}{7, 8} },\n     { actual: candidate([]int{0, -1, -2, -4, 5, 0, -6}), expected: []interface{}{-4, -6} },\n     { actual: candidate([]int{1, 2, 3}), expected: []interface{}{2, 3} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    var max_product int = 0\n    var max_index int = 0\n    var min_index int = 0\n    var max_value int = 0\n    var min_value int = 0\n    var product int = 0\n    var result []interface{}\n    for i, v := range arr {\n        if i == 0 {\n            max_value = v\n            min_value = v\n            max_index = i\n            min_index = i\n        } else {\n            if v > max_value {\n                max_value = v\n                max_index = i\n            }\n            if v < min_value {\n                min_value = v\n                min_index = i\n            }\n        }\n    }\n    if max_index == min_index {\n        for i, v := range arr {\n            if i == 0 {\n                max_value = v\n                min_value = v\n                max_index = i\n                min_index = i\n            } else {\n                if v > max_value {\n                    max_value = v\n                    max_index = i\n                }\n                if v < min_value {\n                    min_value = v\n                    min_index = i\n                }\n            }\n        }\n    }\n    product = max_value * min_value\n    result = append(result, max_index, min_index, product)\n    return result\n}\n",
    "    var max_prod int\n    var max_i, max_j int\n    for i := 0; i < len(arr); i++ {\n        for j := i + 1; j < len(arr); j++ {\n            prod := arr[i] * arr[j]\n            if prod > max_prod {\n                max_prod = prod\n                max_i = i\n                max_j = j\n            }\n        }\n    }\n    return []interface{}{max_prod, max_i, max_j}\n}\n",
    "    var max, second_max int\n    var max_index, second_max_index int\n\n    for i, v := range arr {\n        if v > max {\n            second_max = max\n            second_max_index = max_index\n            max = v\n            max_index = i\n        } else if v > second_max {\n            second_max = v\n            second_max_index = i\n        }\n    }\n\n    return []interface{}{max, second_max, max_index, second_max_index}\n}\n",
    "    var max_product int\n    var max_index int\n    var min_index int\n    for i := 0; i < len(arr); i++ {\n        for j := i + 1; j < len(arr); j++ {\n            if arr[i] * arr[j] > max_product {\n                max_product = arr[i] * arr[j]\n                max_index = i\n                min_index = j\n            }\n        }\n    }\n    return []interface{}{max_product, max_index, min_index}\n}\n",
    "    var max, max2, max3, min, min2 int\n    max = arr[0]\n    max2 = arr[0]\n    max3 = arr[0]\n    min = arr[0]\n    min2 = arr[0]\n    for _, v := range arr {\n        if v > max {\n            max3 = max2\n            max2 = max\n            max = v\n        } else if v > max2 {\n            max3 = max2\n            max2 = v\n        } else if v > max3 {\n            max3 = v\n        }\n        if v < min {\n            min2 = min\n            min = v\n        } else if v < min2 {\n            min2 = v\n        }\n    }\n    if max*max2 > max*min*min2 {\n        return []interface{}{max, max2}\n    }\n    return []interface{}{max, min, min2}\n}\n",
    "    var max_product int\n    var max_index int\n    var min_index int\n    for i, v := range arr {\n        if v > max_product {\n            max_product = v\n            max_index = i\n        }\n    }\n    max_product = 0\n    for i, v := range arr {\n        if v > max_product && i != max_index {\n            max_product = v\n            min_index = i\n        }\n    }\n    return []interface{}{arr[max_index], arr[min_index]}\n}\n",
    "    var result []interface{}\n    var max, second_max int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > max {\n            second_max = max\n            max = arr[i]\n        } else if arr[i] > second_max {\n            second_max = arr[i]\n        }\n    }\n    result = append(result, max, second_max)\n    return result\n}\n",
    "    var max, secondMax int\n    for _, v := range arr {\n        if v > max {\n            secondMax = max\n            max = v\n        } else if v > secondMax {\n            secondMax = v\n        }\n    }\n    return []interface{}{max, secondMax}\n}\n",
    "    var max1, max2 int\n    max1 = arr[0]\n    max2 = arr[1]\n    if max1 < max2 {\n        max1, max2 = max2, max1\n    }\n    for i := 2; i < len(arr); i++ {\n        if arr[i] > max1 {\n            max2 = max1\n            max1 = arr[i]\n        } else if arr[i] > max2 {\n            max2 = arr[i]\n        }\n    }\n    return []interface{}{max1, max2}\n}\n",
    "    var max_1, max_2, max_3, min_1, min_2 int\n    for _, v := range arr {\n        if v > max_1 {\n            max_3 = max_2\n            max_2 = max_1\n            max_1 = v\n        } else if v > max_2 {\n            max_3 = max_2\n            max_2 = v\n        } else if v > max_3 {\n            max_3 = v\n        }\n\n        if v < min_1 {\n            min_2 = min_1\n            min_1 = v\n        } else if v < min_2 {\n            min_2 = v\n        }\n    }\n\n    return []interface{}{max_1, max_2, max_3, min_1, min_2}\n}\n",
    "    if len(arr) < 2 {\n        return []interface{}{}\n    }\n    max1, max2 := arr[0], arr[1]\n    if max1 < max2 {\n        max1, max2 = max2, max1\n    }\n    for i := 2; i < len(arr); i++ {\n        if arr[i] > max1 {\n            max2 = max1\n            max1 = arr[i]\n        } else if arr[i] > max2 {\n            max2 = arr[i]\n        }\n    }\n    return []interface{}{max1, max2}\n}\n",
    "    var max_1, max_2, max_3, min_1, min_2 int\n    for _, v := range arr {\n        if v > max_1 {\n            max_3 = max_2\n            max_2 = max_1\n            max_1 = v\n        } else if v > max_2 {\n            max_3 = max_2\n            max_2 = v\n        } else if v > max_3 {\n            max_3 = v\n        }\n\n        if v < min_1 {\n            min_2 = min_1\n            min_1 = v\n        } else if v < min_2 {\n            min_2 = v\n        }\n    }\n\n    return []interface{}{max_1, max_2, max_3, min_1, min_2}\n}\n",
    "    var max_product int\n    var max_index int\n    var min_index int\n    var max_value int\n    var min_value int\n    var result []interface{}\n    for i, v := range arr {\n        if i == 0 {\n            max_value = v\n            min_value = v\n            max_index = i\n            min_index = i\n        } else {\n            if v > max_value {\n                max_value = v\n                max_index = i\n            } else if v < min_value {\n                min_value = v\n                min_index = i\n            }\n        }\n    }\n    max_product = max_value * min_value\n    result = append(result, max_product)\n    result = append(result, max_index)\n    result = append(result, min_index)\n    return result\n}\n",
    "    var max, max2 int\n    var max_index, max2_index int\n    for i, v := range arr {\n        if v > max {\n            max = v\n            max_index = i\n        }\n    }\n    for i, v := range arr {\n        if v > max2 && i != max_index {\n            max2 = v\n            max2_index = i\n        }\n    }\n    return []interface{}{max_index, max2_index}\n}\n",
    "    var max_1, max_2 int\n    for _, v := range arr {\n        if v > max_1 {\n            max_2 = max_1\n            max_1 = v\n        } else if v > max_2 {\n            max_2 = v\n        }\n    }\n    return []interface{}{max_1, max_2}\n}\n",
    "    var max_product int\n    var max_product_pair []interface{}\n    for i := 0; i < len(arr); i++ {\n        for j := i + 1; j < len(arr); j++ {\n            if arr[i] * arr[j] > max_product {\n                max_product = arr[i] * arr[j]\n                max_product_pair = []interface{}{arr[i], arr[j]}\n            }\n        }\n    }\n    return max_product_pair\n}\n",
    "    var max1, max2, max3, min1, min2 int\n    max1, max2, max3, min1, min2 = 0, 0, 0, 0, 0\n    for _, v := range arr {\n        if v > max1 {\n            max3 = max2\n            max2 = max1\n            max1 = v\n        } else if v > max2 {\n            max3 = max2\n            max2 = v\n        } else if v > max3 {\n            max3 = v\n        }\n        if v < min1 {\n            min2 = min1\n            min1 = v\n        } else if v < min2 {\n            min2 = v\n        }\n    }\n    return []interface{}{max1, max2, max3, min1, min2}\n}\n",
    "    var max, second_max int\n    var max_index, second_max_index int\n    for index, value := range arr {\n        if value > max {\n            second_max = max\n            second_max_index = max_index\n            max = value\n            max_index = index\n        } else if value > second_max {\n            second_max = value\n            second_max_index = index\n        }\n    }\n    return []interface{}{max, second_max, max_index, second_max_index}\n}\n",
    "    var max, second_max int\n    var max_index, second_max_index int\n    for i, v := range arr {\n        if v > max {\n            second_max = max\n            second_max_index = max_index\n            max = v\n            max_index = i\n        } else if v > second_max {\n            second_max = v\n            second_max_index = i\n        }\n    }\n    return []interface{}{max_index, second_max_index, max * second_max}\n}\n",
    "    var max1, max2 int\n    if arr[0] > arr[1] {\n        max1 = arr[0]\n        max2 = arr[1]\n    } else {\n        max1 = arr[1]\n        max2 = arr[0]\n    }\n\n    for i := 2; i < len(arr); i++ {\n        if arr[i] > max1 {\n            max2 = max1\n            max1 = arr[i]\n        } else if arr[i] > max2 {\n            max2 = arr[i]\n        }\n    }\n\n    return []interface{}{max1, max2}\n}\n"
  ]
}