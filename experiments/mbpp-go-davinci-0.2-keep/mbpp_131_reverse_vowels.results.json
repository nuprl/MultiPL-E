{
  "name": "mbpp_131_reverse_vowels",
  "language": "go_test.go",
  "prompt": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_131_reverse_vowels.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := len(str1) - 1; i >= 0; i-- {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 += string(str1[i])\n        }\n    }\n    fmt.Println(str2)\n    var str3 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 += string(str2[0])\n            str2 = str2[1:]\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510566,
      "stdout": "o\n\na\n--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpphaj7vo1_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Write your code here\n    return \"\"\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510567,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpty_8pjum_test.go:29: expected 'Python', got ''\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpty_8pjum_test.go:29: expected 'ASU', got ''\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmpty_8pjum_test.go:29: expected 'ab', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = map[string]int{\"a\": 1, \"e\": 1, \"i\": 1, \"o\": 1, \"u\": 1}\n    var str_arr = []string{}\n    var vowels_arr = []string{}\n    var result = \"\"\n\n    for _, char := range str1 {\n        str_arr = append(str_arr, string(char))\n        if _, ok := vowels[string(char)]; ok {\n            vowels_arr = append(vowels_arr, string(char))\n        }\n    }\n\n    for i := 0; i < len(str_arr); i++ {\n        if _, ok := vowels[str_arr[i]]; ok {\n            result += vowels_arr[len(vowels_arr) - 1]\n            vowels_arr = vowels_arr[:len(vowels_arr) - 1]\n        } else {\n            result += str_arr[i]\n        }\n    }\n\n    return result\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510566,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpxgut1efw_test.go:49: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str2 = []string{}\n    var str3 = []string{}\n    for _, char := range str1 {\n        str2 = append(str2, string(char))\n    }\n    for _, char := range str2 {\n        if contains(vowels, char) {\n            str3 = append([]string{char}, str3...)\n        }\n    }\n    var j = 0\n    for i, char := range str2 {\n        if contains(vowels, char) {\n            str2[i] = str3[j]\n            j++\n        }\n    }\n    return strings.Join(str2, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510566,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoj4n80cj_test.go:17:12: undefined: contains\n/tmp/tmpoj4n80cj_test.go:23:12: undefined: contains\n/tmp/tmpoj4n80cj_test.go:28:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Write your code here\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 string\n    var str3 string\n    for _, char := range str1 {\n        if contains(vowels, string(char)) {\n            str2 += string(char)\n        }\n    }\n    for _, char := range str1 {\n        if contains(vowels, string(char)) {\n            str3 += string(str2[len(str2)-1])\n            str2 = str2[:len(str2)-1]\n        } else {\n            str3 += string(char)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510566,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpto5z5u0i_test.go:15:12: undefined: contains\n/tmp/tmpto5z5u0i_test.go:20:12: undefined: contains\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str1_runes = []rune(str1)\n    var str1_vowels = []rune{}\n    var str1_vowels_index = []int{}\n    var str1_vowels_index_reverse = []int{}\n    var str1_vowels_reverse = []rune{}\n    var str1_vowels_reverse_index = []int{}\n    var str1_vowels_reverse_index_reverse = []int{}\n    var str1_vowels_reverse_index_reverse_index = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse_index = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse_index = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse_index_reverse = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index_reverse = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index_reverse = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index = []int{}\n   \nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510566,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpccagq4gk_test.go:30:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n\n    var str2 string\n    var str3 string\n    for _, c := range str1 {\n        if vowels[string(c)] {\n            str2 += string(c)\n        } else {\n            str3 += string(c)\n        }\n    }\n\n    var str4 string\n    for i := len(str2) - 1; i >= 0; i-- {\n        str4 += string(str2[i])\n    }\n\n    var str5 string\n    for i := 0; i < len(str1); i++ {\n        if vowels[string(str1[i])] {\n            str5 += string(str4[0])\n            str4 = str4[1:]\n        } else {\n            str5 += string(str3[0])\n            str3 = str3[1:]\n        }\n    }\n\n    return str5\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510567,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpda9h82s__test.go:62: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for _, c := range str1 {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            str2 = string(c) + str2\n        }\n    }\n    var str3 string\n    for _, c := range str1 {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            str3 = str3 + string(str2[0])\n            str2 = str2[1:]\n        } else {\n            str3 = str3 + string(c)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510567,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpf7ch_drg_test.go:43: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 = str1[i:i+1] + str2\n        }\n    }\n    var str3 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 = str3 + str2[0:1]\n            str2 = str2[1:]\n        } else {\n            str3 = str3 + str1[i:i+1]\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510567,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpnbsa4jg2_test.go:43: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str2 = \"\"\n    var str3 = \"\"\n    var str4 = \"\"\n    var str5 = \"\"\n    var str6 = \"\"\n    var str7 = \"\"\n    var str8 = \"\"\n    var str9 = \"\"\n    var str10 = \"\"\n    for _, char := range str1 {\n        str2 = str2 + string(char)\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                str3 = str3 + string(char)\n            }\n        }\n    }\n    for i := len(str3) - 1; i >= 0; i-- {\n        str4 = str4 + string(str3[i])\n    }\n    for _, char := range str2 {\n        str5 = str5 + string(char)\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                str6 = str6 + string(char)\n            }\n        }\n    }\n    for i := len(str6) - 1; i >= 0; i-- {\n        str7 = str7 + string(str6[i])\n    }\n    for _, char := range str5 {\n        str8 = str8 + string(char)\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                str9 = str9 + string(char)\n            }\n        }\n    }\n    for i := len(str9) - 1; i >= 0; i-- {\n        str10 = str10 + string(str9[i])\n    }\n    return str4 + str7 + str10\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510567,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpy_4whsgz_test.go:71: expected 'Python', got 'ooo'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpy_4whsgz_test.go:71: expected 'ASU', got 'AUAUAU'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmpy_4whsgz_test.go:71: expected 'ab', got 'aaa'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for _, char := range str1 {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n            str2 = string(char) + str2\n        } else {\n            str2 = str2 + string(char)\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510567,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpbkpj6qqs_test.go:36: expected 'Python', got 'oPythn'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpbkpj6qqs_test.go:36: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 = str1[i:i+1] + str2\n        }\n    }\n    var str3 string\n    var j int\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 = str3 + str2[j:j+1]\n            j++\n        } else {\n            str3 = str3 + str1[i:i+1]\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510566,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpfm7v5jfw_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    var stack []string\n    for _, v := range str1 {\n        if _, ok := vowels[string(v)]; ok {\n            stack = append(stack, string(v))\n        }\n    }\n    for _, v := range str1 {\n        if _, ok := vowels[string(v)]; ok {\n            str2 += stack[len(stack)-1]\n            stack = stack[:len(stack)-1]\n        } else {\n            str2 += string(v)\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510567,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpxoqzxsa3_test.go:50: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for _, char := range str1 {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n            str2 = string(char) + str2\n        }\n    }\n    var str3 string\n    for _, char := range str1 {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n            str3 += string(str2[0])\n            str2 = str2[1:]\n        } else {\n            str3 += string(char)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510567,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpsxj26_zp_test.go:43: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := len(str1) - 1; i >= 0; i-- {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 += string(str1[i])\n        }\n    }\n    var str3 string\n    var j int = 0\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510567,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpqgd0dumw_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := len(str1) - 1; i >= 0; i-- {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 += string(str1[i])\n        }\n    }\n    var str3 string\n    j := 0\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510566,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmppb362zuj_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str1_vowels []string\n    var str1_vowels_reversed []string\n    var str1_vowels_reversed_index = 0\n    var str1_vowels_index = 0\n\n    for _, char := range str1 {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                str1_vowels = append(str1_vowels, string(char))\n            }\n        }\n    }\n\n    for i := len(str1_vowels) - 1; i >= 0; i-- {\n        str1_vowels_reversed = append(str1_vowels_reversed, str1_vowels[i])\n    }\n\n    for i := 0; i < len(str1); i++ {\n        for _, vowel := range vowels {\n            if string(str1[i]) == vowel {\n                str1 = str1[:i] + str1_vowels_reversed[str1_vowels_reversed_index] + str1[i+1:]\n                str1_vowels_reversed_index++\n            }\n        }\n    }\n\n    return str1\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510566,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb1_ext2b_test.go:14:9: str1_vowels_index declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 = str1[i:i+1] + str2\n        }\n    }\n    var str3 string\n    j := 0\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 = str3 + str2[j:j+1]\n            j++\n        } else {\n            str3 = str3 + str1[i:i+1]\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510566,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmptv66rwfb_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // convert string to rune slice\n    str1_runes := []rune(str1)\n    // create a map of vowels\n    vowels := map[rune]bool{\n        'a': true,\n        'e': true,\n        'i': true,\n        'o': true,\n        'u': true,\n    }\n    // create a slice of indexes of vowels\n    vowel_indexes := []int{}\n    for i, r := range str1_runes {\n        if _, ok := vowels[r]; ok {\n            vowel_indexes = append(vowel_indexes, i)\n        }\n    }\n    // reverse the vowels\n    for i := 0; i < len(vowel_indexes)/2; i++ {\n        str1_runes[vowel_indexes[i]], str1_runes[vowel_indexes[len(vowel_indexes)-i-1]] = str1_runes[vowel_indexes[len(vowel_indexes)-i-1]], str1_runes[vowel_indexes[i]]\n    }\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510566,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmphoa28685_test.go:49: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]string{\"a\": \"a\", \"e\": \"e\", \"i\": \"i\", \"o\": \"o\", \"u\": \"u\"}\n    // Create a slice of the string\n    str1_slice := []string{}\n    // Create a slice of the vowels\n    vowels_slice := []string{}\n    // Create a slice of the non-vowels\n    non_vowels_slice := []string{}\n    // Iterate over the string\n    for _, char := range str1 {\n        // If the character is a vowel\n        if _, ok := vowels[string(char)]; ok {\n            // Add it to the vowels slice\n            vowels_slice = append(vowels_slice, string(char))\n        } else {\n            // Add it to the non-vowels slice\n            non_vowels_slice = append(non_vowels_slice, string(char))\n        }\n    }\n    // Reverse the vowels slice\n    for i, j := 0, len(vowels_slice)-1; i < j; i, j = i+1, j-1 {\n        vowels_slice[i], vowels_slice[j] = vowels_slice[j], vowels_slice[i]\n    }\n    // Iterate over the string\n    for _, char := range str1 {\n        // If the character is a vowel\n        if _, ok := vowels[string(char)]; ok {\n            // Add the reversed vowel to the string slice\n            str1_slice = append(str1_slice, vowels_slice[0])\n            // Remove the vowel from the reversed vowels slice\n            vowels_slice = vowels_slice[1:]\n        } else {\n            // Add the non-vowel to the string slice\n            str1_slice = append(str1_slice, non_vowels_slice[0])\n            // Remove the non-vowel from the non-vowels slice\n            non_vowels_slice = non_vowels_slice[1:]\n        }\n    }\n    // Return the reversed\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510566,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp8yao5kt1_test.go:49:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    str1_runes := []rune(str1)\n    vowels := []rune{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    vowel_count := 0\n    for _, char := range str1_runes {\n        for _, vowel := range vowels {\n            if char == vowel {\n                vowel_count++\n            }\n        }\n    }\n    vowel_indexes := make([]int, vowel_count)\n    vowel_count = 0\n    for i, char := range str1_runes {\n        for _, vowel := range vowels {\n            if char == vowel {\n                vowel_indexes[vowel_count] = i\n                vowel_count++\n            }\n        }\n    }\n    for i := 0; i < len(vowel_indexes)/2; i++ {\n        str1_runes[vowel_indexes[i]], str1_runes[vowel_indexes[len(vowel_indexes)-i-1]] = str1_runes[vowel_indexes[len(vowel_indexes)-i-1]], str1_runes[vowel_indexes[i]]\n    }\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123567,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 = \"\"\n    var str3 = \"\"\n    var str4 = \"\"\n    for _, char := range str1 {\n        str2 += string(char)\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                str3 += string(char)\n            }\n        }\n    }\n    for _, char := range str2 {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                str4 += string(str3[len(str3)-1])\n                str3 = str3[:len(str3)-1]\n            } else {\n                str4 += string(char)\n            }\n        }\n    }\n    return str4\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123568,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmphtr2m140_test.go:50: expected 'Python', got 'PPPPPyyyyyttttthhhhhooooonnnnn'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmphtr2m140_test.go:50: expected 'ASU', got 'UUUUUSSSSSAAAAA'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmphtr2m140_test.go:50: expected 'ab', got 'aaaaabbbbb'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Write your code here\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    str1_array := []string{}\n    for _, char := range str1 {\n        str1_array = append(str1_array, string(char))\n    }\n    fmt.Println(str1_array)\n    for i, char := range str1_array {\n        for _, vowel := range vowels {\n            if char == vowel {\n                for j := len(str1_array)-1; j > i; j-- {\n                    if str1_array[j] == vowel {\n                        str1_array[i], str1_array[j] = str1_array[j], str1_array[i]\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return strings.Join(str1_array, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123567,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfzt2q60f_test.go:29:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123568,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'Python', got ''\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'ASU', got ''\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'ab', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\": true}\n    var str1_runes = []rune(str1)\n    var str1_runes_len = len(str1_runes)\n    var i, j = 0, str1_runes_len - 1\n    for i < j {\n        if vowels[string(str1_runes[i])] && vowels[string(str1_runes[j])] {\n            str1_runes[i], str1_runes[j] = str1_runes[j], str1_runes[i]\n            i++\n            j--\n        } else if vowels[string(str1_runes[i])] {\n            j--\n        } else if vowels[string(str1_runes[j])] {\n            i++\n        } else {\n            i++\n            j--\n        }\n    }\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123568,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp3nbu2qh3_test.go:46: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Write your code here\n    var vowels = map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n\n    var str2 = []string{}\n    var str3 = []string{}\n    for _, char := range str1 {\n        str2 = append(str2, string(char))\n    }\n\n    for _, char := range str2 {\n        if vowels[char] {\n            str3 = append(str3, char)\n        }\n    }\n\n    for i, char := range str2 {\n        if vowels[char] {\n            str2[i] = str3[len(str3)-1]\n            str3 = str3[:len(str3)-1]\n        }\n    }\n\n    return fmt.Sprintf(\"%s\", str2)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123568,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmp_f56r9nk_test.go:56: expected 'Python', got '[P y t h o n]'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp_f56r9nk_test.go:56: expected 'ASU', got '[U S A]'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmp_f56r9nk_test.go:56: expected 'ab', got '[a b]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 = str2 + string(str1[i])\n        }\n    }\n    fmt.Println(str2)\n    var str3 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 = str3 + string(str2[len(str2)-1])\n            str2 = str2[:len(str2)-1]\n        } else {\n            str3 = str3 + string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123568,
      "stdout": "o\n\na\n--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp6r8qfaqh_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    var vowel_list []string\n    for _, c := range str1 {\n        if _, ok := vowels[string(c)]; ok {\n            vowel_list = append(vowel_list, string(c))\n        }\n    }\n    for _, c := range str1 {\n        if _, ok := vowels[string(c)]; ok {\n            str2 += vowel_list[len(vowel_list)-1]\n            vowel_list = vowel_list[:len(vowel_list)-1]\n        } else {\n            str2 += string(c)\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123568,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp8nqmqwvn_test.go:50: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for _, char := range str1 {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n            str2 = string(char) + str2\n        }\n    }\n    var str3 string\n    for _, char := range str1 {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n            str3 += string(str2[0])\n            str2 = str2[1:]\n        } else {\n            str3 += string(char)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510567,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpsxj26_zp_test.go:43: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Write your code here\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 string\n    var str3 string\n    for _, char := range str1 {\n        if contains(vowels, string(char)) {\n            str2 += string(char)\n        }\n    }\n    for _, char := range str1 {\n        if contains(vowels, string(char)) {\n            str3 += string(str2[len(str2)-1])\n            str2 = str2[:len(str2)-1]\n        } else {\n            str3 += string(char)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123567,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmp7c0qgh_test.go:15:12: undefined: contains\n/tmp/tmpmp7c0qgh_test.go:20:12: undefined: contains\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str2 string\n    var str3 string\n    var str4 string\n    var str5 string\n    var str6 string\n    var str7 string\n    var str8 string\n    var str9 string\n    var str10 string\n    var str11 string\n    var str12 string\n    var str13 string\n    var str14 string\n    var str15 string\n    var str16 string\n    var str17 string\n    var str18 string\n    var str19 string\n    var str20 string\n    var str21 string\n    var str22 string\n    var str23 string\n    var str24 string\n    var str25 string\n    var str26 string\n    var str27 string\n    var str28 string\n    var str29 string\n    var str30 string\n    var str31 string\n    var str32 string\n    var str33 string\n    var str34 string\n    var str35 string\n    var str36 string\n    var str37 string\n    var str38 string\n    var str39 string\n    var str40 string\n    var str41 string\n    var str42 string\n    var str43 string\n    var str44 string\n    var str45 string\n    var str46 string\n    var str47 string\n    var str48 string\n    var str49 string\n    var str50 string\n    var str51 string\n    var str52 string\n    var str53 string\n    var str54 string\n    var str55 string\n    var str56 string\n    var str57 string\n    var str58 string\n    var str59 string\n    var str60 string\n    var str61 string\n    var str62 string\n    var str63 string\n    var str64 string\n    var str65 string\n    var str66 string\n    var str67 string\n    var str68 string\n    var str69 string\n    var str70 string\n    var str71 string\n    var str72 string\n    var str73 string\n    var str74 string\n    var str75 string\n    var str76 string\n    var str77 string\n    var str78 string\n    var str79 string\n    var str80 string\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123566,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnq4fz4hw_test.go:90:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str1_list = []string{}\n    var str1_vowels = []string{}\n    var str1_vowels_reversed = []string{}\n    var str1_reversed = \"\"\n\n    for _, char := range str1 {\n        str1_list = append(str1_list, string(char))\n    }\n\n    for _, char := range str1_list {\n        for _, vowel := range vowels {\n            if char == vowel {\n                str1_vowels = append(str1_vowels, char)\n            }\n        }\n    }\n\n    for i := len(str1_vowels) - 1; i >= 0; i-- {\n        str1_vowels_reversed = append(str1_vowels_reversed, str1_vowels[i])\n    }\n\n    for i, char := range str1_list {\n        for j, vowel := range str1_vowels {\n            if char == vowel {\n                str1_list[i] = str1_vowels_reversed[j]\n            }\n        }\n    }\n\n    for _, char := range str1_list {\n        str1_reversed += char\n    }\n\n    return str1_reversed\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123568,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 = \"\"\n    var str3 = \"\"\n    for _, char := range str1 {\n        if contains(vowels, string(char)) {\n            str2 = string(char) + str2\n        } else {\n            str3 = str3 + string(char)\n        }\n    }\n    return str3 + str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123567,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp81_q1jwe_test.go:14:12: undefined: contains\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Write your code here\n    return \"\"\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510567,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpty_8pjum_test.go:29: expected 'Python', got ''\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpty_8pjum_test.go:29: expected 'ASU', got ''\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmpty_8pjum_test.go:29: expected 'ab', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Write your code here\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    str1_runes := []rune(str1)\n    str1_runes_len := len(str1_runes)\n    for i, j := 0, str1_runes_len-1; i < j; {\n        if !is_vowel(str1_runes[i], vowels) {\n            i++\n        } else if !is_vowel(str1_runes[j], vowels) {\n            j--\n        } else {\n            str1_runes[i], str1_runes[j] = str1_runes[j], str1_runes[i]\n            i++\n            j--\n        }\n    }\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123567,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptfuzhk3w_test.go:15:13: undefined: is_vowel\n/tmp/tmptfuzhk3w_test.go:17:20: undefined: is_vowel\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := len(str1) - 1; i >= 0; i-- {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 += string(str1[i])\n        }\n    }\n    var str3 string\n    var j int = 0\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510567,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpqgd0dumw_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []rune{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    var str1_runes = []rune(str1)\n    var str1_runes_len = len(str1_runes)\n    var i, j int = 0, str1_runes_len - 1\n    for i < j {\n        if !contains(vowels, str1_runes[i]) {\n            i++\n            continue\n        }\n        if !contains(vowels, str1_runes[j]) {\n            j--\n            continue\n        }\n        str1_runes[i], str1_runes[j] = str1_runes[j], str1_runes[i]\n        i++\n        j--\n    }\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123567,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdkkma6y3_test.go:15:13: undefined: contains\n/tmp/tmpdkkma6y3_test.go:19:13: undefined: contains\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str2 string\n    var str3 string\n    var str4 string\n    var str5 string\n    var str6 string\n    var str7 string\n    var str8 string\n    var str9 string\n    var str10 string\n    var str11 string\n    var str12 string\n    var str13 string\n    var str14 string\n    var str15 string\n    var str16 string\n    var str17 string\n    var str18 string\n    var str19 string\n    var str20 string\n    var str21 string\n    var str22 string\n    var str23 string\n    var str24 string\n    var str25 string\n    var str26 string\n    var str27 string\n    var str28 string\n    var str29 string\n    var str30 string\n    var str31 string\n    var str32 string\n    var str33 string\n    var str34 string\n    var str35 string\n    var str36 string\n    var str37 string\n    var str38 string\n    var str39 string\n    var str40 string\n    var str41 string\n    var str42 string\n    var str43 string\n    var str44 string\n    var str45 string\n    var str46 string\n    var str47 string\n    var str48 string\n    var str49 string\n    var str50 string\n    var str51 string\n    var str52 string\n    var str53 string\n    var str54 string\n    var str55 string\n    var str56 string\n    var str57 string\n    var str58 string\n    var str59 string\n    var str60 string\n    var str61 string\n    var str62 string\n    var str63 string\n    var str64 string\n    var str65 string\n    var str66 string\n    var str67 string\n    var str68 string\n    var str69 string\n    var str70 string\n    var str71 string\n    var str72 string\n    var str73 string\n    var str74 string\n    var str75 string\n    var str76 string\n    var str77 string\n    var str78 string\n    var str79 string\n    var str80 string\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123566,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnq4fz4hw_test.go:90:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := len(str1)-1; i >= 0; i-- {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 += string(str1[i])\n        }\n    }\n    var str3 string\n    var j int\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123568,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpks4rnlh9_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\": true}\n    // Create a slice of characters\n    chars := []string{}\n    // Create a slice of vowels\n    vchars := []string{}\n    // Iterate through the string\n    for _, char := range str1 {\n        // If the character is a vowel, add it to the slice of vowels\n        if _, ok := vowels[string(char)]; ok {\n            vchars = append(vchars, string(char))\n        }\n        // Add the character to the slice of characters\n        chars = append(chars, string(char))\n    }\n    // Iterate through the slice of characters\n    for i, char := range chars {\n        // If the character is a vowel, replace it with the last vowel in the slice of vowels\n        if _, ok := vowels[char]; ok {\n            chars[i] = vchars[len(vchars) - 1]\n            // Remove the last vowel from the slice of vowels\n            vchars = vchars[:len(vchars) - 1]\n        }\n    }\n    // Return the joined slice of characters\n    return fmt.Sprintf(\"%s\", strings.Join(chars, \"\"))\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123567,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpasols27p_test.go:35:30: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := len(str1) - 1; i >= 0; i-- {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 += string(str1[i])\n        }\n    }\n    var str3 string\n    j := 0\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510566,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmppb362zuj_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // convert string to rune slice\n    str1_runes := []rune(str1)\n    // create a map of vowels\n    vowels := map[rune]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true}\n    // create a slice of indexes of vowels\n    var vowel_indexes []int\n    for i, char := range str1_runes {\n        if _, ok := vowels[char]; ok {\n            vowel_indexes = append(vowel_indexes, i)\n        }\n    }\n    // reverse the vowels\n    for i := 0; i < len(vowel_indexes)/2; i++ {\n        str1_runes[vowel_indexes[i]], str1_runes[vowel_indexes[len(vowel_indexes)-1-i]] = str1_runes[vowel_indexes[len(vowel_indexes)-1-i]], str1_runes[vowel_indexes[i]]\n    }\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123568,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpnintom6z_test.go:43: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str1_list = []string{}\n    var str1_vowels = []string{}\n    var str1_vowels_reversed = []string{}\n    var str1_reversed = \"\"\n\n    for _, char := range str1 {\n        str1_list = append(str1_list, string(char))\n    }\n\n    for _, char := range str1_list {\n        for _, vowel := range vowels {\n            if char == vowel {\n                str1_vowels = append(str1_vowels, char)\n            }\n        }\n    }\n\n    for i := len(str1_vowels) - 1; i >= 0; i-- {\n        str1_vowels_reversed = append(str1_vowels_reversed, str1_vowels[i])\n    }\n\n    for i, char := range str1_list {\n        for _, vowel := range vowels {\n            if char == vowel {\n                str1_list[i] = str1_vowels_reversed[0]\n                str1_vowels_reversed = str1_vowels_reversed[1:]\n            }\n        }\n    }\n\n    for _, char := range str1_list {\n        str1_reversed += char\n    }\n\n    return str1_reversed\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123568,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Write your code here\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str2 = []string{}\n    var str3 = []string{}\n    for _, c := range str1 {\n        str2 = append(str2, string(c))\n    }\n    for _, c := range str2 {\n        if contains(vowels, c) {\n            str3 = append(str3, c)\n        }\n    }\n    for i, c := range str2 {\n        if contains(vowels, c) {\n            str2[i] = str3[len(str3)-1]\n            str3 = str3[:len(str3)-1]\n        }\n    }\n    return strings.Join(str2, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123567,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_8x0vsbg_test.go:18:12: undefined: contains\n/tmp/tmp_8x0vsbg_test.go:23:12: undefined: contains\n/tmp/tmp_8x0vsbg_test.go:28:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str2 = []string{}\n    var str3 = []string{}\n    for _, char := range str1 {\n        str2 = append(str2, string(char))\n    }\n    for _, char := range str2 {\n        if contains(vowels, char) {\n            str3 = append(str3, char)\n        }\n    }\n    for i, char := range str2 {\n        if contains(vowels, char) {\n            str2[i] = str3[len(str3)-1]\n            str3 = str3[:len(str3)-1]\n        }\n    }\n    return strings.Join(str2, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123567,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzsoqebou_test.go:17:12: undefined: contains\n/tmp/tmpzsoqebou_test.go:22:12: undefined: contains\n/tmp/tmpzsoqebou_test.go:27:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    str2 := []rune(str1)\n    i, j := 0, len(str2) - 1\n    for i < j {\n        if !is_vowel(str2[i]) {\n            i++\n        } else if !is_vowel(str2[j]) {\n            j--\n        } else {\n            str2[i], str2[j] = str2[j], str2[i]\n            i++\n            j--\n        }\n    }\n    return string(str2)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123567,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg_7gai11_test.go:13:13: undefined: is_vowel\n/tmp/tmpg_7gai11_test.go:15:20: undefined: is_vowel\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 = str2 + string(str1[i])\n        }\n    }\n    str2 = reverse(str2)\n    var str3 string\n    var j int = 0\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 = str3 + string(str2[j])\n            j++\n        } else {\n            str3 = str3 + string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123567,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8cciz8vk_test.go:16:12: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    var str1_runes = []rune(str1)\n    var str1_vowels = []rune{}\n    var str1_vowels_index = []int{}\n    for i, c := range str1_runes {\n        if _, ok := vowels[string(c)]; ok {\n            str1_vowels = append(str1_vowels, c)\n            str1_vowels_index = append(str1_vowels_index, i)\n        }\n    }\n    for i := 0; i < len(str1_vowels_index); i++ {\n        str1_runes[str1_vowels_index[i]] = str1_vowels[len(str1_vowels) - 1 - i]\n    }\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123568,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpxat6dv_k_test.go:47: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    str1_list := []string{}\n    for _, char := range str1 {\n        str1_list = append(str1_list, string(char))\n    }\n    i := 0\n    j := len(str1_list) - 1\n    for i < j {\n        if !contains(vowels, str1_list[i]) {\n            i++\n            continue\n        }\n        if !contains(vowels, str1_list[j]) {\n            j--\n            continue\n        }\n        str1_list[i], str1_list[j] = str1_list[j], str1_list[i]\n        i++\n        j--\n    }\n    return strings.Join(str1_list, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123568,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_psk9zda_test.go:18:13: undefined: contains\n/tmp/tmp_psk9zda_test.go:22:13: undefined: contains\n/tmp/tmp_psk9zda_test.go:30:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Write your code here\n    return \"\"\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510567,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpty_8pjum_test.go:29: expected 'Python', got ''\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpty_8pjum_test.go:29: expected 'ASU', got ''\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmpty_8pjum_test.go:29: expected 'ab', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = map[string]int{\n        \"a\": 1,\n        \"e\": 1,\n        \"i\": 1,\n        \"o\": 1,\n        \"u\": 1,\n    }\n    var str2 string\n    var str3 string\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str2 += string(char)\n        }\n    }\n    for i := len(str2) - 1; i >= 0; i-- {\n        str3 += string(str2[i])\n    }\n    var str4 string\n    var str5 string\n    var j int\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str4 += string(str3[j])\n            j++\n        } else {\n            str4 += string(char)\n        }\n    }\n    for _, char := range str4 {\n        if _, ok := vowels[string(char)]; ok {\n            str5 += string(char)\n        }\n    }\n    return str5\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123569,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmplsi8wloi_test.go:61: expected 'Python', got 'o'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmplsi8wloi_test.go:61: expected 'ASU', got ''\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmplsi8wloi_test.go:61: expected 'ab', got 'a'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // your code here\n    return str1\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123569,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp21ik5iuh_test.go:29: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str2 string\n    var str3 string\n    for _, v := range str1 {\n        if string(v) == \" \" {\n            str2 += \" \"\n            continue\n        }\n        for _, vv := range vowels {\n            if string(v) == vv {\n                str2 += string(v)\n                break\n            }\n        }\n        str3 += string(v)\n    }\n    var str4 string\n    var str5 string\n    for i := len(str2) - 1; i >= 0; i-- {\n        str4 += string(str2[i])\n    }\n    for i := 0; i < len(str3); i++ {\n        if string(str3[i]) == \" \" {\n            str5 += \" \"\n            continue\n        }\n        for _, vv := range vowels {\n            if string(str3[i]) == vv {\n                str5 += string(str4[0])\n                str4 = str4[1:]\n                break\n            }\n        }\n        if string(str3[i]) != \" \" {\n            str5 += string(str3[i])\n        }\n    }\n    return str5\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123569,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmp_fn3xk47_test.go:65: expected 'Python', got 'Pythoon'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp_fn3xk47_test.go:65: expected 'ASU', got 'AUSUA'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmp_fn3xk47_test.go:65: expected 'ab', got 'aab'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Convert string to rune slice\n    str := []rune(str1)\n    // Create a map of vowels\n    vowels := map[rune]bool{\n        'a': true,\n        'e': true,\n        'i': true,\n        'o': true,\n        'u': true,\n    }\n    // Create a slice to store the vowels\n    var vowel_slice []rune\n    // Iterate over the string and store the vowels in the slice\n    for _, char := range str {\n        if _, ok := vowels[char]; ok {\n            vowel_slice = append(vowel_slice, char)\n        }\n    }\n    // Reverse the slice\n    for i, j := 0, len(vowel_slice)-1; i < j; i, j = i+1, j-1 {\n        vowel_slice[i], vowel_slice[j] = vowel_slice[j], vowel_slice[i]\n    }\n    // Iterate over the string and replace the vowels with the reversed slice\n    for i, char := range str {\n        if _, ok := vowels[char]; ok {\n            str[i] = vowel_slice[0]\n            vowel_slice = vowel_slice[1:]\n        }\n    }\n    return string(str)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123569,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpz36ms2dm_test.go:57: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 = str1[i:i+1] + str2\n        }\n    }\n    var str3 string\n    var j int\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 = str3 + str2[j:j+1]\n            j++\n        } else {\n            str3 = str3 + str1[i:i+1]\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510566,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpfm7v5jfw_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    var str2 = []string{}\n    for _, c := range str1 {\n        str2 = append(str2, string(c))\n    }\n    var i, j = 0, len(str2) - 1\n    for i < j {\n        if _, ok := vowels[str2[i]]; ok {\n            if _, ok := vowels[str2[j]]; ok {\n                str2[i], str2[j] = str2[j], str2[i]\n                i++\n                j--\n            } else {\n                j--\n            }\n        } else {\n            i++\n        }\n    }\n    return strings.Join(str2, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123569,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6v107ysk_test.go:35:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]int{\"a\": 1, \"e\": 1, \"i\": 1, \"o\": 1, \"u\": 1}\n    // Create a slice of the string\n    str1_slice := []string{}\n    // Create a slice of the vowels\n    vowels_slice := []string{}\n    // Create a slice of the non-vowels\n    non_vowels_slice := []string{}\n    // Iterate through the string\n    for _, char := range str1 {\n        // If the character is a vowel, add it to the vowels slice\n        if _, ok := vowels[string(char)]; ok {\n            vowels_slice = append(vowels_slice, string(char))\n        } else {\n            non_vowels_slice = append(non_vowels_slice, string(char))\n        }\n    }\n    // Reverse the vowels slice\n    for i, j := 0, len(vowels_slice)-1; i < j; i, j = i+1, j-1 {\n        vowels_slice[i], vowels_slice[j] = vowels_slice[j], vowels_slice[i]\n    }\n    // Iterate through the string\n    for _, char := range str1 {\n        // If the character is a vowel, add it to the vowels slice\n        if _, ok := vowels[string(char)]; ok {\n            str1_slice = append(str1_slice, vowels_slice[0])\n            vowels_slice = vowels_slice[1:]\n        } else {\n            str1_slice = append(str1_slice, non_vowels_slice[0])\n            non_vowels_slice = non_vowels_slice[1:]\n        }\n    }\n    // Return the string\n    return fmt.Sprintf(\"%s\", str1_slice)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123569,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpgvyt_4pd_test.go:61: expected 'Python', got '[P y t h o n]'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpgvyt_4pd_test.go:61: expected 'ASU', got '[U S A]'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmpgvyt_4pd_test.go:61: expected 'ab', got '[a b]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := len(str1) - 1; i >= 0; i-- {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 += string(str1[i])\n        }\n    }\n    var str3 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 += string(str2[0])\n            str2 = str2[1:]\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123569,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp8dm4ccww_test.go:43: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for _, c := range str1 {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            str2 = string(c) + str2\n        }\n    }\n    var str3 string\n    for _, c := range str1 {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            str3 += string(str2[0])\n            str2 = str2[1:]\n        } else {\n            str3 += string(c)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123569,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpa0sjlwbr_test.go:43: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str1_runes = []rune(str1)\n    var str1_vowels = []rune{}\n    var str1_vowels_index = []int{}\n    var str1_vowels_reversed = []rune{}\n    var str1_vowels_reversed_index = 0\n\n    for index, char := range str1_runes {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                str1_vowels = append(str1_vowels, char)\n                str1_vowels_index = append(str1_vowels_index, index)\n            }\n        }\n    }\n\n    for i := len(str1_vowels)-1; i >= 0; i-- {\n        str1_vowels_reversed = append(str1_vowels_reversed, str1_vowels[i])\n    }\n\n    for _, index := range str1_vowels_index {\n        str1_runes[index] = str1_vowels_reversed[str1_vowels_reversed_index]\n        str1_vowels_reversed_index++\n    }\n\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123569,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Write your code here\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str2 string\n    var str3 string\n    var str4 string\n    for _, char := range str1 {\n        str2 = str2 + string(char)\n    }\n    for _, char := range str2 {\n        if string(char) == \"y\" || string(char) == \"Y\" {\n            str3 = str3 + string(char)\n        } else {\n            for _, vowel := range vowels {\n                if string(char) == vowel {\n                    str3 = str3 + string(char)\n                }\n            }\n        }\n    }\n    for _, char := range str2 {\n        if string(char) == \"y\" || string(char) == \"Y\" {\n            str4 = str4 + string(char)\n        } else {\n            for _, vowel := range vowels {\n                if string(char) == vowel {\n                    str4 = str4 + string(char)\n                }\n            }\n        }\n    }\n    for _, char := range str2 {\n        if string(char) == \"y\" || string(char) == \"Y\" {\n            str4 = str4 + string(char)\n        } else {\n            for _, vowel := range vowels {\n                if string(char) == vowel {\n                    str4 = str4 + string(char)\n                }\n            }\n        }\n    }\n    for _, char := range str2 {\n        if string(char) == \"y\" || string(char) == \"Y\" {\n            str4 = str4 + string(char)\n        } else {\n            for _, vowel := range vowels {\n                if string(char) == vowel {\n                    str4 = str4 + string(char)\n                }\n            }\n        }\n    }\n    for _, char := range str2 {\n        if string(char) == \"y\" || string(char) == \"Y\" {\n            str4 = str4 + string(char)\n        }\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123569,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfie28g1g_test.go:66:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    vowels := []rune{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    str1_runes := []rune(str1)\n    for i, j := 0, len(str1_runes)-1; i < j; {\n        if !contains(vowels, str1_runes[i]) {\n            i++\n            continue\n        }\n        if !contains(vowels, str1_runes[j]) {\n            j--\n            continue\n        }\n        str1_runes[i], str1_runes[j] = str1_runes[j], str1_runes[i]\n        i++\n        j--\n    }\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123569,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptn9k4pqd_test.go:13:13: undefined: contains\n/tmp/tmptn9k4pqd_test.go:17:13: undefined: contains\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for _, c := range str1 {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            str2 = string(c) + str2\n        }\n    }\n    var str3 string\n    for _, c := range str1 {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            str3 += string(str2[0])\n            str2 = str2[1:]\n        } else {\n            str3 += string(c)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123569,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpa0sjlwbr_test.go:43: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\": true}\n    for _, char := range str1 {\n        if vowels[string(char)] {\n            str2 = string(char) + str2\n        }\n    }\n    var str3 string\n    var i = 0\n    for _, char := range str1 {\n        if vowels[string(char)] {\n            str3 += string(str2[i])\n            i++\n        } else {\n            str3 += string(char)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123570,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpx3lw4mn5_test.go:45: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for _, char := range str1 {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n            str2 = string(char) + str2\n        } else {\n            str2 = str2 + string(char)\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510567,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpbkpj6qqs_test.go:36: expected 'Python', got 'oPythn'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpbkpj6qqs_test.go:36: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str_vowels []string\n    var str_consonants []string\n    var str_vowels_reversed []string\n    var str_final []string\n    for _, char := range str1 {\n        if string(char) == \" \" {\n            str_final = append(str_final, string(char))\n        } else {\n            str_consonants = append(str_consonants, string(char))\n        }\n    }\n    for _, char := range str_consonants {\n        for _, vowel := range vowels {\n            if char == vowel {\n                str_vowels = append(str_vowels, char)\n            }\n        }\n    }\n    for i := len(str_vowels) - 1; i >= 0; i-- {\n        str_vowels_reversed = append(str_vowels_reversed, str_vowels[i])\n    }\n    for i := 0; i < len(str_consonants); i++ {\n        for _, vowel := range vowels {\n            if str_consonants[i] == vowel {\n                str_final = append(str_final, str_vowels_reversed[0])\n                str_vowels_reversed = str_vowels_reversed[1:]\n            }\n        }\n        if len(str_vowels_reversed) == 0 {\n            str_final = append(str_final, str_consonants[i])\n        }\n    }\n    for _, char := range str_final {\n        str2 += char\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123570,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpgcbbhprq_test.go:65: expected 'Python', got 'oon'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpgcbbhprq_test.go:65: expected 'ASU', got 'USA'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmpgcbbhprq_test.go:65: expected 'ab', got 'aab'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]int{\"a\": 1, \"e\": 1, \"i\": 1, \"o\": 1, \"u\": 1}\n    // Create a slice of the string\n    str1_slice := []string{}\n    // Create a slice of the vowels\n    vowels_slice := []string{}\n    // Iterate over the string\n    for _, char := range str1 {\n        // If the character is a vowel, add it to the vowels slice\n        if _, ok := vowels[string(char)]; ok {\n            vowels_slice = append(vowels_slice, string(char))\n        }\n        // Add the character to the string slice\n        str1_slice = append(str1_slice, string(char))\n    }\n    // Reverse the vowels slice\n    for i, j := 0, len(vowels_slice)-1; i < j; i, j = i+1, j-1 {\n        vowels_slice[i], vowels_slice[j] = vowels_slice[j], vowels_slice[i]\n    }\n    // Iterate over the string slice\n    for i, char := range str1_slice {\n        // If the character is a vowel, replace it with the corresponding vowel from the reversed vowels slice\n        if _, ok := vowels[char]; ok {\n            str1_slice[i] = vowels_slice[0]\n            vowels_slice = vowels_slice[1:]\n        }\n    }\n    // Return the string slice as a string\n    return fmt.Sprintf(\"%s\", str1_slice)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123570,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmp7_9a758v_test.go:56: expected 'Python', got '[P y t h o n]'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp7_9a758v_test.go:56: expected 'ASU', got '[U S A]'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmp7_9a758v_test.go:56: expected 'ab', got '[a b]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for _, char := range str1 {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n            str2 = string(char) + str2\n        } else {\n            str2 += string(char)\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123570,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmp05hyxh9n_test.go:36: expected 'Python', got 'oPythn'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp05hyxh9n_test.go:36: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []rune{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    var str1_runes = []rune(str1)\n    var str1_vowels = []rune{}\n    var str1_vowels_index = []int{}\n    var str1_vowels_index_reverse = []int{}\n    var str1_vowels_reverse = []rune{}\n    var str1_vowels_reverse_index = []int{}\n    var str1_vowels_reverse_index_reverse = []int{}\n    var str1_vowels_reverse_index_reverse_index = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse_index = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse_index = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse_index_reverse = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index_reverse = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index_reverse = []int{}\n    var str1_vowels_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index_reverse_index = []int{\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123569,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp7jyzlhe3_test.go:29:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 string\n    var str3 string\n    for _, char := range str1 {\n        if contains(vowels, string(char)) {\n            str2 += string(char)\n        }\n    }\n    for _, char := range str1 {\n        if contains(vowels, string(char)) {\n            str3 += string(str2[len(str2)-1])\n            str2 = str2[:len(str2)-1]\n        } else {\n            str3 += string(char)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123570,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwsn2751z_test.go:14:12: undefined: contains\n/tmp/tmpwsn2751z_test.go:19:12: undefined: contains\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\": true}\n    for _, char := range str1 {\n        if vowels[string(char)] {\n            str2 = string(char) + str2\n        }\n    }\n    var str3 string\n    var j int\n    for _, char := range str1 {\n        if vowels[string(char)] {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(char)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123570,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpu_dqfuag_test.go:45: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str1_list = []string{}\n    var str1_vowels = []string{}\n    var str1_vowels_reversed = []string{}\n    var str1_reversed = \"\"\n\n    for _, char := range str1 {\n        str1_list = append(str1_list, string(char))\n    }\n\n    for _, char := range str1_list {\n        for _, vowel := range vowels {\n            if char == vowel {\n                str1_vowels = append(str1_vowels, char)\n            }\n        }\n    }\n\n    for i := len(str1_vowels) - 1; i >= 0; i-- {\n        str1_vowels_reversed = append(str1_vowels_reversed, str1_vowels[i])\n    }\n\n    for i, char := range str1_list {\n        for _, vowel := range vowels {\n            if char == vowel {\n                str1_list[i] = str1_vowels_reversed[0]\n                str1_vowels_reversed = str1_vowels_reversed[1:]\n            }\n        }\n    }\n\n    for _, char := range str1_list {\n        str1_reversed += char\n    }\n\n    return str1_reversed\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123568,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str2 = \"\"\n    var str3 = \"\"\n    for _, char := range str1 {\n        if is_vowel(string(char), vowels) {\n            str2 += string(char)\n        }\n    }\n    for i := len(str2) - 1; i >= 0; i-- {\n        str3 += string(str2[i])\n    }\n    var str4 = \"\"\n    var j = 0\n    for _, char := range str1 {\n        if is_vowel(string(char), vowels) {\n            str4 += string(str3[j])\n            j++\n        } else {\n            str4 += string(char)\n        }\n    }\n    return str4\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123570,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpygsnkcgy_test.go:14:12: undefined: is_vowel\n/tmp/tmpygsnkcgy_test.go:24:12: undefined: is_vowel\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str1_list = []string{}\n    var str1_vowels = []string{}\n    var str1_vowels_reverse = []string{}\n    var str1_vowels_reverse_index = []int{}\n    var str1_vowels_reverse_index_count = 0\n    var str1_vowels_reverse_index_count_max = 0\n    var str1_vowels_reverse_index_count_max_index = 0\n    var str1_vowels_reverse_index_count_max_index_list = []int{}\n    var str1_vowels_reverse_index_count_max_index_list_count = 0\n    var str1_vowels_reverse_index_count_max_index_list_count_max = 0\n    var str1_vowels_reverse_index_count_max_index_list_count_max_index = 0\n    var str1_vowels_reverse_index_count_max_index_list_count_max_index_list = []int{}\n    var str1_vowels_reverse_index_count_max_index_list_count_max_index_list_count = 0\n    var str1_vowels_reverse_index_count_max_index_list_count_max_index_list_count_max = 0\n    var str1_vowels_reverse_index_count_max_index_list_count_max_index_list_count_max_index = 0\n    var str1_vowels_reverse_index_count_max_index_list_count_max_index_list_count_max_index_list = []int{}\n    var str1_vowels_reverse_index_count_max_index_list_count_max_index_list_count_max_index_list_count = 0\n    var str1_vowels_reverse_index_count_max_index_list_count_max_index_\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123569,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2zt0r3g5_test.go:28:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for _, c := range str1 {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            str2 = string(c) + str2\n        }\n    }\n    var str3 string\n    for _, c := range str1 {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            str3 += string(str2[0])\n            str2 = str2[1:]\n        } else {\n            str3 += string(c)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123569,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpa0sjlwbr_test.go:43: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\": true}\n    var vowels_list []string\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            vowels_list = append(vowels_list, string(char))\n        }\n    }\n    for i, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str2 += vowels_list[len(vowels_list) - i - 1]\n        } else {\n            str2 += string(char)\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123570,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\npanic: runtime error: index out of range [-4] [recovered]\n\tpanic: runtime error: index out of range [-4]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x5364c0, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x5364c0, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.reverse_vowels(0x545abf, 0x6, 0x4cd164, 0x5fa500)\n\t/tmp/tmpvz32vpap_test.go:20 +0x536\ncommand-line-arguments_test.TestReverse_Vowels(0xc000186300)\n\t/tmp/tmpvz32vpap_test.go:35 +0x53\ntesting.tRunner(0xc000186300, 0x54f4d8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    str1_list := []string{}\n    for _, char := range str1 {\n        str1_list = append(str1_list, string(char))\n    }\n    vowels_list := []string{}\n    for _, char := range str1_list {\n        for _, vowel := range vowels {\n            if char == vowel {\n                vowels_list = append(vowels_list, char)\n            }\n        }\n    }\n    for i, char := range str1_list {\n        for _, vowel := range vowels {\n            if char == vowel {\n                str1_list[i] = vowels_list[len(vowels_list)-1]\n                vowels_list = vowels_list[:len(vowels_list)-1]\n            }\n        }\n    }\n    return strings.Join(str1_list, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123570,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp72zhh756_test.go:31:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Write your code here\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    str1_list := []string{}\n    for _, char := range str1 {\n        str1_list = append(str1_list, string(char))\n    }\n    for i, char := range str1_list {\n        for _, vowel := range vowels {\n            if char == vowel {\n                for j := len(str1_list) - 1; j > i; j-- {\n                    for _, vowel := range vowels {\n                        if str1_list[j] == vowel {\n                            str1_list[i], str1_list[j] = str1_list[j], str1_list[i]\n                            break\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return strings.Join(str1_list, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123570,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6_fj84qg_test.go:30:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Initialize a string slice to store the vowels\n    vowels := []string{}\n    // Initialize a string slice to store the consonants\n    consonants := []string{}\n    // Initialize a string slice to store the result\n    result := []string{}\n    // Initialize a string slice to store the vowels\n    vowels_map := map[string]int{\n        \"a\": 1,\n        \"e\": 1,\n        \"i\": 1,\n        \"o\": 1,\n        \"u\": 1,\n    }\n    // Initialize a string slice to store the consonants\n    consonants_map := map[string]int{\n        \"b\": 1,\n        \"c\": 1,\n        \"d\": 1,\n        \"f\": 1,\n        \"g\": 1,\n        \"h\": 1,\n        \"j\": 1,\n        \"k\": 1,\n        \"l\": 1,\n        \"m\": 1,\n        \"n\": 1,\n        \"p\": 1,\n        \"q\": 1,\n        \"r\": 1,\n        \"s\": 1,\n        \"t\": 1,\n        \"v\": 1,\n        \"w\": 1,\n        \"x\": 1,\n        \"y\": 1,\n        \"z\": 1,\n    }\n    // Loop through the string\n    for _, char := range str1 {\n        // If the character is a vowel, append it to the vowels slice\n        if _, ok := vowels_map[string(char)]; ok {\n            vowels = append(vowels, string(char))\n        } else {\n            // If the character is a consonant, append it to the consonants slice\n            if _, ok := consonants_map[string(char)]; ok {\n                consonants = append(consonants, string(char))\n            }\n        }\n    }\n    // Loop through the string\n    for _, char := range str1 {\n        // If the character is a vowel, append it to the result slice\n        if _, ok := vowels_map[string(char)]; ok {\n            result = append(result, vowels[len(vowels)-1])\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123570,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprkjgq8mz_test.go:66:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\": true}\n    var str1_runes = []rune(str1)\n    var str1_vowels = []rune{}\n    var str1_vowels_index = []int{}\n    for i, r := range str1_runes {\n        if _, ok := vowels[string(r)]; ok {\n            str1_vowels = append(str1_vowels, r)\n            str1_vowels_index = append(str1_vowels_index, i)\n        }\n    }\n    for i, r := range str1_vowels {\n        str1_runes[str1_vowels_index[i]] = r\n    }\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123571,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpbe3gzw_e_test.go:41: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Write your code here\n    return \"\"\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510567,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpty_8pjum_test.go:29: expected 'Python', got ''\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpty_8pjum_test.go:29: expected 'ASU', got ''\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmpty_8pjum_test.go:29: expected 'ab', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for _, char := range str1 {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n            str2 = string(char) + str2\n        }\n    }\n    var str3 string\n    for _, char := range str1 {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n            str3 += string(str2[0])\n            str2 = str2[1:]\n        } else {\n            str3 += string(char)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510567,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpsxj26_zp_test.go:43: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Write your code here\n    var vowels = map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    var str_arr = []string{}\n    var vowels_arr = []string{}\n    for _, char := range str1 {\n        str_arr = append(str_arr, string(char))\n        if vowels[string(char)] {\n            vowels_arr = append(vowels_arr, string(char))\n        }\n    }\n    for i, char := range str_arr {\n        if vowels[string(char)] {\n            str_arr[i] = vowels_arr[len(vowels_arr)-1]\n            vowels_arr = vowels_arr[:len(vowels_arr)-1]\n        }\n    }\n    return strings.Join(str_arr, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123571,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7giisf6j_test.go:32:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]string{\"a\": \"a\", \"e\": \"e\", \"i\": \"i\", \"o\": \"o\", \"u\": \"u\"}\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str2 = string(char) + str2\n        }\n    }\n    var str3 string\n    var j int\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(char)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123571,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpxvopwpq0_test.go:45: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str1_vowels []string\n    var str1_vowels_reversed []string\n    var str1_reversed string\n\n    for _, char := range str1 {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                str1_vowels = append(str1_vowels, string(char))\n            }\n        }\n    }\n\n    for i := len(str1_vowels) - 1; i >= 0; i-- {\n        str1_vowels_reversed = append(str1_vowels_reversed, str1_vowels[i])\n    }\n\n    for i, char := range str1 {\n        for j, vowel := range str1_vowels {\n            if string(char) == vowel {\n                str1_reversed += str1_vowels_reversed[j]\n            } else {\n                str1_reversed += string(str1[i])\n            }\n        }\n    }\n\n    return str1_reversed\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123572,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp9u_8pkq__test.go:55: expected 'ASU', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := len(str1) - 1; i >= 0; i-- {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 += string(str1[i])\n        }\n    }\n    var str3 string\n    var j int = 0\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510567,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpqgd0dumw_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 = \"\"\n    var str3 = \"\"\n    for _, char := range str1 {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                str2 += string(char)\n            }\n        }\n    }\n    for i := len(str2) - 1; i >= 0; i-- {\n        str3 += string(str2[i])\n    }\n    var str4 = \"\"\n    var str5 = \"\"\n    var j = 0\n    for _, char := range str1 {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                str4 += string(str3[j])\n                j++\n            } else {\n                str4 += string(char)\n            }\n        }\n    }\n    for i := len(str4) - 1; i >= 0; i-- {\n        str5 += string(str4[i])\n    }\n    return str5\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123572,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmphqz9dla__test.go:57: expected 'Python', got 'nnnnnooooohhhhhtttttyyyyyPPPPP'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmphqz9dla__test.go:57: expected 'ASU', got 'AAAAASSSSSUUUUU'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmphqz9dla__test.go:57: expected 'ab', got 'bbbbbaaaaa'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for _, char := range str1 {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n            str2 = string(char) + str2\n        }\n    }\n    var str3 string\n    for _, char := range str1 {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n            str3 += string(str2[0])\n            str2 = str2[1:]\n        } else {\n            str3 += string(char)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510567,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpsxj26_zp_test.go:43: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str1_runes = []rune(str1)\n    var str1_vowels = []string{}\n    var str1_vowels_runes = []rune{}\n    var str1_vowels_runes_reversed = []rune{}\n    var str1_vowels_reversed = []string{}\n    var str1_reversed = \"\"\n    for _, char := range str1_runes {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                str1_vowels = append(str1_vowels, string(char))\n            }\n        }\n    }\n    for _, char := range str1_vowels {\n        str1_vowels_runes = append(str1_vowels_runes, []rune(char)[0])\n    }\n    for i := len(str1_vowels_runes) - 1; i >= 0; i-- {\n        str1_vowels_runes_reversed = append(str1_vowels_runes_reversed, str1_vowels_runes[i])\n    }\n    for _, char := range str1_vowels_runes_reversed {\n        str1_vowels_reversed = append(str1_vowels_reversed, string(char))\n    }\n    for i, char := range str1_runes {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                str1_reversed += str1_vowels_reversed[i]\n            } else {\n                str1_reversed += string(char)\n            }\n        }\n    }\n    return str1_reversed\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123572,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\npanic: runtime error: index out of range [4] with length 1 [recovered]\n\tpanic: runtime error: index out of range [4] with length 1\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x5363a0, 0xc0001580c0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x5363a0, 0xc0001580c0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.reverse_vowels(0x545862, 0x6, 0x4cd224, 0x5fa378)\n\t/tmp/tmperkug4m0_test.go:36 +0x95b\ncommand-line-arguments_test.TestReverse_Vowels(0xc000102600)\n\t/tmp/tmperkug4m0_test.go:52 +0x53\ntesting.tRunner(0xc000102600, 0x54f278)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str1_list = []string{}\n    var str1_vowels = []string{}\n    var str1_vowels_reversed = []string{}\n    var str1_vowels_reversed_index = []int{}\n    var str1_vowels_reversed_index_counter = 0\n    var str1_vowels_reversed_index_counter_max = 0\n    var str1_vowels_reversed_index_counter_max_index = 0\n    var str1_vowels_reversed_index_counter_max_index_counter = 0\n    var str1_vowels_reversed_index_counter_max_index_counter_max = 0\n    var str1_vowels_reversed_index_counter_max_index_counter_max_index = 0\n    var str1_vowels_reversed_index_counter_max_index_counter_max_index_counter = 0\n    var str1_vowels_reversed_index_counter_max_index_counter_max_index_counter_max = 0\n    var str1_vowels_reversed_index_counter_max_index_counter_max_index_counter_max_index = 0\n    var str1_vowels_reversed_index_counter_max_index_counter_max_index_counter_max_index_counter = 0\n    var str1_vowels_reversed_index_counter_max_index_counter_max_index_counter_max_index_counter_max = 0\n    var str1_vowels_reversed_index_counter_max_index_counter_max_index_counter_max_index_counter_max_index = 0\n    var str1_vowels_reversed_index_counter_max_index_counter_max_index_counter_max_index_counter_max_index_counter = 0\n    var str1_v\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123571,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpwfc7ay6e_test.go:28:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str1_runes = []rune(str1)\n    var str1_vowels []string\n    var str1_vowels_index []int\n    var str1_vowels_index_reversed []int\n\n    for i, v := range str1_runes {\n        for _, vv := range vowels {\n            if string(v) == vv {\n                str1_vowels = append(str1_vowels, string(v))\n                str1_vowels_index = append(str1_vowels_index, i)\n            }\n        }\n    }\n\n    for i := len(str1_vowels_index) - 1; i >= 0; i-- {\n        str1_vowels_index_reversed = append(str1_vowels_index_reversed, str1_vowels_index[i])\n    }\n\n    for i, v := range str1_vowels_index_reversed {\n        str1_runes[v] = []rune(str1_vowels[i])[0]\n    }\n\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123572,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]string{\"a\": \"a\", \"e\": \"e\", \"i\": \"i\", \"o\": \"o\", \"u\": \"u\"}\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str2 = string(char) + str2\n        }\n    }\n    var str3 string\n    var j int = 0\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(char)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123572,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmperr731ua_test.go:45: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    str2 := []byte(str1)\n    i := 0\n    j := len(str2) - 1\n    for i < j {\n        if str2[i] == 'a' || str2[i] == 'e' || str2[i] == 'i' || str2[i] == 'o' || str2[i] == 'u' {\n            for j > i {\n                if str2[j] == 'a' || str2[j] == 'e' || str2[j] == 'i' || str2[j] == 'o' || str2[j] == 'u' {\n                    str2[i], str2[j] = str2[j], str2[i]\n                    j--\n                    break\n                }\n                j--\n            }\n        }\n        i++\n    }\n    return string(str2)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123572,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpas50wqpn_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 = \"\"\n    var str3 = \"\"\n    var str4 = \"\"\n    var str5 = \"\"\n    var str6 = \"\"\n    var str7 = \"\"\n    var str8 = \"\"\n    var str9 = \"\"\n    var str10 = \"\"\n    var str11 = \"\"\n    var str12 = \"\"\n    var str13 = \"\"\n    var str14 = \"\"\n    var str15 = \"\"\n    var str16 = \"\"\n    var str17 = \"\"\n    var str18 = \"\"\n    var str19 = \"\"\n    var str20 = \"\"\n    var str21 = \"\"\n    var str22 = \"\"\n    var str23 = \"\"\n    var str24 = \"\"\n    var str25 = \"\"\n    var str26 = \"\"\n    var str27 = \"\"\n    var str28 = \"\"\n    var str29 = \"\"\n    var str30 = \"\"\n    var str31 = \"\"\n    var str32 = \"\"\n    var str33 = \"\"\n    var str34 = \"\"\n    var str35 = \"\"\n    var str36 = \"\"\n    var str37 = \"\"\n    var str38 = \"\"\n    var str39 = \"\"\n    var str40 = \"\"\n    var str41 = \"\"\n    var str42 = \"\"\n    var str43 = \"\"\n    var str44 = \"\"\n    var str45 = \"\"\n    var str46 = \"\"\n    var str47 = \"\"\n    var str48 = \"\"\n    var str49 = \"\"\n    var str50 = \"\"\n    var str51 = \"\"\n    var str52 = \"\"\n    var str53 = \"\"\n    var str54 = \"\"\n    var str55 = \"\"\n    var str56 = \"\"\n    var str57 = \"\"\n    var str58 = \"\"\n    var str59 = \"\"\n    var str60 = \"\"\n    var str61 = \"\"\n    var str62 = \"\"\n    var str63 = \"\"\n    var str64 = \"\"\n    var str65 = \"\"\n    var str66 = \"\"\n    var str67 = \"\"\n    var str68 = \"\"\n    var str69 = \"\"\n    var str70 = \"\"\n    var str71 =\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123571,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpft3knhvq_test.go:81:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // create a map of vowels\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\": true}\n    // create a slice of the string\n    str1_slice := []string{}\n    // create a slice of the vowels\n    vowels_slice := []string{}\n    // create a slice of the non-vowels\n    non_vowels_slice := []string{}\n    // iterate through the string\n    for _, letter := range str1 {\n        // if the letter is a vowel\n        if vowels[string(letter)] {\n            // append the letter to the vowels slice\n            vowels_slice = append(vowels_slice, string(letter))\n        } else {\n            // append the letter to the non-vowels slice\n            non_vowels_slice = append(non_vowels_slice, string(letter))\n        }\n    }\n    // reverse the vowels slice\n    for i, j := 0, len(vowels_slice)-1; i < j; i, j = i+1, j-1 {\n        vowels_slice[i], vowels_slice[j] = vowels_slice[j], vowels_slice[i]\n    }\n    // iterate through the string\n    for _, letter := range str1 {\n        // if the letter is a vowel\n        if vowels[string(letter)] {\n            // append the letter to the vowels slice\n            str1_slice = append(str1_slice, vowels_slice[0])\n            // remove the letter from the vowels slice\n            vowels_slice = vowels_slice[1:]\n        } else {\n            // append the letter to the non-vowels slice\n            str1_slice = append(str1_slice, non_vowels_slice[0])\n            // remove the letter from the non-vowels slice\n            non_vowels_slice = non_vowels_slice[1:]\n        }\n    }\n    // return the string\n    return strings.Join(str1_slice, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123572,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpffbu6iz9_test.go:49:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123568,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'Python', got ''\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'ASU', got ''\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'ab', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for _, c := range str1 {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            str2 = string(c) + str2\n        }\n    }\n    var str3 string\n    for _, c := range str1 {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            str3 += string(str2[0])\n            str2 = str2[1:]\n        } else {\n            str3 += string(c)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123569,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpa0sjlwbr_test.go:43: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 = str2 + string(str1[i])\n        }\n    }\n    fmt.Println(str2)\n    var str3 string\n    for i := len(str2) - 1; i >= 0; i-- {\n        str3 = str3 + string(str2[i])\n    }\n    fmt.Println(str3)\n    var str4 string\n    var j int = 0\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str4 = str4 + string(str3[j])\n            j++\n        } else {\n            str4 = str4 + string(str1[i])\n        }\n    }\n    return str4\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123572,
      "stdout": "o\no\n\n\na\na\n--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp4u72ebwz_test.go:50: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 = str1[i:i+1] + str2\n        }\n    }\n    var str3 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 = str3 + str2[0:1]\n            str2 = str2[1:]\n        } else {\n            str3 = str3 + str1[i:i+1]\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510567,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpnbsa4jg2_test.go:43: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for _, c := range str1 {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            str2 = string(c) + str2\n        }\n    }\n    var str3 string\n    for _, c := range str1 {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            str3 += string(str2[0])\n            str2 = str2[1:]\n        } else {\n            str3 += string(c)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123569,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpa0sjlwbr_test.go:43: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    var str2 = \"\"\n    var str3 = \"\"\n    for _, char := range str1 {\n        if vowels[string(char)] {\n            str2 = string(char) + str2\n        } else {\n            str3 = string(char) + str3\n        }\n    }\n    var str4 = \"\"\n    var j = 0\n    for _, char := range str1 {\n        if vowels[string(char)] {\n            str4 = str4 + string(str2[j])\n            j++\n        } else {\n            str4 = str4 + string(char)\n        }\n    }\n    return str4\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123572,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp6mn61v_a_test.go:54: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = map[string]int{\"a\": 1, \"e\": 1, \"i\": 1, \"o\": 1, \"u\": 1}\n    var str2 string\n    var str3 string\n    for _, s := range str1 {\n        if _, ok := vowels[string(s)]; ok {\n            str2 = str2 + string(s)\n        } else {\n            str3 = str3 + string(s)\n        }\n    }\n    var str4 string\n    for _, s := range str3 {\n        str4 = str4 + string(s)\n    }\n    for i := len(str2) - 1; i >= 0; i-- {\n        str4 = str4 + string(str2[i])\n    }\n    return str4\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123572,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpyr85rznr_test.go:45: expected 'Python', got 'Pythno'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpyr85rznr_test.go:45: expected 'ASU', got 'USA'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmpyr85rznr_test.go:45: expected 'ab', got 'ba'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := len(str1) - 1; i >= 0; i-- {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 += string(str1[i])\n        }\n    }\n    fmt.Println(str2)\n    var str3 string\n    var j int\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123572,
      "stdout": "o\n\na\n--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpoldtmz8k_test.go:45: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str_list = []string{}\n    var vowels_list = []string{}\n    var result = \"\"\n    for _, char := range str1 {\n        str_list = append(str_list, string(char))\n    }\n    for _, char := range str1 {\n        if contains(vowels, string(char)) {\n            vowels_list = append(vowels_list, string(char))\n        }\n    }\n    for i, char := range str_list {\n        if contains(vowels, char) {\n            str_list[i] = vowels_list[len(vowels_list)-1]\n            vowels_list = vowels_list[:len(vowels_list)-1]\n        }\n    }\n    for _, char := range str_list {\n        result += char\n    }\n    return result\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123572,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph66u3my7_test.go:18:12: undefined: contains\n/tmp/tmph66u3my7_test.go:23:12: undefined: contains\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    var vowel_stack []string\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            vowel_stack = append(vowel_stack, string(char))\n        }\n    }\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str2 += vowel_stack[len(vowel_stack)-1]\n            vowel_stack = vowel_stack[:len(vowel_stack)-1]\n        } else {\n            str2 += string(char)\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123572,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmprjptfw4w_test.go:50: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := len(str1) - 1; i >= 0; i-- {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 += string(str1[i])\n        }\n    }\n    var str3 string\n    var j int = 0\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510567,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpqgd0dumw_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    str := []rune(str1)\n    vowels := []rune{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    var vowel_indices []int\n    for i, c := range str {\n        for _, v := range vowels {\n            if c == v {\n                vowel_indices = append(vowel_indices, i)\n            }\n        }\n    }\n    for i, j := 0, len(vowel_indices)-1; i < j; i, j = i+1, j-1 {\n        str[vowel_indices[i]], str[vowel_indices[j]] = str[vowel_indices[j]], str[vowel_indices[i]]\n    }\n    return string(str)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123572,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Write your code here\n    return str1\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123572,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp9jfnulsu_test.go:29: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for _, c := range str1 {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            str2 = string(c) + str2\n        }\n    }\n    var str3 string\n    for _, c := range str1 {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            str3 += string(str2[0])\n            str2 = str2[1:]\n        } else {\n            str3 += string(c)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123569,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpa0sjlwbr_test.go:43: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 = str2 + string(str1[i])\n        }\n    }\n    fmt.Println(str2)\n    var str3 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 = str3 + string(str2[len(str2)-1])\n            str2 = str2[:len(str2)-1]\n        } else {\n            str3 = str3 + string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123568,
      "stdout": "o\n\na\n--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp6r8qfaqh_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // your code here\n    return str1\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123569,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp21ik5iuh_test.go:29: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str2 = \"\"\n    var str3 = \"\"\n    for _, char := range str1 {\n        if is_vowel(string(char), vowels) {\n            str2 += string(char)\n        }\n    }\n    for _, char := range str1 {\n        if is_vowel(string(char), vowels) {\n            str3 += string(str2[len(str2)-1])\n            str2 = str2[:len(str2)-1]\n        } else {\n            str3 += string(char)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123572,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb36imai3_test.go:14:12: undefined: is_vowel\n/tmp/tmpb36imai3_test.go:19:12: undefined: is_vowel\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    var vowel_stack []string\n\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            vowel_stack = append(vowel_stack, string(char))\n        }\n    }\n\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str2 += vowel_stack[len(vowel_stack)-1]\n            vowel_stack = vowel_stack[:len(vowel_stack)-1]\n        } else {\n            str2 += string(char)\n        }\n    }\n\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123572,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpcpg8zxvm_test.go:53: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123568,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'Python', got ''\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'ASU', got ''\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'ab', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := len(str1) - 1; i >= 0; i-- {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 += string(str1[i])\n        }\n    }\n    var str3 string\n    var j int = 0\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510567,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpqgd0dumw_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str1_arr = []string{}\n    var vowels_arr = []string{}\n    var result = \"\"\n\n    for _, char := range str1 {\n        str1_arr = append(str1_arr, string(char))\n    }\n\n    for _, char := range str1_arr {\n        for _, vowel := range vowels {\n            if char == vowel {\n                vowels_arr = append(vowels_arr, char)\n            }\n        }\n    }\n\n    for _, char := range str1_arr {\n        for _, vowel := range vowels {\n            if char == vowel {\n                result += vowels_arr[len(vowels_arr)-1]\n                vowels_arr = vowels_arr[:len(vowels_arr)-1]\n            } else {\n                result += char\n            }\n        }\n    }\n\n    return result\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123572,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmprb91t0o0_test.go:56: expected 'Python', got 'PPPPPPPPPPyyyyyyyyyytttttttttthhhhhhhhhhoooooooooonnnnnnnnnn'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmprb91t0o0_test.go:56: expected 'ASU', got 'UUUUUUUUUASSSSSSSSSSAAAAAUAAAA'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmprb91t0o0_test.go:56: expected 'ab', got 'aaaaaaaaaabbbbbbbbbb'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := len(str1) - 1; i >= 0; i-- {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 += string(str1[i])\n        }\n    }\n    var str3 string\n    j := 0\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510566,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmppb362zuj_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for _, c := range str1 {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            str2 = string(c) + str2\n        }\n    }\n    var str3 string\n    for _, c := range str1 {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            str3 = str3 + string(str2[0])\n            str2 = str2[1:]\n        } else {\n            str3 = str3 + string(c)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510567,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpf7ch_drg_test.go:43: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 = str1[i:i+1] + str2\n        }\n    }\n    var str3 string\n    var j int = 0\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 = str3 + str2[j:j+1]\n            j++\n        } else {\n            str3 = str3 + str1[i:i+1]\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123573,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpysqowxca_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Write your code here\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 string\n    var str3 string\n    var str4 string\n    var str5 string\n    var str6 string\n    var str7 string\n    var str8 string\n    var str9 string\n    var str10 string\n    var str11 string\n    var str12 string\n    var str13 string\n    var str14 string\n    var str15 string\n    var str16 string\n    var str17 string\n    var str18 string\n    var str19 string\n    var str20 string\n    var str21 string\n    var str22 string\n    var str23 string\n    var str24 string\n    var str25 string\n    var str26 string\n    var str27 string\n    var str28 string\n    var str29 string\n    var str30 string\n    var str31 string\n    var str32 string\n    var str33 string\n    var str34 string\n    var str35 string\n    var str36 string\n    var str37 string\n    var str38 string\n    var str39 string\n    var str40 string\n    var str41 string\n    var str42 string\n    var str43 string\n    var str44 string\n    var str45 string\n    var str46 string\n    var str47 string\n    var str48 string\n    var str49 string\n    var str50 string\n    var str51 string\n    var str52 string\n    var str53 string\n    var str54 string\n    var str55 string\n    var str56 string\n    var str57 string\n    var str58 string\n    var str59 string\n    var str60 string\n    var str61 string\n    var str62 string\n    var str63 string\n    var str64 string\n    var str65 string\n    var str66 string\n    var str67 string\n    var str68 string\n    var str69 string\n    var str70 string\n    var str71 string\n    var str72 string\n    var str73 string\n    var str74 string\n    var str75 string\n    var str76 string\n    var str77 string\n    var str78 string\n    var str79 string\n    var str80 string\n    var str81 string\n   \nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123572,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfhci5_9p_test.go:93:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 = str1[i:i+1] + str2\n        }\n    }\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 = str2[1:]\n        } else {\n            str2 = str1[i:i+1] + str2\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123573,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpatet_0b8_test.go:41: expected 'Python', got 'ntyPo'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmpatet_0b8_test.go:41: expected 'ab', got 'b'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Write your code here\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    str1_arr := []string{}\n    for _, char := range str1 {\n        str1_arr = append(str1_arr, string(char))\n    }\n    fmt.Println(str1_arr)\n    i := 0\n    j := len(str1_arr) - 1\n    for i < j {\n        if !contains(vowels, str1_arr[i]) {\n            i++\n            continue\n        }\n        if !contains(vowels, str1_arr[j]) {\n            j--\n            continue\n        }\n        str1_arr[i], str1_arr[j] = str1_arr[j], str1_arr[i]\n        i++\n        j--\n    }\n    return strings.Join(str1_arr, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123573,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjv5i0ia0_test.go:20:13: undefined: contains\n/tmp/tmpjv5i0ia0_test.go:24:13: undefined: contains\n/tmp/tmpjv5i0ia0_test.go:32:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 = []string{}\n    var str3 = []string{}\n    for _, c := range str1 {\n        str2 = append(str2, string(c))\n    }\n    for _, c := range str2 {\n        if contains(vowels, c) {\n            str3 = append(str3, c)\n        }\n    }\n    for i, c := range str2 {\n        if contains(vowels, c) {\n            str2[i] = str3[len(str3)-1]\n            str3 = str3[:len(str3)-1]\n        }\n    }\n    return strings.Join(str2, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123573,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp81j1y3r__test.go:17:12: undefined: contains\n/tmp/tmp81j1y3r__test.go:22:12: undefined: contains\n/tmp/tmp81j1y3r__test.go:27:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Write your code here\n    var vowels = map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    var str1_runes = []rune(str1)\n    var str1_vowels = []rune{}\n    for _, char := range str1_runes {\n        if _, ok := vowels[string(char)]; ok {\n            str1_vowels = append(str1_vowels, char)\n        }\n    }\n    var str1_vowels_len = len(str1_vowels)\n    var str1_vowels_index = str1_vowels_len - 1\n    for index, char := range str1_runes {\n        if _, ok := vowels[string(char)]; ok {\n            str1_runes[index] = str1_vowels[str1_vowels_index]\n            str1_vowels_index--\n        }\n    }\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123574,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp8nehawue_test.go:51: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str1_list = []string(str1)\n    var str1_vowels = []string{}\n    var str1_vowels_index = []int{}\n    var str1_vowels_index_reverse = []int{}\n    var str1_vowels_reverse = []string{}\n    var str1_vowels_reverse_index = []int{}\n    var str1_vowels_reverse_index_reverse = []int{}\n    var str1_vowels_reverse_index_reverse_list = []string{}\n    var str1_vowels_reverse_index_reverse_list_str = \"\"\n\n    for i, v := range str1_list {\n        for _, vv := range vowels {\n            if v == vv {\n                str1_vowels = append(str1_vowels, v)\n                str1_vowels_index = append(str1_vowels_index, i)\n            }\n        }\n    }\n\n    for i, v := range str1_vowels {\n        str1_vowels_reverse = append(str1_vowels_reverse, v)\n        str1_vowels_reverse_index = append(str1_vowels_reverse_index, i)\n    }\n\n    for i, v := range str1_vowels_reverse_index {\n        str1_vowels_reverse_index_reverse = append(str1_vowels_reverse_index_reverse, v)\n        str1_vowels_reverse_index_reverse_list = append(str1_vowels_reverse_index_reverse_list, str1_vowels_reverse[i])\n    }\n\n    for i, v := range str1_vowels_index {\n        str1_vowels_index_reverse = append(str1_vowels_index_reverse, v)\n        str1_vowels_reverse_index_reverse_\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123573,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpm39qv1bf_test.go:43:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Write your code here\n    return str1\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123572,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp9jfnulsu_test.go:29: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 = str1[i:i+1] + str2\n        }\n    }\n    var str3 string\n    var j int\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 = str3 + str2[j:j+1]\n            j++\n        } else {\n            str3 = str3 + str1[i:i+1]\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510566,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpfm7v5jfw_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    str2 := []byte(str1)\n    for i, j := 0, len(str2)-1; i < j; {\n        if !is_vowel(str2[i]) {\n            i++\n        } else if !is_vowel(str2[j]) {\n            j--\n        } else {\n            str2[i], str2[j] = str2[j], str2[i]\n            i++\n            j--\n        }\n    }\n    return string(str2)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123574,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_lr2h_06_test.go:12:13: undefined: is_vowel\n/tmp/tmp_lr2h_06_test.go:14:20: undefined: is_vowel\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Write your code here\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    str1_list := []string{}\n    for _, char := range str1 {\n        str1_list = append(str1_list, string(char))\n    }\n    for i, char := range str1_list {\n        for _, vowel := range vowels {\n            if char == vowel {\n                for j := len(str1_list)-1; j > i; j-- {\n                    for _, vowel2 := range vowels {\n                        if str1_list[j] == vowel2 {\n                            str1_list[i], str1_list[j] = str1_list[j], str1_list[i]\n                            break\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return strings.Join(str1_list, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123574,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp687_7ino_test.go:30:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := len(str1) - 1; i >= 0; i-- {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 += string(str1[i])\n        }\n    }\n    fmt.Println(str2)\n    var str3 string\n    var j int\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123572,
      "stdout": "o\n\na\n--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpoldtmz8k_test.go:45: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var vowels_map = make(map[string]int)\n    var vowels_list []string\n    for _, v := range vowels {\n        vowels_map[v] = 1\n    }\n    for _, v := range str1 {\n        if _, ok := vowels_map[string(v)]; ok {\n            vowels_list = append(vowels_list, string(v))\n        }\n    }\n    for i, v := range str1 {\n        if _, ok := vowels_map[string(v)]; ok {\n            str2 += vowels_list[len(vowels_list) - 1 - i]\n        } else {\n            str2 += string(v)\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123574,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\npanic: runtime error: index out of range [-4] [recovered]\n\tpanic: runtime error: index out of range [-4]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.reverse_vowels(0x5457df, 0x6, 0x4cd164, 0x5fa200)\n\t/tmp/tmpkywqi8k__test.go:24 +0x516\ncommand-line-arguments_test.TestReverse_Vowels(0xc000001380)\n\t/tmp/tmpkywqi8k__test.go:39 +0x53\ntesting.tRunner(0xc000001380, 0x54f1f8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]int{\"a\": 1, \"e\": 1, \"i\": 1, \"o\": 1, \"u\": 1}\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str2 = string(char) + str2\n        }\n    }\n    var str3 string\n    var i = 0\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str3 = str3 + string(str2[i])\n            i++\n        } else {\n            str3 = str3 + string(char)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123574,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpsd99zv5m_test.go:45: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a slice of the string\n    str1_slice := []rune(str1)\n    // Create a slice of the vowels\n    vowels := []rune{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    // Create a slice of the indices of the vowels\n    vowel_indices := []int{}\n    // Iterate through the string and append the indices of the vowels to vowel_indices\n    for i, char := range str1_slice {\n        for _, vowel := range vowels {\n            if char == vowel {\n                vowel_indices = append(vowel_indices, i)\n            }\n        }\n    }\n    // Iterate through the vowel_indices and swap the vowels\n    for i := 0; i < len(vowel_indices)/2; i++ {\n        str1_slice[vowel_indices[i]], str1_slice[vowel_indices[len(vowel_indices)-1-i]] = str1_slice[vowel_indices[len(vowel_indices)-1-i]], str1_slice[vowel_indices[i]]\n    }\n    return string(str1_slice)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123574,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 = str2 + string(str1[i])\n        }\n    }\n    var str3 string\n    for i := len(str2) - 1; i >= 0; i-- {\n        str3 = str3 + string(str2[i])\n    }\n    var str4 string\n    var j int = 0\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str4 = str4 + string(str3[j])\n            j++\n        } else {\n            str4 = str4 + string(str1[i])\n        }\n    }\n    return str4\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123574,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp2_qp9w72_test.go:48: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    var str2 = []string{}\n    var str3 = []string{}\n    for _, char := range str1 {\n        str2 = append(str2, string(char))\n    }\n    for _, char := range str1 {\n        if vowels[string(char)] {\n            str3 = append(str3, string(char))\n        }\n    }\n    for i, char := range str2 {\n        if vowels[string(char)] {\n            str2[i] = str3[len(str3)-1]\n            str3 = str3[:len(str3)-1]\n        }\n    }\n    return strings.Join(str2, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123574,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1hmbbk4w_test.go:33:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 = \"\"\n    var str3 = \"\"\n    var str4 = \"\"\n    var str5 = \"\"\n    var str6 = \"\"\n    var str7 = \"\"\n    var str8 = \"\"\n    var str9 = \"\"\n    var str10 = \"\"\n    var str11 = \"\"\n    var str12 = \"\"\n    var str13 = \"\"\n    var str14 = \"\"\n    var str15 = \"\"\n    var str16 = \"\"\n    var str17 = \"\"\n    var str18 = \"\"\n    var str19 = \"\"\n    var str20 = \"\"\n    var str21 = \"\"\n    var str22 = \"\"\n    var str23 = \"\"\n    var str24 = \"\"\n    var str25 = \"\"\n    var str26 = \"\"\n    var str27 = \"\"\n    var str28 = \"\"\n    var str29 = \"\"\n    var str30 = \"\"\n    var str31 = \"\"\n    var str32 = \"\"\n    var str33 = \"\"\n    var str34 = \"\"\n    var str35 = \"\"\n    var str36 = \"\"\n    var str37 = \"\"\n    var str38 = \"\"\n    var str39 = \"\"\n    var str40 = \"\"\n    var str41 = \"\"\n    var str42 = \"\"\n    var str43 = \"\"\n    var str44 = \"\"\n    var str45 = \"\"\n    var str46 = \"\"\n    var str47 = \"\"\n    var str48 = \"\"\n    var str49 = \"\"\n    var str50 = \"\"\n    var str51 = \"\"\n    var str52 = \"\"\n    var str53 = \"\"\n    var str54 = \"\"\n    var str55 = \"\"\n    var str56 = \"\"\n    var str57 = \"\"\n    var str58 = \"\"\n    var str59 = \"\"\n    var str60 = \"\"\n    var str61 = \"\"\n    var str62 = \"\"\n    var str63 = \"\"\n    var str64 = \"\"\n    var str65 = \"\"\n    var str66 = \"\"\n    var str67 = \"\"\n    var str68 = \"\"\n    var str69 = \"\"\n    var str70 = \"\"\n    var str71 =\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123571,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpft3knhvq_test.go:81:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = map[string]bool {\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    var str1_runes = []rune(str1)\n    var str1_vowels []rune\n    for _, r := range str1_runes {\n        if _, ok := vowels[string(r)]; ok {\n            str1_vowels = append(str1_vowels, r)\n        }\n    }\n    var str1_vowels_len = len(str1_vowels)\n    var str1_vowels_idx = str1_vowels_len - 1\n    for i, r := range str1_runes {\n        if _, ok := vowels[string(r)]; ok {\n            str1_runes[i] = str1_vowels[str1_vowels_idx]\n            str1_vowels_idx--\n        }\n    }\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123574,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp7w0ns8v6_test.go:50: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // your code here\n    return str1\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123569,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp21ik5iuh_test.go:29: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123568,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'Python', got ''\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'ASU', got ''\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'ab', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str_list = []string{}\n    var vowel_list = []string{}\n    var result = \"\"\n\n    for _, char := range str1 {\n        str_list = append(str_list, string(char))\n    }\n\n    for _, char := range str_list {\n        for _, vowel := range vowels {\n            if char == vowel {\n                vowel_list = append(vowel_list, char)\n            }\n        }\n    }\n\n    for _, char := range str_list {\n        for _, vowel := range vowels {\n            if char == vowel {\n                result += vowel_list[len(vowel_list)-1]\n                vowel_list = vowel_list[:len(vowel_list)-1]\n            } else {\n                result += char\n            }\n        }\n    }\n\n    return result\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123574,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmphwr9i9fu_test.go:56: expected 'Python', got 'PPPPPyyyyyttttthhhhhooooonnnnn'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmphwr9i9fu_test.go:56: expected 'ASU', got 'UUUUUSSSSSAAAAA'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmphwr9i9fu_test.go:56: expected 'ab', got 'aaaaabbbbb'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 += string(str1[i])\n        }\n    }\n    fmt.Println(str2)\n    var str3 string\n    for i := len(str2) - 1; i >= 0; i-- {\n        str3 += string(str2[i])\n    }\n    fmt.Println(str3)\n    var str4 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str4 += string(str3[0])\n            str3 = str3[1:]\n        } else {\n            str4 += string(str1[i])\n        }\n    }\n    return str4\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123574,
      "stdout": "o\no\n\n\na\na\n--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpchbbjlth_test.go:49: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str1_list = []string(str1)\n    var str1_vowels = []string{}\n    var str1_vowels_index = []int{}\n    var str1_vowels_index_reverse = []int{}\n    var str1_vowels_reverse = []string{}\n    var str1_vowels_reverse_index = []int{}\n    var str1_vowels_reverse_index_reverse = []int{}\n    var str1_vowels_reverse_index_reverse_list = []string{}\n    var str1_vowels_reverse_index_reverse_list_string = \"\"\n\n    for i := 0; i < len(str1_list); i++ {\n        for j := 0; j < len(vowels); j++ {\n            if str1_list[i] == vowels[j] {\n                str1_vowels = append(str1_vowels, str1_list[i])\n                str1_vowels_index = append(str1_vowels_index, i)\n            }\n        }\n    }\n\n    for i := len(str1_vowels) - 1; i >= 0; i-- {\n        str1_vowels_reverse = append(str1_vowels_reverse, str1_vowels[i])\n        str1_vowels_reverse_index = append(str1_vowels_reverse_index, str1_vowels_index[i])\n    }\n\n    for i := len(str1_vowels_reverse_index) - 1; i >= 0; i-- {\n        str1_vowels_reverse_index_reverse = append(str1_vowels_reverse_index_reverse, str1_vowels_reverse_index[i])\n    }\n\n    for i := 0; i < len(str1_vowels_reverse_index_reverse); i++ {\n        str1_vow\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123573,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpergarm_f_test.go:41:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var str3 string\n    for _, char := range str1 {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n            str2 = string(char) + str2\n        } else {\n            str3 = str3 + string(char)\n        }\n    }\n    for i, char := range str3 {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n            str3 = str3[:i] + string(str2[0]) + str3[i+1:]\n            str2 = str2[1:]\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123575,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpg7z77896_test.go:43: expected 'Python', got 'Pythn'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpg7z77896_test.go:43: expected 'ASU', got 'USA'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmpg7z77896_test.go:43: expected 'ab', got 'b'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Python:\n    // vowels = 'aeiou'\n    // str1 = list(str1)\n    // i = 0\n    // j = len(str1) - 1\n    // while i < j:\n    //     if str1[i].lower() not in vowels:\n    //         i += 1\n    //     elif str1[j].lower() not in vowels:\n    //         j -= 1\n    //     else:\n    //         str1[i], str1[j] = str1[j], str1[i]\n    //         i += 1\n    //         j -= 1\n    // return ''.join(str1)\n\n    vowels := \"aeiou\"\n    str1_runes := []rune(str1)\n    i := 0\n    j := len(str1_runes) - 1\n    for i < j {\n        if !strings.ContainsRune(vowels, unicode.ToLower(str1_runes[i])) {\n            i += 1\n        } else if !strings.ContainsRune(vowels, unicode.ToLower(str1_runes[j])) {\n            j -= 1\n        } else {\n            str1_runes[i], str1_runes[j] = str1_runes[j], str1_runes[i]\n            i += 1\n            j -= 1\n        }\n    }\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123574,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe7g34um2_test.go:31:13: undefined: strings\n/tmp/tmpe7g34um2_test.go:31:42: undefined: unicode\n/tmp/tmpe7g34um2_test.go:33:20: undefined: strings\n/tmp/tmpe7g34um2_test.go:33:49: undefined: unicode\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // TODO: Implement me\n    return \"\"\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123575,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpp0lu3o1y_test.go:29: expected 'Python', got ''\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpp0lu3o1y_test.go:29: expected 'ASU', got ''\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmpp0lu3o1y_test.go:29: expected 'ab', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str1_runes = []rune(str1)\n    var str1_runes_len = len(str1_runes)\n    var str1_vowels = []rune{}\n    var str1_vowels_len = 0\n    var str1_vowels_index = []int{}\n    var str1_vowels_index_len = 0\n    var str1_vowels_index_i = 0\n    var str1_vowels_index_j = 0\n    var str1_vowels_index_tmp = 0\n    var str1_vowels_index_tmp_i = 0\n    var str1_vowels_index_tmp_j = 0\n    var str1_vowels_index_tmp_k = 0\n    var str1_vowels_index_tmp_l = 0\n    var str1_vowels_index_tmp_m = 0\n    var str1_vowels_index_tmp_n = 0\n    var str1_vowels_index_tmp_o = 0\n    var str1_vowels_index_tmp_p = 0\n    var str1_vowels_index_tmp_q = 0\n    var str1_vowels_index_tmp_r = 0\n    var str1_vowels_index_tmp_s = 0\n    var str1_vowels_index_tmp_t = 0\n    var str1_vowels_index_tmp_u = 0\n    var str1_vowels_index_tmp_v = 0\n    var str1_vowels_index_tmp_w = 0\n    var str1_vowels_index_tmp_x = 0\n    var str1_vowels_index_tmp_y = 0\n    var str1_vowels_index_tmp_z = 0\n    var str1_vowels_index_tmp_a = 0\n    var str1_vowels_index_\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123574,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpysyc4k4o_test.go:39:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels []rune\n    for _, c := range str1 {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            vowels = append(vowels, c)\n        }\n    }\n    var result []rune\n    for _, c := range str1 {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            result = append(result, vowels[len(vowels)-1])\n            vowels = vowels[:len(vowels)-1]\n        } else {\n            result = append(result, c)\n        }\n    }\n    return string(result)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123575,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp3kuk3mhi_test.go:43: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Write your code here\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str2 string\n    var str3 string\n    var str4 string\n    var str5 string\n    var str6 string\n    var str7 string\n    var str8 string\n    var str9 string\n    var str10 string\n    var str11 string\n    var str12 string\n    var str13 string\n    var str14 string\n    var str15 string\n    var str16 string\n    var str17 string\n    var str18 string\n    var str19 string\n    var str20 string\n    var str21 string\n    var str22 string\n    var str23 string\n    var str24 string\n    var str25 string\n    var str26 string\n    var str27 string\n    var str28 string\n    var str29 string\n    var str30 string\n    var str31 string\n    var str32 string\n    var str33 string\n    var str34 string\n    var str35 string\n    var str36 string\n    var str37 string\n    var str38 string\n    var str39 string\n    var str40 string\n    var str41 string\n    var str42 string\n    var str43 string\n    var str44 string\n    var str45 string\n    var str46 string\n    var str47 string\n    var str48 string\n    var str49 string\n    var str50 string\n    var str51 string\n    var str52 string\n    var str53 string\n    var str54 string\n    var str55 string\n    var str56 string\n    var str57 string\n    var str58 string\n    var str59 string\n    var str60 string\n    var str61 string\n    var str62 string\n    var str63 string\n    var str64 string\n    var str65 string\n    var str66 string\n    var str67 string\n    var str68 string\n    var str69 string\n    var str70 string\n    var str71 string\n    var str72 string\n    var str73 string\n    var str74 string\n    var str75 string\n    var str76 string\n    var str77 string\n    var str78 string\n    var str79\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123574,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpph0ql73k_test.go:89:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    str2 := []rune(str1)\n    i := 0\n    j := len(str1) - 1\n    for i < j {\n        if is_vowel(str2[i]) && is_vowel(str2[j]) {\n            str2[i], str2[j] = str2[j], str2[i]\n            i++\n            j--\n        } else if is_vowel(str2[i]) {\n            j--\n        } else if is_vowel(str2[j]) {\n            i++\n        } else {\n            i++\n            j--\n        }\n    }\n    return string(str2)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123575,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaj5g2hh1_test.go:14:12: undefined: is_vowel\n/tmp/tmpaj5g2hh1_test.go:18:19: undefined: is_vowel\n/tmp/tmpaj5g2hh1_test.go:20:19: undefined: is_vowel\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := len(str1) - 1; i >= 0; i-- {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 += string(str1[i])\n        }\n    }\n    var str3 string\n    j := 0\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510566,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmppb362zuj_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 = str1[i:i+1] + str2\n        }\n    }\n    var str3 string\n    var j int = 0\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 = str3 + str2[j:j+1]\n            j++\n        } else {\n            str3 = str3 + str1[i:i+1]\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123573,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpysqowxca_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for _, c := range str1 {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            str2 = string(c) + str2\n        } else {\n            str2 = str2 + string(c)\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123576,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpefa62wdt_test.go:36: expected 'Python', got 'oPythn'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpefa62wdt_test.go:36: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 = \"\"\n    var str3 = \"\"\n    var str4 = \"\"\n    var str5 = \"\"\n    var str6 = \"\"\n    var str7 = \"\"\n    var str8 = \"\"\n    var str9 = \"\"\n    var str10 = \"\"\n    var str11 = \"\"\n    var str12 = \"\"\n    var str13 = \"\"\n    var str14 = \"\"\n    var str15 = \"\"\n    var str16 = \"\"\n    var str17 = \"\"\n    var str18 = \"\"\n    var str19 = \"\"\n    var str20 = \"\"\n    var str21 = \"\"\n    var str22 = \"\"\n    var str23 = \"\"\n    var str24 = \"\"\n    var str25 = \"\"\n    var str26 = \"\"\n    var str27 = \"\"\n    var str28 = \"\"\n    var str29 = \"\"\n    var str30 = \"\"\n    var str31 = \"\"\n    var str32 = \"\"\n    var str33 = \"\"\n    var str34 = \"\"\n    var str35 = \"\"\n    var str36 = \"\"\n    var str37 = \"\"\n    var str38 = \"\"\n    var str39 = \"\"\n    var str40 = \"\"\n    var str41 = \"\"\n    var str42 = \"\"\n    var str43 = \"\"\n    var str44 = \"\"\n    var str45 = \"\"\n    var str46 = \"\"\n    var str47 = \"\"\n    var str48 = \"\"\n    var str49 = \"\"\n    var str50 = \"\"\n    var str51 = \"\"\n    var str52 = \"\"\n    var str53 = \"\"\n    var str54 = \"\"\n    var str55 = \"\"\n    var str56 = \"\"\n    var str57 = \"\"\n    var str58 = \"\"\n    var str59 = \"\"\n    var str60 = \"\"\n    var str61 = \"\"\n    var str62 = \"\"\n    var str63 = \"\"\n    var str64 = \"\"\n    var str65 = \"\"\n    var str66 = \"\"\n    var str67 = \"\"\n    var str68 = \"\"\n    var str69 = \"\"\n    var str70 = \"\"\n    var str71 =\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123571,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpft3knhvq_test.go:81:6: expected '(', found TestReverse_Vowels\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str2 = \"\"\n    var str3 = \"\"\n    for _, char := range str1 {\n        if contains(vowels, string(char)) {\n            str2 = string(char) + str2\n        } else {\n            str3 = str3 + string(char)\n        }\n    }\n    var str4 = \"\"\n    var j = 0\n    for i := 0; i < len(str1); i++ {\n        if contains(vowels, string(str1[i])) {\n            str4 = str4 + string(str2[j])\n            j++\n        } else {\n            str4 = str4 + string(str1[i])\n        }\n    }\n    return str4\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123575,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9p22yqnl_test.go:14:12: undefined: contains\n/tmp/tmp9p22yqnl_test.go:23:12: undefined: contains\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Write your code here\n    return \"\"\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510567,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpty_8pjum_test.go:29: expected 'Python', got ''\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpty_8pjum_test.go:29: expected 'ASU', got ''\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmpty_8pjum_test.go:29: expected 'ab', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 = str2 + string(str1[i])\n        }\n    }\n    fmt.Println(str2)\n    var str3 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 = str3 + string(str2[len(str2)-1])\n            str2 = str2[:len(str2)-1]\n        } else {\n            str3 = str3 + string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123568,
      "stdout": "o\n\na\n--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp6r8qfaqh_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    str2 := []byte(str1)\n    for i, j := 0, len(str2)-1; i < j; i, j = i+1, j-1 {\n        for ; i < j; i++ {\n            if str2[i] == 'a' || str2[i] == 'e' || str2[i] == 'i' || str2[i] == 'o' || str2[i] == 'u' {\n                break\n            }\n        }\n        for ; i < j; j-- {\n            if str2[j] == 'a' || str2[j] == 'e' || str2[j] == 'i' || str2[j] == 'o' || str2[j] == 'u' {\n                break\n            }\n        }\n        str2[i], str2[j] = str2[j], str2[i]\n    }\n    return string(str2)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123576,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpcnt2li7d_test.go:42: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := len(str1) - 1; i >= 0; i-- {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 += string(str1[i])\n        }\n    }\n    var str3 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 += string(str2[0])\n            str2 = str2[1:]\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123569,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp8dm4ccww_test.go:43: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 = str1[i:i+1] + str2\n        }\n    }\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str1 = str1[:i] + str2[:1] + str1[i+1:]\n            str2 = str2[1:]\n        }\n    }\n    return str1\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123576,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp2dygfcun_test.go:40: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Write your code here\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    str1_runes := []rune(str1)\n    str1_vowels := []string{}\n    for _, char := range str1_runes {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                str1_vowels = append(str1_vowels, string(char))\n            }\n        }\n    }\n    for i, char := range str1_runes {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                str1_runes[i] = rune(str1_vowels[len(str1_vowels)-1])\n                str1_vowels = str1_vowels[:len(str1_vowels)-1]\n            }\n        }\n    }\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123575,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphet2p3cw_test.go:24:37: cannot convert str1_vowels[len(str1_vowels) - 1] (type string) to type rune\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Python:\n    // vowels = \"aeiou\"\n    // str1 = list(str1)\n    // i, j = 0, len(str1) - 1\n    // while i < j:\n    //     if str1[i].lower() not in vowels:\n    //         i += 1\n    //     elif str1[j].lower() not in vowels:\n    //         j -= 1\n    //     else:\n    //         str1[i], str1[j] = str1[j], str1[i]\n    //         i += 1\n    //         j -= 1\n    // return \"\".join(str1)\n\n    vowels := \"aeiou\"\n    str1_runes := []rune(str1)\n    i, j := 0, len(str1_runes) - 1\n    for i < j {\n        if !strings.ContainsRune(vowels, unicode.ToLower(str1_runes[i])) {\n            i += 1\n        } else if !strings.ContainsRune(vowels, unicode.ToLower(str1_runes[j])) {\n            j -= 1\n        } else {\n            str1_runes[i], str1_runes[j] = str1_runes[j], str1_runes[i]\n            i += 1\n            j -= 1\n        }\n    }\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123576,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6fp32msn_test.go:29:13: undefined: strings\n/tmp/tmp6fp32msn_test.go:29:42: undefined: unicode\n/tmp/tmp6fp32msn_test.go:31:20: undefined: strings\n/tmp/tmp6fp32msn_test.go:31:49: undefined: unicode\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := len(str1) - 1; i >= 0; i-- {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 += string(str1[i])\n        }\n    }\n    var str3 string\n    var j int = 0\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510567,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpqgd0dumw_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str1_list = []string{}\n    var vowels_list = []string{}\n    var result_list = []string{}\n    for _, char := range str1 {\n        str1_list = append(str1_list, string(char))\n    }\n    for _, char := range str1_list {\n        for _, vowel := range vowels {\n            if char == vowel {\n                vowels_list = append(vowels_list, char)\n            }\n        }\n    }\n    for _, char := range str1_list {\n        for _, vowel := range vowels {\n            if char == vowel {\n                result_list = append(result_list, vowels_list[len(vowels_list)-1])\n                vowels_list = vowels_list[:len(vowels_list)-1]\n            } else {\n                result_list = append(result_list, char)\n            }\n        }\n    }\n    return fmt.Sprintf(\"%s\", result_list)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123576,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpgi9q4bj3_test.go:52: expected 'Python', got '[P P P P P P P P P P y y y y y y y y y y t t t t t t t t t t h h h h h h h h h h o o o o o o o o o o n n n n n n n n n n]'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpgi9q4bj3_test.go:52: expected 'ASU', got '[U U U U U U U U U A S S S S S S S S S S A A A A A U A A A A]'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmpgi9q4bj3_test.go:52: expected 'ab', got '[a a a a a a a a a a b b b b b b b b b b]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Write your code here\n    var vowels = map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n\n    var arr = []string{}\n    var arr_vowels = []string{}\n    for _, v := range str1 {\n        if vowels[string(v)] {\n            arr_vowels = append(arr_vowels, string(v))\n        }\n        arr = append(arr, string(v))\n    }\n\n    for i, v := range arr {\n        if vowels[v] {\n            arr[i] = arr_vowels[len(arr_vowels)-1]\n            arr_vowels = arr_vowels[:len(arr_vowels)-1]\n        }\n    }\n\n    return strings.Join(arr, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123576,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpofaxb0s0_test.go:35:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 = \"\"\n    var str3 = \"\"\n    for _, char := range str1 {\n        if string(char) == \"y\" {\n            str2 += \"y\"\n        } else {\n            for _, vowel := range vowels {\n                if string(char) == vowel {\n                    str3 += string(char)\n                }\n            }\n        }\n    }\n    for _, char := range str1 {\n        if string(char) == \"y\" {\n            str2 += \"y\"\n        } else {\n            for _, vowel := range vowels {\n                if string(char) == vowel {\n                    str2 += string(str3[len(str3)-1])\n                    str3 = str3[:len(str3)-1]\n                }\n            }\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123576,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpguoag1o8_test.go:54: expected 'Python', got 'yyo'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpguoag1o8_test.go:54: expected 'ASU', got ''\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmpguoag1o8_test.go:54: expected 'ab', got 'a'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    // Create a slice of the string\n    str1_slice := []string{}\n    for _, char := range str1 {\n        str1_slice = append(str1_slice, string(char))\n    }\n    // Create a slice of the vowels\n    vowels_slice := []string{}\n    for _, char := range str1 {\n        if vowels[string(char)] {\n            vowels_slice = append(vowels_slice, string(char))\n        }\n    }\n    // Reverse the vowels\n    for i := 0; i < len(vowels_slice)/2; i++ {\n        temp := vowels_slice[i]\n        vowels_slice[i] = vowels_slice[len(vowels_slice)-1-i]\n        vowels_slice[len(vowels_slice)-1-i] = temp\n    }\n    // Replace the vowels in the string\n    j := 0\n    for i := 0; i < len(str1_slice); i++ {\n        if vowels[str1_slice[i]] {\n            str1_slice[i] = vowels_slice[j]\n            j++\n        }\n    }\n    // Return the string\n    return strings.Join(str1_slice, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123576,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbvr2wa86_test.go:45:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    str1_list := []string{}\n    vowels_list := []string{}\n    for _, char := range str1 {\n        str1_list = append(str1_list, string(char))\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                vowels_list = append(vowels_list, string(char))\n            }\n        }\n    }\n    for i, char := range str1_list {\n        for _, vowel := range vowels {\n            if char == vowel {\n                str1_list[i] = vowels_list[len(vowels_list)-1]\n                vowels_list = vowels_list[:len(vowels_list)-1]\n            }\n        }\n    }\n    return fmt.Sprintf(\"%s\", str1_list)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123576,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmp37_fwlpu_test.go:47: expected 'Python', got '[P y t h o n]'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp37_fwlpu_test.go:47: expected 'ASU', got '[A S U]'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmp37_fwlpu_test.go:47: expected 'ab', got '[a b]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Write your code here\n    return str1\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123572,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp9jfnulsu_test.go:29: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    vowels := []rune{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    str1_runes := []rune(str1)\n    str1_vowels := []rune{}\n    str1_vowels_index := []int{}\n    for i, v := range str1_runes {\n        for _, vv := range vowels {\n            if v == vv {\n                str1_vowels = append(str1_vowels, v)\n                str1_vowels_index = append(str1_vowels_index, i)\n            }\n        }\n    }\n    for i, v := range str1_vowels_index {\n        str1_runes[v] = str1_vowels[len(str1_vowels)-i-1]\n    }\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123576,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n        \"A\": true,\n        \"E\": true,\n        \"I\": true,\n        \"O\": true,\n        \"U\": true,\n    }\n    var vowel_stack []string\n    for _, char := range str1 {\n        if vowels[string(char)] {\n            vowel_stack = append(vowel_stack, string(char))\n        }\n    }\n    for _, char := range str1 {\n        if vowels[string(char)] {\n            str2 += vowel_stack[len(vowel_stack)-1]\n            vowel_stack = vowel_stack[:len(vowel_stack)-1]\n        } else {\n            str2 += string(char)\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123576,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123568,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'Python', got ''\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'ASU', got ''\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'ab', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []rune{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    var str1_runes = []rune(str1)\n    var str1_vowels_runes []rune\n    var str1_vowels_runes_reverse []rune\n    var str1_vowels_runes_reverse_index int = 0\n\n    for _, char := range str1_runes {\n        for _, vowel := range vowels {\n            if char == vowel {\n                str1_vowels_runes = append(str1_vowels_runes, char)\n            }\n        }\n    }\n\n    for i := len(str1_vowels_runes) - 1; i >= 0; i-- {\n        str1_vowels_runes_reverse = append(str1_vowels_runes_reverse, str1_vowels_runes[i])\n    }\n\n    for i, char := range str1_runes {\n        for _, vowel := range vowels {\n            if char == vowel {\n                str1_runes[i] = str1_vowels_runes_reverse[str1_vowels_runes_reverse_index]\n                str1_vowels_runes_reverse_index++\n            }\n        }\n    }\n\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123576,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    vowels := []rune{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    str1_runes := []rune(str1)\n    var str1_vowels []rune\n    for _, char := range str1_runes {\n        for _, vowel := range vowels {\n            if char == vowel {\n                str1_vowels = append(str1_vowels, char)\n            }\n        }\n    }\n    str1_vowels_reversed := make([]rune, len(str1_vowels))\n    for i, j := 0, len(str1_vowels)-1; i < j; i, j = i+1, j-1 {\n        str1_vowels_reversed[i], str1_vowels_reversed[j] = str1_vowels[j], str1_vowels[i]\n    }\n    for i, char := range str1_runes {\n        for j, vowel := range vowels {\n            if char == vowel {\n                str1_runes[i] = str1_vowels_reversed[j]\n            }\n        }\n    }\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123576,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\npanic: runtime error: index out of range [3] with length 1 [recovered]\n\tpanic: runtime error: index out of range [3] with length 1\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000158000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000158000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.reverse_vowels(0x5457db, 0x6, 0x4cd164, 0x5fa160)\n\t/tmp/tmpi5l8xsg7_test.go:27 +0x2c5\ncommand-line-arguments_test.TestReverse_Vowels(0xc000102600)\n\t/tmp/tmpi5l8xsg7_test.go:41 +0x53\ntesting.tRunner(0xc000102600, 0x54f1f0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123568,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'Python', got ''\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'ASU', got ''\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'ab', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123568,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'Python', got ''\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'ASU', got ''\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'ab', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Write your code here\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    str1_list := []string{}\n    for _, char := range str1 {\n        str1_list = append(str1_list, string(char))\n    }\n    for i := 0; i < len(str1_list); i++ {\n        if str1_list[i] == \"a\" || str1_list[i] == \"e\" || str1_list[i] == \"i\" || str1_list[i] == \"o\" || str1_list[i] == \"u\" {\n            for j := len(str1_list) - 1; j > i; j-- {\n                if str1_list[j] == \"a\" || str1_list[j] == \"e\" || str1_list[j] == \"i\" || str1_list[j] == \"o\" || str1_list[j] == \"u\" {\n                    str1_list[i], str1_list[j] = str1_list[j], str1_list[i]\n                    break\n                }\n            }\n        }\n    }\n    return strings.Join(str1_list, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123576,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn6fuoxn4_test.go:26:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n\n    // Convert string to a rune slice\n    str1_runes := []rune(str1)\n\n    // Create a slice of the vowels\n    str1_vowels := []rune{}\n    for _, char := range str1_runes {\n        if _, ok := vowels[string(char)]; ok {\n            str1_vowels = append(str1_vowels, char)\n        }\n    }\n\n    // Reverse the slice of vowels\n    for i, j := 0, len(str1_vowels)-1; i < j; i, j = i+1, j-1 {\n        str1_vowels[i], str1_vowels[j] = str1_vowels[j], str1_vowels[i]\n    }\n\n    // Replace the vowels in the original string with the reversed vowels\n    for i, char := range str1_runes {\n        if _, ok := vowels[string(char)]; ok {\n            str1_runes[i] = str1_vowels[0]\n            str1_vowels = str1_vowels[1:]\n        }\n    }\n\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123576,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp5clrs5nk_test.go:61: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for _, c := range str1 {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            str2 = string(c) + str2\n        }\n    }\n    var str3 string\n    for _, c := range str1 {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            str3 += string(str2[0])\n            str2 = str2[1:]\n        } else {\n            str3 += string(c)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123569,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpa0sjlwbr_test.go:43: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123568,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'Python', got ''\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'ASU', got ''\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'ab', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for _, char := range str1 {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n            str2 = string(char) + str2\n        }\n    }\n    var str3 string\n    for _, char := range str1 {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n            str3 += string(str2[0])\n            str2 = str2[1:]\n        } else {\n            str3 += string(char)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510567,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpsxj26_zp_test.go:43: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := len(str1) - 1; i >= 0; i-- {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 += string(str1[i])\n        }\n    }\n    var str3 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 += string(str2[0])\n            str2 = str2[1:]\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123569,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp8dm4ccww_test.go:43: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    for i := 0; i < len(str1); i++ {\n        if contains(vowels, string(str1[i])) {\n            str2 = string(str1[i]) + str2\n        }\n    }\n    var str3 string\n    var j int\n    for i := 0; i < len(str1); i++ {\n        if contains(vowels, string(str1[i])) {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123576,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwee5phqw_test.go:13:12: undefined: contains\n/tmp/tmpwee5phqw_test.go:20:12: undefined: contains\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str1_list = []string{}\n    var str1_vowels = []string{}\n    var str1_vowels_reversed = []string{}\n    var str1_reversed = \"\"\n    var str1_vowels_reversed_index = 0\n\n    for _, char := range str1 {\n        str1_list = append(str1_list, string(char))\n    }\n\n    for _, char := range str1_list {\n        for _, vowel := range vowels {\n            if char == vowel {\n                str1_vowels = append(str1_vowels, char)\n            }\n        }\n    }\n\n    for i := len(str1_vowels) - 1; i >= 0; i-- {\n        str1_vowels_reversed = append(str1_vowels_reversed, str1_vowels[i])\n    }\n\n    for _, char := range str1_list {\n        for _, vowel := range vowels {\n            if char == vowel {\n                str1_reversed += str1_vowels_reversed[str1_vowels_reversed_index]\n                str1_vowels_reversed_index++\n            } else {\n                str1_reversed += char\n            }\n        }\n    }\n\n    return str1_reversed\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123576,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmp0ipyoos0_test.go:62: expected 'Python', got 'PPPPPPPPPPyyyyyyyyyytttttttttthhhhhhhhhhoooooooooonnnnnnnnnn'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp0ipyoos0_test.go:62: expected 'ASU', got 'UUUUUUUUUASSSSSSSSSSAAAAAUAAAA'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmp0ipyoos0_test.go:62: expected 'ab', got 'aaaaaaaaaabbbbbbbbbb'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 = str1[i:i+1] + str2\n        }\n    }\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str1 = str1[:i] + str2[:1] + str1[i+1:]\n            str2 = str2[1:]\n        }\n    }\n    return str1\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123576,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp2dygfcun_test.go:40: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\": true}\n    // Create a slice of the string\n    str_slice := []string{}\n    // Create a slice of the vowels\n    vowel_slice := []string{}\n    // Iterate over the string\n    for _, char := range str1 {\n        str_slice = append(str_slice, string(char))\n        if vowels[string(char)] {\n            vowel_slice = append(vowel_slice, string(char))\n        }\n    }\n    // Reverse the vowel slice\n    for i, j := 0, len(vowel_slice)-1; i < j; i, j = i+1, j-1 {\n        vowel_slice[i], vowel_slice[j] = vowel_slice[j], vowel_slice[i]\n    }\n    // Iterate over the string slice and replace the vowels with the reversed vowels\n    for i, char := range str_slice {\n        if vowels[char] {\n            str_slice[i] = vowel_slice[0]\n            vowel_slice = vowel_slice[1:]\n        }\n    }\n    // Return the string\n    return strings.Join(str_slice, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123576,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpubkkk6i9_test.go:35:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]bool{\n        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    var vowel_list []string\n    for _, char := range str1 {\n        if vowels[string(char)] {\n            vowel_list = append(vowel_list, string(char))\n        }\n    }\n    for _, char := range str1 {\n        if vowels[string(char)] {\n            str2 += vowel_list[len(vowel_list)-1]\n            vowel_list = vowel_list[:len(vowel_list)-1]\n        } else {\n            str2 += string(char)\n        }\n    }\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123577,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpqjxnm2ln_test.go:50: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123568,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'Python', got ''\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'ASU', got ''\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'ab', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str1_list = []string{}\n    var str1_vowels = []string{}\n    var str1_vowels_reversed = []string{}\n    var str1_vowels_reversed_index = 0\n    var str1_vowels_reversed_index_map = map[int]int{}\n    var str1_vowels_reversed_index_map_index = 0\n\n    for _, char := range str1 {\n        str1_list = append(str1_list, string(char))\n    }\n\n    for index, char := range str1_list {\n        for _, vowel := range vowels {\n            if char == vowel {\n                str1_vowels = append(str1_vowels, char)\n                str1_vowels_reversed_index_map[index] = str1_vowels_reversed_index_map_index\n                str1_vowels_reversed_index_map_index++\n            }\n        }\n    }\n\n    for i := len(str1_vowels) - 1; i >= 0; i-- {\n        str1_vowels_reversed = append(str1_vowels_reversed, str1_vowels[i])\n    }\n\n    for index, char := range str1_list {\n        for _, vowel := range vowels {\n            if char == vowel {\n                str1_list[index] = str1_vowels_reversed[str1_vowels_reversed_index]\n                str1_vowels_reversed_index++\n            }\n        }\n    }\n\n    return strings.Join(str1_list, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123576,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppq8z82_e_test.go:45:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Create a map of vowels\n    vowels := map[string]int{\"a\":1, \"e\":1, \"i\":1, \"o\":1, \"u\":1}\n    // Create a slice of the string\n    str_slice := []string{}\n    for _, char := range str1 {\n        str_slice = append(str_slice, string(char))\n    }\n    // Create a slice of the vowels\n    vowels_slice := []string{}\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            vowels_slice = append(vowels_slice, string(char))\n        }\n    }\n    // Reverse the vowels\n    for i, char := range str_slice {\n        if _, ok := vowels[char]; ok {\n            str_slice[i] = vowels_slice[len(vowels_slice)-1]\n            vowels_slice = vowels_slice[:len(vowels_slice)-1]\n        }\n    }\n    // Return the string\n    return strings.Join(str_slice, \"\")\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123576,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjhnpuy1v_test.go:32:12: undefined: strings\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Python:\n    // vowels = \"aeiou\"\n    // str1 = list(str1)\n    // i = 0\n    // j = len(str1) - 1\n    // while i < j:\n    //     if str1[i].lower() not in vowels:\n    //         i += 1\n    //     elif str1[j].lower() not in vowels:\n    //         j -= 1\n    //     else:\n    //         str1[i], str1[j] = str1[j], str1[i]\n    //         i += 1\n    //         j -= 1\n    // return \"\".join(str1)\n\n    // Go:\n    vowels := \"aeiou\"\n    str1_runes := []rune(str1)\n    i := 0\n    j := len(str1_runes) - 1\n    for i < j {\n        if !contains(vowels, str1_runes[i]) {\n            i++\n        } else if !contains(vowels, str1_runes[j]) {\n            j--\n        } else {\n            str1_runes[i], str1_runes[j] = str1_runes[j], str1_runes[i]\n            i++\n            j--\n        }\n    }\n    return string(str1_runes)\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123577,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2b9np8hk_test.go:32:13: undefined: contains\n/tmp/tmp2b9np8hk_test.go:34:20: undefined: contains\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str1_list = []string{}\n    var str1_vowels = []string{}\n    var str1_vowels_reversed = []string{}\n    var str1_reversed = \"\"\n\n    for _, char := range str1 {\n        str1_list = append(str1_list, string(char))\n    }\n\n    for _, char := range str1_list {\n        for _, vowel := range vowels {\n            if char == vowel {\n                str1_vowels = append(str1_vowels, char)\n            }\n        }\n    }\n\n    for i := len(str1_vowels) - 1; i >= 0; i-- {\n        str1_vowels_reversed = append(str1_vowels_reversed, str1_vowels[i])\n    }\n\n    for i, char := range str1_list {\n        for _, vowel := range vowels {\n            if char == vowel {\n                str1_list[i] = str1_vowels_reversed[0]\n                str1_vowels_reversed = str1_vowels_reversed[1:]\n            }\n        }\n    }\n\n    for _, char := range str1_list {\n        str1_reversed += char\n    }\n\n    return str1_reversed\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123577,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp5a6r6ndj_test.go:63: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // Write your code here\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str1_arr = []string{}\n    var vowels_arr = []string{}\n    var result = \"\"\n    for _, char := range str1 {\n        str1_arr = append(str1_arr, string(char))\n    }\n    for _, char := range str1_arr {\n        for _, vowel := range vowels {\n            if char == vowel {\n                vowels_arr = append(vowels_arr, char)\n            }\n        }\n    }\n    for _, char := range str1_arr {\n        for _, vowel := range vowels {\n            if char == vowel {\n                result += vowels_arr[len(vowels_arr) - 1]\n                vowels_arr = vowels_arr[:len(vowels_arr) - 1]\n            } else {\n                result += char\n            }\n        }\n    }\n    return result\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123577,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmpjy_9h7nu_test.go:53: expected 'Python', got 'PPPPPPPPPPyyyyyyyyyytttttttttthhhhhhhhhhoooooooooonnnnnnnnnn'\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpjy_9h7nu_test.go:53: expected 'ASU', got 'UUUUUUUUUASSSSSSSSSSAAAAAUAAAA'\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmpjy_9h7nu_test.go:53: expected 'ab', got 'aaaaaaaaaabbbbbbbbbb'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 string\n    var str3 string\n    var str4 string\n    var str5 string\n    var str6 string\n    var str7 string\n    var str8 string\n    var str9 string\n    var str10 string\n    var str11 string\n    var str12 string\n    var str13 string\n    var str14 string\n    var str15 string\n    var str16 string\n    var str17 string\n    var str18 string\n    var str19 string\n    var str20 string\n    var str21 string\n    var str22 string\n    var str23 string\n    var str24 string\n    var str25 string\n    var str26 string\n    var str27 string\n    var str28 string\n    var str29 string\n    var str30 string\n    var str31 string\n    var str32 string\n    var str33 string\n    var str34 string\n    var str35 string\n    var str36 string\n    var str37 string\n    var str38 string\n    var str39 string\n    var str40 string\n    var str41 string\n    var str42 string\n    var str43 string\n    var str44 string\n    var str45 string\n    var str46 string\n    var str47 string\n    var str48 string\n    var str49 string\n    var str50 string\n    var str51 string\n    var str52 string\n    var str53 string\n    var str54 string\n    var str55 string\n    var str56 string\n    var str57 string\n    var str58 string\n    var str59 string\n    var str60 string\n    var str61 string\n    var str62 string\n    var str63 string\n    var str64 string\n    var str65 string\n    var str66 string\n    var str67 string\n    var str68 string\n    var str69 string\n    var str70 string\n    var str71 string\n    var str72 string\n    var str73 string\n    var str74 string\n    var str75 string\n    var str76 string\n    var str77 string\n    var str78 string\n    var str79 string\n    var str80 string\n    var str81 string\n    var str82 string\n    var\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123576,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpqcr11br8_test.go:93:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var str2 string\n    var str3 string\n    for _, char := range str1 {\n        if string(char) == \"y\" {\n            str2 += string(char)\n        } else {\n            for _, vowel := range vowels {\n                if string(char) == vowel {\n                    str3 += string(char)\n                }\n            }\n        }\n    }\n    str3 = reverse(str3)\n    var str4 string\n    var str5 string\n    for _, char := range str1 {\n        if string(char) == \"y\" {\n            str4 += string(char)\n        } else {\n            for _, vowel := range vowels {\n                if string(char) == vowel {\n                    str4 += string(str3[0])\n                    str3 = str3[1:]\n                }\n            }\n        }\n    }\n    return str4\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123577,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6c6bwkui_test.go:24:12: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := len(str1)-1; i >= 0; i-- {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 += string(str1[i])\n        }\n    }\n    var str3 string\n    var j int\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123568,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpks4rnlh9_test.go:44: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123568,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__0 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'Python', got ''\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'ASU', got ''\n    --- FAIL: TestReverse_Vowels/test_num__2 (0.00s)\n        tmp4mfjn4gc_test.go:29: expected 'ab', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var str1_list = []string{}\n    var str1_vowels = []string{}\n    var str1_vowels_reversed = []string{}\n    var str1_reversed = \"\"\n\n    for _, char := range str1 {\n        str1_list = append(str1_list, string(char))\n    }\n\n    for _, char := range str1_list {\n        for _, vowel := range vowels {\n            if char == vowel {\n                str1_vowels = append(str1_vowels, char)\n            }\n        }\n    }\n\n    for i := len(str1_vowels) - 1; i >= 0; i-- {\n        str1_vowels_reversed = append(str1_vowels_reversed, str1_vowels[i])\n    }\n\n    for i, char := range str1_list {\n        for j, vowel := range str1_vowels {\n            if char == vowel {\n                str1_list[i] = str1_vowels_reversed[j]\n            }\n        }\n    }\n\n    for _, char := range str1_list {\n        str1_reversed += char\n    }\n\n    return str1_reversed\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123568,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = map[string]int{\"a\": 1, \"e\": 1, \"i\": 1, \"o\": 1, \"u\": 1}\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str2 = string(char) + str2\n        }\n    }\n    var str3 string\n    var j int = 0\n    for _, char := range str1 {\n        if _, ok := vowels[string(char)]; ok {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(char)\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123577,
      "stdout": "--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpd1nzcpbu_test.go:45: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var vowel_positions []int\n    var vowel_chars []string\n\n    for i, char := range str1 {\n        for _, vowel := range vowels {\n            if string(char) == vowel {\n                vowel_positions = append(vowel_positions, i)\n                vowel_chars = append(vowel_chars, string(char))\n            }\n        }\n    }\n\n    for i, char := range str1 {\n        if len(vowel_positions) > 0 && i == vowel_positions[0] {\n            str2 += vowel_chars[len(vowel_chars) - 1]\n            vowel_positions = vowel_positions[1:]\n            vowel_chars = vowel_chars[:len(vowel_chars) - 1]\n        } else {\n            str2 += string(char)\n        }\n    }\n\n    return str2\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123577,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package reverse_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1 string) string {\n    var str2 string\n    for i := len(str1) - 1; i >= 0; i-- {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str2 += string(str1[i])\n        }\n    }\n    fmt.Println(str2)\n    var str3 string\n    var j int\n    for i := 0; i < len(str1); i++ {\n        if str1[i] == 'a' || str1[i] == 'e' || str1[i] == 'i' || str1[i] == 'o' || str1[i] == 'u' {\n            str3 += string(str2[j])\n            j++\n        } else {\n            str3 += string(str1[i])\n        }\n    }\n    return str3\n}\n\nfunc TestReverse_Vowels(t *testing.T) {\n  candidate := reverse_vowels\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Python\"), expected: \"Python\" },\n     { actual: candidate(\"USA\"), expected: \"ASU\" },\n     { actual: candidate(\"ab\"), expected: \"ab\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123572,
      "stdout": "o\n\na\n--- FAIL: TestReverse_Vowels (0.00s)\n    --- FAIL: TestReverse_Vowels/test_num__1 (0.00s)\n        tmpoldtmz8k_test.go:45: expected 'ASU', got 'USA'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}