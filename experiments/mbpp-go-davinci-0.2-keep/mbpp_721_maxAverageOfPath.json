{
  "name": "mbpp_721_maxAverageOfPath",
  "language": "go_test.go",
  "prompt": "package maxAverageOfPath_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost [][]int) float64 {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_721_maxAverageOfPath.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestMaxaverageofpath(t *testing.T) {\n  candidate := maxAverageOfPath\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{6, 5, 4}, []int{7, 3, 9}}), expected: 5.2 },\n     { actual: candidate([][]int{[]int{2, 3, 4}, []int{7, 6, 5}, []int{8, 4, 10}}), expected: 6.2 },\n     { actual: candidate([][]int{[]int{3, 4, 5}, []int{8, 7, 6}, []int{9, 5, 11}}), expected: 7.2 },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{7, 8, 9}}), expected: 5.8 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    // dp[i][j] means the max average of path from (0, 0) to (i, j)\n    dp := make([][]float64, len(cost))\n    for i := 0; i < len(cost); i++ {\n        dp[i] = make([]float64, len(cost[0]))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n",
    "    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n",
    "    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n",
    "    if len(cost) == 0 {\n        return 0\n    }\n\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n",
    "    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0.0\n    }\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n",
    "    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n\n    n := len(cost)\n    m := len(cost[0])\n\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[n-1][m-1] / float64(n+m-1)\n}\n",
    "    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    for i := 1; i < len(cost); i++ {\n        cost[i][0] += cost[i-1][0]\n    }\n    for j := 1; j < len(cost[0]); j++ {\n        cost[0][j] += cost[0][j-1]\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            cost[i][j] += max(cost[i-1][j], cost[i][j-1])\n        }\n    }\n    return float64(cost[len(cost)-1][len(cost[0])-1]) / float64(len(cost) + len(cost[0]) - 1)\n}\n",
    "    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n",
    "    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n",
    "    n := len(cost)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return float64(cost[0][0])\n    }\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n",
    "    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var sum float64\n    for i := 0; i < len(cost); i++ {\n        for j := 0; j < len(cost[0]); j++ {\n            if i == 0 && j == 0 {\n                continue\n            }\n            if i == 0 {\n                cost[i][j] += cost[i][j-1]\n            } else if j == 0 {\n                cost[i][j] += cost[i-1][j]\n            } else {\n                cost[i][j] += max(cost[i-1][j], cost[i][j-1])\n            }\n            sum += float64(cost[i][j])\n        }\n    }\n    return sum / float64(len(cost) * len(cost[0]))\n}\n",
    "    if len(cost) == 0 {\n        return 0\n    }\n\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n",
    "    n := len(cost)\n    if n == 0 {\n        return 0\n    }\n    m := len(cost[0])\n    if m == 0 {\n        return 0\n    }\n    if n == 1 && m == 1 {\n        return float64(cost[0][0])\n    }\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[n-1][m-1] / float64(n+m-1)\n}\n",
    "    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n",
    "    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n",
    "    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n\n    n := len(cost)\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n\n    for i := 1; i < n; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n\n    return dp[n-1][n-1] / float64(2*n-1)\n}\n",
    "    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost[0]) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var dp [][]float64\n    for i := 0; i < len(cost); i++ {\n        dp = append(dp, make([]float64, len(cost[0])))\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < len(cost); i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for i := 1; i < len(cost[0]); i++ {\n        dp[0][i] = dp[0][i-1] + float64(cost[0][i])\n    }\n    for i := 1; i < len(cost); i++ {\n        for j := 1; j < len(cost[0]); j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[len(cost)-1][len(cost[0])-1] / float64(len(cost) + len(cost[0]) - 1)\n}\n",
    "    if len(cost) == 0 {\n        return 0\n    }\n    if len(cost) == 1 {\n        return float64(cost[0][0])\n    }\n    if len(cost[0]) == 1 {\n        return float64(cost[0][0])\n    }\n    var sum float64 = 0\n    var count int = 0\n    var max float64 = 0\n    var maxCount int = 0\n    var maxSum float64 = 0\n    var maxAvg float64 = 0\n    var avg float64 = 0\n    var dfs func(int, int)\n    dfs = func(i, j int) {\n        if i == len(cost) - 1 && j == len(cost[0]) - 1 {\n            sum += float64(cost[i][j])\n            count++\n            avg = sum / float64(count)\n            if avg > maxAvg {\n                maxAvg = avg\n                maxSum = sum\n                maxCount = count\n            }\n            sum -= float64(cost[i][j])\n            count--\n            return\n        }\n        sum += float64(cost[i][j])\n        count++\n        if i < len(cost) - 1 {\n            dfs(i + 1, j)\n        }\n        if j < len(cost[0]) - 1 {\n            dfs(i, j + 1)\n        }\n        sum -= float64(cost[i][j])\n        count--\n    }\n    dfs(0, 0)\n    fmt.Println(maxAvg, maxSum, maxCount)\n    return maxAvg\n}\n",
    "    if len(cost) == 0 {\n        return 0\n    }\n    m, n := len(cost), len(cost[0])\n    dp := make([][]float64, m)\n    for i := 0; i < m; i++ {\n        dp[i] = make([]float64, n)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < m; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < n; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < m; i++ {\n        for j := 1; j < n; j++ {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + float64(cost[i][j])\n        }\n    }\n    return dp[m-1][n-1] / float64(m+n-1)\n}\n",
    "    if len(cost) == 0 || len(cost[0]) == 0 {\n        return 0\n    }\n    n := len(cost)\n    m := len(cost[0])\n    dp := make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = float64(cost[0][0])\n    for i := 1; i < n; i++ {\n        dp[i][0] = dp[i-1][0] + float64(cost[i][0])\n    }\n    for j := 1; j < m; j++ {\n        dp[0][j] = dp[0][j-1] + float64(cost[0][j])\n    }\n    for i := 1; i < n; i++ {\n        for j := 1; j < m; j++ {\n            dp[i][j] = float64(cost[i][j]) + max(dp[i-1][j], dp[i][j-1])\n        }\n    }\n    return dp[n-1][m-1] / float64(n + m - 1)\n}\n"
  ]
}