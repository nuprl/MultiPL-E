{
  "name": "mbpp_299_max_aggregate",
  "language": "go_test.go",
  "prompt": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_299_max_aggregate.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    max_aggregate = make([]interface{}, len(stdata[0]))\n\n    for i := 0; i < len(stdata); i++ {\n        for j := 0; j < len(stdata[i]); j++ {\n            switch stdata[i][j].(type) {\n            case int:\n                if stdata[i][j].(int) > max_aggregate[j].(int) {\n                    max_aggregate[j] = stdata[i][j]\n                }\n            case float64:\n                if stdata[i][j].(float64) > max_aggregate[j].(float64) {\n                    max_aggregate[j] = stdata[i][j]\n                }\n            case string:\n                if stdata[i][j].(string) > max_aggregate[j].(string) {\n                    max_aggregate[j] = stdata[i][j]\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnkejfadp_test.go:41:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnkejfadp_test.go:41:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnkejfadp_test.go:42:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnkejfadp_test.go:42:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnkejfadp_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnkejfadp_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // Write your code here\n    return nil\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8z5iks49_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8z5iks49_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8z5iks49_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8z5iks49_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8z5iks49_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8z5iks49_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for _, v := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = v\n        } else {\n            for i, v2 := range v {\n                switch v2.(type) {\n                case int:\n                    if v2.(int) > max_agg[i].(int) {\n                        max_agg[i] = v2\n                    }\n                case string:\n                    if v2.(string) > max_agg[i].(string) {\n                        max_agg[i] = v2\n                    }\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpp31i15c2_test.go:39:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpp31i15c2_test.go:39:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpp31i15c2_test.go:40:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpp31i15c2_test.go:40:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpp31i15c2_test.go:41:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpp31i15c2_test.go:41:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate_value []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate_value) == 0 {\n            max_aggregate_value = row\n        } else {\n            for i, value := range row {\n                switch value.(type) {\n                case int:\n                    if value.(int) > max_aggregate_value[i].(int) {\n                        max_aggregate_value[i] = value\n                    }\n                case string:\n                    if value.(string) > max_aggregate_value[i].(string) {\n                        max_aggregate_value[i] = value\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate_value\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcvn7ed21_test.go:39:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcvn7ed21_test.go:39:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcvn7ed21_test.go:40:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcvn7ed21_test.go:40:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcvn7ed21_test.go:41:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcvn7ed21_test.go:41:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    if len(stdata) == 0 {\n        return nil\n    }\n    max := stdata[0]\n    for _, v := range stdata {\n        if v[1].(int) > max[1].(int) {\n            max = v\n        }\n    }\n    return max\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppvrocz6e_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppvrocz6e_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppvrocz6e_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppvrocz6e_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppvrocz6e_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppvrocz6e_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_agg[i].(int) {\n                    max_agg[i] = v\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqlfizibl_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqlfizibl_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqlfizibl_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqlfizibl_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqlfizibl_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqlfizibl_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2saan8on_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2saan8on_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2saan8on_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2saan8on_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2saan8on_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2saan8on_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu1_i4zan_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu1_i4zan_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu1_i4zan_test.go:46:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:46:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpln35wwqu_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln35wwqu_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln35wwqu_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln35wwqu_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln35wwqu_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln35wwqu_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpln35wwqu_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln35wwqu_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln35wwqu_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln35wwqu_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln35wwqu_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln35wwqu_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_agg[i].(int) {\n                    max_agg[i] = v\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqlfizibl_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqlfizibl_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqlfizibl_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqlfizibl_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqlfizibl_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqlfizibl_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO: Write your code here\n    return []interface{}{}\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk3cuq96c_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk3cuq96c_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk3cuq96c_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk3cuq96c_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpk3cuq96c_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpk3cuq96c_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_agg = stdata[i]\n        } else {\n            if stdata[i][1].(int) > max_agg[1].(int) {\n                max_agg = stdata[i]\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7c933unl_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7c933unl_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7c933unl_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7c933unl_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7c933unl_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7c933unl_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu1_i4zan_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu1_i4zan_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu1_i4zan_test.go:46:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:46:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = make([]interface{}, len(row))\n            copy(max_agg, row)\n        } else {\n            for i, v := range row {\n                if v.(int) > max_agg[i].(int) {\n                    max_agg[i] = v\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpo_dpfcfh_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo_dpfcfh_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo_dpfcfh_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo_dpfcfh_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpo_dpfcfh_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpo_dpfcfh_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO: implement\n    return nil\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3q56zl8i_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3q56zl8i_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3q56zl8i_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3q56zl8i_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3q56zl8i_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3q56zl8i_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2saan8on_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2saan8on_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2saan8on_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2saan8on_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2saan8on_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2saan8on_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2saan8on_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2saan8on_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2saan8on_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2saan8on_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2saan8on_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2saan8on_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    if len(stdata) == 0 {\n        return []interface{}{}\n    }\n    result := make([]interface{}, len(stdata[0]))\n    for _, row := range stdata {\n        for i, v := range row {\n            switch v.(type) {\n            case int:\n                if v.(int) > result[i].(int) {\n                    result[i] = v\n                }\n            case float64:\n                if v.(float64) > result[i].(float64) {\n                    result[i] = v\n                }\n            case string:\n                if v.(string) > result[i].(string) {\n                    result[i] = v\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc6fhpq6k_test.go:42:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc6fhpq6k_test.go:42:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc6fhpq6k_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc6fhpq6k_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc6fhpq6k_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc6fhpq6k_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max_val interface{}\n        for j := 0; j < len(stdata); j++ {\n            if j == 0 {\n                max_val = stdata[j][i]\n            } else {\n                if stdata[j][i].(int) > max_val.(int) {\n                    max_val = stdata[j][i]\n                }\n            }\n        }\n        max_agg = append(max_agg, max_val)\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6yf_m86b_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6yf_m86b_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6yf_m86b_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6yf_m86b_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6yf_m86b_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6yf_m86b_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    max := make([]interface{}, len(stdata[0]))\n    for _, row := range stdata {\n        for i, val := range row {\n            switch val.(type) {\n            case int:\n                if val.(int) > max[i].(int) {\n                    max[i] = val\n                }\n            case float64:\n                if val.(float64) > max[i].(float64) {\n                    max[i] = val\n                }\n            case string:\n                if val.(string) > max[i].(string) {\n                    max[i] = val\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwjzch4sh_test.go:39:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpwjzch4sh_test.go:39:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpwjzch4sh_test.go:40:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpwjzch4sh_test.go:40:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpwjzch4sh_test.go:41:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpwjzch4sh_test.go:41:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_val int\n    var max_idx int\n    for i, v := range stdata {\n        if i == 0 {\n            max_val = v[1].(int)\n            max_idx = i\n        } else {\n            if v[1].(int) > max_val {\n                max_val = v[1].(int)\n                max_idx = i\n            }\n        }\n    }\n    return stdata[max_idx]\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpos5_pzfp_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpos5_pzfp_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpos5_pzfp_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpos5_pzfp_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpos5_pzfp_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpos5_pzfp_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_aggregate = stdata[i]\n        } else {\n            if max_aggregate[1].(int) < stdata[i][1].(int) {\n                max_aggregate = stdata[i]\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2wa9c7q3_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2wa9c7q3_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2wa9c7q3_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2wa9c7q3_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2wa9c7q3_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2wa9c7q3_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    max_agg = make([]interface{}, len(stdata[0]))\n    for i := 0; i < len(stdata[0]); i++ {\n        max_agg[i] = stdata[0][i]\n    }\n    for i := 1; i < len(stdata); i++ {\n        for j := 0; j < len(stdata[0]); j++ {\n            switch stdata[i][j].(type) {\n            case int:\n                if stdata[i][j].(int) > max_agg[j].(int) {\n                    max_agg[j] = stdata[i][j]\n                }\n            case float64:\n                if stdata[i][j].(float64) > max_agg[j].(float64) {\n                    max_agg[j] = stdata[i][j]\n                }\n            case string:\n                if stdata[i][j].(string) > max_agg[j].(string) {\n                    max_agg[j] = stdata[i][j]\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxp41qnly_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxp41qnly_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxp41qnly_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxp41qnly_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxp41qnly_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxp41qnly_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2saan8on_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2saan8on_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2saan8on_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2saan8on_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2saan8on_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2saan8on_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_aggregate = stdata[i]\n        } else {\n            for j := 0; j < len(stdata[i]); j++ {\n                if max_aggregate[j] < stdata[i][j] {\n                    max_aggregate[j] = stdata[i][j]\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2bxxtg80_test.go:16:37: invalid operation: max_aggregate[j] < stdata[i][j] (operator < not defined on interface)\n/tmp/tmp2bxxtg80_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2bxxtg80_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2bxxtg80_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2bxxtg80_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2bxxtg80_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2bxxtg80_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    var max_aggregate_value float64\n    var max_aggregate_index int\n    for i, row := range stdata {\n        if i == 0 {\n            max_aggregate = row\n            max_aggregate_value = row[1].(float64)\n            max_aggregate_index = i\n        } else {\n            if row[1].(float64) > max_aggregate_value {\n                max_aggregate = row\n                max_aggregate_value = row[1].(float64)\n                max_aggregate_index = i\n            }\n        }\n    }\n    fmt.Println(\"max_aggregate_index:\", max_aggregate_index)\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkdhdcroa_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpkdhdcroa_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpkdhdcroa_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpkdhdcroa_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpkdhdcroa_test.go:39:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpkdhdcroa_test.go:39:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu1_i4zan_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu1_i4zan_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu1_i4zan_test.go:46:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:46:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        for i, col := range row {\n            if i == 0 {\n                max_aggregate = append(max_aggregate, col)\n            } else {\n                if col.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = col\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuhrqc_wz_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpuhrqc_wz_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpuhrqc_wz_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpuhrqc_wz_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpuhrqc_wz_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpuhrqc_wz_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    var max_aggregate_value float64\n    var max_aggregate_index int\n    for i, v := range stdata {\n        if i == 0 {\n            max_aggregate = v\n            max_aggregate_value = v[1].(float64)\n            max_aggregate_index = i\n        } else {\n            if v[1].(float64) > max_aggregate_value {\n                max_aggregate = v\n                max_aggregate_value = v[1].(float64)\n                max_aggregate_index = i\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5zgg1toy_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5zgg1toy_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5zgg1toy_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5zgg1toy_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5zgg1toy_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5zgg1toy_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO: Implement\n    return []interface{}{}\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq0t_gg3b_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpq0t_gg3b_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpq0t_gg3b_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpq0t_gg3b_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpq0t_gg3b_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpq0t_gg3b_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    max_aggregate = make([]interface{}, len(stdata[0]))\n    for i := 0; i < len(stdata[0]); i++ {\n        max_aggregate[i] = stdata[0][i]\n    }\n    for i := 1; i < len(stdata); i++ {\n        for j := 0; j < len(stdata[i]); j++ {\n            switch stdata[i][j].(type) {\n            case int:\n                if stdata[i][j].(int) > max_aggregate[j].(int) {\n                    max_aggregate[j] = stdata[i][j]\n                }\n            case float64:\n                if stdata[i][j].(float64) > max_aggregate[j].(float64) {\n                    max_aggregate[j] = stdata[i][j]\n                }\n            case string:\n                if stdata[i][j].(string) > max_aggregate[j].(string) {\n                    max_aggregate[j] = stdata[i][j]\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvd4552tx_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvd4552tx_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvd4552tx_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvd4552tx_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvd4552tx_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvd4552tx_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for i := range stdata {\n        if i == 0 {\n            max_agg = stdata[i]\n        } else {\n            for j := range stdata[i] {\n                if stdata[i][j].(float64) > max_agg[j].(float64) {\n                    max_agg[j] = stdata[i][j]\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8xnm_mij_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8xnm_mij_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8xnm_mij_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8xnm_mij_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8xnm_mij_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8xnm_mij_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu1_i4zan_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu1_i4zan_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu1_i4zan_test.go:46:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:46:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_agg = stdata[i]\n        } else {\n            if stdata[i][1].(int) > max_agg[1].(int) {\n                max_agg = stdata[i]\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7c933unl_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7c933unl_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7c933unl_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7c933unl_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7c933unl_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7c933unl_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, val := range row {\n                if val.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = val\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxo_s84eu_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxo_s84eu_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxo_s84eu_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxo_s84eu_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxo_s84eu_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxo_s84eu_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, item := range row {\n                if item.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = item\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7q260sar_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7q260sar_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7q260sar_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7q260sar_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7q260sar_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7q260sar_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for _, tuple := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = tuple\n        } else {\n            for i, v := range tuple {\n                if v.(int) > max_agg[i].(int) {\n                    max_agg[i] = v\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv4_ivuix_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpv4_ivuix_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpv4_ivuix_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpv4_ivuix_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpv4_ivuix_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpv4_ivuix_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for _, tup := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = tup\n        } else {\n            for i, v := range tup {\n                if v.(int) > max_agg[i].(int) {\n                    max_agg[i] = v\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0vn4boex_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0vn4boex_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0vn4boex_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0vn4boex_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0vn4boex_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0vn4boex_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO: implement this function\n    return nil\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8_5ezjuf_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8_5ezjuf_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8_5ezjuf_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8_5ezjuf_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8_5ezjuf_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8_5ezjuf_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_agg[i].(int) {\n                        max_agg[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_agg[i].(float64) {\n                        max_agg[i] = v\n                    }\n                case string:\n                    if v.(string) > max_agg[i].(string) {\n                        max_agg[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpiqgwmyno_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpiqgwmyno_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpiqgwmyno_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpiqgwmyno_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpiqgwmyno_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpiqgwmyno_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    var max_aggregate_value float64 = 0\n    for _, row := range stdata {\n        var aggregate_value float64 = 0\n        for _, value := range row {\n            aggregate_value += value.(float64)\n        }\n        if aggregate_value > max_aggregate_value {\n            max_aggregate = row\n            max_aggregate_value = aggregate_value\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7psp60te_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7psp60te_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7psp60te_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7psp60te_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7psp60te_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7psp60te_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu1_i4zan_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu1_i4zan_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu1_i4zan_test.go:46:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:46:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, col := range row {\n                if col.(int) > max_agg[i].(int) {\n                    max_agg[i] = col\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnak49wer_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnak49wer_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnak49wer_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnak49wer_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnak49wer_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnak49wer_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    if len(stdata) == 0 {\n        return []interface{}{}\n    }\n\n    var max_aggregate []interface{}\n    for _, tuple := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = tuple\n        } else {\n            for i, v := range tuple {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5_4bs9bq_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5_4bs9bq_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5_4bs9bq_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5_4bs9bq_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5_4bs9bq_test.go:39:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5_4bs9bq_test.go:39:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2saan8on_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2saan8on_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2saan8on_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2saan8on_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2saan8on_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2saan8on_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp04rqgok__test.go:39:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp04rqgok__test.go:39:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp04rqgok__test.go:40:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp04rqgok__test.go:40:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp04rqgok__test.go:41:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp04rqgok__test.go:41:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO: Implement this function.\n    return []interface{}{}\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1fg_iseh_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1fg_iseh_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1fg_iseh_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1fg_iseh_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1fg_iseh_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1fg_iseh_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO: write your code here\n    return nil\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd5k2_tcf_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpd5k2_tcf_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpd5k2_tcf_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpd5k2_tcf_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpd5k2_tcf_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpd5k2_tcf_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for i, row := range stdata {\n        if i == 0 {\n            max_agg = make([]interface{}, len(row))\n            copy(max_agg, row)\n        } else {\n            for j, val := range row {\n                switch val.(type) {\n                case int:\n                    if val.(int) > max_agg[j].(int) {\n                        max_agg[j] = val\n                    }\n                case float64:\n                    if val.(float64) > max_agg[j].(float64) {\n                        max_agg[j] = val\n                    }\n                case string:\n                    if val.(string) > max_agg[j].(string) {\n                        max_agg[j] = val\n                    }\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_dniz8vu_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_dniz8vu_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_dniz8vu_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_dniz8vu_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_dniz8vu_test.go:46:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_dniz8vu_test.go:46:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO: Implement me!\n    return nil\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpycp6as90_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpycp6as90_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpycp6as90_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpycp6as90_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpycp6as90_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpycp6as90_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for _, row := range stdata {\n        if max_agg == nil {\n            max_agg = row\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_agg[i].(int) {\n                        max_agg[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_agg[i].(float64) {\n                        max_agg[i] = v\n                    }\n                case string:\n                    if v.(string) > max_agg[i].(string) {\n                        max_agg[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkk9x4ril_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpkk9x4ril_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpkk9x4ril_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpkk9x4ril_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpkk9x4ril_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpkk9x4ril_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    max := stdata[0]\n    for _, v := range stdata {\n        if v[1].(int) > max[1].(int) {\n            max = v\n        }\n    }\n    return max\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpafjny_mx_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpafjny_mx_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpafjny_mx_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpafjny_mx_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpafjny_mx_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpafjny_mx_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_aggregate = stdata[i]\n        } else {\n            if stdata[i][1].(int) > max_aggregate[1].(int) {\n                max_aggregate = stdata[i]\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5zqsrkfz_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5zqsrkfz_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5zqsrkfz_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5zqsrkfz_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5zqsrkfz_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5zqsrkfz_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO: Implement\n    return []interface{}{}\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq0t_gg3b_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpq0t_gg3b_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpq0t_gg3b_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpq0t_gg3b_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpq0t_gg3b_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpq0t_gg3b_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_agg = stdata[i]\n        } else {\n            if stdata[i][0].(int) > max_agg[0].(int) {\n                max_agg = stdata[i]\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8lpr6uof_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8lpr6uof_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8lpr6uof_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8lpr6uof_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8lpr6uof_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8lpr6uof_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if max_aggregate == nil {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqxg5auep_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqxg5auep_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqxg5auep_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqxg5auep_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqxg5auep_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqxg5auep_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, tuple := range stdata {\n        if max_aggregate == nil {\n            max_aggregate = tuple\n        } else {\n            for i, value := range tuple {\n                switch value.(type) {\n                case int:\n                    if value.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = value\n                    }\n                case float64:\n                    if value.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = value\n                    }\n                case string:\n                    if value.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = value\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7gct7_fw_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7gct7_fw_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7gct7_fw_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7gct7_fw_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7gct7_fw_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7gct7_fw_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_agg[i].(int) {\n                        max_agg[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_agg[i].(float64) {\n                        max_agg[i] = v\n                    }\n                case string:\n                    if v.(string) > max_agg[i].(string) {\n                        max_agg[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpiqgwmyno_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpiqgwmyno_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpiqgwmyno_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpiqgwmyno_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpiqgwmyno_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpiqgwmyno_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    var max_value float64\n    var max_key string\n    var max_count int\n    for _, row := range stdata {\n        if row[0].(string) == \"MAX\" {\n            if row[2].(float64) > max_value {\n                max_value = row[2].(float64)\n                max_key = row[1].(string)\n                max_count = 1\n            } else if row[2].(float64) == max_value {\n                max_count += 1\n            }\n        }\n    }\n    max_aggregate = append(max_aggregate, max_key, max_value, max_count)\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpla9yzx8g_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpla9yzx8g_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpla9yzx8g_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpla9yzx8g_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpla9yzx8g_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpla9yzx8g_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var result []interface{}\n    for _, row := range stdata {\n        for _, col := range row {\n            result = append(result, col)\n        }\n    }\n    return result\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3jb2qi9e_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3jb2qi9e_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3jb2qi9e_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3jb2qi9e_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3jb2qi9e_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3jb2qi9e_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, val := range row {\n                if val.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = val\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxbjs2a95_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxbjs2a95_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxbjs2a95_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxbjs2a95_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxbjs2a95_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxbjs2a95_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_agg[i].(int) {\n                        max_agg[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_agg[i].(float64) {\n                        max_agg[i] = v\n                    }\n                case string:\n                    if v.(string) > max_agg[i].(string) {\n                        max_agg[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpiqgwmyno_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpiqgwmyno_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpiqgwmyno_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpiqgwmyno_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpiqgwmyno_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpiqgwmyno_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu1_i4zan_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu1_i4zan_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu1_i4zan_test.go:46:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:46:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max_value interface{}\n        for j := 0; j < len(stdata); j++ {\n            if j == 0 {\n                max_value = stdata[j][i]\n            } else {\n                if stdata[j][i].(int) > max_value.(int) {\n                    max_value = stdata[j][i]\n                }\n            }\n        }\n        max_aggregate = append(max_aggregate, max_value)\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpenjr0eld_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpenjr0eld_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpenjr0eld_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpenjr0eld_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpenjr0eld_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpenjr0eld_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2saan8on_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2saan8on_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2saan8on_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2saan8on_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2saan8on_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2saan8on_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpln35wwqu_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln35wwqu_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln35wwqu_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln35wwqu_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln35wwqu_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln35wwqu_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, tuple := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = tuple\n        } else {\n            for i, value := range tuple {\n                switch value.(type) {\n                case int:\n                    if value.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = value\n                    }\n                case float64:\n                    if value.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = value\n                    }\n                case string:\n                    if value.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = value\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt04x6d64_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt04x6d64_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt04x6d64_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt04x6d64_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt04x6d64_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt04x6d64_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    max := 0\n    for _, v := range stdata {\n        if v[1].(int) > max {\n            max = v[1].(int)\n        }\n    }\n    return []interface{}{max}\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3f7o9gpi_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3f7o9gpi_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3f7o9gpi_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3f7o9gpi_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3f7o9gpi_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3f7o9gpi_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    max := stdata[0]\n    for _, v := range stdata {\n        if v[1].(int) > max[1].(int) {\n            max = v\n        }\n    }\n    return max\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpafjny_mx_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpafjny_mx_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpafjny_mx_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpafjny_mx_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpafjny_mx_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpafjny_mx_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    max := make([]interface{}, len(stdata[0]))\n    for _, row := range stdata {\n        for i, col := range row {\n            switch col.(type) {\n            case int:\n                if col.(int) > max[i].(int) {\n                    max[i] = col\n                }\n            case float64:\n                if col.(float64) > max[i].(float64) {\n                    max[i] = col\n                }\n            case string:\n                if col.(string) > max[i].(string) {\n                    max[i] = col\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi99bm8q0_test.go:39:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpi99bm8q0_test.go:39:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi99bm8q0_test.go:40:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpi99bm8q0_test.go:40:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi99bm8q0_test.go:41:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpi99bm8q0_test.go:41:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu1_i4zan_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu1_i4zan_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu1_i4zan_test.go:46:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:46:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_aggregate = stdata[i]\n        } else {\n            for j := 0; j < len(stdata[i]); j++ {\n                if j == 0 {\n                    continue\n                } else {\n                    if stdata[i][j] > max_aggregate[j] {\n                        max_aggregate[j] = stdata[i][j]\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptrloo2d6_test.go:19:37: invalid operation: stdata[i][j] > max_aggregate[j] (operator > not defined on interface)\n/tmp/tmptrloo2d6_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptrloo2d6_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptrloo2d6_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptrloo2d6_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptrloo2d6_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptrloo2d6_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    result := make([]interface{}, len(stdata[0]))\n    for i := 0; i < len(stdata[0]); i++ {\n        result[i] = stdata[0][i]\n    }\n    for i := 1; i < len(stdata); i++ {\n        for j := 0; j < len(stdata[i]); j++ {\n            switch stdata[i][j].(type) {\n            case int:\n                if result[j].(int) < stdata[i][j].(int) {\n                    result[j] = stdata[i][j]\n                }\n            case float64:\n                if result[j].(float64) < stdata[i][j].(float64) {\n                    result[j] = stdata[i][j]\n                }\n            case string:\n                if result[j].(string) < stdata[i][j].(string) {\n                    result[j] = stdata[i][j]\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8nkgpc3i_test.go:42:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8nkgpc3i_test.go:42:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8nkgpc3i_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8nkgpc3i_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8nkgpc3i_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8nkgpc3i_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO: Implement me!\n    return []interface{}{}\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprer5gl3s_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprer5gl3s_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprer5gl3s_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprer5gl3s_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprer5gl3s_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprer5gl3s_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if max_aggregate == nil {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, value := range row {\n                if value.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = value\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnapm475p_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnapm475p_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnapm475p_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnapm475p_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnapm475p_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnapm475p_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if max_aggregate == nil {\n            max_aggregate = row\n        } else {\n            for i, val := range row {\n                switch val.(type) {\n                case int:\n                    if val.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = val\n                    }\n                case float64:\n                    if val.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = val\n                    }\n                case string:\n                    if val.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = val\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr4fulbek_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr4fulbek_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr4fulbek_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr4fulbek_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr4fulbek_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr4fulbek_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_aggregate = stdata[i]\n        } else {\n            for j := 0; j < len(stdata[i]); j++ {\n                if stdata[i][j].(int) > max_aggregate[j].(int) {\n                    max_aggregate[j] = stdata[i][j]\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp44naijke_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp44naijke_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp44naijke_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp44naijke_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp44naijke_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp44naijke_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    var max_aggregate_value float64 = 0.0\n    for _, row := range stdata {\n        var aggregate_value float64 = 0.0\n        for _, value := range row {\n            switch value.(type) {\n            case float64:\n                aggregate_value += value.(float64)\n            }\n        }\n        if aggregate_value > max_aggregate_value {\n            max_aggregate_value = aggregate_value\n            max_aggregate = row\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnyn7m6gy_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnyn7m6gy_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnyn7m6gy_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnyn7m6gy_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnyn7m6gy_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnyn7m6gy_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        max_agg = append(max_agg, stdata[0][i])\n    }\n    for i := 1; i < len(stdata); i++ {\n        for j := 0; j < len(stdata[i]); j++ {\n            switch stdata[i][j].(type) {\n            case int:\n                if stdata[i][j].(int) > max_agg[j].(int) {\n                    max_agg[j] = stdata[i][j]\n                }\n            case float64:\n                if stdata[i][j].(float64) > max_agg[j].(float64) {\n                    max_agg[j] = stdata[i][j]\n                }\n            case string:\n                if stdata[i][j].(string) > max_agg[j].(string) {\n                    max_agg[j] = stdata[i][j]\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn5c3fr0a_test.go:42:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpn5c3fr0a_test.go:42:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpn5c3fr0a_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpn5c3fr0a_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpn5c3fr0a_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpn5c3fr0a_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO: Implement me!\n    return nil\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpycp6as90_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpycp6as90_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpycp6as90_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpycp6as90_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpycp6as90_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpycp6as90_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmxu_5vmv_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmxu_5vmv_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmxu_5vmv_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmxu_5vmv_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmxu_5vmv_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmxu_5vmv_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    var max_value float64 = 0.0\n    for _, row := range stdata {\n        var agg_value float64 = 0.0\n        for _, value := range row {\n            agg_value += value.(float64)\n        }\n        if agg_value > max_value {\n            max_value = agg_value\n            max_aggregate = row\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp87y5dgj3_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp87y5dgj3_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp87y5dgj3_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp87y5dgj3_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp87y5dgj3_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp87y5dgj3_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_aggregate = stdata[i]\n        } else {\n            if stdata[i][1].(int) > max_aggregate[1].(int) {\n                max_aggregate = stdata[i]\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5zqsrkfz_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5zqsrkfz_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5zqsrkfz_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5zqsrkfz_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5zqsrkfz_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5zqsrkfz_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO: Write your code here\n    return nil\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwif3_54b_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpwif3_54b_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpwif3_54b_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpwif3_54b_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpwif3_54b_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpwif3_54b_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu1_i4zan_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu1_i4zan_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu1_i4zan_test.go:46:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:46:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, val := range row {\n                if val.(int) > max_agg[i].(int) {\n                    max_agg[i] = val\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi4jauv7u_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpi4jauv7u_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi4jauv7u_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpi4jauv7u_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi4jauv7u_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpi4jauv7u_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    var max_aggregate_value float64 = 0.0\n    for _, row := range stdata {\n        var aggregate_value float64 = 0.0\n        for _, value := range row {\n            switch value.(type) {\n            case int:\n                aggregate_value += float64(value.(int))\n            case float64:\n                aggregate_value += value.(float64)\n            default:\n                panic(\"Unsupported type\")\n            }\n        }\n        if aggregate_value > max_aggregate_value {\n            max_aggregate = row\n            max_aggregate_value = aggregate_value\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8xcd71no_test.go:39:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8xcd71no_test.go:39:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8xcd71no_test.go:40:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8xcd71no_test.go:40:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8xcd71no_test.go:41:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8xcd71no_test.go:41:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    max_aggregate := make([]interface{}, len(stdata[0]))\n    for i := 0; i < len(stdata[0]); i++ {\n        max_aggregate[i] = stdata[0][i]\n    }\n    for i := 1; i < len(stdata); i++ {\n        for j := 0; j < len(stdata[0]); j++ {\n            if stdata[i][j].(int) > max_aggregate[j].(int) {\n                max_aggregate[j] = stdata[i][j]\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp13_nsygb_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp13_nsygb_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp13_nsygb_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp13_nsygb_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp13_nsygb_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp13_nsygb_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO: implement\n    return []interface{}{}\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3qo99sja_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3qo99sja_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3qo99sja_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3qo99sja_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3qo99sja_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3qo99sja_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    if len(stdata) == 0 {\n        return nil\n    }\n    max := stdata[0]\n    for _, v := range stdata {\n        if v[1].(int) > max[1].(int) {\n            max = v\n        }\n    }\n    return max\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppvrocz6e_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppvrocz6e_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppvrocz6e_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppvrocz6e_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppvrocz6e_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppvrocz6e_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if max_aggregate == nil {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt9jmgiij_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt9jmgiij_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt9jmgiij_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt9jmgiij_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpt9jmgiij_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpt9jmgiij_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i := 0; i < len(row); i++ {\n                if row[i].(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = row[i]\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsderjq3g_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpsderjq3g_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsderjq3g_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpsderjq3g_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsderjq3g_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpsderjq3g_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if max_aggregate == nil {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzgtxaoww_test.go:40:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzgtxaoww_test.go:40:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzgtxaoww_test.go:41:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzgtxaoww_test.go:41:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzgtxaoww_test.go:42:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzgtxaoww_test.go:42:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, col := range row {\n                if col.(int) > max_agg[i].(int) {\n                    max_agg[i] = col\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnak49wer_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnak49wer_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnak49wer_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnak49wer_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnak49wer_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnak49wer_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if max_aggregate == nil {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvyqyugnf_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvyqyugnf_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvyqyugnf_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvyqyugnf_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvyqyugnf_test.go:46:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvyqyugnf_test.go:46:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_value []interface{}\n    max_value = stdata[0]\n    for _, value := range stdata {\n        if value[1].(int) > max_value[1].(int) {\n            max_value = value\n        }\n    }\n    return max_value\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfrwhf29s_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfrwhf29s_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfrwhf29s_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfrwhf29s_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfrwhf29s_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfrwhf29s_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    if len(stdata) == 0 {\n        return nil\n    }\n\n    // Initialize the max aggregate with the first tuple.\n    max_aggregate := make([]interface{}, len(stdata[0]))\n    copy(max_aggregate, stdata[0])\n\n    for _, tuple := range stdata[1:] {\n        for i, v := range tuple {\n            switch v.(type) {\n            case int:\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            case float64:\n                if v.(float64) > max_aggregate[i].(float64) {\n                    max_aggregate[i] = v\n                }\n            case string:\n                if v.(string) > max_aggregate[i].(string) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmtejbhne_test.go:47:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmtejbhne_test.go:47:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmtejbhne_test.go:48:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmtejbhne_test.go:48:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmtejbhne_test.go:49:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmtejbhne_test.go:49:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var result []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max float64\n        for j := 0; j < len(stdata); j++ {\n            if stdata[j][i].(float64) > max {\n                max = stdata[j][i].(float64)\n            }\n        }\n        result = append(result, max)\n    }\n    return result\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx8r_o890_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx8r_o890_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx8r_o890_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx8r_o890_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx8r_o890_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx8r_o890_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_aggregate = stdata[i]\n        } else {\n            if stdata[i][1].(int) > max_aggregate[1].(int) {\n                max_aggregate = stdata[i]\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5zqsrkfz_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5zqsrkfz_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5zqsrkfz_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5zqsrkfz_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5zqsrkfz_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5zqsrkfz_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if max_aggregate == nil {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvyqyugnf_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvyqyugnf_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvyqyugnf_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvyqyugnf_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvyqyugnf_test.go:46:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvyqyugnf_test.go:46:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    max := make([]interface{}, len(stdata[0]))\n    for _, row := range stdata {\n        for i, v := range row {\n            switch v.(type) {\n            case int:\n                if v.(int) > max[i].(int) {\n                    max[i] = v\n                }\n            case float64:\n                if v.(float64) > max[i].(float64) {\n                    max[i] = v\n                }\n            case string:\n                if v.(string) > max[i].(string) {\n                    max[i] = v\n                }\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1aqcswkd_test.go:39:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1aqcswkd_test.go:39:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1aqcswkd_test.go:40:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1aqcswkd_test.go:40:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1aqcswkd_test.go:41:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1aqcswkd_test.go:41:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, tuple := range stdata {\n        if max_aggregate == nil {\n            max_aggregate = tuple\n        } else {\n            for i, value := range tuple {\n                switch value.(type) {\n                case int:\n                    if value.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = value\n                    }\n                case float64:\n                    if value.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = value\n                    }\n                case string:\n                    if value.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = value\n                    }\n                default:\n                    fmt.Println(\"Unknown type\")\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbelvo89w_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbelvo89w_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbelvo89w_test.go:46:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbelvo89w_test.go:46:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbelvo89w_test.go:47:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbelvo89w_test.go:47:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max_val interface{}\n        for j := 0; j < len(stdata); j++ {\n            if j == 0 {\n                max_val = stdata[j][i]\n            } else {\n                if stdata[j][i].(int) > max_val.(int) {\n                    max_val = stdata[j][i]\n                }\n            }\n        }\n        max_aggregate = append(max_aggregate, max_val)\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6boaimzl_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6boaimzl_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6boaimzl_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6boaimzl_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp6boaimzl_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp6boaimzl_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO: Implement me!\n    return []interface{}{}\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprer5gl3s_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprer5gl3s_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprer5gl3s_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprer5gl3s_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprer5gl3s_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprer5gl3s_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO: implement\n    return []interface{}{}\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3qo99sja_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3qo99sja_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3qo99sja_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3qo99sja_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3qo99sja_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3qo99sja_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    max := stdata[0]\n    for i := 1; i < len(stdata); i++ {\n        if stdata[i][1].(int) > max[1].(int) {\n            max = stdata[i]\n        }\n    }\n    return max\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgxf92lvb_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgxf92lvb_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgxf92lvb_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgxf92lvb_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgxf92lvb_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgxf92lvb_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO: Implement the function here\n    return nil\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3o3jcoyy_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3o3jcoyy_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3o3jcoyy_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3o3jcoyy_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3o3jcoyy_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3o3jcoyy_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        max_agg = append(max_agg, stdata[0][i])\n    }\n    for i := 1; i < len(stdata); i++ {\n        for j := 0; j < len(stdata[i]); j++ {\n            switch stdata[i][j].(type) {\n            case int:\n                if stdata[i][j].(int) > max_agg[j].(int) {\n                    max_agg[j] = stdata[i][j]\n                }\n            case float64:\n                if stdata[i][j].(float64) > max_agg[j].(float64) {\n                    max_agg[j] = stdata[i][j]\n                }\n            case string:\n                if stdata[i][j].(string) > max_agg[j].(string) {\n                    max_agg[j] = stdata[i][j]\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn5c3fr0a_test.go:42:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpn5c3fr0a_test.go:42:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpn5c3fr0a_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpn5c3fr0a_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpn5c3fr0a_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpn5c3fr0a_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    if len(stdata) == 0 {\n        return nil\n    }\n    max := stdata[0]\n    for _, v := range stdata {\n        if v[1].(int) > max[1].(int) {\n            max = v\n        }\n    }\n    return max\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppvrocz6e_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppvrocz6e_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppvrocz6e_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppvrocz6e_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppvrocz6e_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppvrocz6e_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, cell := range row {\n                if cell.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = cell\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxbk7etm9_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxbk7etm9_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxbk7etm9_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxbk7etm9_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxbk7etm9_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxbk7etm9_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    if len(stdata) == 0 {\n        return []interface{}{}\n    }\n    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = make([]interface{}, len(row))\n            copy(max_agg, row)\n        } else {\n            for i, cell := range row {\n                if max_agg[i] == nil {\n                    max_agg[i] = cell\n                } else if cell != nil {\n                    switch cell.(type) {\n                    case int:\n                        if cell.(int) > max_agg[i].(int) {\n                            max_agg[i] = cell\n                        }\n                    case float64:\n                        if cell.(float64) > max_agg[i].(float64) {\n                            max_agg[i] = cell\n                        }\n                    case string:\n                        if cell.(string) > max_agg[i].(string) {\n                            max_agg[i] = cell\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2xnb5ys8_test.go:51:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2xnb5ys8_test.go:51:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2xnb5ys8_test.go:52:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2xnb5ys8_test.go:52:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2xnb5ys8_test.go:53:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2xnb5ys8_test.go:53:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = make([]interface{}, len(row))\n            copy(max_agg, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_agg[i].(int) {\n                        max_agg[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_agg[i].(float64) {\n                        max_agg[i] = v\n                    }\n                case string:\n                    if v.(string) > max_agg[i].(string) {\n                        max_agg[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9bmbzpto_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9bmbzpto_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9bmbzpto_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9bmbzpto_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp9bmbzpto_test.go:46:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp9bmbzpto_test.go:46:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, tuple := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = tuple\n        } else {\n            for i, val := range tuple {\n                switch val.(type) {\n                case int:\n                    if val.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = val\n                    }\n                case float64:\n                    if val.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = val\n                    }\n                case string:\n                    if val.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = val\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjd627fv9_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpjd627fv9_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpjd627fv9_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpjd627fv9_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpjd627fv9_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpjd627fv9_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    if len(stdata) == 0 {\n        return []interface{}{}\n    }\n    max := stdata[0]\n    for _, v := range stdata {\n        if v[1].(int) > max[1].(int) {\n            max = v\n        }\n    }\n    return max\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123553,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfcrnllzl_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfcrnllzl_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfcrnllzl_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfcrnllzl_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfcrnllzl_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfcrnllzl_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO: Implement me\n    return []interface{}{}\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123553,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph49jaogr_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph49jaogr_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph49jaogr_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph49jaogr_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmph49jaogr_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmph49jaogr_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_agg[i].(int) {\n                    max_agg[i] = v\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqlfizibl_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqlfizibl_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqlfizibl_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqlfizibl_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqlfizibl_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqlfizibl_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO\n    return nil\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123553,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbkvsg6n4_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbkvsg6n4_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbkvsg6n4_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbkvsg6n4_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbkvsg6n4_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbkvsg6n4_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    max_agg := make([]interface{}, len(stdata[0]))\n    for i := 0; i < len(stdata[0]); i++ {\n        max_agg[i] = stdata[0][i]\n    }\n    for i := 1; i < len(stdata); i++ {\n        for j := 0; j < len(stdata[0]); j++ {\n            if stdata[i][j].(int) > max_agg[j].(int) {\n                max_agg[j] = stdata[i][j]\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123553,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppv6ui3_c_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppv6ui3_c_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppv6ui3_c_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppv6ui3_c_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmppv6ui3_c_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmppv6ui3_c_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_aggregate = stdata[i]\n        } else {\n            for j := 0; j < len(stdata[i]); j++ {\n                if stdata[i][j].(int) > max_aggregate[j].(int) {\n                    max_aggregate[j] = stdata[i][j]\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp44naijke_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp44naijke_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp44naijke_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp44naijke_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp44naijke_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp44naijke_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i := 0; i < len(row); i++ {\n                if row[i].(int) > max_agg[i].(int) {\n                    max_agg[i] = row[i]\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123554,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxbshtltn_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxbshtltn_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxbshtltn_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxbshtltn_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpxbshtltn_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpxbshtltn_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, col := range row {\n                if col.(int) > max_agg[i].(int) {\n                    max_agg[i] = col\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnak49wer_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnak49wer_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnak49wer_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnak49wer_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnak49wer_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnak49wer_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO: Implement\n    return []interface{}{}\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq0t_gg3b_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpq0t_gg3b_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpq0t_gg3b_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpq0t_gg3b_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpq0t_gg3b_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpq0t_gg3b_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_aggregate = stdata[i]\n        } else {\n            if stdata[i][1].(int) > max_aggregate[1].(int) {\n                max_aggregate = stdata[i]\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5zqsrkfz_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5zqsrkfz_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5zqsrkfz_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5zqsrkfz_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5zqsrkfz_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5zqsrkfz_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO: Implement me!\n    return nil\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpycp6as90_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpycp6as90_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpycp6as90_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpycp6as90_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpycp6as90_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpycp6as90_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmxu_5vmv_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmxu_5vmv_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmxu_5vmv_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmxu_5vmv_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmxu_5vmv_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmxu_5vmv_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO: Implement\n    return nil\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123554,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaztl1skk_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpaztl1skk_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpaztl1skk_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpaztl1skk_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpaztl1skk_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpaztl1skk_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i := 0; i < len(row); i++ {\n                if row[i].(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = row[i]\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsderjq3g_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpsderjq3g_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsderjq3g_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpsderjq3g_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpsderjq3g_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpsderjq3g_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_agg[i].(int) {\n                    max_agg[i] = v\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqlfizibl_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqlfizibl_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqlfizibl_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqlfizibl_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqlfizibl_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqlfizibl_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // Write your code here\n    return []interface{}{}\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123554,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_n5wcz7v_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_n5wcz7v_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_n5wcz7v_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_n5wcz7v_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp_n5wcz7v_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp_n5wcz7v_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_aggregate = stdata[i]\n        } else {\n            for j := 0; j < len(stdata[i]); j++ {\n                if max_aggregate[j].(int) < stdata[i][j].(int) {\n                    max_aggregate[j] = stdata[i][j]\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123554,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd435kxc8_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpd435kxc8_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpd435kxc8_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpd435kxc8_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpd435kxc8_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpd435kxc8_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_agg[i].(int) {\n                    max_agg[i] = v\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqlfizibl_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqlfizibl_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqlfizibl_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqlfizibl_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqlfizibl_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqlfizibl_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    if len(stdata) == 0 {\n        return nil\n    }\n\n    max_aggregate := make([]interface{}, len(stdata[0]))\n    for i := range max_aggregate {\n        max_aggregate[i] = stdata[0][i]\n    }\n\n    for _, row := range stdata {\n        for i, value := range row {\n            switch max_aggregate[i].(type) {\n            case int:\n                if value.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = value\n                }\n            case float64:\n                if value.(float64) > max_aggregate[i].(float64) {\n                    max_aggregate[i] = value\n                }\n            case string:\n                if value.(string) > max_aggregate[i].(string) {\n                    max_aggregate[i] = value\n                }\n            default:\n                panic(fmt.Sprintf(\"Unsupported type: %T\", value))\n            }\n        }\n    }\n\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123554,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnxobq7n8_test.go:50:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnxobq7n8_test.go:50:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnxobq7n8_test.go:51:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnxobq7n8_test.go:51:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnxobq7n8_test.go:52:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnxobq7n8_test.go:52:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if max_aggregate == nil {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzgtxaoww_test.go:40:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzgtxaoww_test.go:40:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzgtxaoww_test.go:41:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzgtxaoww_test.go:41:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzgtxaoww_test.go:42:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzgtxaoww_test.go:42:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO: implement\n    return nil\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3q56zl8i_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3q56zl8i_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3q56zl8i_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3q56zl8i_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3q56zl8i_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3q56zl8i_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_aggregate = stdata[i]\n        } else {\n            if stdata[i][1].(int) > max_aggregate[1].(int) {\n                max_aggregate = stdata[i]\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5zqsrkfz_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5zqsrkfz_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5zqsrkfz_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5zqsrkfz_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5zqsrkfz_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5zqsrkfz_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    var max_aggregate_value int\n    for _, row := range stdata {\n        var aggregate int\n        for _, value := range row {\n            switch value.(type) {\n            case int:\n                aggregate += value.(int)\n            }\n        }\n        if aggregate > max_aggregate_value {\n            max_aggregate_value = aggregate\n            max_aggregate = row\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123554,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1ppij88b_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1ppij88b_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1ppij88b_test.go:36:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1ppij88b_test.go:36:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1ppij88b_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1ppij88b_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO: implement this function\n    return []interface{}{}\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123554,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfo898a0z_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfo898a0z_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfo898a0z_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfo898a0z_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfo898a0z_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfo898a0z_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for _, row := range stdata {\n        if max_agg == nil {\n            max_agg = row\n        } else {\n            for i, col := range row {\n                switch col.(type) {\n                case int:\n                    if col.(int) > max_agg[i].(int) {\n                        max_agg[i] = col\n                    }\n                case float64:\n                    if col.(float64) > max_agg[i].(float64) {\n                        max_agg[i] = col\n                    }\n                case string:\n                    if col.(string) > max_agg[i].(string) {\n                        max_agg[i] = col\n                    }\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123554,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpckxa66bb_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpckxa66bb_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpckxa66bb_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpckxa66bb_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpckxa66bb_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpckxa66bb_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2saan8on_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2saan8on_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2saan8on_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2saan8on_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2saan8on_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2saan8on_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmxu_5vmv_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmxu_5vmv_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmxu_5vmv_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmxu_5vmv_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmxu_5vmv_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmxu_5vmv_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_aggregate = stdata[i]\n        } else {\n            if stdata[i][1].(int) > max_aggregate[1].(int) {\n                max_aggregate = stdata[i]\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5zqsrkfz_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5zqsrkfz_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5zqsrkfz_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5zqsrkfz_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5zqsrkfz_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5zqsrkfz_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, tuple := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = tuple\n        } else {\n            for i := range tuple {\n                if tuple[i].(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = tuple[i]\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123554,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7woewbsk_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7woewbsk_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7woewbsk_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7woewbsk_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7woewbsk_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7woewbsk_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for _, row := range stdata {\n        if max_agg == nil {\n            max_agg = make([]interface{}, len(row))\n            copy(max_agg, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_agg[i].(int) {\n                        max_agg[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_agg[i].(float64) {\n                        max_agg[i] = v\n                    }\n                case string:\n                    if v.(string) > max_agg[i].(string) {\n                        max_agg[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123554,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnigwmj17_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnigwmj17_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnigwmj17_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnigwmj17_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnigwmj17_test.go:46:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnigwmj17_test.go:46:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO: implement this function\n    return []interface{}{}\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123554,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfo898a0z_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfo898a0z_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfo898a0z_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfo898a0z_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpfo898a0z_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpfo898a0z_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for _, row := range stdata {\n        if max_agg == nil {\n            max_agg = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_agg[i].(int) {\n                    max_agg[i] = v\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123554,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpw9y8g2p8_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpw9y8g2p8_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpw9y8g2p8_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpw9y8g2p8_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpw9y8g2p8_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpw9y8g2p8_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        max_agg = append(max_agg, stdata[0][i])\n    }\n    for i := 1; i < len(stdata); i++ {\n        for j := 0; j < len(stdata[i]); j++ {\n            if max_agg[j].(int) < stdata[i][j].(int) {\n                max_agg[j] = stdata[i][j]\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123554,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1r51e6_b_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1r51e6_b_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1r51e6_b_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1r51e6_b_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1r51e6_b_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1r51e6_b_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    result := make([]interface{}, len(stdata[0]))\n    for i := 0; i < len(stdata[0]); i++ {\n        result[i] = stdata[0][i]\n    }\n    for i := 1; i < len(stdata); i++ {\n        for j := 0; j < len(stdata[i]); j++ {\n            if result[j].(int) < stdata[i][j].(int) {\n                result[j] = stdata[i][j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123554,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc4322q14_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc4322q14_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc4322q14_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc4322q14_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpc4322q14_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpc4322q14_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmxu_5vmv_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmxu_5vmv_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmxu_5vmv_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmxu_5vmv_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmxu_5vmv_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmxu_5vmv_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    if len(stdata) == 0 {\n        return nil\n    }\n    max_aggregate := stdata[0]\n    for _, v := range stdata {\n        if v[1].(int) > max_aggregate[1].(int) {\n            max_aggregate = v\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123554,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy_1e7q1k_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpy_1e7q1k_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpy_1e7q1k_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpy_1e7q1k_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpy_1e7q1k_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpy_1e7q1k_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO: Implement this function.\n    return nil\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123554,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5cei8nyl_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5cei8nyl_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5cei8nyl_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5cei8nyl_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5cei8nyl_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5cei8nyl_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if max_aggregate == nil {\n            max_aggregate = row\n        } else {\n            for i, col := range row {\n                if col.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = col\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123554,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8g1mhfc6_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8g1mhfc6_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8g1mhfc6_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8g1mhfc6_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8g1mhfc6_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8g1mhfc6_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpln35wwqu_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln35wwqu_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln35wwqu_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln35wwqu_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpln35wwqu_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpln35wwqu_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO\n    return nil\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123553,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbkvsg6n4_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbkvsg6n4_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbkvsg6n4_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbkvsg6n4_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpbkvsg6n4_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpbkvsg6n4_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for _, row := range stdata {\n        if max_agg == nil {\n            max_agg = row\n        } else {\n            for i, val := range row {\n                if val.(int) > max_agg[i].(int) {\n                    max_agg[i] = val\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123554,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgx9jvtjn_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgx9jvtjn_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgx9jvtjn_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgx9jvtjn_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgx9jvtjn_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgx9jvtjn_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_aggregate = stdata[i]\n        } else {\n            if stdata[i][1].(int) > max_aggregate[1].(int) {\n                max_aggregate = stdata[i]\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5zqsrkfz_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5zqsrkfz_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5zqsrkfz_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5zqsrkfz_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp5zqsrkfz_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp5zqsrkfz_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO: implement\n    return []interface{}{}\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3qo99sja_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3qo99sja_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3qo99sja_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3qo99sja_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3qo99sja_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3qo99sja_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu1_i4zan_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu1_i4zan_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu1_i4zan_test.go:46:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:46:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO: Implement\n    return []interface{}{}\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq0t_gg3b_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpq0t_gg3b_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpq0t_gg3b_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpq0t_gg3b_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpq0t_gg3b_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpq0t_gg3b_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    var max_aggregate_value float64\n    for _, row := range stdata {\n        var row_value float64\n        for _, value := range row {\n            switch value.(type) {\n            case int:\n                row_value += float64(value.(int))\n            case float64:\n                row_value += value.(float64)\n            }\n        }\n        if row_value > max_aggregate_value {\n            max_aggregate_value = row_value\n            max_aggregate = row\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123554,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7hk2xhqf_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7hk2xhqf_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7hk2xhqf_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7hk2xhqf_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7hk2xhqf_test.go:39:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7hk2xhqf_test.go:39:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    if len(stdata) == 0 {\n        return nil\n    }\n    if len(stdata) == 1 {\n        return stdata[0]\n    }\n    max := stdata[0]\n    for i := 1; i < len(stdata); i++ {\n        if stdata[i][1].(int) > max[1].(int) {\n            max = stdata[i]\n        }\n    }\n    return max\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123554,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp06hx9mbp_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp06hx9mbp_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp06hx9mbp_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp06hx9mbp_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp06hx9mbp_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp06hx9mbp_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2saan8on_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2saan8on_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2saan8on_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2saan8on_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2saan8on_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2saan8on_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n            continue\n        }\n        for i, cell := range row {\n            if cell.(int) > max_aggregate[i].(int) {\n                max_aggregate[i] = cell\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123555,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplb9elhy__test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplb9elhy__test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplb9elhy__test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplb9elhy__test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplb9elhy__test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplb9elhy__test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_agg[i].(int) {\n                    max_agg[i] = v\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqlfizibl_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqlfizibl_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqlfizibl_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqlfizibl_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqlfizibl_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqlfizibl_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if max_aggregate == nil {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvyqyugnf_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvyqyugnf_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvyqyugnf_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvyqyugnf_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvyqyugnf_test.go:46:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvyqyugnf_test.go:46:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    max := 0\n    for i := 0; i < len(stdata); i++ {\n        if stdata[i][1].(int) > max {\n            max = stdata[i][1].(int)\n        }\n    }\n    return []interface{}{max}\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcnxgclnx_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcnxgclnx_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcnxgclnx_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcnxgclnx_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpcnxgclnx_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpcnxgclnx_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if max_aggregate == nil {\n            max_aggregate = row\n        } else {\n            for i, val := range row {\n                switch val.(type) {\n                case int:\n                    if val.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = val\n                    }\n                case float64:\n                    if val.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = val\n                    }\n                case string:\n                    if val.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = val\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr4fulbek_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr4fulbek_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr4fulbek_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr4fulbek_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpr4fulbek_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpr4fulbek_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_agg[i].(int) {\n                    max_agg[i] = v\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqlfizibl_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqlfizibl_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqlfizibl_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqlfizibl_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqlfizibl_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqlfizibl_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu1_i4zan_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu1_i4zan_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpu1_i4zan_test.go:46:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpu1_i4zan_test.go:46:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmxu_5vmv_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmxu_5vmv_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmxu_5vmv_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmxu_5vmv_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmxu_5vmv_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmxu_5vmv_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for _, row := range stdata {\n        if len(max_agg) == 0 {\n            max_agg = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_agg[i].(int) {\n                    max_agg[i] = v\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqlfizibl_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqlfizibl_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqlfizibl_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqlfizibl_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqlfizibl_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqlfizibl_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, tuple := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = tuple\n        } else {\n            for i, value := range tuple {\n                if value.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = value\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdqfzh2u7_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdqfzh2u7_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdqfzh2u7_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdqfzh2u7_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpdqfzh2u7_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpdqfzh2u7_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO: implement this function\n    return nil\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123547,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8_5ezjuf_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8_5ezjuf_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8_5ezjuf_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8_5ezjuf_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp8_5ezjuf_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp8_5ezjuf_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_agg = stdata[i]\n        } else {\n            if stdata[i][1].(int) > max_agg[1].(int) {\n                max_agg = stdata[i]\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7c933unl_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7c933unl_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7c933unl_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7c933unl_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7c933unl_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7c933unl_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    max := make([]interface{}, len(stdata[0]))\n    for i := 0; i < len(stdata[0]); i++ {\n        max[i] = stdata[0][i]\n    }\n    for i := 1; i < len(stdata); i++ {\n        for j := 0; j < len(stdata[0]); j++ {\n            if max[j].(int) < stdata[i][j].(int) {\n                max[j] = stdata[i][j]\n            }\n        }\n    }\n    return max\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphv7_vy48_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmphv7_vy48_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphv7_vy48_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmphv7_vy48_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphv7_vy48_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmphv7_vy48_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    max_aggregate := make([]interface{}, len(stdata[0]))\n    for _, row := range stdata {\n        for i, col := range row {\n            switch col.(type) {\n            case int:\n                if col.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = col\n                }\n            case float64:\n                if col.(float64) > max_aggregate[i].(float64) {\n                    max_aggregate[i] = col\n                }\n            case string:\n                if col.(string) > max_aggregate[i].(string) {\n                    max_aggregate[i] = col\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1bve6my__test.go:39:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1bve6my__test.go:39:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1bve6my__test.go:40:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1bve6my__test.go:40:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp1bve6my__test.go:41:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp1bve6my__test.go:41:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2saan8on_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2saan8on_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2saan8on_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2saan8on_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2saan8on_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp2saan8on_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_agg = stdata[i]\n        } else {\n            if stdata[i][1].(int) > max_agg[1].(int) {\n                max_agg = stdata[i]\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510633,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7c933unl_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7c933unl_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7c933unl_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7c933unl_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7c933unl_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7c933unl_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    if len(stdata) == 0 {\n        return []interface{}{}\n    }\n    max := stdata[0]\n    for _, v := range stdata[1:] {\n        if v[1].(int) > max[1].(int) {\n            max = v\n        }\n    }\n    return max\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprs52bxr9_test.go:29:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprs52bxr9_test.go:29:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprs52bxr9_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprs52bxr9_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmprs52bxr9_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmprs52bxr9_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO: implement me\n    return []interface{}{}\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplegf6sqi_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplegf6sqi_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplegf6sqi_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplegf6sqi_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmplegf6sqi_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmplegf6sqi_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    max_agg := make([]interface{}, len(stdata[0]))\n    for i := 0; i < len(stdata[0]); i++ {\n        max_agg[i] = stdata[0][i]\n    }\n    for i := 1; i < len(stdata); i++ {\n        for j := 0; j < len(stdata[i]); j++ {\n            if stdata[i][j].(int) > max_agg[j].(int) {\n                max_agg[j] = stdata[i][j]\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7tr8czvj_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7tr8czvj_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7tr8czvj_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7tr8czvj_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp7tr8czvj_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp7tr8czvj_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if max_aggregate == nil {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, v := range row {\n                switch v.(type) {\n                case int:\n                    if v.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = v\n                    }\n                case float64:\n                    if v.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = v\n                    }\n                case string:\n                    if v.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = v\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvyqyugnf_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvyqyugnf_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvyqyugnf_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvyqyugnf_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpvyqyugnf_test.go:46:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpvyqyugnf_test.go:46:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_agg []interface{}\n    for _, row := range stdata {\n        if max_agg == nil {\n            max_agg = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_agg[i].(int) {\n                    max_agg[i] = v\n                }\n            }\n        }\n    }\n    return max_agg\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123554,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpw9y8g2p8_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpw9y8g2p8_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpw9y8g2p8_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpw9y8g2p8_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpw9y8g2p8_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpw9y8g2p8_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    var max_aggregate_value float64\n    for _, row := range stdata {\n        var agg_value float64\n        for _, value := range row {\n            switch value.(type) {\n            case int:\n                agg_value += float64(value.(int))\n            case float64:\n                agg_value += value.(float64)\n            }\n        }\n        if agg_value > max_aggregate_value {\n            max_aggregate_value = agg_value\n            max_aggregate = row\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx9oirxjo_test.go:37:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx9oirxjo_test.go:37:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx9oirxjo_test.go:38:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx9oirxjo_test.go:38:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpx9oirxjo_test.go:39:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpx9oirxjo_test.go:39:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var result []interface{}\n    for _, row := range stdata {\n        for i, col := range row {\n            if i >= len(result) {\n                result = append(result, col)\n            } else if col.(int) > result[i].(int) {\n                result[i] = col\n            }\n        }\n    }\n    return result\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0h64z0wj_test.go:30:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0h64z0wj_test.go:30:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0h64z0wj_test.go:31:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0h64z0wj_test.go:31:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp0h64z0wj_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp0h64z0wj_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, value := range row {\n                switch value.(type) {\n                case int:\n                    if value.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = value\n                    }\n                case float64:\n                    if value.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = value\n                    }\n                case string:\n                    if value.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = value\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpid0cl34d_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpid0cl34d_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpid0cl34d_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpid0cl34d_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpid0cl34d_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpid0cl34d_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    max_aggregate = make([]interface{}, len(stdata[0]))\n    for i := 0; i < len(stdata); i++ {\n        for j := 0; j < len(stdata[i]); j++ {\n            if i == 0 {\n                max_aggregate[j] = stdata[i][j]\n            } else {\n                if stdata[i][j].(int) > max_aggregate[j].(int) {\n                    max_aggregate[j] = stdata[i][j]\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzwwwcz7s_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzwwwcz7s_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzwwwcz7s_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzwwwcz7s_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpzwwwcz7s_test.go:35:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpzwwwcz7s_test.go:35:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if max_aggregate == nil {\n            max_aggregate = row\n        } else {\n            for i, cell := range row {\n                switch cell.(type) {\n                case int:\n                    if cell.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = cell\n                    }\n                case float64:\n                    if cell.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = cell\n                    }\n                case string:\n                    if cell.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = cell\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpp56lthg4_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpp56lthg4_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpp56lthg4_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpp56lthg4_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpp56lthg4_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpp56lthg4_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, _ := range row {\n                if row[i].(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = row[i]\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphnsghe4h_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmphnsghe4h_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphnsghe4h_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmphnsghe4h_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmphnsghe4h_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmphnsghe4h_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_value interface{}\n    var max_index int\n    for i, v := range stdata {\n        if i == 0 {\n            max_value = v[1]\n            max_index = i\n        } else {\n            switch v[1].(type) {\n            case int:\n                if v[1].(int) > max_value.(int) {\n                    max_value = v[1]\n                    max_index = i\n                }\n            case float64:\n                if v[1].(float64) > max_value.(float64) {\n                    max_value = v[1]\n                    max_index = i\n                }\n            case string:\n                if v[1].(string) > max_value.(string) {\n                    max_value = v[1]\n                    max_index = i\n                }\n            }\n        }\n    }\n    return stdata[max_index]\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptj4gyimy_test.go:46:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptj4gyimy_test.go:46:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptj4gyimy_test.go:47:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptj4gyimy_test.go:47:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptj4gyimy_test.go:48:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmptj4gyimy_test.go:48:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate_value []interface{}\n    for _, row := range stdata {\n        if max_aggregate_value == nil {\n            max_aggregate_value = row\n        } else {\n            for i, value := range row {\n                switch value.(type) {\n                case int:\n                    if value.(int) > max_aggregate_value[i].(int) {\n                        max_aggregate_value[i] = value\n                    }\n                case float64:\n                    if value.(float64) > max_aggregate_value[i].(float64) {\n                        max_aggregate_value[i] = value\n                    }\n                case string:\n                    if value.(string) > max_aggregate_value[i].(string) {\n                        max_aggregate_value[i] = value\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate_value\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3smldnqq_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3smldnqq_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3smldnqq_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3smldnqq_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3smldnqq_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3smldnqq_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    if len(stdata) == 0 {\n        return nil\n    }\n    if len(stdata) == 1 {\n        return stdata[0]\n    }\n    var max_aggregate []interface{}\n    for _, tuple := range stdata {\n        if len(tuple) != len(max_aggregate) {\n            fmt.Println(\"Invalid tuple length\")\n            return nil\n        }\n        for i := 0; i < len(tuple); i++ {\n            switch tuple[i].(type) {\n            case int:\n                if tuple[i].(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = tuple[i]\n                }\n            case float64:\n                if tuple[i].(float64) > max_aggregate[i].(float64) {\n                    max_aggregate[i] = tuple[i]\n                }\n            case string:\n                if tuple[i].(string) > max_aggregate[i].(string) {\n                    max_aggregate[i] = tuple[i]\n                }\n            default:\n                fmt.Println(\"Invalid type\")\n                return nil\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnm74qv4p_test.go:52:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnm74qv4p_test.go:52:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnm74qv4p_test.go:53:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnm74qv4p_test.go:53:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpnm74qv4p_test.go:54:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpnm74qv4p_test.go:54:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if max_aggregate == nil {\n            max_aggregate = make([]interface{}, len(row))\n            copy(max_aggregate, row)\n        } else {\n            for i, val := range row {\n                switch val.(type) {\n                case int:\n                    if val.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = val\n                    }\n                case float64:\n                    if val.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = val\n                    }\n                case string:\n                    if val.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = val\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqx3b8cqs_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqx3b8cqs_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqx3b8cqs_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqx3b8cqs_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpqx3b8cqs_test.go:46:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpqx3b8cqs_test.go:46:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, v := range row {\n                if v.(int) > max_aggregate[i].(int) {\n                    max_aggregate[i] = v\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmxu_5vmv_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmxu_5vmv_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmxu_5vmv_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmxu_5vmv_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpmxu_5vmv_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpmxu_5vmv_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    max := stdata[0]\n    for i := 1; i < len(stdata); i++ {\n        if stdata[i][1].(int) > max[1].(int) {\n            max = stdata[i]\n        }\n    }\n    return max\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgxf92lvb_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgxf92lvb_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgxf92lvb_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgxf92lvb_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpgxf92lvb_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpgxf92lvb_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for i := 0; i < len(stdata); i++ {\n        if i == 0 {\n            max_aggregate = stdata[i]\n        } else {\n            for j := 0; j < len(stdata[i]); j++ {\n                if stdata[i][j].(int) > max_aggregate[j].(int) {\n                    max_aggregate[j] = stdata[i][j]\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp44naijke_test.go:32:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp44naijke_test.go:32:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp44naijke_test.go:33:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp44naijke_test.go:33:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp44naijke_test.go:34:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp44naijke_test.go:34:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    // TODO: implement\n    return []interface{}{}\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123551,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3qo99sja_test.go:21:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3qo99sja_test.go:21:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3qo99sja_test.go:22:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3qo99sja_test.go:22:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3qo99sja_test.go:23:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3qo99sja_test.go:23:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var result []interface{}\n    for i := 0; i < len(stdata[0]); i++ {\n        var max interface{}\n        for j := 0; j < len(stdata); j++ {\n            if j == 0 {\n                max = stdata[j][i]\n            } else {\n                switch stdata[j][i].(type) {\n                case int:\n                    if stdata[j][i].(int) > max.(int) {\n                        max = stdata[j][i]\n                    }\n                case float64:\n                    if stdata[j][i].(float64) > max.(float64) {\n                        max = stdata[j][i]\n                    }\n                case string:\n                    if stdata[j][i].(string) > max.(string) {\n                        max = stdata[j][i]\n                    }\n                }\n            }\n        }\n        result = append(result, max)\n    }\n    return result\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl_ew9oax_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpl_ew9oax_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_ew9oax_test.go:46:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpl_ew9oax_test.go:46:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl_ew9oax_test.go:47:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpl_ew9oax_test.go:47:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    var max_aggregate []interface{}\n    for _, row := range stdata {\n        if len(max_aggregate) == 0 {\n            max_aggregate = row\n        } else {\n            for i, val := range row {\n                switch val.(type) {\n                case int:\n                    if val.(int) > max_aggregate[i].(int) {\n                        max_aggregate[i] = val\n                    }\n                case float64:\n                    if val.(float64) > max_aggregate[i].(float64) {\n                        max_aggregate[i] = val\n                    }\n                case string:\n                    if val.(string) > max_aggregate[i].(string) {\n                        max_aggregate[i] = val\n                    }\n                }\n            }\n        }\n    }\n    return max_aggregate\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123556,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuzho4tf1_test.go:43:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpuzho4tf1_test.go:43:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpuzho4tf1_test.go:44:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpuzho4tf1_test.go:44:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpuzho4tf1_test.go:45:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmpuzho4tf1_test.go:45:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package max_aggregate_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata [][]interface{}) []interface{} {\n    max := 0\n    for _, v := range stdata {\n        if v[1].(int) > max {\n            max = v[1].(int)\n        }\n    }\n    return []interface{}{max}\n}\n\nfunc TestMax_Aggregate(t *testing.T) {\n  candidate := max_aggregate\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 90}, []interface{}{\"Sabah Colley\", 88}, []interface{}{\"Peter Nichols\", 7}, []interface{}{\"Juan Whelan\", 122}, []interface{}{\"Sabah Colley\", 84}}), expected: []interface{}{\"Juan Whelan\", 212} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 50}, []interface{}{\"Sabah Colley\", 48}, []interface{}{\"Peter Nichols\", 37}, []interface{}{\"Juan Whelan\", 22}, []interface{}{\"Sabah Colley\", 14}}), expected: []interface{}{\"Juan Whelan\", 72} },\n     { actual: candidate([][]int{[]interface{}{\"Juan Whelan\", 10}, []interface{}{\"Sabah Colley\", 20}, []interface{}{\"Peter Nichols\", 30}, []interface{}{\"Juan Whelan\", 40}, []interface{}{\"Sabah Colley\", 50}}), expected: []interface{}{\"Sabah Colley\", 70} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123549,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3f7o9gpi_test.go:26:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3f7o9gpi_test.go:26:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3f7o9gpi_test.go:27:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3f7o9gpi_test.go:27:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp3f7o9gpi_test.go:28:33: cannot use [][]int{...} (type [][]int) as type [][]interface {} in argument to candidate\n/tmp/tmp3f7o9gpi_test.go:28:47: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    }
  ]
}