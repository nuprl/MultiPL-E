{
  "name": "mbpp_617_min_Jumps",
  "language": "go_test.go",
  "prompt": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_617_min_Jumps.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var x, y int\n    var count float64\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += step.(int)\n        case string:\n            y += step.(string)\n        }\n        count += 1\n    }\n    return count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510493,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpp7546bxk_test.go:18:15: invalid operation: y += step.(string) (mismatched types int and string)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var x, y float64\n    for _, step := range steps {\n        switch step.(type) {\n        case string:\n            switch step.(string) {\n            case \"up\":\n                y++\n            case \"down\":\n                y--\n            case \"left\":\n                x--\n            case \"right\":\n                x++\n            }\n        case int:\n            switch step.(int) {\n            case 1:\n                x++\n            case 2:\n                x--\n            case 3:\n                y++\n            case 4:\n                y--\n            }\n        }\n    }\n    return (x*x + y*y) / (2 * d)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510493,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv0u6krce_test.go:37:24: invalid operation: (x * x + y * y) / (2 * d) (mismatched types float64 and int)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var x, y, count float64\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            return count\n        }\n        if x > float64(d) {\n            return -1\n        }\n        count++\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510493,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpwua9pxg1_test.go:45: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpwua9pxg1_test.go:45: expected '%!s(int=0)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpwua9pxg1_test.go:45: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    if len(steps) == 0 {\n        return 0\n    }\n    if len(steps) == 1 {\n        return 1\n    }\n    var sum float64 = 0\n    for _, step := range steps {\n        sum += step.(float64)\n    }\n    if sum == float64(d) {\n        return 1\n    }\n    if sum < float64(d) {\n        return float64(d) / sum\n    }\n    if sum > float64(d) {\n        return float64(d) / sum\n    }\n    return 0\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510493,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\npanic: interface conversion: interface {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface {} is int, not float64\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523720, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523720, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.min_Jumps(0xc0000866d0, 0x2, 0x2, 0xb, 0xf)\n\t/tmp/tmp05mpegpv_test.go:18 +0x12e\ncommand-line-arguments_test.TestMin_Jumps(0xc000102600)\n\t/tmp/tmp05mpegpv_test.go:39 +0xb1\ntesting.tRunner(0xc000102600, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n        a int\n        b int\n        c int\n        d int\n        e int\n        f int\n        g int\n        h int\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n        a int\n        b int\n        c int\n        d int\n        e int\n        f int\n        g int\n        h int\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n        a int\n        b int\n        c int\n        d int\n        e int\n        f int\n        g int\n        h int\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n        a int\n        b int\n        c int\n        d int\n        e int\n        f int\n        g int\n        h int\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n        a int\n        b int\n        c int\n        d int\n        e int\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510492,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5dnnkpeb_test.go:138:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var i, j, k, l, m, n int\n    var x, y, z, a, b, c float64\n    var result float64\n    var temp float64\n    var temp1 float64\n    var temp2 float64\n    var temp3 float64\n    var temp4 float64\n    var temp5 float64\n    var temp6 float64\n    var temp7 float64\n    var temp8 float64\n    var temp9 float64\n    var temp10 float64\n    var temp11 float64\n    var temp12 float64\n    var temp13 float64\n    var temp14 float64\n    var temp15 float64\n    var temp16 float64\n    var temp17 float64\n    var temp18 float64\n    var temp19 float64\n    var temp20 float64\n    var temp21 float64\n    var temp22 float64\n    var temp23 float64\n    var temp24 float64\n    var temp25 float64\n    var temp26 float64\n    var temp27 float64\n    var temp28 float64\n    var temp29 float64\n    var temp30 float64\n    var temp31 float64\n    var temp32 float64\n    var temp33 float64\n    var temp34 float64\n    var temp35 float64\n    var temp36 float64\n    var temp37 float64\n    var temp38 float64\n    var temp39 float64\n    var temp40 float64\n    var temp41 float64\n    var temp42 float64\n    var temp43 float64\n    var temp44 float64\n    var temp45 float64\n    var temp46 float64\n    var temp47 float64\n    var temp48 float64\n    var temp49 float64\n    var temp50 float64\n    var temp51 float64\n    var temp52 float64\n    var temp53 float64\n    var temp54 float64\n    var temp55 float64\n    var temp56 float64\n    var temp57 float64\n    var temp58 float64\n    var temp59 float64\n    var temp60 float64\n    var temp61 float64\n    var temp62 float64\n    var temp63 float64\n    var temp64 float64\n    var temp65 float64\n    var temp66 float64\n    var temp67 float64\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510492,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptjzx6q8t_test.go:81:6: expected '(', found TestMin_Jumps\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        i, j int\n        n int = len(steps)\n        m int = n + 1\n        dp [][]float64 = make([][]float64, m)\n    )\n\n    for i = 0; i < m; i++ {\n        dp[i] = make([]float64, m)\n    }\n\n    for i = 0; i < m; i++ {\n        dp[i][0] = 1\n    }\n\n    for i = 1; i < m; i++ {\n        for j = 1; j < m; j++ {\n            if i > j {\n                dp[i][j] = dp[i - 1][j]\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - i]\n            }\n        }\n    }\n\n    return dp[n][d]\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510493,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\npanic: runtime error: index out of range [11] with length 3 [recovered]\n\tpanic: runtime error: index out of range [11] with length 3\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc0001b8048)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc0001b8048)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.min_Jumps(0xc0000bced0, 0x2, 0x2, 0xb, 0xf)\n\t/tmp/tmpu_ta0p9h_test.go:35 +0x1f6\ncommand-line-arguments_test.TestMin_Jumps(0xc000186300)\n\t/tmp/tmpu_ta0p9h_test.go:45 +0xb1\ntesting.tRunner(0xc000186300, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        i, j int\n        n int = len(steps)\n        m int = len(steps[0].([]interface{}))\n        dp [][]float64 = make([][]float64, n)\n        res float64 = 0\n    )\n\n    for i = 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n\n    for i = 0; i < n; i++ {\n        for j = 0; j < m; j++ {\n            if i == 0 && j == 0 {\n                dp[i][j] = 1\n            } else if i == 0 {\n                dp[i][j] = dp[i][j-1] / 2\n            } else if j == 0 {\n                dp[i][j] = dp[i-1][j] / 2\n            } else {\n                dp[i][j] = (dp[i-1][j] + dp[i][j-1]) / 2\n            }\n        }\n    }\n\n    for i = 0; i < n; i++ {\n        for j = 0; j < m; j++ {\n            if i + j == d {\n                res += dp[i][j]\n            }\n        }\n    }\n\n    return res\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510493,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\npanic: interface conversion: interface {} is int, not []interface {} [recovered]\n\tpanic: interface conversion: interface {} is int, not []interface {}\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523720, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523720, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.min_Jumps(0xc0000866d0, 0x2, 0x2, 0xb, 0xf)\n\t/tmp/tmp4mf8jnj7_test.go:13 +0x325\ncommand-line-arguments_test.TestMin_Jumps(0xc000102600)\n\t/tmp/tmp4mf8jnj7_test.go:54 +0xb1\ntesting.tRunner(0xc000102600, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    if len(steps) == 0 {\n        return 0\n    }\n    if len(steps) == 1 {\n        if steps[0].(int) == d {\n            return 1\n        } else {\n            return 0\n        }\n    }\n    if steps[0].(int) == d {\n        return 1\n    }\n    return 1 + min_Jumps(steps[1:], d - steps[0].(int))\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510493,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpn3j4hn89_test.go:41: expected '%!s(float64=3.5)', got '%!s(float64=1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpn3j4hn89_test.go:41: expected '%!s(int=0)', got '%!s(float64=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var sum float64 = 0\n    for _, step := range steps {\n        sum += step.(float64)\n    }\n    return sum / float64(d)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510493,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\npanic: interface conversion: interface {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface {} is int, not float64\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523720, 0xc00018c240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523720, 0xc00018c240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.min_Jumps(0xc000086ed0, 0x2, 0x2, 0xb, 0xf)\n\t/tmp/tmpy9cecmf6_test.go:12 +0x9c\ncommand-line-arguments_test.TestMin_Jumps(0xc000186300)\n\t/tmp/tmpy9cecmf6_test.go:24 +0xb1\ntesting.tRunner(0xc000186300, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var count float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            count += float64(step.(int))\n        case float64:\n            count += step.(float64)\n        }\n    }\n    return count / float64(d)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510493,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp2n_95720_test.go:37: expected '%!s(float64=3.5)', got '%!s(float64=0.6363636363636364)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmp2n_95720_test.go:37: expected '%!s(int=0)', got '%!s(float64=+Inf)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmp2n_95720_test.go:37: expected '%!s(int=1)', got '%!s(float64=2.272727272727273)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var total_steps float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            total_steps += float64(step.(int))\n        case float64:\n            total_steps += step.(float64)\n        }\n    }\n    return total_steps / float64(d)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510493,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpfucodhyz_test.go:38: expected '%!s(float64=3.5)', got '%!s(float64=0.6363636363636364)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpfucodhyz_test.go:38: expected '%!s(int=0)', got '%!s(float64=+Inf)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpfucodhyz_test.go:38: expected '%!s(int=1)', got '%!s(float64=2.272727272727273)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            return count + 1\n        }\n        if x > float64(d) {\n            return -1\n        }\n        if y == 0 {\n            count++\n        }\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510493,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp5djfr1l8_test.go:48: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmp5djfr1l8_test.go:48: expected '%!s(int=0)', got '%!s(float64=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        x, y float64\n        i int\n    )\n    for i = 0; i < len(steps); i++ {\n        switch steps[i].(type) {\n        case int:\n            x += float64(steps[i].(int))\n        case float64:\n            x += steps[i].(float64)\n        case string:\n            if steps[i].(string) == \"up\" {\n                y += 1\n            } else if steps[i].(string) == \"down\" {\n                y -= 1\n            }\n        }\n    }\n    if x == float64(d) && y == 0 {\n        return float64(i)\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510493,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpm6xa7xru_test.go:49: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpm6xa7xru_test.go:49: expected '%!s(int=0)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpm6xa7xru_test.go:49: expected '%!s(int=1)', got '%!s(float64=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var i, j int\n    var jump float64\n    var x, y float64\n    var x_step, y_step float64\n    var x_step_max, y_step_max float64\n    var x_step_min, y_step_min float64\n    var x_step_max_index, y_step_max_index int\n    var x_step_min_index, y_step_min_index int\n    var x_step_max_index_prev, y_step_max_index_prev int\n    var x_step_min_index_prev, y_step_min_index_prev int\n    var x_step_max_prev, y_step_max_prev float64\n    var x_step_min_prev, y_step_min_prev float64\n    var x_step_max_prev_prev, y_step_max_prev_prev float64\n    var x_step_min_prev_prev, y_step_min_prev_prev float64\n    var x_step_max_prev_prev_prev, y_step_max_prev_prev_prev float64\n    var x_step_min_prev_prev_prev, y_step_min_prev_prev_prev float64\n    var x_step_max_prev_prev_prev_prev, y_step_max_prev_prev_prev_prev float64\n    var x_step_min_prev_prev_prev_prev, y_step_min_prev_prev_prev_prev float64\n    var x_step_max_prev_prev_prev_prev_prev, y_step_max_prev_prev_prev_prev_prev float64\n    var x_step_min_prev_prev_prev_prev_prev, y_step_min_prev_prev_prev_prev_prev float64\n    var x_step_max_prev_prev_prev_prev_prev_prev, y_step_max_prev_prev_prev_prev_prev_prev float64\n    var x_step_min_prev_prev_prev_prev_prev_prev, y_step_min_prev_prev_prev_prev_prev_prev float64\n    var\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510492,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpopn8bej__test.go:33:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        x, y float64\n        count int\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            x += step.(float64)\n        case string:\n            if step.(string) == \"D\" {\n                y -= 1\n            } else {\n                y += 1\n            }\n        }\n        if x == float64(d) {\n            count += 1\n            x = 0\n        }\n    }\n    return float64(count)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510493,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpaxds7opw_test.go:50: expected '%!s(float64=3.5)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var x, y, count float64\n    x = 0\n    y = 0\n    count = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) && y == 0 {\n            return count\n        }\n        count++\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510493,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpvh192vel_test.go:45: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpvh192vel_test.go:45: expected '%!s(int=0)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpvh192vel_test.go:45: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var x, y int\n    var count float64\n    for _, v := range steps {\n        switch v.(type) {\n        case string:\n            if v.(string) == \"D\" {\n                y--\n            } else {\n                y++\n            }\n        case int:\n            x += v.(int)\n        }\n        if x == d {\n            return count\n        }\n        if x > d {\n            return -1\n        }\n        count++\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510493,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpkgsu600l_test.go:50: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpkgsu600l_test.go:50: expected '%!s(int=0)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpkgsu600l_test.go:50: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var i, j, k, l int\n    var x, y, z, w float64\n    var m, n, o, p float64\n    var q, r, s, t float64\n    var u, v, w, x float64\n    var y, z, a, b float64\n    var c, d, e, f float64\n    var g, h, i, j float64\n    var k, l, m, n float64\n    var o, p, q, r float64\n    var s, t, u, v float64\n    var w, x, y, z float64\n    var a, b, c, d float64\n    var e, f, g, h float64\n    var i, j, k, l float64\n    var m, n, o, p float64\n    var q, r, s, t float64\n    var u, v, w, x float64\n    var y, z, a, b float64\n    var c, d, e, f float64\n    var g, h, i, j float64\n    var k, l, m, n float64\n    var o, p, q, r float64\n    var s, t, u, v float64\n    var w, x, y, z float64\n    var a, b, c, d float64\n    var e, f, g, h float64\n    var i, j, k, l float64\n    var m, n, o, p float64\n    var q, r, s, t float64\n    var u, v, w, x float64\n    var y, z, a, b float64\n    var c, d, e, f float64\n    var g, h, i, j float64\n    var k, l, m, n float64\n    var o, p, q, r float64\n    var s, t, u, v float64\n    var w, x, y, z float64\n    var a, b, c, d float64\n    var e, f, g, h float64\n    var i, j, k, l float64\n    var m, n, o, p float64\n   \nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510492,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpka8yn710_test.go:54:6: expected '(', found TestMin_Jumps\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    if len(steps) == 0 {\n        return 0\n    }\n\n    if len(steps) == 1 {\n        if steps[0].(int) >= d {\n            return 1\n        } else {\n            return -1\n        }\n    }\n\n    var min_jumps float64 = -1\n    for i := 0; i < len(steps); i++ {\n        var jumps float64 = min_Jumps(steps[i+1:], d - steps[i].(int))\n        if jumps != -1 && (min_jumps == -1 || jumps + 1 < min_jumps) {\n            min_jumps = jumps + 1\n        }\n    }\n\n    return min_jumps\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510493,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpx1bomj7u_test.go:48: expected '%!s(float64=3.5)', got '%!s(float64=1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpx1bomj7u_test.go:48: expected '%!s(int=0)', got '%!s(float64=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    // To print results to the standard output you can use fmt.Println()\n    // Example: fmt.Println(\"Hello world!\")\n    var result float64\n    result = 0.0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            result += float64(step.(int))\n        case float64:\n            result += step.(float64)\n        }\n    }\n    return result\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123319,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp5pm1ro6i_test.go:41: expected '%!s(float64=3.5)', got '%!s(float64=7)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmp5pm1ro6i_test.go:41: expected '%!s(int=0)', got '%!s(float64=7)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmp5pm1ro6i_test.go:41: expected '%!s(int=1)', got '%!s(float64=25)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var x, y, count float64 = 0, 0, 0\n    for _, step := range steps {\n        switch step {\n        case \"UP\":\n            y++\n        case \"DOWN\":\n            y--\n        case \"LEFT\":\n            x--\n        case \"RIGHT\":\n            x++\n        }\n        count++\n        if x == float64(d) && y == 0 {\n            return count\n        }\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123319,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp2vpj4oek_test.go:45: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmp2vpj4oek_test.go:45: expected '%!s(int=0)', got '%!s(float64=1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmp2vpj4oek_test.go:45: expected '%!s(int=1)', got '%!s(float64=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        n int = len(steps)\n        i int = 0\n        j int = 0\n        k int = 0\n        x int = 0\n        y int = 0\n        z int = 0\n        a int = 0\n        b int = 0\n        c int = 0\n        m int = 0\n        s int = 0\n        t int = 0\n        u int = 0\n        v int = 0\n        w int = 0\n        x1 int = 0\n        y1 int = 0\n        z1 int = 0\n        x2 int = 0\n        y2 int = 0\n        z2 int = 0\n        x3 int = 0\n        y3 int = 0\n        z3 int = 0\n        x4 int = 0\n        y4 int = 0\n        z4 int = 0\n        x5 int = 0\n        y5 int = 0\n        z5 int = 0\n        x6 int = 0\n        y6 int = 0\n        z6 int = 0\n        x7 int = 0\n        y7 int = 0\n        z7 int = 0\n        x8 int = 0\n        y8 int = 0\n        z8 int = 0\n        x9 int = 0\n        y9 int = 0\n        z9 int = 0\n        x10 int = 0\n        y10 int = 0\n        z10 int = 0\n        x11 int = 0\n        y11 int = 0\n        z11 int = 0\n        x12 int = 0\n        y12 int = 0\n        z12 int = 0\n        x13 int = 0\n        y13 int = 0\n        z13 int = 0\n        x14 int = 0\n        y14 int = 0\n        z14 int = 0\n        x15 int = 0\n        y15 int = 0\n        z15 int = 0\n        x16 int = 0\n        y16 int = 0\n        z16 int = 0\n        x17 int = 0\n        y17 int = 0\n        z17 int = 0\n        x18 int = 0\n        y18 int = 0\n        z18 int = 0\n        x19 int = 0\n        y19 int = 0\n        z19 int = 0\n        x20 int = 0\n        y\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123318,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3lzj9030_test.go:85:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var count float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            count += float64(step.(int))\n        case float64:\n            count += step.(float64)\n        }\n    }\n    return count / float64(d)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510493,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp2n_95720_test.go:37: expected '%!s(float64=3.5)', got '%!s(float64=0.6363636363636364)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmp2n_95720_test.go:37: expected '%!s(int=0)', got '%!s(float64=+Inf)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmp2n_95720_test.go:37: expected '%!s(int=1)', got '%!s(float64=2.272727272727273)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        x, y float64\n        jumps float64\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            x += step.(float64)\n        }\n        if x >= float64(d) {\n            return jumps\n        }\n        y = float64(d) - x\n        if y > x {\n            jumps += 1\n            x = y\n        }\n    }\n    return jumps\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123319,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpuyguhmu5_test.go:48: expected '%!s(float64=3.5)', got '%!s(float64=1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpuyguhmu5_test.go:48: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var sum float64 = 0\n    for _, v := range steps {\n        sum += v.(float64)\n    }\n    return sum / float64(d)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123311,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\npanic: interface conversion: interface {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface {} is int, not float64\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2(0x523720, 0xc0001902a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc0001a0300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523720, 0xc0001902a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.min_Jumps(0xc0001ca6d0, 0x2, 0x2, 0xb, 0xf)\n\t/tmp/tmphogx5q49_test.go:13 +0x9c\ncommand-line-arguments_test.TestMin_Jumps(0xc0001a0300)\n\t/tmp/tmphogx5q49_test.go:25 +0xb1\ntesting.tRunner(0xc0001a0300, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, v := range steps {\n        switch v.(type) {\n        case int:\n            count += float64(v.(int))\n        case float64:\n            count += v.(float64)\n        }\n        x += count\n        y += count\n        if x >= float64(d) {\n            return y\n        }\n    }\n    return 0\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123319,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpq7hvhugs_test.go:44: expected '%!s(float64=3.5)', got '%!s(float64=0)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpq7hvhugs_test.go:44: expected '%!s(int=0)', got '%!s(float64=3)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpq7hvhugs_test.go:44: expected '%!s(int=1)', got '%!s(float64=11)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        result float64\n        x, y int\n    )\n\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += step.(int)\n        case string:\n            y += 1\n        }\n\n        if x == d {\n            result += 1\n            x = 0\n        }\n    }\n\n    if x > 0 {\n        result += 1\n    }\n\n    return result + float64(y)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123319,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp3o5ieaxt_test.go:51: expected '%!s(float64=3.5)', got '%!s(float64=1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmp3o5ieaxt_test.go:51: expected '%!s(int=0)', got '%!s(float64=1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmp3o5ieaxt_test.go:51: expected '%!s(int=1)', got '%!s(float64=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    // To print results to the standard output you can use fmt.Println()\n    // Example: fmt.Println(\"Hello world!\")\n    return 0.0\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123319,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpvouot2j8_test.go:31: expected '%!s(float64=3.5)', got '%!s(float64=0)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpvouot2j8_test.go:31: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        n int = len(steps)\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n    )\n    return float64(n)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123319,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpm2_y4x17_test.go:17:9: n redeclared in this block\n\tprevious declaration at /tmp/tmpm2_y4x17_test.go:11:9\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    if len(steps) == 0 {\n        return 0\n    }\n    if len(steps) == 1 {\n        return 1\n    }\n    var sum float64 = 0\n    for _, v := range steps {\n        sum += v.(float64)\n    }\n    return sum / float64(d)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123311,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\npanic: interface conversion: interface {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface {} is int, not float64\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523720, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523720, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.min_Jumps(0xc00008c6d0, 0x2, 0x2, 0xb, 0xf)\n\t/tmp/tmpx395esb5_test.go:18 +0xcb\ncommand-line-arguments_test.TestMin_Jumps(0xc000102600)\n\t/tmp/tmpx395esb5_test.go:30 +0xb1\ntesting.tRunner(0xc000102600, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        i, j int\n        x, y float64\n    )\n    for i = 0; i < len(steps); i++ {\n        switch steps[i].(type) {\n        case string:\n            if steps[i] == \"D\" {\n                y--\n            } else {\n                y++\n            }\n        case int:\n            x += float64(steps[i].(int))\n        }\n    }\n    if x == float64(d) && y == 0 {\n        return float64(i)\n    }\n    if x < float64(d) {\n        return -1\n    }\n    return float64(i) + (x - float64(d)) / y\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123319,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd71n9463_test.go:11:12: j declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        x, y, min_jumps float64\n    )\n    for _, step := range steps {\n        switch step.(type) {\n            case int:\n                x += float64(step.(int))\n            case float64:\n                x += step.(float64)\n            case string:\n                y += float64(len(step.(string)))\n        }\n        if x == float64(d) {\n            min_jumps++\n            x = 0\n        } else if x > float64(d) {\n            min_jumps++\n            x = x - float64(d)\n        }\n        if y == float64(d) {\n            min_jumps++\n            y = 0\n        } else if y > float64(d) {\n            min_jumps++\n            y = y - float64(d)\n        }\n    }\n    if x > 0 || y > 0 {\n        min_jumps++\n    }\n    return min_jumps\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123319,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpz_v4t_ri_test.go:58: expected '%!s(float64=3.5)', got '%!s(float64=1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpz_v4t_ri_test.go:58: expected '%!s(int=0)', got '%!s(float64=5)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpz_v4t_ri_test.go:58: expected '%!s(int=1)', got '%!s(float64=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z int\n        a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z float64\n    )\n\n    return 0\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123309,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5g7n2blf_test.go:12:18: d redeclared in this block\n\tprevious declaration at /tmp/tmp5g7n2blf_test.go:9:44\n/tmp/tmp5g7n2blf_test.go:12:33: i redeclared in this block\n\tprevious declaration at /tmp/tmp5g7n2blf_test.go:11:9\n/tmp/tmp5g7n2blf_test.go:12:36: j redeclared in this block\n\tprevious declaration at /tmp/tmp5g7n2blf_test.go:11:9\n/tmp/tmp5g7n2blf_test.go:12:39: k redeclared in this block\n\tprevious declaration at /tmp/tmp5g7n2blf_test.go:11:9\n/tmp/tmp5g7n2blf_test.go:12:42: l redeclared in this block\n\tprevious declaration at /tmp/tmp5g7n2blf_test.go:11:9\n/tmp/tmp5g7n2blf_test.go:12:45: m redeclared in this block\n\tprevious declaration at /tmp/tmp5g7n2blf_test.go:11:9\n/tmp/tmp5g7n2blf_test.go:12:48: n redeclared in this block\n\tprevious declaration at /tmp/tmp5g7n2blf_test.go:11:9\n/tmp/tmp5g7n2blf_test.go:12:51: o redeclared in this block\n\tprevious declaration at /tmp/tmp5g7n2blf_test.go:11:9\n/tmp/tmp5g7n2blf_test.go:12:54: p redeclared in this block\n\tprevious declaration at /tmp/tmp5g7n2blf_test.go:11:9\n/tmp/tmp5g7n2blf_test.go:12:57: q redeclared in this block\n\tprevious declaration at /tmp/tmp5g7n2blf_test.go:11:9\n/tmp/tmp5g7n2blf_test.go:12:57: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        i int\n        j int\n        k int\n        n int\n        m int\n        x float64\n        y float64\n        z float64\n        a float64\n        b float64\n        c float64\n        dp [][]float64\n    )\n    n = len(steps)\n    m = d + 1\n    dp = make([][]float64, n)\n    for i = 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    dp[0][0] = 1\n    for i = 1; i < n; i++ {\n        switch steps[i].(type) {\n        case int:\n            x = float64(steps[i].(int))\n        case float64:\n            x = steps[i].(float64)\n        }\n        for j = 0; j < m; j++ {\n            if j == 0 {\n                dp[i][j] = dp[i - 1][j] / x\n            } else {\n                for k = 1; k <= j; k++ {\n                    dp[i][j] += dp[i - 1][j - k] / x\n                }\n            }\n        }\n    }\n    for i = 0; i < m; i++ {\n        y += dp[n - 1][i]\n    }\n    return y\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123319,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmple_vg5ow_test.go:18:9: z declared but not used\n/tmp/tmple_vg5ow_test.go:19:9: a declared but not used\n/tmp/tmple_vg5ow_test.go:20:9: b declared but not used\n/tmp/tmple_vg5ow_test.go:21:9: c declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var x, y float64 = 0, 0\n    var count float64 = 0\n    for i := 0; i < len(steps); i++ {\n        switch steps[i].(type) {\n        case int:\n            x += float64(steps[i].(int))\n        case float64:\n            x += steps[i].(float64)\n        case string:\n            y += float64(len(steps[i].(string)))\n        }\n        if x == float64(d) {\n            return count + 1\n        }\n        if x > float64(d) {\n            return count + (x - float64(d))\n        }\n        count++\n    }\n    return count + (float64(d) - x)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123319,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpw8shqf5q_test.go:47: expected '%!s(float64=3.5)', got '%!s(float64=6)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpw8shqf5q_test.go:47: expected '%!s(int=0)', got '%!s(float64=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        x, y, i, j int\n        count float64\n    )\n    for i = 0; i < len(steps); i++ {\n        if steps[i] == \"D\" {\n            y--\n        } else if steps[i] == \"U\" {\n            y++\n        } else if steps[i] == \"L\" {\n            x--\n        } else if steps[i] == \"R\" {\n            x++\n        }\n        if x == d {\n            count++\n            x = 0\n        }\n        if y == d {\n            count++\n            y = 0\n        }\n    }\n    return count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123319,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpm9anpowk_test.go:11:18: j declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        n int = len(steps)\n        i int\n        j int\n        k int\n        x float64\n        y float64\n        z float64\n        a float64\n        b float64\n        c float64\n        d float64\n        e float64\n        f float64\n        g float64\n        h float64\n        i float64\n        j float64\n        k float64\n        l float64\n        m float64\n        n float64\n        o float64\n        p float64\n        q float64\n        r float64\n        s float64\n        t float64\n        u float64\n        v float64\n        w float64\n        x float64\n        y float64\n        z float64\n        a float64\n        b float64\n        c float64\n        d float64\n        e float64\n        f float64\n        g float64\n        h float64\n        i float64\n        j float64\n        k float64\n        l float64\n        m float64\n        n float64\n        o float64\n        p float64\n        q float64\n        r float64\n        s float64\n        t float64\n        u float64\n        v float64\n        w float64\n        x float64\n        y float64\n        z float64\n        a float64\n        b float64\n        c float64\n        d float64\n        e float64\n        f float64\n        g float64\n        h float64\n        i float64\n        j float64\n        k float64\n        l float64\n        m float64\n        n float64\n        o float64\n        p float64\n        q float64\n        r float64\n        s float64\n        t float64\n        u float64\n        v float64\n        w float64\n        x float64\n        y float64\n        z float64\n        a float64\n        b float64\n        c float64\n        d float64\n        e float64\n        f float64\n        g float64\n        h float64\n        i float64\n        j float64\n        k float64\n        l float64\n        m float64\n        n float64\n        o float64\n        p float64\n       \nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123318,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpwevqft53_test.go:113:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var jumps float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step {\n        case \"UP\":\n            y++\n        case \"DOWN\":\n            y--\n        case \"LEFT\":\n            x--\n        case \"RIGHT\":\n            x++\n        }\n        if x == float64(d) {\n            return jumps + 1\n        }\n        if x == float64(d) && y == 0 {\n            return jumps + 1\n        }\n        if x == float64(d) && y == 0 {\n            return jumps + 1\n        }\n        if x == float64(d) && y == 0 {\n            return jumps + 1\n        }\n        if x == float64(d) && y == 0 {\n            return jumps + 1\n        }\n        if x == float64(d) && y == 0 {\n            return jumps + 1\n        }\n        if x == float64(d) && y == 0 {\n            return jumps + 1\n        }\n        if x == float64(d) && y == 0 {\n            return jumps + 1\n        }\n        if x == float64(d) && y == 0 {\n            return jumps + 1\n        }\n        if x == float64(d) && y == 0 {\n            return jumps + 1\n        }\n        if x == float64(d) && y == 0 {\n            return jumps + 1\n        }\n        if x == float64(d) && y == 0 {\n            return jumps + 1\n        }\n        if x == float64(d) && y == 0 {\n            return jumps + 1\n        }\n        if x == float64(d) && y == 0 {\n            return jumps + 1\n        }\n        if x == float64(d) && y == 0 {\n            return jumps + 1\n        }\n        if x == float64(d) && y == 0 {\n            return jumps + 1\n        }\n        if x == float64(d) && y == 0 {\n            return jumps + 1\n        }\n        if x == float64(d) && y == 0 {\n           \nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123318,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpi7u74slm_test.go:78:6: expected '(', found TestMin_Jumps\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        n int = len(steps)\n        i int = 0\n        j int = 0\n        k int = 0\n        x int = 0\n        y int = 0\n        z int = 0\n        a int = 0\n        b int = 0\n        c int = 0\n        m int = 0\n        n1 int = 0\n        n2 int = 0\n        n3 int = 0\n        n4 int = 0\n        n5 int = 0\n        n6 int = 0\n        n7 int = 0\n        n8 int = 0\n        n9 int = 0\n        n10 int = 0\n        n11 int = 0\n        n12 int = 0\n        n13 int = 0\n        n14 int = 0\n        n15 int = 0\n        n16 int = 0\n        n17 int = 0\n        n18 int = 0\n        n19 int = 0\n        n20 int = 0\n        n21 int = 0\n        n22 int = 0\n        n23 int = 0\n        n24 int = 0\n        n25 int = 0\n        n26 int = 0\n        n27 int = 0\n        n28 int = 0\n        n29 int = 0\n        n30 int = 0\n        n31 int = 0\n        n32 int = 0\n        n33 int = 0\n        n34 int = 0\n        n35 int = 0\n        n36 int = 0\n        n37 int = 0\n        n38 int = 0\n        n39 int = 0\n        n40 int = 0\n        n41 int = 0\n        n42 int = 0\n        n43 int = 0\n        n44 int = 0\n        n45 int = 0\n        n46 int = 0\n        n47 int = 0\n        n48 int = 0\n        n49 int = 0\n        n50 int = 0\n        n51 int = 0\n        n52 int = 0\n        n53 int = 0\n        n54 int = 0\n        n55 int = 0\n        n56 int = 0\n        n57 int = 0\n        n58 int = 0\n        n59 int = 0\n        n60 int = 0\n        n61 int = 0\n        n62 int = 0\n        n63 int\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123318,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpdy9u10rl_test.go:85:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var x, y int = 0, 0\n    var jump float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += step.(int)\n        case float64:\n            y += int(step.(float64))\n        }\n        if x == d {\n            return jump\n        }\n        if x > d {\n            return -1\n        }\n        if y == 0 {\n            jump++\n        }\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123319,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpxgy0o3f6_test.go:47: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpxgy0o3f6_test.go:47: expected '%!s(int=0)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpxgy0o3f6_test.go:47: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) && y == 0 {\n            return count\n        }\n        count++\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123319,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpks2dbe8u_test.go:43: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpks2dbe8u_test.go:43: expected '%!s(int=0)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpks2dbe8u_test.go:43: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        i int\n        j float64\n        k float64\n    )\n    for i = 0; i < len(steps); i++ {\n        switch steps[i].(type) {\n        case int:\n            j += float64(steps[i].(int))\n        case float64:\n            j += steps[i].(float64)\n        }\n        if j >= float64(d) {\n            break\n        }\n    }\n    k = j - float64(d)\n    if k > 0 {\n        return float64(i) + k\n    }\n    return float64(i)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123319,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmphq6_7w3c_test.go:48: expected '%!s(float64=3.5)', got '%!s(float64=2)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmphq6_7w3c_test.go:48: expected '%!s(int=0)', got '%!s(float64=3)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmphq6_7w3c_test.go:48: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var x, y, count float64\n    for _, step := range steps {\n        switch step {\n        case \"UP\":\n            y++\n        case \"DOWN\":\n            y--\n        case \"LEFT\":\n            x--\n        case \"RIGHT\":\n            x++\n        }\n        count++\n        if x == float64(d) || y == float64(d) {\n            return count\n        }\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123319,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp1o9ah9q3_test.go:46: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmp1o9ah9q3_test.go:46: expected '%!s(int=0)', got '%!s(float64=1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmp1o9ah9q3_test.go:46: expected '%!s(int=1)', got '%!s(float64=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        n int = len(steps)\n        i int = 0\n        j int = 0\n        k int = 0\n        l int = 0\n        m int = 0\n        x int = 0\n        y int = 0\n        z int = 0\n        a int = 0\n        b int = 0\n        c int = 0\n        dp [][]float64 = make([][]float64, n)\n        res float64 = 0\n    )\n\n    for i = 0; i < n; i++ {\n        dp[i] = make([]float64, n)\n    }\n\n    for i = 0; i < n; i++ {\n        for j = 0; j < n; j++ {\n            dp[i][j] = -1\n        }\n    }\n\n    for i = 0; i < n; i++ {\n        dp[i][i] = 0\n    }\n\n    for i = 0; i < n; i++ {\n        for j = i; j < n; j++ {\n            if i == j {\n                continue\n            }\n\n            for k = i; k < j; k++ {\n                if dp[i][k] == -1 || dp[k + 1][j] == -1 {\n                    continue\n                }\n\n                if dp[i][j] == -1 || dp[i][j] > dp[i][k] + dp[k + 1][j] + 1 {\n                    dp[i][j] = dp[i][k] + dp[k + 1][j] + 1\n                }\n            }\n        }\n    }\n\n    for i = 0; i < n; i++ {\n        for j = 0; j < n; j++ {\n            fmt.Printf(\"%f \", dp[i][j])\n        }\n        fmt.Println()\n    }\n\n    for i = 0; i < n; i++ {\n        for j = 0; j < n; j++ {\n            for k = 0; k < n; k++ {\n                for l = 0; l < n; l++ {\n                    if dp[i][j] == -\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123318,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp8sjje22w_test.go:71:6: expected '(', found TestMin_Jumps\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y += 1\n        case \"down\":\n            y -= 1\n        case \"left\":\n            x -= 1\n        case \"right\":\n            x += 1\n        }\n        if x == d || y == d {\n            return count + 1\n        }\n        count += 1\n    }\n    return count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123319,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqhq4rqow_test.go:25:14: invalid operation: x == d (mismatched types float64 and int)\n/tmp/tmpqhq4rqow_test.go:25:24: invalid operation: y == d (mismatched types float64 and int)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        i, j, k int\n        n, m int\n        x, y float64\n        x1, y1 float64\n        x2, y2 float64\n        x3, y3 float64\n        x4, y4 float64\n        x5, y5 float64\n        x6, y6 float64\n        x7, y7 float64\n        x8, y8 float64\n        x9, y9 float64\n        x10, y10 float64\n        x11, y11 float64\n        x12, y12 float64\n        x13, y13 float64\n        x14, y14 float64\n        x15, y15 float64\n        x16, y16 float64\n        x17, y17 float64\n        x18, y18 float64\n        x19, y19 float64\n        x20, y20 float64\n        x21, y21 float64\n        x22, y22 float64\n        x23, y23 float64\n        x24, y24 float64\n        x25, y25 float64\n        x26, y26 float64\n        x27, y27 float64\n        x28, y28 float64\n        x29, y29 float64\n        x30, y30 float64\n        x31, y31 float64\n        x32, y32 float64\n        x33, y33 float64\n        x34, y34 float64\n        x35, y35 float64\n        x36, y36 float64\n        x37, y37 float64\n        x38, y38 float64\n        x39, y39 float64\n        x40, y40 float64\n        x41, y41 float64\n        x42, y42 float64\n        x43, y43 float64\n        x44, y44 float64\n        x45, y45 float64\n        x46, y46 float64\n        x47, y47 float64\n        x48, y48 float64\n        x49, y49 float64\n        x50, y50 float64\n        x51, y51 float64\n        x52, y52 float64\n        x53, y53 float64\n        x54, y54 float64\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123318,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp967jwouc_test.go:69:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var n int = len(steps)\n    var dp [][]float64 = make([][]float64, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]float64, d + 1)\n        for j := 0; j < d + 1; j++ {\n            dp[i][j] = -1\n        }\n    }\n    return min_Jumps_recursive(steps, 0, 0, d, dp)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123320,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6mz02f97_test.go:18:12: undefined: min_Jumps_recursive\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    return 0\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123321,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpj1rzwy4a_test.go:29: expected '%!s(float64=3.5)', got '%!s(float64=0)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpj1rzwy4a_test.go:29: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var result float64\n    var x, y int\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += step.(int)\n        case string:\n            y += 1\n        }\n        if x == d {\n            result += 1\n            x = 0\n        }\n    }\n    if x != 0 {\n        result += 1\n    }\n    result += float64(y) / 2\n    return result\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123321,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpepexzpj1_test.go:47: expected '%!s(float64=3.5)', got '%!s(float64=1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpepexzpj1_test.go:47: expected '%!s(int=0)', got '%!s(float64=1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpepexzpj1_test.go:47: expected '%!s(int=1)', got '%!s(float64=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var result float64\n    var x float64\n    var y float64\n    for _, step := range steps {\n        switch step.(type) {\n        case string:\n            if step == \"D\" {\n                y -= 1\n            } else {\n                y += 1\n            }\n        case int:\n            x += float64(step.(int))\n        }\n        if x > d {\n            return -1\n        }\n        if y == 0 {\n            result += 1\n            x = 0\n        }\n    }\n    return result\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123320,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp235f_de9_test.go:24:14: invalid operation: x > d (mismatched types float64 and int)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        i int\n        j int\n        k int\n        n int\n        m int\n        x float64\n        y float64\n        z float64\n        a float64\n        b float64\n        c float64\n        dp [][]float64\n        dp_1 [][]float64\n        dp_2 [][]float64\n        dp_3 [][]float64\n        dp_4 [][]float64\n    )\n\n    n = len(steps)\n    m = d + 1\n    dp = make([][]float64, n)\n    dp_1 = make([][]float64, n)\n    dp_2 = make([][]float64, n)\n    dp_3 = make([][]float64, n)\n    dp_4 = make([][]float64, n)\n    for i = 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n        dp_1[i] = make([]float64, m)\n        dp_2[i] = make([]float64, m)\n        dp_3[i] = make([]float64, m)\n        dp_4[i] = make([]float64, m)\n    }\n\n    for i = 0; i < n; i++ {\n        for j = 0; j < m; j++ {\n            if i == 0 {\n                dp[i][j] = 1\n            } else {\n                x = steps[i].([]interface{})[0].(float64)\n                y = steps[i].([]interface{})[1].(float64)\n                z = steps[i].([]interface{})[2].(float64)\n                a = steps[i].([]interface{})[3].(float64)\n                b = steps[i].([]interface{})[4].(float64)\n                c = steps[i].([]interface{})[5].(float64)\n                dp_1[i][j] = dp[i - 1][j] * (1 - x)\n                dp_2\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123319,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3u_64iv3_test.go:57:6: expected '(', found TestMin_Jumps\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        i, j int\n        n int = len(steps)\n        m int = len(steps[0].([]int))\n        dp [][]float64 = make([][]float64, n)\n        tmp float64 = 0\n    )\n    for i = 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n    }\n    for i = 0; i < n; i++ {\n        for j = 0; j < m; j++ {\n            if i == 0 && j == 0 {\n                dp[i][j] = 1\n            } else {\n                tmp = 0\n                if i - steps[i][j].(int) >= 0 {\n                    tmp += dp[i - steps[i][j].(int)][j]\n                }\n                if j - steps[i][j].(int) >= 0 {\n                    tmp += dp[i][j - steps[i][j].(int)]\n                }\n                dp[i][j] = tmp\n            }\n        }\n    }\n    return dp[n - 1][m - 1]\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123320,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0m16dwz4_test.go:26:32: invalid operation: steps[i][j] (type interface {} does not support indexing)\n/tmp/tmp0m16dwz4_test.go:27:43: invalid operation: steps[i][j] (type interface {} does not support indexing)\n/tmp/tmp0m16dwz4_test.go:29:32: invalid operation: steps[i][j] (type interface {} does not support indexing)\n/tmp/tmp0m16dwz4_test.go:30:46: invalid operation: steps[i][j] (type interface {} does not support indexing)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            return count\n        }\n        if y == 0 {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123321,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpx5wsd27d_test.go:45: expected '%!s(float64=3.5)', got '%!s(float64=2)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpx5wsd27d_test.go:45: expected '%!s(int=0)', got '%!s(float64=2)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpx5wsd27d_test.go:45: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case string:\n            if step.(string) == \"D\" {\n                y -= 1\n            } else if step.(string) == \"U\" {\n                y += 1\n            } else if step.(string) == \"L\" {\n                x -= 1\n            } else if step.(string) == \"R\" {\n                x += 1\n            }\n        case int:\n            if step.(int) > 0 {\n                x += float64(step.(int))\n            } else {\n                y += float64(step.(int))\n            }\n        case float64:\n            if step.(float64) > 0 {\n                x += step.(float64)\n            } else {\n                y += step.(float64)\n            }\n        }\n        if x == float64(d) {\n            count += 1\n            x = 0\n        }\n    }\n    return count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123321,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp7mdx5r2r_test.go:62: expected '%!s(float64=3.5)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        n int = len(steps)\n        i int = 0\n        j int = 0\n        k int = 0\n        m int = 0\n        x int = 0\n        y int = 0\n        z int = 0\n        a int = 0\n        b int = 0\n        c int = 0\n        l int = 0\n        r int = 0\n        t int = 0\n        u int = 0\n        v int = 0\n        w int = 0\n        x1 int = 0\n        y1 int = 0\n        z1 int = 0\n        a1 int = 0\n        b1 int = 0\n        c1 int = 0\n        l1 int = 0\n        r1 int = 0\n        t1 int = 0\n        u1 int = 0\n        v1 int = 0\n        w1 int = 0\n        x2 int = 0\n        y2 int = 0\n        z2 int = 0\n        a2 int = 0\n        b2 int = 0\n        c2 int = 0\n        l2 int = 0\n        r2 int = 0\n        t2 int = 0\n        u2 int = 0\n        v2 int = 0\n        w2 int = 0\n        x3 int = 0\n        y3 int = 0\n        z3 int = 0\n        a3 int = 0\n        b3 int = 0\n        c3 int = 0\n        l3 int = 0\n        r3 int = 0\n        t3 int = 0\n        u3 int = 0\n        v3 int = 0\n        w3 int = 0\n        x4 int = 0\n        y4 int = 0\n        z4 int = 0\n        a4 int = 0\n        b4 int = 0\n        c4 int = 0\n        l4 int = 0\n        r4 int = 0\n        t4 int = 0\n        u4 int = 0\n        v4 int = 0\n        w4 int = 0\n        x5 int = 0\n        y5 int = 0\n        z5 int = 0\n        a5 int = 0\n        b5 int = 0\n        c5 int = 0\n        l5 int = 0\n        r5 int = 0\n        t5 int = 0\n        u5\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123320,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmphioguqk8_test.go:85:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        n int\n        x, y float64\n    )\n    n = len(steps)\n    x, y = 0, 0\n    for i := 0; i < n; i++ {\n        switch steps[i].(type) {\n        case int:\n            x += float64(steps[i].(int))\n        case float64:\n            x += steps[i].(float64)\n        }\n        if x > float64(d) {\n            return -1\n        }\n    }\n    if x == float64(d) {\n        return 0\n    }\n    if x < float64(d) {\n        return float64(d) - x\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123321,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4tqq6_0e_test.go:12:12: y declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var i float64\n    for _, v := range steps {\n        switch v.(type) {\n        case int:\n            i += float64(v.(int))\n        case float64:\n            i += v.(float64)\n        }\n    }\n    return i / float64(d)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123321,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmph3lsj8ga_test.go:37: expected '%!s(float64=3.5)', got '%!s(float64=0.6363636363636364)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmph3lsj8ga_test.go:37: expected '%!s(int=0)', got '%!s(float64=+Inf)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmph3lsj8ga_test.go:37: expected '%!s(int=1)', got '%!s(float64=2.272727272727273)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var x, y, count float64\n    x = 0\n    y = 0\n    count = 0\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y += 1\n        case \"down\":\n            y -= 1\n        case \"left\":\n            x -= 1\n        case \"right\":\n            x += 1\n        }\n        if x == d || y == d {\n            count += 1\n            x = 0\n            y = 0\n        }\n    }\n    return count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123321,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0omz_jy2_test.go:26:14: invalid operation: x == d (mismatched types float64 and int)\n/tmp/tmp0omz_jy2_test.go:26:24: invalid operation: y == d (mismatched types float64 and int)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    if len(steps) == 0 {\n        return 0\n    }\n    if len(steps) == 1 {\n        if steps[0] == \"D\" {\n            return 1\n        } else {\n            return 0\n        }\n    }\n    if len(steps) == 2 {\n        if steps[0] == \"D\" && steps[1] == \"D\" {\n            return 1\n        } else {\n            return 0\n        }\n    }\n    if len(steps) == 3 {\n        if steps[0] == \"D\" && steps[1] == \"D\" && steps[2] == \"D\" {\n            return 1\n        } else {\n            return 0\n        }\n    }\n    if len(steps) == 4 {\n        if steps[0] == \"D\" && steps[1] == \"D\" && steps[2] == \"D\" && steps[3] == \"D\" {\n            return 1\n        } else {\n            return 0\n        }\n    }\n    if len(steps) == 5 {\n        if steps[0] == \"D\" && steps[1] == \"D\" && steps[2] == \"D\" && steps[3] == \"D\" && steps[4] == \"D\" {\n            return 1\n        } else {\n            return 0\n        }\n    }\n    if len(steps) == 6 {\n        if steps[0] == \"D\" && steps[1] == \"D\" && steps[2] == \"D\" && steps[3] == \"D\" && steps[4] == \"D\" && steps[5] == \"D\" {\n            return 1\n        } else {\n            return 0\n        }\n    }\n    if len(steps) == 7 {\n        if steps[0] == \"D\" && steps[1] == \"D\" && steps[2] == \"D\" && steps[3] == \"D\" && steps[4] == \"D\" && steps[5] == \"D\" && steps[6] == \"D\" {\n            return 1\n        } else {\n            return 0\n        }\n    }\n    if len(steps) == 8 {\n        if steps[0] == \"\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123321,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprjuzgw9x_test.go:63:24: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var min_jumps float64 = 0\n    var x_pos float64 = 0\n    var y_pos float64 = 0\n    var x_steps float64 = 0\n    var y_steps float64 = 0\n    var x_step_count float64 = 0\n    var y_step_count float64 = 0\n    var x_step_count_max float64 = 0\n    var y_step_count_max float64 = 0\n    var x_step_count_min float64 = 0\n    var y_step_count_min float64 = 0\n    var x_step_count_max_min_diff float64 = 0\n    var y_step_count_max_min_diff float64 = 0\n    var x_step_count_max_min_diff_min float64 = 0\n    var y_step_count_max_min_diff_min float64 = 0\n    var x_step_count_max_min_diff_max float64 = 0\n    var y_step_count_max_min_diff_max float64 = 0\n    var x_step_count_max_min_diff_min_max_diff float64 = 0\n    var y_step_count_max_min_diff_min_max_diff float64 = 0\n    var x_step_count_max_min_diff_min_max_diff_min float64 = 0\n    var y_step_count_max_min_diff_min_max_diff_min float64 = 0\n    var x_step_count_max_min_diff_min_max_diff_max float64 = 0\n    var y_step_count_max_min_diff_min_max_diff_max float64 = 0\n    var x_step_count_max_min_diff_min_max_diff_min_max_diff float64 = 0\n    var y_step_count_max_min_diff_min_max_diff_min_max_diff float64 = 0\n    var x_step_count_max_min_diff_min_max_diff_min_max_diff_min float64 = 0\n    var y_step_count_max_min_diff_min_max_diff_\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123321,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpy5iv7iuc_test.go:36:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    // To print results to the standard output you can use fmt.Println()\n    // Example: fmt.Println(\"Hello world!\")\n    var (\n        x, y int\n        res float64\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += step.(int)\n        case string:\n            y += len(step.(string))\n        }\n    }\n    res = float64(x) / float64(d)\n    if y > 0 {\n        res += float64(y)\n    }\n    return res\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123322,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpp83kilgy_test.go:47: expected '%!s(float64=3.5)', got '%!s(float64=0.6363636363636364)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpp83kilgy_test.go:47: expected '%!s(int=0)', got '%!s(float64=+Inf)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpp83kilgy_test.go:47: expected '%!s(int=1)', got '%!s(float64=2.272727272727273)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var x, y float64\n    for _, step := range steps {\n        switch step.(type) {\n        case string:\n            switch step.(string) {\n            case \"UP\":\n                y++\n            case \"DOWN\":\n                y--\n            case \"LEFT\":\n                x--\n            case \"RIGHT\":\n                x++\n            }\n        case int:\n            switch step.(int) {\n            case 0:\n                x++\n            case 1:\n                y++\n            case 2:\n                x--\n            case 3:\n                y--\n            }\n        }\n    }\n    return (x*x + y*y) / (2 * float64(d))\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123322,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpcx_vo9oc_test.go:56: expected '%!s(float64=3.5)', got '%!s(float64=0.045454545454545456)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpcx_vo9oc_test.go:56: expected '%!s(int=0)', got '%!s(float64=+Inf)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpcx_vo9oc_test.go:56: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var x, y, count float64\n    for _, step := range steps {\n        switch step.(type) {\n        case string:\n            if step.(string) == \"D\" {\n                y -= 1\n            } else {\n                y += 1\n            }\n        case int:\n            x += float64(step.(int))\n        }\n        if x == float64(d) {\n            count += 1\n        } else if x > float64(d) {\n            count += 1\n            x = 0\n        }\n    }\n    return count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123322,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp8ozp9vez_test.go:47: expected '%!s(float64=3.5)', got '%!s(float64=0)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmp8ozp9vez_test.go:47: expected '%!s(int=0)', got '%!s(float64=2)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmp8ozp9vez_test.go:47: expected '%!s(int=1)', got '%!s(float64=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        count int\n        x, y int\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += step.(int)\n            if x == d {\n                return float64(count + 1)\n            }\n        case float64:\n            y += int(step.(float64))\n            if y == 0 {\n                return float64(count + 1)\n            }\n        }\n        count++\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123322,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp3vvy2g_p_test.go:47: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmp3vvy2g_p_test.go:47: expected '%!s(int=0)', got '%!s(float64=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aaa int\n    var bbb int\n    var ccc int\n    var ddd int\n    var eee int\n    var fff int\n    var ggg int\n    var hhh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var pppp int\n    var qqqq int\n   \nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123321,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_23tu4t__test.go:99:6: expected '(', found TestMin_Jumps\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        n int = len(steps)\n        i int = 0\n        j int = 0\n        k int = 0\n        x int = 0\n        y int = 0\n        z int = 0\n        x1 int = 0\n        y1 int = 0\n        z1 int = 0\n        x2 int = 0\n        y2 int = 0\n        z2 int = 0\n        x3 int = 0\n        y3 int = 0\n        z3 int = 0\n        x4 int = 0\n        y4 int = 0\n        z4 int = 0\n        x5 int = 0\n        y5 int = 0\n        z5 int = 0\n        x6 int = 0\n        y6 int = 0\n        z6 int = 0\n        x7 int = 0\n        y7 int = 0\n        z7 int = 0\n        x8 int = 0\n        y8 int = 0\n        z8 int = 0\n        x9 int = 0\n        y9 int = 0\n        z9 int = 0\n        x10 int = 0\n        y10 int = 0\n        z10 int = 0\n        x11 int = 0\n        y11 int = 0\n        z11 int = 0\n        x12 int = 0\n        y12 int = 0\n        z12 int = 0\n        x13 int = 0\n        y13 int = 0\n        z13 int = 0\n        x14 int = 0\n        y14 int = 0\n        z14 int = 0\n        x15 int = 0\n        y15 int = 0\n        z15 int = 0\n        x16 int = 0\n        y16 int = 0\n        z16 int = 0\n        x17 int = 0\n        y17 int = 0\n        z17 int = 0\n        x18 int = 0\n        y18 int = 0\n        z18 int = 0\n        x19 int = 0\n        y19 int = 0\n        z19 int = 0\n        x20 int = 0\n        y20 int = 0\n        z20 int = 0\n        x21 int = 0\n        y21 int = 0\n        z21 int = 0\n        x22 int = 0\n        y22 int = 0\n        z22 int = 0\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123321,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxvs2lvg2_test.go:85:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    // To print results to the standard output you can use fmt.Println()\n    // Example: fmt.Println(\"Hello world!\")\n    var x, y, count float64\n    for _, step := range steps {\n        switch step {\n        case \"UP\":\n            y++\n        case \"DOWN\":\n            y--\n        case \"LEFT\":\n            x--\n        case \"RIGHT\":\n            x++\n        }\n        if x == float64(d) || y == float64(d) {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123322,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpgd5dmh59_test.go:47: expected '%!s(float64=3.5)', got '%!s(float64=0)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpgd5dmh59_test.go:47: expected '%!s(int=0)', got '%!s(float64=2)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpgd5dmh59_test.go:47: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        n int = len(steps)\n        i int\n        j float64 = 0\n        k float64 = 0\n        l float64 = 0\n        m float64 = 0\n        x float64 = 0\n        y float64 = 0\n        z float64 = 0\n    )\n    for i = 0; i < n; i++ {\n        switch steps[i].(type) {\n            case int:\n                x = float64(steps[i].(int))\n            case float64:\n                x = steps[i].(float64)\n        }\n        if x > 0 {\n            j += x\n        } else {\n            k += x\n        }\n        if j > d {\n            m = j - d\n            j = d\n        }\n        if k < 0 {\n            l = k\n            k = 0\n        }\n        if k == 0 && l < 0 {\n            y = -l\n        }\n        if j == d && m > 0 {\n            z = m\n        }\n    }\n    return y + z\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123322,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk2_5v6ld_test.go:33:14: invalid operation: j > d (mismatched types float64 and int)\n/tmp/tmpk2_5v6ld_test.go:34:19: invalid operation: j - d (mismatched types float64 and int)\n/tmp/tmpk2_5v6ld_test.go:35:15: cannot use d (type int) as type float64 in assignment\n/tmp/tmpk2_5v6ld_test.go:44:14: invalid operation: j == d (mismatched types float64 and int)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        x, y int\n        jumps float64\n    )\n\n    for _, step := range steps {\n        switch step {\n            case \"N\":\n                y++\n            case \"S\":\n                y--\n            case \"E\":\n                x++\n            case \"W\":\n                x--\n        }\n        if x == d || y == d {\n            return jumps + 1\n        }\n        jumps++\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123322,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpswptqr7p_test.go:49: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpswptqr7p_test.go:49: expected '%!s(int=0)', got '%!s(float64=1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpswptqr7p_test.go:49: expected '%!s(int=1)', got '%!s(float64=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var (\n        i, j, k, l int\n        m, n, o, p float64\n        q, r, s, t float64\n    )\n    for i = 0; i < len(steps); i++ {\n        switch steps[i].(type) {\n        case int:\n            j = steps[i].(int)\n            if j > 0 {\n                m += float64(j)\n            } else {\n                n += float64(j)\n            }\n        case float64:\n            o = steps[i].(float64)\n            if o > 0 {\n                q += o\n            } else {\n                r += o\n            }\n        }\n    }\n    if m > 0 {\n        p = m\n    } else {\n        p = -n\n    }\n    if q > 0 {\n        s = q\n    } else {\n        s = -r\n    }\n    t = p + s\n    if t > 0 {\n        k = int(t)\n    } else {\n        k = int(-t)\n    }\n    if k > d {\n        return float64(k)\n    } else {\n        return float64(d)\n    }\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123322,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpanm7g23m_test.go:12:18: l declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var x, y, n int\n    for _, step := range steps {\n        switch step {\n            case \"N\":\n                y++\n            case \"S\":\n                y--\n            case \"E\":\n                x++\n            case \"W\":\n                x--\n            default:\n                n = step.(int)\n        }\n    }\n    if x == d {\n        return float64(y)\n    }\n    if y == d {\n        return float64(x)\n    }\n    if x == 0 && y == 0 {\n        return float64(n)\n    }\n    if x == 0 || y == 0 {\n        return float64(n) + float64(d)\n    }\n    return float64(n) + float64(d) + float64(d)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123323,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpg0z2mlar_test.go:55: expected '%!s(float64=3.5)', got '%!s(float64=4)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpg0z2mlar_test.go:55: expected '%!s(int=1)', got '%!s(float64=14)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var x, y float64\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n    }\n    return (d - x) / y\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123311,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp60al0i6c_test.go:19:12: invalid operation: d - x (mismatched types int and float64)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var x, y, count float64\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y += 1\n        case \"down\":\n            y -= 1\n        case \"left\":\n            x -= 1\n        case \"right\":\n            x += 1\n        }\n        if x == d || y == d {\n            return count\n        }\n        count += 1\n    }\n    return count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123322,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqhpjxvqx_test.go:22:14: invalid operation: x == d (mismatched types float64 and int)\n/tmp/tmpqhpjxvqx_test.go:22:24: invalid operation: y == d (mismatched types float64 and int)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += float64(step.(float64))\n        }\n        if x == float64(d) {\n            return count + 1\n        }\n        if y == 0 {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123323,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp8bi91byl_test.go:45: expected '%!s(float64=3.5)', got '%!s(float64=2)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmp8bi91byl_test.go:45: expected '%!s(int=0)', got '%!s(float64=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            return count + 1\n        }\n        if x > float64(d) {\n            return -1\n        }\n        if y == 0 {\n            count++\n        }\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510493,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp5djfr1l8_test.go:48: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmp5djfr1l8_test.go:48: expected '%!s(int=0)', got '%!s(float64=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n            case int:\n                count += 1\n                x += float64(step.(int))\n            case float64:\n                count += 1\n                x += step.(float64)\n            case string:\n                count += 1\n                y += 1\n            default:\n                fmt.Println(\"Invalid step\")\n        }\n        if x >= float64(d) {\n            break\n        }\n    }\n    if x < float64(d) {\n        count += float64(d) - x\n    }\n    return count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123323,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp05tatsec_test.go:52: expected '%!s(float64=3.5)', got '%!s(float64=6)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmp05tatsec_test.go:52: expected '%!s(int=0)', got '%!s(float64=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        x, y int\n        count float64\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += step.(int)\n        case string:\n            y += 1\n        }\n        if x == d {\n            return count + 1\n        }\n    }\n    return count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123323,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpj8jbvfw1_test.go:43: expected '%!s(float64=3.5)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var result float64\n    var x, y int\n    for _, v := range steps {\n        switch v.(type) {\n        case int:\n            x += v.(int)\n        case string:\n            y += v.(string)\n        }\n    }\n    result = math.Sqrt(float64((x*x)+(y*y)))\n    return result\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123323,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmmkj33w2_test.go:18:15: invalid operation: y += v.(string) (mismatched types int and string)\n/tmp/tmpmmkj33w2_test.go:21:14: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, v := range steps {\n        switch v.(type) {\n        case string:\n            if v.(string) == \"D\" {\n                y -= 1\n            } else if v.(string) == \"U\" {\n                y += 1\n            } else if v.(string) == \"L\" {\n                x -= 1\n            } else if v.(string) == \"R\" {\n                x += 1\n            }\n        case int:\n            if v.(int) == 0 {\n                return -1\n            }\n            if x == 0 {\n                if y < 0 {\n                    count += float64(v.(int)) / float64(y)\n                } else {\n                    count += float64(v.(int)) / float64(y)\n                }\n            } else if y == 0 {\n                if x < 0 {\n                    count += float64(v.(int)) / float64(x)\n                } else {\n                    count += float64(v.(int)) / float64(x)\n                }\n            } else {\n                if x < 0 {\n                    count += float64(v.(int)) / float64(x)\n                } else {\n                    count += float64(v.(int)) / float64(x)\n                }\n            }\n        }\n    }\n    if x == float64(d) && y == 0 {\n        return count\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123323,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpt4ax5rb8_test.go:71: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpt4ax5rb8_test.go:71: expected '%!s(int=0)', got '%!s(float64=+Inf)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpt4ax5rb8_test.go:71: expected '%!s(int=1)', got '%!s(float64=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        x, y, count float64\n    )\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y++\n        case \"down\":\n            y--\n        case \"left\":\n            x--\n        case \"right\":\n            x++\n        }\n        if x == d || y == d {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123323,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpewlyna9l_test.go:24:14: invalid operation: x == d (mismatched types float64 and int)\n/tmp/tmpewlyna9l_test.go:24:24: invalid operation: y == d (mismatched types float64 and int)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        i, j int\n        x, y float64\n        min_jumps float64\n    )\n    for i = 0; i < len(steps); i++ {\n        switch steps[i].(type) {\n        case int:\n            x += float64(steps[i].(int))\n        case float64:\n            x += steps[i].(float64)\n        case string:\n            y += float64(len(steps[i].(string)))\n        }\n    }\n    min_jumps = (x + y) / float64(d)\n    return min_jumps\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123323,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_igcjbr0_test.go:11:12: j declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        x, y, count float64\n    )\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y++\n        case \"down\":\n            y--\n        case \"left\":\n            x--\n        case \"right\":\n            x++\n        }\n        if x == d || y == d {\n            count++\n            x, y = 0, 0\n        }\n    }\n    return count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123323,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5617aaci_test.go:24:14: invalid operation: x == d (mismatched types float64 and int)\n/tmp/tmp5617aaci_test.go:24:24: invalid operation: y == d (mismatched types float64 and int)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            return count + 1\n        }\n        if y == 0 {\n            count += 1\n        }\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123323,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmps_c5njr1_test.go:45: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmps_c5njr1_test.go:45: expected '%!s(int=0)', got '%!s(float64=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    if len(steps) == 0 {\n        return 0\n    }\n    if len(steps) == 1 {\n        return 1\n    }\n    var (\n        x float64\n        y float64\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case string:\n            if step.(string) == \"D\" {\n                y -= 1\n            } else {\n                y += 1\n            }\n        case int:\n            x += float64(step.(int))\n        }\n    }\n    if x < float64(d) {\n        return -1\n    }\n    if y == 0 {\n        return x / float64(d)\n    }\n    return (x / float64(d)) + 1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123324,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpfzx9tn29_test.go:56: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpfzx9tn29_test.go:56: expected '%!s(int=0)', got '%!s(float64=+Inf)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpfzx9tn29_test.go:56: expected '%!s(int=1)', got '%!s(float64=2.272727272727273)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    if len(steps) == 0 {\n        return 0\n    }\n    if len(steps) == 1 {\n        return steps[0].(float64)\n    }\n    var sum float64 = 0\n    for _, v := range steps {\n        sum += v.(float64)\n    }\n    return sum / float64(d)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123324,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\npanic: interface conversion: interface {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523720, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523720, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.min_Jumps(0xc0000926d0, 0x2, 0x2, 0xb, 0xf)\n\t/tmp/tmp86w32lti_test.go:18 +0xdf\ncommand-line-arguments_test.TestMin_Jumps(0xc000001380)\n\t/tmp/tmp86w32lti_test.go:30 +0xb1\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    // To print results to the standard output you can use fmt.Println()\n    // Example: fmt.Println(\"Hello world!\")\n    var x, y, count float64\n    x = 0\n    y = 0\n    count = 0\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y++\n        case \"down\":\n            y--\n        case \"left\":\n            x--\n        case \"right\":\n            x++\n        }\n        if x == d || y == d {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123324,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl8gw30rf_test.go:28:14: invalid operation: x == d (mismatched types float64 and int)\n/tmp/tmpl8gw30rf_test.go:28:24: invalid operation: y == d (mismatched types float64 and int)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var x, y, count float64\n    for _, step := range steps {\n        switch step {\n        case \"N\":\n            y++\n        case \"S\":\n            y--\n        case \"E\":\n            x++\n        case \"W\":\n            x--\n        }\n        if x == d && y == 0 {\n            return count\n        }\n        count++\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123324,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps7ept2gg_test.go:22:14: invalid operation: x == d (mismatched types float64 and int)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        i, j int\n        n int = len(steps)\n        m int = n + 1\n        dp [][]float64 = make([][]float64, m)\n        sum float64 = 0\n    )\n    for i = 0; i < m; i++ {\n        dp[i] = make([]float64, m)\n    }\n    for i = 0; i < n; i++ {\n        dp[i][i] = steps[i].(float64)\n        sum += dp[i][i]\n    }\n    for i = 0; i < n; i++ {\n        for j = i + 1; j < n; j++ {\n            dp[i][j] = dp[i][j - 1] + steps[j].(float64)\n            sum += dp[i][j]\n        }\n    }\n    return sum / float64(n * (n + 1) / 2)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123324,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\npanic: interface conversion: interface {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface {} is int, not float64\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523720, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523720, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.min_Jumps(0xc00011aed0, 0x2, 0x2, 0xb, 0xf)\n\t/tmp/tmpjksaswld_test.go:21 +0x2a5\ncommand-line-arguments_test.TestMin_Jumps(0xc000102600)\n\t/tmp/tmpjksaswld_test.go:40 +0xb1\ntesting.tRunner(0xc000102600, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        n int = len(steps)\n        dp = make([]float64, n)\n        i int\n    )\n    dp[0] = steps[0].(float64)\n    for i = 1; i < n; i++ {\n        dp[i] = dp[i-1] + steps[i].(float64)\n    }\n    return dp[n-1] / float64(d)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123324,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\npanic: interface conversion: interface {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface {} is int, not float64\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523720, 0xc00018c240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523720, 0xc00018c240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.min_Jumps(...)\n\t/tmp/tmpswsod7dz_test.go:15\ncommand-line-arguments_test.TestMin_Jumps(0xc000186300)\n\t/tmp/tmpswsod7dz_test.go:29 +0x633\ntesting.tRunner(0xc000186300, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var x, y int = 0, 0\n    var count int = 0\n    for _, step := range steps {\n        switch step {\n        case \"N\":\n            y += 1\n        case \"S\":\n            y -= 1\n        case \"E\":\n            x += 1\n        case \"W\":\n            x -= 1\n        }\n        if x == d && y == 0 {\n            return float64(count)\n        }\n        count += 1\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123325,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpyo06hl9v_test.go:46: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpyo06hl9v_test.go:46: expected '%!s(int=1)', got '%!s(float64=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n    )\n    for i = 0; i < len(steps); i++ {\n        switch steps[i].(type) {\n        case int:\n            j = steps[i].(int)\n            if j > d {\n                return -1\n            }\n        case float64:\n            k = int(steps[i].(float64))\n            if k > d {\n                return -1\n            }\n        case string:\n            l = len(steps[i].(string))\n            if l > d {\n                return -1\n            }\n        case []int:\n            m = len(steps[i].([]int))\n            if m > d {\n                return -1\n            }\n        case []float64:\n            n = len(steps[i].([]float64))\n            if n > d {\n                return -1\n            }\n        case []string:\n            o = len(steps[i].([]string))\n            if o > d {\n                return -1\n            }\n        case [][]int:\n            p = len(steps[i].([][]int))\n            if p > d {\n                return -1\n            }\n        case [][]float64:\n            q = len(steps[i].([][]float64))\n            if q > d {\n                return -1\n            }\n        case [][]string:\n            r = len(steps[i].([][]string))\n            if r > d {\n                return -1\n            }\n        case []interface{}:\n            s = len(steps[i].([]interface{}))\n            if s > d {\n                return -1\n            }\n        case map[int]int:\n            t = len(steps[i].(map[int]int))\n            if t > d {\n                return -1\n            }\n        case map[\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123324,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpk4_jivzk_test.go:88:6: expected '(', found TestMin_Jumps\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    if len(steps) == 0 {\n        return 0\n    }\n    var sum float64 = 0\n    for _, v := range steps {\n        if v.(int) > d {\n            return -1\n        }\n        sum += float64(v.(int))\n    }\n    if sum < float64(d) {\n        return -1\n    }\n    if sum == float64(d) {\n        return 1\n    }\n    var count float64 = 0\n    for _, v := range steps {\n        if sum > float64(d) {\n            sum -= float64(v.(int))\n            count++\n        } else {\n            break\n        }\n    }\n    return count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123325,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpqeu1bqzk_test.go:53: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpqeu1bqzk_test.go:53: expected '%!s(int=0)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpqeu1bqzk_test.go:53: expected '%!s(int=1)', got '%!s(float64=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var result float64\n    var x, y int\n    for _, step := range steps {\n        switch step {\n        case \"UP\":\n            y++\n        case \"DOWN\":\n            y--\n        case \"LEFT\":\n            x--\n        case \"RIGHT\":\n            x++\n        }\n    }\n    result = float64(d - x)\n    if result < 0 {\n        result = -result\n    }\n    if result < float64(d - y) {\n        result = float64(d - y)\n    }\n    if result < float64(y) {\n        result = float64(y)\n    }\n    return result\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123325,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpz0ljjkfc_test.go:53: expected '%!s(float64=3.5)', got '%!s(float64=11)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpz0ljjkfc_test.go:53: expected '%!s(int=1)', got '%!s(float64=11)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        i, j int\n        n int = len(steps)\n        m int = d\n        dp [][]float64 = make([][]float64, n)\n        step float64\n    )\n\n    for i = 0; i < n; i++ {\n        dp[i] = make([]float64, m + 1)\n        for j = 0; j <= m; j++ {\n            dp[i][j] = -1.0\n        }\n    }\n\n    for j = 0; j <= m; j++ {\n        dp[0][j] = float64(j)\n    }\n\n    for i = 1; i < n; i++ {\n        step = steps[i].(float64)\n        for j = 0; j <= m; j++ {\n            if j < step {\n                dp[i][j] = dp[i - 1][j]\n            } else {\n                dp[i][j] = math.Min(dp[i - 1][j], 1 + dp[i][j - int(step)])\n            }\n        }\n    }\n\n    return dp[n - 1][m]\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123324,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsqf0unaz_test.go:32:18: invalid operation: j < step (mismatched types int and float64)\n/tmp/tmpsqf0unaz_test.go:35:28: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        i, j int\n        x, y float64\n        x_, y_ float64\n        x_max, y_max float64\n        x_min, y_min float64\n        x_max_, y_max_ float64\n        x_min_, y_min_ float64\n        x_max__, y_max__ float64\n        x_min__, y_min__ float64\n        x_max___, y_max___ float64\n        x_min___, y_min___ float64\n        x_max____, y_max____ float64\n        x_min____, y_min____ float64\n        x_max_____, y_max_____ float64\n        x_min_____, y_min_____ float64\n        x_max______, y_max______ float64\n        x_min______, y_min______ float64\n        x_max_______, y_max_______ float64\n        x_min_______, y_min_______ float64\n        x_max________, y_max________ float64\n        x_min________, y_min________ float64\n        x_max_________, y_max_________ float64\n        x_min_________, y_min_________ float64\n        x_max__________, y_max__________ float64\n        x_min__________, y_min__________ float64\n        x_max___________, y_max___________ float64\n        x_min___________, y_min___________ float64\n        x_max____________, y_max____________ float64\n        x_min____________, y_min____________ float64\n        x_max_____________, y_max_____________ float64\n        x_min_____________, y_min_____________ float64\n        x_max______________, y_max______________ float64\n        x_min______________, y_min______________ float64\n        x_max_______________, y_max_______________ float64\n        x_min_______________, y_min_______________ float64\n        x_max________________, y_max________________ float64\n        x_min________________, y_min________________ float64\n        x_max_________________, y_max_________________ float64\n        x_min\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123324,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpqe885_5v_test.go:49:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case string:\n            if step == \"D\" {\n                y -= 1\n            } else {\n                y += 1\n            }\n        case int:\n            x += float64(step.(int))\n        }\n        if x == float64(d) {\n            return count\n        }\n        if x > float64(d) {\n            return -1\n        }\n        if y == 0 {\n            count += 1\n        }\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123325,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp364o97vy_test.go:52: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmp364o97vy_test.go:52: expected '%!s(int=0)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmp364o97vy_test.go:52: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        x, y, count float64\n    )\n    for _, step := range steps {\n        switch step {\n        case \"N\":\n            y++\n        case \"S\":\n            y--\n        case \"E\":\n            x++\n        case \"W\":\n            x--\n        }\n        if x == d || y == d {\n            count++\n            x, y = 0, 0\n        }\n    }\n    return count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123325,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp07glsu6o_test.go:24:14: invalid operation: x == d (mismatched types float64 and int)\n/tmp/tmp07glsu6o_test.go:24:24: invalid operation: y == d (mismatched types float64 and int)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        x, y, count float64\n    )\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y++\n        case \"down\":\n            y--\n        case \"left\":\n            x--\n        case \"right\":\n            x++\n        }\n        if x == d || y == d {\n            count++\n            x, y = 0, 0\n        }\n    }\n    return count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123323,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5617aaci_test.go:24:14: invalid operation: x == d (mismatched types float64 and int)\n/tmp/tmp5617aaci_test.go:24:24: invalid operation: y == d (mismatched types float64 and int)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        n int = len(steps)\n        i int\n        j int\n        k int\n        l int\n        m int\n        n_jumps float64\n    )\n\n    if n == 0 {\n        return 0\n    }\n\n    for i = 0; i < n; i++ {\n        for j = i + 1; j < n; j++ {\n            if steps[j].(int) > steps[i].(int) {\n                break\n            }\n        }\n\n        if j == n {\n            return -1\n        }\n\n        n_jumps++\n\n        for k = j; k < n; k++ {\n            if steps[k].(int) > steps[j - 1].(int) {\n                break\n            }\n        }\n\n        if k == n {\n            return -1\n        }\n\n        n_jumps++\n\n        for l = k; l < n; l++ {\n            if steps[l].(int) > steps[k - 1].(int) {\n                break\n            }\n        }\n\n        if l == n {\n            return -1\n        }\n\n        n_jumps++\n\n        for m = l; m < n; m++ {\n            if steps[m].(int) > steps[l - 1].(int) {\n                break\n            }\n        }\n\n        if m == n {\n            return -1\n        }\n\n        n_jumps++\n\n        if steps[m].(int) >= d {\n            return n_jumps\n        }\n    }\n\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123325,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpvd9b5bkb_test.go:96: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpvd9b5bkb_test.go:96: expected '%!s(int=0)', got '%!s(float64=4)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpvd9b5bkb_test.go:96: expected '%!s(int=1)', got '%!s(float64=4)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        n int = len(steps)\n        i int = 0\n        j int = 0\n        k int = 0\n        x int = 0\n        y int = 0\n        z int = 0\n        a int = 0\n        b int = 0\n        c int = 0\n        m int = 0\n        l int = 0\n        r int = 0\n        s int = 0\n        t int = 0\n        u int = 0\n        v int = 0\n        w int = 0\n        x1 int = 0\n        y1 int = 0\n        z1 int = 0\n        a1 int = 0\n        b1 int = 0\n        c1 int = 0\n        m1 int = 0\n        l1 int = 0\n        r1 int = 0\n        s1 int = 0\n        t1 int = 0\n        u1 int = 0\n        v1 int = 0\n        w1 int = 0\n        x2 int = 0\n        y2 int = 0\n        z2 int = 0\n        a2 int = 0\n        b2 int = 0\n        c2 int = 0\n        m2 int = 0\n        l2 int = 0\n        r2 int = 0\n        s2 int = 0\n        t2 int = 0\n        u2 int = 0\n        v2 int = 0\n        w2 int = 0\n        x3 int = 0\n        y3 int = 0\n        z3 int = 0\n        a3 int = 0\n        b3 int = 0\n        c3 int = 0\n        m3 int = 0\n        l3 int = 0\n        r3 int = 0\n        s3 int = 0\n        t3 int = 0\n        u3 int = 0\n        v3 int = 0\n        w3 int = 0\n        x4 int = 0\n        y4 int = 0\n        z4 int = 0\n        a4 int = 0\n        b4 int = 0\n        c4 int = 0\n        m4 int = 0\n        l4 int = 0\n        r4 int = 0\n        s4 int = 0\n        t4 int = 0\n        u4 int = 0\n        v4 int = 0\n        w4 int = 0\n        x5 int\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123316,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpdcsi25zf_test.go:86:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        n int = len(steps)\n        dp [][]float64 = make([][]float64, n)\n        i int\n        j int\n        k int\n        v float64\n        min float64\n    )\n    for i = 0; i < n; i++ {\n        dp[i] = make([]float64, d+1)\n        for j = 0; j <= d; j++ {\n            dp[i][j] = -1\n        }\n    }\n    dp[0][0] = 0\n    for i = 1; i < n; i++ {\n        v = steps[i].(float64)\n        for j = 0; j <= d; j++ {\n            if dp[i-1][j] != -1 {\n                if j + int(v) <= d {\n                    dp[i][j+int(v)] = dp[i-1][j] + 1\n                }\n                if j - int(v) >= 0 {\n                    dp[i][j-int(v)] = dp[i-1][j] + 1\n                }\n            }\n        }\n    }\n    min = -1\n    for i = 0; i < n; i++ {\n        if dp[i][d] != -1 {\n            if min == -1 || dp[i][d] < min {\n                min = dp[i][d]\n            }\n        }\n    }\n    return min\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123325,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpp7km0z3y_test.go:15:9: k declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, v := range steps {\n        switch v.(type) {\n            case int:\n                x += float64(v.(int))\n            case float64:\n                y += v.(float64)\n            default:\n                fmt.Println(\"Invalid input\")\n        }\n        if x == float64(d) && y == 0 {\n            return count\n        }\n        if x > float64(d) || y > 0 {\n            return -1\n        }\n        count++\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123325,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpjk8xavi5_test.go:49: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpjk8xavi5_test.go:49: expected '%!s(int=0)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpjk8xavi5_test.go:49: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    if len(steps) == 0 {\n        return 0\n    }\n    if len(steps) == 1 {\n        return 1\n    }\n    var (\n        x float64 = 0\n        y float64 = 0\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            x += step.(float64)\n        case string:\n            switch step.(string) {\n            case \"up\":\n                y += 1\n            case \"down\":\n                y -= 1\n            case \"left\":\n                x -= 1\n            case \"right\":\n                x += 1\n            }\n        }\n    }\n    return float64(d) / x\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123325,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmphd9w_lna_test.go:57: expected '%!s(float64=3.5)', got '%!s(float64=1.5714285714285714)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmphd9w_lna_test.go:57: expected '%!s(int=1)', got '%!s(float64=0.44)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var x, y float64\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n    }\n\n    if x == float64(d) {\n        return y\n    }\n\n    if x > float64(d) {\n        return -1\n    }\n\n    return y + 2*(float64(d) - x)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123325,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpeb8_1cp4_test.go:46: expected '%!s(float64=3.5)', got '%!s(float64=8)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpeb8_1cp4_test.go:46: expected '%!s(int=0)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpeb8_1cp4_test.go:46: expected '%!s(int=1)', got '%!s(float64=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        x, y float64\n        count int\n    )\n    for _, step := range steps {\n        switch step.(type) {\n            case int:\n                x += float64(step.(int))\n            case float64:\n                x += step.(float64)\n            case string:\n                if step.(string) == \"D\" {\n                    y -= 1\n                } else {\n                    y += 1\n                }\n        }\n        if x == float64(d) && y == 0 {\n            return float64(count)\n        }\n        count++\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123325,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpws1lmske_test.go:50: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpws1lmske_test.go:50: expected '%!s(int=0)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpws1lmske_test.go:50: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    if len(steps) == 0 {\n        return 0\n    }\n\n    if len(steps) == 1 {\n        return float64(steps[0].(int))\n    }\n\n    var sum float64 = 0\n    for _, step := range steps {\n        sum += float64(step.(int))\n    }\n\n    return sum / float64(d)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123326,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpv34l0e1g_test.go:41: expected '%!s(float64=3.5)', got '%!s(float64=0.6363636363636364)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpv34l0e1g_test.go:41: expected '%!s(int=0)', got '%!s(float64=+Inf)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpv34l0e1g_test.go:41: expected '%!s(int=1)', got '%!s(float64=2.272727272727273)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        sum float64\n        i int\n    )\n    for i = 0; i < len(steps); i++ {\n        sum += steps[i].(float64)\n    }\n    return sum / float64(d)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123326,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\npanic: interface conversion: interface {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523720, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523720, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.min_Jumps(...)\n\t/tmp/tmpg6ptfwyi_test.go:15\ncommand-line-arguments_test.TestMin_Jumps(0xc000001380)\n\t/tmp/tmpg6ptfwyi_test.go:27 +0x4b9\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var n int = len(steps)\n    var i int = 0\n    var j int = 0\n    var k int = 0\n    var count int = 0\n    var result float64 = 0\n    var temp float64 = 0\n    var temp_count int = 0\n    var temp_result float64 = 0\n    var temp_steps []interface{} = make([]interface{}, n)\n    var temp_steps_count int = 0\n    var temp_steps_result float64 = 0\n    var temp_steps_steps []interface{} = make([]interface{}, n)\n    var temp_steps_steps_count int = 0\n    var temp_steps_steps_result float64 = 0\n    var temp_steps_steps_steps []interface{} = make([]interface{}, n)\n    var temp_steps_steps_steps_count int = 0\n    var temp_steps_steps_steps_result float64 = 0\n    var temp_steps_steps_steps_steps []interface{} = make([]interface{}, n)\n    var temp_steps_steps_steps_steps_count int = 0\n    var temp_steps_steps_steps_steps_result float64 = 0\n    var temp_steps_steps_steps_steps_steps []interface{} = make([]interface{}, n)\n    var temp_steps_steps_steps_steps_steps_count int = 0\n    var temp_steps_steps_steps_steps_steps_result float64 = 0\n    var temp_steps_steps_steps_steps_steps_steps []interface{} = make([]interface{}, n)\n    var temp_steps_steps_steps_steps_steps_steps_count int = 0\n    var temp_steps_steps_steps_steps_steps_steps_result float64 = 0\n    var temp_steps_steps_steps_steps_steps_steps_steps []interface{} = make([]interface{}, n)\n    var temp_steps_steps_steps_steps_steps_steps_steps_count int = 0\n    var temp_steps_steps_steps_steps_steps_steps_steps_result float64 = 0\n    var temp_steps_steps_steps_steps_steps_steps_steps_\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123325,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1hr9kl63_test.go:40:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var x, y int\n    var count float64\n    for _, step := range steps {\n        switch step {\n        case \"UP\":\n            y++\n        case \"DOWN\":\n            y--\n        case \"LEFT\":\n            x--\n        case \"RIGHT\":\n            x++\n        }\n        if x == d || y == d {\n            return count + 1\n        }\n        count++\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123326,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpy7t0x_fy_test.go:47: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpy7t0x_fy_test.go:47: expected '%!s(int=0)', got '%!s(float64=1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpy7t0x_fy_test.go:47: expected '%!s(int=1)', got '%!s(float64=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n    )\n    for i = 0; i < len(steps); i++ {\n        switch steps[i].(type) {\n        case int:\n            j = steps[i].(int)\n            if j == 0 {\n                return 0\n            }\n            if j < d {\n                k++\n            }\n        case float64:\n            l = int(steps[i].(float64))\n            if l == 0 {\n                return 0\n            }\n            if l < d {\n                m++\n            }\n        case string:\n            n = len(steps[i].(string))\n            if n == 0 {\n                return 0\n            }\n            if n < d {\n                o++\n            }\n        case []int:\n            p = len(steps[i].([]int))\n            if p == 0 {\n                return 0\n            }\n            if p < d {\n                q++\n            }\n        case []float64:\n            r = len(steps[i].([]float64))\n            if r == 0 {\n                return 0\n            }\n            if r < d {\n                s++\n            }\n        case []string:\n            t = len(steps[i].([]string))\n            if t == 0 {\n                return 0\n            }\n            if t < d {\n                u++\n            }\n        case [][]int:\n            v = len(steps[i].([][]int))\n            if v == 0 {\n                return 0\n            }\n            if v < d {\n                w++\n            }\n        case [][]float64:\n            x = len(steps[i].([][]float64))\n            if x == 0 {\n                return 0\n            }\n            if x < d {\n                y++\n            }\n        case [][]string:\n            z = len(steps[i].\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123325,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp03j1tpyk_test.go:98:1: expected selector or type assertion, found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var x, y, count float64\n    for _, step := range steps {\n        switch step {\n            case \"up\":\n                y++\n            case \"down\":\n                y--\n            case \"left\":\n                x--\n            case \"right\":\n                x++\n        }\n        if x == d || y == d {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123301,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu9dkry4l_test.go:22:14: invalid operation: x == d (mismatched types float64 and int)\n/tmp/tmpu9dkry4l_test.go:22:24: invalid operation: y == d (mismatched types float64 and int)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var jump_count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            jump_count++\n            x = 0\n        }\n        if y == 0 {\n            jump_count++\n            y = 0\n        }\n    }\n    return jump_count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123326,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmppmz7bvcv_test.go:47: expected '%!s(float64=3.5)', got '%!s(float64=2)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmppmz7bvcv_test.go:47: expected '%!s(int=0)', got '%!s(float64=2)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmppmz7bvcv_test.go:47: expected '%!s(int=1)', got '%!s(float64=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var count int\n    var x, y int\n    for _, v := range steps {\n        switch v.(type) {\n        case int:\n            x += v.(int)\n        case string:\n            y += 1\n        }\n        if x == d {\n            count += 1\n            x = 0\n        }\n        if y == d {\n            count += 1\n            y = 0\n        }\n    }\n    return float64(count)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123326,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp7ee6l_zh_test.go:47: expected '%!s(float64=3.5)', got '%!s(float64=0)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmp7ee6l_zh_test.go:47: expected '%!s(int=0)', got '%!s(float64=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, v := range steps {\n        switch v.(type) {\n        case int:\n            x += float64(v.(int))\n        case float64:\n            y += float64(v.(float64))\n        }\n        if x == float64(d) {\n            return count\n        }\n        count++\n    }\n    return count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123326,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpnz9x5zep_test.go:44: expected '%!s(float64=3.5)', got '%!s(float64=2)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpnz9x5zep_test.go:44: expected '%!s(int=0)', got '%!s(float64=2)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpnz9x5zep_test.go:44: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var x, y, count float64\n    x = 0\n    y = 0\n    count = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case string:\n            y += float64(step.(string))\n        }\n        if x == d {\n            return count\n        }\n        if x > d {\n            return -1\n        }\n        count += 1\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123326,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp38h3orsn_test.go:20:25: cannot convert step.(string) (type string) to type float64\n/tmp/tmp38h3orsn_test.go:22:14: invalid operation: x == d (mismatched types float64 and int)\n/tmp/tmp38h3orsn_test.go:25:14: invalid operation: x > d (mismatched types float64 and int)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var (\n        x, y float64\n        count int\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case string:\n            switch step {\n            case \"up\":\n                y++\n            case \"down\":\n                y--\n            case \"left\":\n                x--\n            case \"right\":\n                x++\n            }\n        case int:\n            count += step.(int)\n        }\n        if x == float64(d) && y == 0 {\n            return float64(count)\n        }\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123326,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp9r1afkts_test.go:53: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmp9r1afkts_test.go:53: expected '%!s(int=0)', got '%!s(float64=3)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmp9r1afkts_test.go:53: expected '%!s(int=1)', got '%!s(float64=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var a, b, c, dp float64\n    dp = 1\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            a = float64(step.(int))\n        case float64:\n            a = step.(float64)\n        default:\n            a = 0\n        }\n        b = a * dp\n        c = b + dp\n        dp = c\n    }\n    return dp\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123326,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpt8gos6br_test.go:43: expected '%!s(float64=3.5)', got '%!s(float64=20)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpt8gos6br_test.go:43: expected '%!s(int=0)', got '%!s(float64=20)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpt8gos6br_test.go:43: expected '%!s(int=1)', got '%!s(float64=180)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        x, y float64\n        count int\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            x += step.(float64)\n        }\n        if x >= float64(d) {\n            break\n        }\n        count++\n    }\n    return float64(count)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123326,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmq4nx67a_test.go:11:12: y declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        n int = len(steps)\n        i int = 0\n        j int = 0\n        k int = 0\n        l int = 0\n        m int = 0\n        x int = 0\n        y int = 0\n        z int = 0\n        a int = 0\n        b int = 0\n        c int = 0\n        d1 int = 0\n        e int = 0\n        f int = 0\n        g int = 0\n        h int = 0\n        i1 int = 0\n        j1 int = 0\n        k1 int = 0\n        l1 int = 0\n        m1 int = 0\n        n1 int = 0\n        o int = 0\n        p int = 0\n        q int = 0\n        r int = 0\n        s int = 0\n        t int = 0\n        u int = 0\n        v int = 0\n        w int = 0\n        x1 int = 0\n        y1 int = 0\n        z1 int = 0\n        a1 int = 0\n        b1 int = 0\n        c1 int = 0\n        d2 int = 0\n        e1 int = 0\n        f1 int = 0\n        g1 int = 0\n        h1 int = 0\n        i2 int = 0\n        j2 int = 0\n        k2 int = 0\n        l2 int = 0\n        m2 int = 0\n        n2 int = 0\n        o1 int = 0\n        p1 int = 0\n        q1 int = 0\n        r1 int = 0\n        s1 int = 0\n        t1 int = 0\n        u1 int = 0\n        v1 int = 0\n        w1 int = 0\n        x2 int = 0\n        y2 int = 0\n        z2 int = 0\n        a2 int = 0\n        b2 int = 0\n        c2 int = 0\n        d3 int = 0\n        e2 int = 0\n        f2 int = 0\n        g2 int = 0\n        h2 int = 0\n        i3 int = 0\n        j3 int = 0\n        k3 int = 0\n        l3 int = 0\n        m3 int = 0\n        n3 int = 0\n        o2 int\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123326,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpghnh9eh__test.go:87:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        x, y float64\n        count int\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            x += step.(float64)\n        case string:\n            if step.(string) == \"D\" {\n                y -= 1\n            } else {\n                y += 1\n            }\n        }\n        if x == float64(d) && y == 0 {\n            return float64(count)\n        }\n        count++\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123327,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp_dy4g7nc_test.go:50: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmp_dy4g7nc_test.go:50: expected '%!s(int=0)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmp_dy4g7nc_test.go:50: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var count int = 0\n    var x int = 0\n    var y int = 0\n    for _, step := range steps {\n        switch step {\n            case \"up\":\n                x++\n            case \"down\":\n                x--\n            case \"left\":\n                y--\n            case \"right\":\n                y++\n        }\n        if x == d || y == d {\n            count++\n        }\n    }\n    return float64(count)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123327,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpw4o550gs_test.go:47: expected '%!s(float64=3.5)', got '%!s(float64=0)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpw4o550gs_test.go:47: expected '%!s(int=0)', got '%!s(float64=2)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpw4o550gs_test.go:47: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    if len(steps) == 0 {\n        return 0\n    }\n    if len(steps) == 1 {\n        return 1\n    }\n    var x float64 = 0\n    var y float64 = 0\n    var jumps float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            x += step.(float64)\n        case string:\n            if step.(string) == \"D\" {\n                y -= 1\n            } else {\n                y += 1\n            }\n        }\n        if x == float64(d) && y == 0 {\n            jumps += 1\n            x = 0\n            y = 0\n        }\n    }\n    if x != 0 || y != 0 {\n        jumps += 1\n    }\n    return jumps\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123327,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpje3shrxc_test.go:59: expected '%!s(float64=3.5)', got '%!s(float64=1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpje3shrxc_test.go:59: expected '%!s(int=0)', got '%!s(float64=1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpje3shrxc_test.go:59: expected '%!s(int=1)', got '%!s(float64=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var count int\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            count += step.(int)\n        case float64:\n            count += int(step.(float64))\n        }\n    }\n    return float64(count) / float64(d)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123327,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpr_42asqz_test.go:37: expected '%!s(float64=3.5)', got '%!s(float64=0.6363636363636364)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpr_42asqz_test.go:37: expected '%!s(int=0)', got '%!s(float64=+Inf)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpr_42asqz_test.go:37: expected '%!s(int=1)', got '%!s(float64=2.272727272727273)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        i, j, k, l int\n        m, n, o, p float64\n        q, r, s, t float64\n        u, v, w, x float64\n        y, z, aa, ab float64\n        ac, ad, ae, af float64\n        ag, ah, ai, aj float64\n        ak, al, am, an float64\n        ao, ap, aq, ar float64\n        as, at, au, av float64\n        aw, ax, ay, az float64\n        ba, bb, bc, bd float64\n        be, bf, bg, bh float64\n        bi, bj, bk, bl float64\n        bm, bn, bo, bp float64\n        bq, br, bs, bt float64\n        bu, bv, bw, bx float64\n        by, bz, ca, cb float64\n        cc, cd, ce, cf float64\n        cg, ch, ci, cj float64\n        ck, cl, cm, cn float64\n        co, cp, cq, cr float64\n        cs, ct, cu, cv float64\n        cw, cx, cy, cz float64\n        da, db, dc, dd float64\n        de, df, dg, dh float64\n        di, dj, dk, dl float64\n        dm, dn, do, dp float64\n        dq, dr, ds, dt float64\n        du, dv, dw, dx float64\n        dy, dz, ea, eb float64\n        ec, ed, ee, ef float64\n        eg, eh, ei, ej float64\n        ek, el, em, en float64\n        eo, ep, eq, er float64\n        es, et, eu, ev float64\n        ew, ex, ey, ez float64\n        fa, fb, fc, fd float64\n        fe, ff, fg, fh float64\n        fi, fj, fk, fl float64\n        fm, fn, fo\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123326,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpe9m8xg3m_test.go:51:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var x, y float64 = 0, 0\n    var count float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            return count + y\n        }\n        if x > float64(d) {\n            return -1\n        }\n        count++\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123327,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpid5gdpyd_test.go:45: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpid5gdpyd_test.go:45: expected '%!s(int=0)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpid5gdpyd_test.go:45: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        n int = len(steps)\n        i int = 0\n        j int = 0\n        k int = 0\n        x int = 0\n        y int = 0\n        z int = 0\n        a int = 0\n        b int = 0\n        c int = 0\n        m int = 0\n        n int = 0\n        o int = 0\n        p int = 0\n        q int = 0\n        r int = 0\n        s int = 0\n        t int = 0\n        u int = 0\n        v int = 0\n        w int = 0\n        x int = 0\n        y int = 0\n        z int = 0\n    )\n    for i = 0; i < n; i++ {\n        switch steps[i].(type) {\n        case int:\n            x = steps[i].(int)\n        case float64:\n            x = int(steps[i].(float64))\n        }\n        for j = i + 1; j < n; j++ {\n            switch steps[j].(type) {\n            case int:\n                y = steps[j].(int)\n            case float64:\n                y = int(steps[j].(float64))\n            }\n            for k = j + 1; k < n; k++ {\n                switch steps[k].(type) {\n                case int:\n                    z = steps[k].(int)\n                case float64:\n                    z = int(steps[k].(float64))\n                }\n                if x + y + z == d {\n                    a++\n                }\n                if x + y - z == d {\n                    b++\n                }\n                if x - y + z == d {\n                    c++\n                }\n                if x - y - z == d {\n                    m++\n                }\n                if -x + y + z == d {\n                    n++\n                }\n                if -x + y - z == d {\n                    o++\n                }\n                if -x - y + z == d {\n                    p++\n                }\n                if -x - y - z == d {\n                    q++\n                }\n                if x + y * z == d {\n                    r\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123326,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0ppmn86w_test.go:83:6: expected '(', found TestMin_Jumps\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        i, j, k int\n        n, m, l int\n        x, y, z float64\n        a, b, c float64\n        d1, d2, d3 float64\n        min float64\n        min_i, min_j, min_k int\n    )\n    n = len(steps)\n    if n == 0 {\n        return 0\n    }\n    m = len(steps[0].([]interface{}))\n    if m == 0 {\n        return 0\n    }\n    l = len(steps[0].([]interface{})[0].([]interface{}))\n    if l == 0 {\n        return 0\n    }\n    min = float64(d)\n    for i = 0; i < n; i++ {\n        for j = 0; j < m; j++ {\n            for k = 0; k < l; k++ {\n                a = steps[i].([]interface{})[j].([]interface{})[k].(float64)\n                b = float64(i)\n                c = float64(j)\n                d1 = a - b\n                d2 = a - c\n                d3 = a - float64(k)\n                if d1 < 0 {\n                    d1 = -d1\n                }\n                if d2 < 0 {\n                    d2 = -d2\n                }\n                if d3 < 0 {\n                    d3 = -d3\n                }\n                x = d1 + d2 + d3\n                if x < min {\n                    min = x\n                    min_i = i\n                    min_j = j\n                    min_k = k\n                }\n            }\n        }\n    }\n    fmt.Println(min_i, min_j, min_k)\n    return min\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123327,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuco633iw_test.go:13:12: y declared but not used\n/tmp/tmpuco633iw_test.go:13:15: z declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        x, y int\n        count int\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += step.(int)\n        case string:\n            y += step.(string)\n        }\n        if x == d {\n            return float64(count)\n        }\n        if y == 0 {\n            return float64(count)\n        }\n        count++\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123327,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0i35zn50_test.go:19:15: invalid operation: y += step.(string) (mismatched types int and string)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var x, y, count float64\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y++\n        case \"down\":\n            y--\n        case \"left\":\n            x--\n        case \"right\":\n            x++\n        }\n        count++\n        if x == float64(d) || y == float64(d) {\n            break\n        }\n    }\n    return count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123327,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmplp56vur6_test.go:46: expected '%!s(float64=3.5)', got '%!s(float64=2)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmplp56vur6_test.go:46: expected '%!s(int=0)', got '%!s(float64=1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmplp56vur6_test.go:46: expected '%!s(int=1)', got '%!s(float64=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var count int\n    var x, y int\n    for _, step := range steps {\n        switch step {\n        case \"UP\":\n            y += 1\n        case \"DOWN\":\n            y -= 1\n        case \"LEFT\":\n            x -= 1\n        case \"RIGHT\":\n            x += 1\n        }\n        if x == d && y == 0 {\n            return float64(count)\n        }\n        count += 1\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123327,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpv4iock7o_test.go:47: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpv4iock7o_test.go:47: expected '%!s(int=1)', got '%!s(float64=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var x, y float64\n    x = 0\n    y = 0\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y += 1\n        case \"down\":\n            y -= 1\n        case \"left\":\n            x -= 1\n        case \"right\":\n            x += 1\n        }\n    }\n    return (x*x + y*y) / (2*d)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123327,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfvj9sn8b_test.go:26:24: invalid operation: (x * x + y * y) / (2 * d) (mismatched types float64 and int)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        n int = len(steps)\n        i int\n        j int\n        k int\n        l int\n        m int\n        nn int\n        mm int\n        nnn int\n        mmm int\n        x int\n        y int\n        z int\n        a int\n        b int\n        c int\n        dp [][][]float64\n        dp2 [][][]float64\n        dp3 [][][]float64\n        dp4 [][][]float64\n        dp5 [][][]float64\n        dp6 [][][]float64\n        dp7 [][][]float64\n        dp8 [][][]float64\n        dp9 [][][]float64\n        dp10 [][][]float64\n        dp11 [][][]float64\n        dp12 [][][]float64\n        dp13 [][][]float64\n        dp14 [][][]float64\n        dp15 [][][]float64\n        dp16 [][][]float64\n        dp17 [][][]float64\n        dp18 [][][]float64\n        dp19 [][][]float64\n        dp20 [][][]float64\n        dp21 [][][]float64\n        dp22 [][][]float64\n        dp23 [][][]float64\n        dp24 [][][]float64\n        dp25 [][][]float64\n        dp26 [][][]float64\n        dp27 [][][]float64\n        dp28 [][][]float64\n        dp29 [][][]float64\n        dp30 [][][]float64\n        dp31 [][][]float64\n        dp32 [][][]float64\n        dp33 [][][]float64\n        dp34 [][][]float64\n        dp35 [][][]float64\n        dp36 [][][]float64\n        dp37 [][][]float64\n        dp38 [][][]float64\n        dp39 [][][]float64\n        dp40 [][][\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123327,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptgc59muk_test.go:67:6: expected '(', found TestMin_Jumps\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var x, y, count float64 = 0, 0, 0\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y++\n        case \"down\":\n            y--\n        case \"left\":\n            x--\n        case \"right\":\n            x++\n        }\n        if x == d || y == d {\n            count++\n            x, y = 0, 0\n        }\n    }\n    return count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123327,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmt0a5vri_test.go:22:14: invalid operation: x == d (mismatched types float64 and int)\n/tmp/tmpmt0a5vri_test.go:22:24: invalid operation: y == d (mismatched types float64 and int)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var x, y float64 = 0, 0\n    var count float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            return count + y\n        }\n        if x > float64(d) {\n            return -1\n        }\n        count += 1\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123328,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp4y123303_test.go:45: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmp4y123303_test.go:45: expected '%!s(int=0)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmp4y123303_test.go:45: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        i int\n        j float64\n        k int\n    )\n    for i = 0; i < len(steps); i++ {\n        switch steps[i].(type) {\n            case int:\n                j += float64(steps[i].(int))\n            case float64:\n                j += steps[i].(float64)\n        }\n        if j >= float64(d) {\n            break\n        }\n    }\n    k = i + 1\n    return float64(k)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123328,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp805rn7s0_test.go:45: expected '%!s(float64=3.5)', got '%!s(float64=3)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmp805rn7s0_test.go:45: expected '%!s(int=0)', got '%!s(float64=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    if len(steps) == 0 {\n        return 0\n    }\n    if len(steps) == 1 {\n        return 1\n    }\n    var jumps float64\n    var curr float64\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            curr += float64(step.(int))\n        case float64:\n            curr += step.(float64)\n        }\n        if curr == float64(d) {\n            jumps++\n            break\n        } else if curr > float64(d) {\n            jumps++\n            break\n        }\n    }\n    return jumps\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123328,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp5gzub7qc_test.go:51: expected '%!s(float64=3.5)', got '%!s(float64=0)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmp5gzub7qc_test.go:51: expected '%!s(int=0)', got '%!s(float64=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var x, y, x_, y_ float64\n    x = 0\n    y = 0\n    for _, v := range steps {\n        switch v.(type) {\n        case string:\n            switch v.(string) {\n            case \"N\":\n                x_ = 0\n                y_ = 1\n            case \"S\":\n                x_ = 0\n                y_ = -1\n            case \"E\":\n                x_ = 1\n                y_ = 0\n            case \"W\":\n                x_ = -1\n                y_ = 0\n            }\n        case int:\n            x_ = float64(v.(int))\n            y_ = 0\n        }\n        x += x_\n        y += y_\n    }\n    if x == float64(d) {\n        return y\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123328,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmptpch76gc_test.go:58: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmptpch76gc_test.go:58: expected '%!s(int=0)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmptpch76gc_test.go:58: expected '%!s(int=1)', got '%!s(float64=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            return count\n        }\n        if x > float64(d) {\n            return -1\n        }\n        if y == 0 {\n            count++\n        }\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123328,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpq8se8zsf_test.go:48: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpq8se8zsf_test.go:48: expected '%!s(int=0)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpq8se8zsf_test.go:48: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        n int\n        x, y int\n        x_, y_ int\n        x_min, x_max, y_min, y_max int\n        x_min_, x_max_, y_min_, y_max_ int\n        x_min_max, x_max_min, y_min_max, y_max_min int\n        x_min_max_, x_max_min_, y_min_max_, y_max_min_ int\n        x_min_max__, x_max_min__, y_min_max__, y_max_min__ int\n        x_min_max___, x_max_min___, y_min_max___, y_max_min___ int\n        x_min_max____, x_max_min____, y_min_max____, y_max_min____ int\n        x_min_max_____, x_max_min_____, y_min_max_____, y_max_min_____ int\n        x_min_max______, x_max_min______, y_min_max______, y_max_min______ int\n        x_min_max_______, x_max_min_______, y_min_max_______, y_max_min_______ int\n        x_min_max________, x_max_min________, y_min_max________, y_max_min________ int\n        x_min_max_________, x_max_min_________, y_min_max_________, y_max_min_________ int\n        x_min_max__________, x_max_min__________, y_min_max__________, y_max_min__________ int\n        x_min_max___________, x_max_min___________, y_min_max___________, y_max_min___________ int\n        x_min_max____________, x_max_min____________, y_min_max____________, y_max_min____________ int\n        x_min_max_____________, x_max_min_____________, y_min_max_____________, y_max_min_____________ int\n        x_min_max______________, x_max_\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123327,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp80rr7ts3_test.go:30:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    if len(steps) == 0 {\n        return 0\n    }\n    var sum float64 = 0\n    for _, v := range steps {\n        switch v.(type) {\n        case int:\n            sum += float64(v.(int))\n        case float64:\n            sum += v.(float64)\n        default:\n            fmt.Println(\"error\")\n        }\n    }\n    return (float64(d) - sum) / float64(len(steps))\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123328,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmptdtkixys_test.go:42: expected '%!s(float64=3.5)', got '%!s(float64=2)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmptdtkixys_test.go:42: expected '%!s(int=0)', got '%!s(float64=-3.5)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmptdtkixys_test.go:42: expected '%!s(int=1)', got '%!s(float64=-7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        x, y float64\n        count int\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            x += step.(float64)\n        case string:\n            if step.(string) == \"D\" {\n                y -= 1\n            } else if step.(string) == \"U\" {\n                y += 1\n            }\n        }\n        if x == float64(d) && y == 0 {\n            return float64(count)\n        }\n        count++\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123328,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpri7cymah_test.go:50: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpri7cymah_test.go:50: expected '%!s(int=0)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpri7cymah_test.go:50: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var x, y float64\n    x, y = 0, 0\n    for _, step := range steps {\n        switch step {\n        case \"N\":\n            y++\n        case \"S\":\n            y--\n        case \"E\":\n            x++\n        case \"W\":\n            x--\n        }\n    }\n    if x == 0 && y == 0 {\n        return 0\n    }\n    if x == 0 || y == 0 {\n        return 1\n    }\n    return 2\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123328,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmppqtr890r_test.go:48: expected '%!s(float64=3.5)', got '%!s(float64=0)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmppqtr890r_test.go:48: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    if len(steps) == 0 {\n        return 0\n    }\n    var sum float64 = 0\n    for _, v := range steps {\n        sum += v.(float64)\n    }\n    return sum / float64(d)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123315,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\npanic: interface conversion: interface {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523720, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523720, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.min_Jumps(0xc0000926d0, 0x2, 0x2, 0xb, 0xf)\n\t/tmp/tmpw4z0nxh0_test.go:15 +0xa8\ncommand-line-arguments_test.TestMin_Jumps(0xc000001380)\n\t/tmp/tmpw4z0nxh0_test.go:27 +0xb1\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        n = len(steps)\n        i = 0\n        j = 0\n        k = 0\n        x = 0\n        y = 0\n        z = 0\n        m = 0\n        a = 0\n        b = 0\n        c = 0\n        l = 0\n        s = 0\n        t = 0\n        u = 0\n        v = 0\n        w = 0\n        x1 = 0\n        y1 = 0\n        z1 = 0\n        m1 = 0\n        a1 = 0\n        b1 = 0\n        c1 = 0\n        l1 = 0\n        s1 = 0\n        t1 = 0\n        u1 = 0\n        v1 = 0\n        w1 = 0\n        x2 = 0\n        y2 = 0\n        z2 = 0\n        m2 = 0\n        a2 = 0\n        b2 = 0\n        c2 = 0\n        l2 = 0\n        s2 = 0\n        t2 = 0\n        u2 = 0\n        v2 = 0\n        w2 = 0\n        x3 = 0\n        y3 = 0\n        z3 = 0\n        m3 = 0\n        a3 = 0\n        b3 = 0\n        c3 = 0\n        l3 = 0\n        s3 = 0\n        t3 = 0\n        u3 = 0\n        v3 = 0\n        w3 = 0\n        x4 = 0\n        y4 = 0\n        z4 = 0\n        m4 = 0\n        a4 = 0\n        b4 = 0\n        c4 = 0\n        l4 = 0\n        s4 = 0\n        t4 = 0\n        u4 = 0\n        v4 = 0\n        w4 = 0\n        x5 = 0\n        y5 = 0\n        z5 = 0\n        m5 = 0\n        a5 = 0\n        b5 = 0\n        c5 = 0\n        l5 = 0\n        s5 = 0\n        t5 = 0\n        u5 = 0\n        v5 = 0\n        w5 = 0\n        x6 = 0\n        y6 = 0\n        z6 = 0\n        m6 = 0\n        a6 = 0\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123327,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpdrwmqbk0_test.go:98:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        i, j int\n        n int = len(steps)\n        m int = len(steps[0].([]int))\n        dp [][]float64 = make([][]float64, n)\n        step int\n        res float64\n    )\n    for i = 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n        for j = 0; j < m; j++ {\n            dp[i][j] = -1\n        }\n    }\n    dp[0][0] = 0\n    for i = 0; i < n; i++ {\n        for j = 0; j < m; j++ {\n            if dp[i][j] == -1 {\n                continue\n            }\n            step = steps[i].([]int)[j]\n            if i + step < n {\n                if dp[i + step][j] == -1 || dp[i + step][j] > dp[i][j] + 1 {\n                    dp[i + step][j] = dp[i][j] + 1\n                }\n            }\n            if j + step < m {\n                if dp[i][j + step] == -1 || dp[i][j + step] > dp[i][j] + 1 {\n                    dp[i][j + step] = dp[i][j] + 1\n                }\n            }\n        }\n    }\n    res = dp[n - 1][m - 1]\n    return res\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123328,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\npanic: interface conversion: interface {} is int, not []int [recovered]\n\tpanic: interface conversion: interface {} is int, not []int\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523720, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523720, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.min_Jumps(0xc00008c6d0, 0x2, 0x2, 0xb, 0xf)\n\t/tmp/tmpitc7te2l_test.go:13 +0x37f\ncommand-line-arguments_test.TestMin_Jumps(0xc000102600)\n\t/tmp/tmpitc7te2l_test.go:54 +0xb1\ntesting.tRunner(0xc000102600, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        x, y float64\n        count int\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case string:\n            if step == \"D\" {\n                y -= 1\n            } else {\n                y += 1\n            }\n        case int:\n            x += float64(step.(int))\n        }\n        if x == float64(d) {\n            return float64(count)\n        }\n        if x > float64(d) {\n            return -1\n        }\n        count++\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123329,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpbtp2d49q_test.go:51: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpbtp2d49q_test.go:51: expected '%!s(int=0)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpbtp2d49q_test.go:51: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        i, j int\n        x, y float64\n        n float64 = float64(len(steps))\n    )\n    for i = 0; i < len(steps); i++ {\n        switch steps[i].(type) {\n        case int:\n            x += float64(steps[i].(int))\n        case float64:\n            x += steps[i].(float64)\n        }\n    }\n    y = n - x\n    if x > y {\n        x, y = y, x\n    }\n    if x == 0 {\n        return float64(d) / y\n    }\n    for i = 1; i <= int(x); i++ {\n        if (y * float64(i)) % x == 0 {\n            j = i\n        }\n    }\n    return float64(d) / float64(j)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123329,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6m9g6er1_test.go:31:29: invalid operation: y * float64(i) % x (operator % not defined on float64)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var x, y int = 0, 0\n    var count float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += step.(int)\n        case string:\n            y += step.(string)\n        }\n        if x == d {\n            return count\n        }\n        if y == 0 {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123329,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0pxxbgzs_test.go:17:15: invalid operation: y += step.(string) (mismatched types int and string)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y++\n        case \"down\":\n            y--\n        case \"left\":\n            x--\n        case \"right\":\n            x++\n        }\n        if x == float64(d) || y == float64(d) {\n            count++\n            x = 0\n            y = 0\n        }\n    }\n    return count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123329,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpn89d7j5l_test.go:49: expected '%!s(float64=3.5)', got '%!s(float64=0)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpn89d7j5l_test.go:49: expected '%!s(int=0)', got '%!s(float64=2)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpn89d7j5l_test.go:49: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n        a int\n        b int\n        c int\n        d int\n        e int\n        f int\n        g int\n        h int\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n        a int\n        b int\n        c int\n        d int\n        e int\n        f int\n        g int\n        h int\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n        a int\n        b int\n        c int\n        d int\n        e int\n        f int\n        g int\n        h int\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n        a int\n        b int\n        c int\n        d int\n        e int\n        f int\n        g int\n        h int\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n        a int\n        b int\n        c int\n        d int\n        e int\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510492,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5dnnkpeb_test.go:138:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var count float64 = 0\n    var x, y float64 = 0, 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            x += step.(float64)\n        case string:\n            if step.(string) == \"D\" {\n                y -= 1\n            } else {\n                y += 1\n            }\n        }\n        if x == float64(d) {\n            return count + 1\n        }\n        if x > float64(d) {\n            return -1\n        }\n        count += 1\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123329,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp1majlaqs_test.go:51: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmp1majlaqs_test.go:51: expected '%!s(int=0)', got '%!s(float64=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    if len(steps) == 0 {\n        return 0\n    }\n    var (\n        x float64 = 0\n        y float64 = 0\n        count float64 = 0\n    )\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            x += step.(float64)\n        case string:\n            if step.(string) == \"D\" {\n                y -= 1\n            } else if step.(string) == \"U\" {\n                y += 1\n            }\n        }\n        if x == float64(d) && y == 0 {\n            count += 1\n        }\n    }\n    return count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123329,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpp4s7dsh__test.go:53: expected '%!s(float64=3.5)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    if len(steps) == 0 {\n        return 0\n    }\n    if len(steps) == 1 {\n        return 1\n    }\n    var sum float64 = 0\n    for _, step := range steps {\n        sum += step.(float64)\n    }\n    return sum / float64(d)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123329,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\npanic: interface conversion: interface {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface {} is int, not float64\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523720, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523720, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.min_Jumps(0xc00008c6d0, 0x2, 0x2, 0xb, 0xf)\n\t/tmp/tmp14flff0x_test.go:18 +0xcb\ncommand-line-arguments_test.TestMin_Jumps(0xc000102600)\n\t/tmp/tmp14flff0x_test.go:30 +0xb1\ntesting.tRunner(0xc000102600, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var x float64 = 0\n    var y float64 = 0\n    var jumps float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            return jumps + y\n        }\n        if x > float64(d) {\n            return -1\n        }\n        if y == 0 {\n            jumps++\n        }\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123329,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpqti7c_h1_test.go:48: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpqti7c_h1_test.go:48: expected '%!s(int=0)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpqti7c_h1_test.go:48: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            return count\n        }\n        if x > float64(d) {\n            return -1\n        }\n        count++\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123329,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp4eh8yls3_test.go:46: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmp4eh8yls3_test.go:46: expected '%!s(int=0)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmp4eh8yls3_test.go:46: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var result float64\n    var x, y float64\n    for _, v := range steps {\n        switch v.(type) {\n            case int:\n                x += float64(v.(int))\n            case float64:\n                y += v.(float64)\n        }\n        if x > d {\n            x = d\n        }\n        if y > d {\n            y = d\n        }\n        if x == d && y == d {\n            return result\n        }\n        result += 1\n    }\n    return result\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123329,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0q__embw_test.go:20:14: invalid operation: x > d (mismatched types float64 and int)\n/tmp/tmp0q__embw_test.go:21:15: cannot use d (type int) as type float64 in assignment\n/tmp/tmp0q__embw_test.go:23:14: invalid operation: y > d (mismatched types float64 and int)\n/tmp/tmp0q__embw_test.go:24:15: cannot use d (type int) as type float64 in assignment\n/tmp/tmp0q__embw_test.go:26:14: invalid operation: x == d (mismatched types float64 and int)\n/tmp/tmp0q__embw_test.go:26:24: invalid operation: y == d (mismatched types float64 and int)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        x, y, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6, x7, y7, x8, y8, x9, y9, x10, y10, x11, y11, x12, y12, x13, y13, x14, y14, x15, y15, x16, y16, x17, y17, x18, y18, x19, y19, x20, y20, x21, y21, x22, y22, x23, y23, x24, y24, x25, y25, x26, y26, x27, y27, x28, y28, x29, y29, x30, y30, x31, y31, x32, y32, x33, y33, x34, y34, x35, y35, x36, y36, x37, y37, x38, y38, x39, y39, x40, y40, x41, y41, x42, y42, x43, y43, x44, y44, x45, y45, x46, y46, x47, y47, x48, y48, x49, y49, x50, y50, x51, y51, x52, y52, x53, y53, x54, y54, x55, y55, x56, y56, x57, y57, x58, y58, x59, y59, x60, y60, x61, y61, x62, y62, x63, y63, x64, y64, x65, y65, x66, y66, x67, y67, x68, y68, x69, y69, x70, y70, x71, y71, x72, y72, x73, y73, x74, y74, x75, y75, x76, y76, x77, y77, x78, y78, x79, y\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123329,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptu08mfqw_test.go:11:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        n int = len(steps)\n        i int = 0\n        j int = 0\n        k int = 0\n        x int = 0\n        y int = 0\n        z int = 0\n        a int = 0\n        b int = 0\n        c int = 0\n        m int = 0\n        n int = 0\n        o int = 0\n        p int = 0\n        q int = 0\n        r int = 0\n        s int = 0\n        t int = 0\n        u int = 0\n        v int = 0\n        w int = 0\n        x int = 0\n        y int = 0\n        z int = 0\n        a int = 0\n        b int = 0\n        c int = 0\n        m int = 0\n        n int = 0\n        o int = 0\n        p int = 0\n        q int = 0\n        r int = 0\n        s int = 0\n        t int = 0\n        u int = 0\n        v int = 0\n        w int = 0\n        x int = 0\n        y int = 0\n        z int = 0\n        a int = 0\n        b int = 0\n        c int = 0\n        m int = 0\n        n int = 0\n        o int = 0\n        p int = 0\n        q int = 0\n        r int = 0\n        s int = 0\n        t int = 0\n        u int = 0\n        v int = 0\n        w int = 0\n        x int = 0\n        y int = 0\n        z int = 0\n        a int = 0\n        b int = 0\n        c int = 0\n        m int = 0\n        n int = 0\n        o int = 0\n        p int = 0\n        q int = 0\n        r int = 0\n        s int = 0\n        t int = 0\n        u int = 0\n        v int = 0\n        w int = 0\n        x int = 0\n        y int = 0\n        z int = 0\n        a int = 0\n        b int = 0\n        c int = 0\n        m int = 0\n        n int = 0\n        o int = 0\n        p int = 0\n        q int = 0\n        r int = 0\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123329,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpy_b5u1hb_test.go:96:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        n int = len(steps)\n        i int\n        j float64\n    )\n    for i = 0; i < n; i++ {\n        j += steps[i].(float64)\n        if j >= float64(d) {\n            break\n        }\n    }\n    return float64(i)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123330,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\npanic: interface conversion: interface {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x523720, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523720, 0xc0000102d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.min_Jumps(...)\n\t/tmp/tmpaa80qxgj_test.go:16\ncommand-line-arguments_test.TestMin_Jumps(0xc000001380)\n\t/tmp/tmpaa80qxgj_test.go:31 +0x4d3\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var x, y int\n    var count int\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += step.(int)\n        case string:\n            y += 1\n        }\n        if x == d {\n            return float64(count + y)\n        }\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123330,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpn0gvyi65_test.go:42: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpn0gvyi65_test.go:42: expected '%!s(int=0)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpn0gvyi65_test.go:42: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var x, y float64 = 0, 0\n    var x_max, y_max float64 = 0, 0\n    var x_min, y_min float64 = 0, 0\n    var x_count, y_count float64 = 0, 0\n    var x_count_max, y_count_max float64 = 0, 0\n    var x_count_min, y_count_min float64 = 0, 0\n    var x_count_max_max, y_count_max_max float64 = 0, 0\n    var x_count_min_min, y_count_min_min float64 = 0, 0\n    var x_count_max_min, y_count_max_min float64 = 0, 0\n    var x_count_min_max, y_count_min_max float64 = 0, 0\n    var x_count_max_max_max, y_count_max_max_max float64 = 0, 0\n    var x_count_min_min_min, y_count_min_min_min float64 = 0, 0\n    var x_count_max_min_min, y_count_max_min_min float64 = 0, 0\n    var x_count_min_max_max, y_count_min_max_max float64 = 0, 0\n    var x_count_max_max_min, y_count_max_max_min float64 = 0, 0\n    var x_count_min_min_max, y_count_min_min_max float64 = 0, 0\n    var x_count_max_min_max, y_count_max_min_max float64 = 0, 0\n    var x_count_min_max_min, y_count_min_max_min float64 = 0, 0\n    var x_count_max_max_max_max, y_count_max_max_max_max float64 = 0, 0\n    var x_count_min_min_min_min, y_count_min_min_min_min float64 = 0, 0\n    var x_count_max_min_min_min, y_count_max_min_min_min float64\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123329,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpejy562mn_test.go:31:6: expected '(', found TestMin_Jumps\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        n int = len(steps)\n        i int = 0\n        j int = 0\n        k int = 0\n        x int = 0\n        y int = 0\n        z int = 0\n        a int = 0\n        b int = 0\n        c int = 0\n        m int = 0\n        s int = 0\n        t int = 0\n        u int = 0\n        v int = 0\n        w int = 0\n        x1 int = 0\n        y1 int = 0\n        z1 int = 0\n        x2 int = 0\n        y2 int = 0\n        z2 int = 0\n        x3 int = 0\n        y3 int = 0\n        z3 int = 0\n        x4 int = 0\n        y4 int = 0\n        z4 int = 0\n        x5 int = 0\n        y5 int = 0\n        z5 int = 0\n        x6 int = 0\n        y6 int = 0\n        z6 int = 0\n        x7 int = 0\n        y7 int = 0\n        z7 int = 0\n        x8 int = 0\n        y8 int = 0\n        z8 int = 0\n        x9 int = 0\n        y9 int = 0\n        z9 int = 0\n        x10 int = 0\n        y10 int = 0\n        z10 int = 0\n        x11 int = 0\n        y11 int = 0\n        z11 int = 0\n        x12 int = 0\n        y12 int = 0\n        z12 int = 0\n        x13 int = 0\n        y13 int = 0\n        z13 int = 0\n        x14 int = 0\n        y14 int = 0\n        z14 int = 0\n        x15 int = 0\n        y15 int = 0\n        z15 int = 0\n        x16 int = 0\n        y16 int = 0\n        z16 int = 0\n        x17 int = 0\n        y17 int = 0\n        z17 int = 0\n        x18 int = 0\n        y18 int = 0\n        z18 int = 0\n        x19 int = 0\n        y19 int = 0\n        z19 int = 0\n        x20 int = 0\n        y\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123318,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3lzj9030_test.go:85:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var x, y, count float64\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            return count\n        }\n        if x > float64(d) {\n            return -1\n        }\n        if y == 0 {\n            count++\n        }\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123330,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpauldm0zp_test.go:46: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpauldm0zp_test.go:46: expected '%!s(int=0)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpauldm0zp_test.go:46: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        n int = len(steps)\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n        aa int\n        ab int\n        ac int\n        ad int\n        ae int\n        af int\n        ag int\n        ah int\n        ai int\n        aj int\n        ak int\n        al int\n        am int\n        an int\n        ao int\n        ap int\n        aq int\n        ar int\n        as int\n        at int\n        au int\n        av int\n        aw int\n        ax int\n        ay int\n        az int\n        ba int\n        bb int\n        bc int\n        bd int\n        be int\n        bf int\n        bg int\n        bh int\n        bi int\n        bj int\n        bk int\n        bl int\n        bm int\n        bn int\n        bo int\n        bp int\n        bq int\n        br int\n        bs int\n        bt int\n        bu int\n        bv int\n        bw int\n        bx int\n        by int\n        bz int\n        ca int\n        cb int\n        cc int\n        cd int\n        ce int\n        cf int\n        cg int\n        ch int\n        ci int\n        cj int\n        ck int\n        cl int\n        cm int\n        cn int\n        co int\n        cp int\n        cq int\n        cr int\n        cs int\n        ct int\n        cu int\n        cv int\n        cw int\n        cx int\n        cy int\n        cz int\n        da int\n        db int\n        dc int\n        dd int\n        de int\n        df int\n        dg int\n        dh int\n        di int\n        dj int\n        dk int\n        dl int\n        dm int\n        dn int\n        do int\n        dp int\n        dq int\n        dr int\n        d\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123329,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpqflcr9w4_test.go:126:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        x, y float64\n        count int\n    )\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y++\n        case \"down\":\n            y--\n        case \"left\":\n            x--\n        case \"right\":\n            x++\n        }\n        if x == float64(d) || y == float64(d) {\n            count++\n            x, y = 0, 0\n        }\n    }\n    return float64(count)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123330,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp3s9_jiqd_test.go:48: expected '%!s(float64=3.5)', got '%!s(float64=0)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmp3s9_jiqd_test.go:48: expected '%!s(int=0)', got '%!s(float64=2)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmp3s9_jiqd_test.go:48: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    if len(steps) == 0 {\n        return 0\n    }\n    if len(steps) == 1 {\n        return float64(d)\n    }\n    if len(steps) == 2 {\n        return float64(d) / 2\n    }\n    var sum float64 = 0\n    for _, v := range steps {\n        sum += v.(float64)\n    }\n    return float64(d) / sum\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123330,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp1qkfttyp_test.go:41: expected '%!s(float64=3.5)', got '%!s(float64=5.5)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmp1qkfttyp_test.go:41: expected '%!s(int=1)', got '%!s(float64=5.5)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var x, y float64\n    x = 0\n    y = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            x += step.(float64)\n        }\n    }\n    y = float64(d) - x\n    if y < 0 {\n        return -1\n    }\n    return y\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123331,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp8td_h4of_test.go:43: expected '%!s(float64=3.5)', got '%!s(float64=4)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmp8td_h4of_test.go:43: expected '%!s(int=0)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmp8td_h4of_test.go:43: expected '%!s(int=1)', got '%!s(float64=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var x, y int = 0, 0\n    var count int = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case string:\n            if step.(string) == \"D\" {\n                x -= 1\n            } else if step.(string) == \"U\" {\n                x += 1\n            } else if step.(string) == \"L\" {\n                y -= 1\n            } else if step.(string) == \"R\" {\n                y += 1\n            }\n        case int:\n            if step.(int) == 1 {\n                x -= 1\n            } else if step.(int) == 2 {\n                x += 1\n            } else if step.(int) == 3 {\n                y -= 1\n            } else if step.(int) == 4 {\n                y += 1\n            }\n        }\n        if x == d && y == 0 {\n            return float64(count)\n        }\n        count += 1\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123331,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpyp0x04my_test.go:58: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpyp0x04my_test.go:58: expected '%!s(int=0)', got '%!s(float64=1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpyp0x04my_test.go:58: expected '%!s(int=1)', got '%!s(float64=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            x += step.(float64)\n        }\n        if x > d {\n            return -1\n        }\n        if x == d {\n            return count\n        }\n        count++\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123330,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqt47nxzn_test.go:21:14: invalid operation: x > d (mismatched types float64 and int)\n/tmp/tmpqt47nxzn_test.go:24:14: invalid operation: x == d (mismatched types float64 and int)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        x, y int = 0, 0\n        jumps float64 = 0\n    )\n    for _, step := range steps {\n        switch step {\n            case \"U\":\n                y++\n            case \"D\":\n                y--\n            case \"L\":\n                x--\n            case \"R\":\n                x++\n        }\n        if x == d || y == d {\n            jumps++\n            x, y = 0, 0\n        }\n    }\n    if x != 0 || y != 0 {\n        jumps++\n    }\n    return jumps\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123331,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpxnjx4w42_test.go:51: expected '%!s(float64=3.5)', got '%!s(float64=0)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpxnjx4w42_test.go:51: expected '%!s(int=0)', got '%!s(float64=2)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpxnjx4w42_test.go:51: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var count int\n    var x, y int\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y++\n        case \"down\":\n            y--\n        case \"left\":\n            x--\n        case \"right\":\n            x++\n        }\n        if x == d {\n            return float64(count + 1)\n        }\n        count++\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123331,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp7o6klq51_test.go:47: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmp7o6klq51_test.go:47: expected '%!s(int=0)', got '%!s(float64=1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmp7o6klq51_test.go:47: expected '%!s(int=1)', got '%!s(float64=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    if len(steps) == 0 {\n        return 0\n    }\n\n    var (\n        min_jumps float64\n        i int\n    )\n\n    for i = 0; i < len(steps); i++ {\n        switch steps[i].(type) {\n        case int:\n            min_jumps += float64(steps[i].(int))\n        case float64:\n            min_jumps += steps[i].(float64)\n        }\n    }\n\n    return min_jumps / float64(d)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123331,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpk801n261_test.go:46: expected '%!s(float64=3.5)', got '%!s(float64=0.6363636363636364)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpk801n261_test.go:46: expected '%!s(int=0)', got '%!s(float64=+Inf)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpk801n261_test.go:46: expected '%!s(int=1)', got '%!s(float64=2.272727272727273)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var x, y float64 = 0, 0\n    var count int = 0\n    for _, step := range steps {\n        switch step.(type) {\n            case string:\n                if step == \"D\" {\n                    y -= 1\n                } else {\n                    y += 1\n                }\n            case int:\n                x += float64(step.(int))\n        }\n        if x == float64(d) {\n            return float64(count + 1)\n        }\n        if x > float64(d) {\n            return float64(-1)\n        }\n        count += 1\n    }\n    return float64(-1)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123331,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpyhrme9jt_test.go:49: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpyhrme9jt_test.go:49: expected '%!s(int=0)', got '%!s(float64=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    if len(steps) == 0 {\n        return 0\n    }\n    if len(steps) == 1 {\n        return float64(steps[0].(int))\n    }\n    var min float64 = float64(steps[0].(int))\n    for i := 1; i < len(steps); i++ {\n        if float64(steps[i].(int)) < min {\n            min = float64(steps[i].(int))\n        }\n    }\n    return min_Jumps(steps[1:], d) + min\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123331,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpxtf5vxvt_test.go:40: expected '%!s(float64=3.5)', got '%!s(float64=7)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpxtf5vxvt_test.go:40: expected '%!s(int=0)', got '%!s(float64=7)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpxtf5vxvt_test.go:40: expected '%!s(int=1)', got '%!s(float64=25)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        i, j, k int\n        n, m    int\n        x, y    int\n        s       int\n        a       [][]int\n        b       [][]int\n        c       [][]int\n        dp      [][]float64\n    )\n    n = len(steps)\n    m = len(steps[0].([]interface{}))\n    a = make([][]int, n)\n    b = make([][]int, n)\n    c = make([][]int, n)\n    for i = 0; i < n; i++ {\n        a[i] = make([]int, m)\n        b[i] = make([]int, m)\n        c[i] = make([]int, m)\n        for j = 0; j < m; j++ {\n            a[i][j] = steps[i].([]interface{})[j].(int)\n            b[i][j] = 0\n            c[i][j] = 0\n        }\n    }\n    dp = make([][]float64, n)\n    for i = 0; i < n; i++ {\n        dp[i] = make([]float64, m)\n        for j = 0; j < m; j++ {\n            dp[i][j] = 0\n        }\n    }\n    dp[0][0] = 1\n    for i = 0; i < n; i++ {\n        for j = 0; j < m; j++ {\n            if a[i][j] == 0 {\n                continue\n            }\n            if i > 0 && a[i-1][j] == 1 {\n                b[i][j]++\n            }\n            if i < n-1 && a[i+1][j] == 1 {\n                b[i][j]++\n            }\n            if j > 0 && a[i][j-1] == 1 {\n                b[i][j]++\n            }\n            if j < m-1 && a[i][j+1] == 1 {\n                b[i][j]++\n            }\n            if i > 0 && j\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123330,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpv4os4ef5_test.go:61:6: expected '(', found TestMin_Jumps\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) && y == 0 {\n            return count\n        }\n        count++\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123319,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpks2dbe8u_test.go:43: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpks2dbe8u_test.go:43: expected '%!s(int=0)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpks2dbe8u_test.go:43: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var x, y float64\n    x = 0\n    y = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n    }\n    if x == float64(d) {\n        return y\n    } else if x > float64(d) {\n        return -1\n    }\n    return min_Jumps(steps, d)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123332,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160378 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54722b, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.min_Jumps(0xc04015fed0, 0x2, 0x2, 0xb, 0x0)\n\t/tmp/tmpboy04bcw_test.go:9 +0x165 fp=0xc020160388 sp=0xc020160380 pc=0x50a765\ncommand-line-arguments_test.min_Jumps(0xc04015fed0, 0x2, 0x2, 0xb, 0x0)\n\t/tmp/tmpboy04bcw_test.go:26 +0xd9 fp=0xc0201603c0 sp=0xc020160388 pc=0x50a6d9\ncommand-line-arguments_test.min_Jumps(0xc04015fed0, 0x2, 0x2, 0xb, 0x0)\n\t/tmp/tmpboy04bcw_test.go:26 +0xd9 fp=0xc0201603f8 sp=0xc0201603c0 pc=0x50a6d9\ncommand-line-arguments_test.min_Jumps(0xc04015fed0, 0x2, 0x2, 0xb, 0x0)\n\t/tmp/tmpboy04bcw_test.go:26 +0xd9 fp=0xc020160430 sp=0xc0201603f8 pc=0x50a6d9\ncommand-line-arguments_test.min_Jumps(0xc04015fed0, 0x2, 0x2, 0xb, 0x0)\n\t/tmp/tmpboy04bcw_test.go:26 +0xd9 fp=0xc020160468 sp=0xc020160430 pc=0x50a6d9\ncommand-line-arguments_test.min_Jumps(0xc04015fed0, 0x2, 0x2, 0xb, 0x0)\n\t/tmp/tmpboy04bcw_test.go:26 +0xd9 fp=0xc0201604a0 sp=0xc020160468 pc=0x50a6d9\ncommand-line-arguments_test.min_Jumps(0xc04015fed0, 0x2, 0x2, 0xb, 0x0)\n\t/tmp/tmpboy04bcw_test.go:26 +0xd9 fp=0xc0201604d8 sp=0xc0201604a0 pc=0x50a6d9\ncommand-line-arguments_test.min_Jumps(0xc04015fed0, 0x2, 0x2, 0xb, 0x0)\n\t/tmp/tmpboy04bcw_test.go:26 +0xd9 fp=0xc020160510 sp=0xc0201604d8 pc=0x50a6d9\ncommand-line-arguments_test.min_Jumps(0xc04015fed0, 0x2, 0x2, 0xb, 0x0)\n\t/tmp/tmpboy04bcw_test.go:26 +0xd9 fp=0xc020160548 sp=0xc020160510 pc=0x50a6d9\ncommand-line-arguments_test.min_Jumps(0xc04015fed0, 0x2, 0x2, 0xb, 0x0)\n\t/tmp/tmpboy04bcw_test.go:26 +0xd9 fp=0xc020160580 sp=0xc020160548 pc=0x50a6d9\ncommand-line-arguments_test.min_Jumps(0xc04015fed0, 0x2, 0x2, 0xb, 0x0)\n\t",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        x, y float64\n        x_, y_ float64\n        x_max, y_max float64\n        x_min, y_min float64\n        x_sum, y_sum float64\n        x_avg, y_avg float64\n        x_count, y_count float64\n        x_median, y_median float64\n        x_mode, y_mode float64\n        x_std, y_std float64\n        x_var, y_var float64\n        x_range, y_range float64\n        x_skew, y_skew float64\n        x_kurt, y_kurt float64\n        x_min_max_diff, y_min_max_diff float64\n        x_min_max_ratio, y_min_max_ratio float64\n        x_std_avg_diff, y_std_avg_diff float64\n        x_std_avg_ratio, y_std_avg_ratio float64\n        x_skew_avg_diff, y_skew_avg_diff float64\n        x_skew_avg_ratio, y_skew_avg_ratio float64\n        x_kurt_avg_diff, y_kurt_avg_diff float64\n        x_kurt_avg_ratio, y_kurt_avg_ratio float64\n        x_skew_std_diff, y_skew_std_diff float64\n        x_skew_std_ratio, y_skew_std_ratio float64\n        x_kurt_std_diff, y_kurt_std_diff float64\n        x_kurt_std_ratio, y_kurt_std_ratio float64\n        x_kurt_skew_diff, y_kurt_skew_diff float64\n        x_kurt_skew_ratio, y_kurt_skew_ratio float64\n        x_min_max_diff_avg_diff, y_min_max_diff\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123330,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptzbh6c7n_test.go:39:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var x, y float64\n    x = 0\n    y = 0\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y += 1\n        case \"down\":\n            y -= 1\n        case \"left\":\n            x -= 1\n        case \"right\":\n            x += 1\n        }\n    }\n    return (x + y) / float64(d)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510491,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp0m2rkse5_test.go:44: expected '%!s(float64=3.5)', got '%!s(float64=0)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmp0m2rkse5_test.go:44: expected '%!s(int=0)', got '%!s(float64=NaN)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmp0m2rkse5_test.go:44: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var n float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            n += float64(step.(int))\n        case float64:\n            n += step.(float64)\n        }\n    }\n    return n / float64(d)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123331,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp1h5om80j_test.go:37: expected '%!s(float64=3.5)', got '%!s(float64=0.6363636363636364)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmp1h5om80j_test.go:37: expected '%!s(int=0)', got '%!s(float64=+Inf)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmp1h5om80j_test.go:37: expected '%!s(int=1)', got '%!s(float64=2.272727272727273)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var x, y, count float64\n    for _, v := range steps {\n        switch v.(type) {\n        case int:\n            x += float64(v.(int))\n        case float64:\n            y += v.(float64)\n        }\n        if x == d {\n            return count\n        }\n        if x > d {\n            return -1\n        }\n        count++\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123331,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprpq6tval_test.go:18:14: invalid operation: x == d (mismatched types float64 and int)\n/tmp/tmprpq6tval_test.go:21:14: invalid operation: x > d (mismatched types float64 and int)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var x, y int\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y++\n        case \"down\":\n            y--\n        case \"left\":\n            x--\n        case \"right\":\n            x++\n        }\n    }\n    return float64(max(abs(x), abs(y)))/float64(d)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123331,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6jievd1v_test.go:24:20: undefined: max\n/tmp/tmp6jievd1v_test.go:24:24: undefined: abs\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var min_jumps float64\n    var i int\n    var x, y float64\n    var x_delta, y_delta float64\n    var x_steps, y_steps float64\n    var x_steps_remaining, y_steps_remaining float64\n\n    x = 0\n    y = 0\n    x_steps = 0\n    y_steps = 0\n    x_steps_remaining = 0\n    y_steps_remaining = 0\n\n    for i = 0; i < len(steps); i++ {\n        switch steps[i].(type) {\n        case string:\n            switch steps[i].(string) {\n            case \"N\":\n                y_steps = y_steps + 1\n                y_steps_remaining = y_steps_remaining + 1\n            case \"S\":\n                y_steps = y_steps + 1\n                y_steps_remaining = y_steps_remaining + 1\n            case \"E\":\n                x_steps = x_steps + 1\n                x_steps_remaining = x_steps_remaining + 1\n            case \"W\":\n                x_steps = x_steps + 1\n                x_steps_remaining = x_steps_remaining + 1\n            }\n        case int:\n            switch steps[i-1].(string) {\n            case \"N\":\n                y_delta = float64(steps[i].(int))\n                y = y + y_delta\n                y_steps_remaining = y_steps_remaining - y_delta\n            case \"S\":\n                y_delta = float64(steps[i].(int))\n                y = y - y_delta\n                y_steps_remaining = y_steps_remaining - y_delta\n            case \"E\":\n                x_delta = float64(steps[i].(int))\n                x = x + x_delta\n                x_steps_remaining = x_steps_remaining - x_delta\n            case \"W\":\n                x_delta = float64(steps[i].(int))\n                x = x - x_delta\n                x_steps_remaining = x\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123330,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmplhbvsudq_test.go:59:6: expected '(', found TestMin_Jumps\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var result float64\n    var x, y int\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += step.(int)\n        case string:\n            y += 1\n        }\n        if x == d {\n            result += 1\n            x = 0\n        }\n        if y == d {\n            result += 1\n            y = 0\n        }\n    }\n    return result\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123331,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp2lbsp9zx_test.go:46: expected '%!s(float64=3.5)', got '%!s(float64=0)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmp2lbsp9zx_test.go:46: expected '%!s(int=0)', got '%!s(float64=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    if len(steps) == 0 {\n        return 0\n    }\n    var max float64\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            max = math.Max(max, float64(step.(int)))\n        case float64:\n            max = math.Max(max, step.(float64))\n        }\n    }\n    return math.Ceil(float64(d) / max)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123331,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpf_ugogef_test.go:17:19: undefined: math\n/tmp/tmpf_ugogef_test.go:19:19: undefined: math\n/tmp/tmpf_ugogef_test.go:22:12: undefined: math\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        x, y int\n        res float64\n    )\n    for _, v := range steps {\n        switch v.(type) {\n        case int:\n            x += v.(int)\n        case string:\n            y += v.(string)\n        }\n    }\n    res = float64(x) / float64(d)\n    if y > 0 {\n        res += float64(y)\n    }\n    return res\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123331,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptal0cxxi_test.go:19:15: invalid operation: y += v.(string) (mismatched types int and string)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        x, y, count float64\n    )\n    for _, step := range steps {\n        switch step {\n            case \"up\":\n                y++\n            case \"down\":\n                y--\n            case \"left\":\n                x--\n            case \"right\":\n                x++\n        }\n        if x == d || y == d {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123331,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk5iq4xl__test.go:24:14: invalid operation: x == d (mismatched types float64 and int)\n/tmp/tmpk5iq4xl__test.go:24:24: invalid operation: y == d (mismatched types float64 and int)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n    )\n    for i = 0; i < len(steps); i++ {\n        switch steps[i].(type) {\n        case int:\n            j = steps[i].(int)\n        case float64:\n            k = int(steps[i].(float64))\n        case string:\n            l = len(steps[i].(string))\n        case []int:\n            m = len(steps[i].([]int))\n        case []float64:\n            n = len(steps[i].([]float64))\n        case []string:\n            o = len(steps[i].([]string))\n        case [][]int:\n            p = len(steps[i].([][]int))\n        case [][]float64:\n            q = len(steps[i].([][]float64))\n        case [][]string:\n            r = len(steps[i].([][]string))\n        case []interface{}:\n            s = len(steps[i].([]interface{}))\n        case [][]interface{}:\n            t = len(steps[i].([][]interface{}))\n        case [][][]int:\n            u = len(steps[i].([][][]int))\n        case [][][]float64:\n            v = len(steps[i].([][][]float64))\n        case [][][]string:\n            w = len(steps[i].([][][]string))\n        case [][][]interface{}:\n            x = len(steps[i].([][][]interface{}))\n        case [][][][]int:\n            y = len(steps[i].([][][][]int))\n        case [][][][]float64:\n            z = len(steps[i].([][][][]float64))\n        }\n    }\n    return\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123331,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcoegz4wz_test.go:69:6: expected '(', found TestMin_Jumps\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var x, y int = 0, 0\n    var x_max, y_max int = 0, 0\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y += 1\n        case \"down\":\n            y -= 1\n        case \"left\":\n            x -= 1\n        case \"right\":\n            x += 1\n        }\n        if x_max < x {\n            x_max = x\n        }\n        if y_max < y {\n            y_max = y\n        }\n    }\n    var x_dist, y_dist int = d - x_max, d - y_max\n    if x_dist < 0 {\n        x_dist = -x_dist\n    }\n    if y_dist < 0 {\n        y_dist = -y_dist\n    }\n    return float64(x_dist + y_dist)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123332,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp2v2zc8m3_test.go:55: expected '%!s(float64=3.5)', got '%!s(float64=22)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmp2v2zc8m3_test.go:55: expected '%!s(int=1)', got '%!s(float64=22)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var x, y, count float64\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            x += step.(float64)\n        case string:\n            if step.(string) == \"D\" {\n                y -= 1\n            } else if step.(string) == \"U\" {\n                y += 1\n            }\n        }\n        if x == float64(d) {\n            count += 1\n        }\n    }\n    return count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123332,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpyv6pc6lm_test.go:46: expected '%!s(float64=3.5)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var count float64 = 0\n    var x, y float64 = 0, 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            x += step.(float64)\n        }\n        if x == float64(d) {\n            count++\n            x = 0\n        }\n    }\n    return count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123331,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp82973r80_test.go:11:12: y declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        i int\n        j int\n        k int\n        l int\n        m int\n        n int\n        o int\n        p int\n        q int\n        r int\n        s int\n        t int\n        u int\n        v int\n        w int\n        x int\n        y int\n        z int\n    )\n    for i = 0; i < len(steps); i++ {\n        switch steps[i].(type) {\n        case int:\n            j = steps[i].(int)\n            if j > d {\n                return -1\n            }\n            if j == d {\n                return 1\n            }\n            k = d - j\n            l = k\n            m = k\n            n = k\n            o = k\n            p = k\n            q = k\n            r = k\n            s = k\n            t = k\n            u = k\n            v = k\n            w = k\n            x = k\n            y = k\n            z = k\n        case float64:\n            j = int(steps[i].(float64))\n            if j > d {\n                return -1\n            }\n            if j == d {\n                return 1\n            }\n            k = d - j\n            l = k\n            m = k\n            n = k\n            o = k\n            p = k\n            q = k\n            r = k\n            s = k\n            t = k\n            u = k\n            v = k\n            w = k\n            x = k\n            y = k\n            z = k\n        }\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123331,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn4u0_iwd_test.go:14:9: l declared but not used\n/tmp/tmpn4u0_iwd_test.go:15:9: m declared but not used\n/tmp/tmpn4u0_iwd_test.go:16:9: n declared but not used\n/tmp/tmpn4u0_iwd_test.go:17:9: o declared but not used\n/tmp/tmpn4u0_iwd_test.go:18:9: p declared but not used\n/tmp/tmpn4u0_iwd_test.go:19:9: q declared but not used\n/tmp/tmpn4u0_iwd_test.go:20:9: r declared but not used\n/tmp/tmpn4u0_iwd_test.go:21:9: s declared but not used\n/tmp/tmpn4u0_iwd_test.go:22:9: t declared but not used\n/tmp/tmpn4u0_iwd_test.go:23:9: u declared but not used\n/tmp/tmpn4u0_iwd_test.go:23:9: too many errors\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step {\n        case \"N\":\n            y++\n        case \"S\":\n            y--\n        case \"E\":\n            x++\n        case \"W\":\n            x--\n        }\n        if x == d && y == 0 {\n            return count\n        }\n        count++\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123306,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaqjy1lem_test.go:24:14: invalid operation: x == d (mismatched types float64 and int)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var result float64\n    result = 0\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var aa int\n    var ab int\n    var ac int\n    var ad int\n    var ae int\n    var af int\n    var ag int\n    var ah int\n    var ai int\n    var aj int\n    var ak int\n    var al int\n    var am int\n    var an int\n    var ao int\n    var ap int\n    var aq int\n    var ar int\n    var as int\n    var at int\n    var au int\n    var av int\n    var aw int\n    var ax int\n    var ay int\n    var az int\n    var ba int\n    var bb int\n    var bc int\n    var bd int\n    var be int\n    var bf int\n    var bg int\n    var bh int\n    var bi int\n    var bj int\n    var bk int\n    var bl int\n    var bm int\n    var bn int\n    var bo int\n    var bp int\n    var bq int\n    var br int\n    var bs int\n    var bt int\n    var bu int\n    var bv int\n    var bw int\n    var bx int\n    var by int\n    var bz int\n    var ca int\n    var cb int\n    var cc int\n    var cd int\n    var ce int\n    var cf int\n    var cg int\n    var ch int\n    var ci int\n    var cj int\n    var ck int\n    var cl int\n    var cm int\n    var cn int\n    var co int\n    var cp int\n    var cq int\n    var cr int\n    var cs int\n    var ct int\n    var cu int\n    var cv int\n   \nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123331,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp313vhin6_test.go:106:6: expected '(', found TestMin_Jumps\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var count float64 = 0\n    var x float64 = 0\n    var y float64 = 0\n    for _, step := range steps {\n        switch step {\n        case \"N\":\n            y += 1\n        case \"S\":\n            y -= 1\n        case \"E\":\n            x += 1\n        case \"W\":\n            x -= 1\n        }\n        if x == d && y == 0 {\n            return count\n        }\n        count += 1\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123331,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5a8s4cgu_test.go:24:14: invalid operation: x == d (mismatched types float64 and int)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var x, y int\n    for _, step := range steps {\n        switch step {\n        case \"up\":\n            y++\n        case \"down\":\n            y--\n        case \"left\":\n            x--\n        case \"right\":\n            x++\n        }\n    }\n    if x == 0 {\n        return float64(abs(y) / d)\n    }\n    if y == 0 {\n        return float64(abs(x) / d)\n    }\n    return float64(abs(x) + abs(y)) / float64(d)\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123331,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1ozilu1i_test.go:25:24: undefined: abs\n/tmp/tmp1ozilu1i_test.go:28:24: undefined: abs\n/tmp/tmp1ozilu1i_test.go:30:20: undefined: abs\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    // Write your code here\n    var count float64 = 0\n    var i float64 = 0\n    for i < float64(len(steps)) {\n        if steps[int(i)] == \"U\" {\n            count++\n            i += 2\n        } else {\n            count++\n            i += 1\n        }\n    }\n    return count\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123332,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpyc_6xcg__test.go:40: expected '%!s(float64=3.5)', got '%!s(float64=2)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpyc_6xcg__test.go:40: expected '%!s(int=0)', got '%!s(float64=2)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmpyc_6xcg__test.go:40: expected '%!s(int=1)', got '%!s(float64=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var x, y float64 = 0, 0\n    var jumps float64 = 0\n    for _, step := range steps {\n        switch step.(type) {\n        case int:\n            x += float64(step.(int))\n        case float64:\n            y += step.(float64)\n        }\n        if x == float64(d) {\n            return jumps + y\n        }\n        if x > float64(d) {\n            return -1\n        }\n        jumps++\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123332,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmp19p16opm_test.go:45: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmp19p16opm_test.go:45: expected '%!s(int=0)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__2 (0.00s)\n        tmp19p16opm_test.go:45: expected '%!s(int=1)', got '%!s(float64=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package min_Jumps_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps []interface{}, d int) float64 {\n    var (\n        x, y float64\n        jumps float64\n    )\n    for _, step := range steps {\n        switch step.(type) {\n            case int:\n                x += float64(step.(int))\n            case float64:\n                x += step.(float64)\n            case string:\n                if step.(string) == \"D\" {\n                    y -= 1\n                } else {\n                    y += 1\n                }\n        }\n        if x == float64(d) {\n            return jumps + 1\n        }\n        if x > float64(d) {\n            return -1\n        }\n        jumps += 1\n    }\n    return -1\n}\n\nfunc TestMin_Jumps(t *testing.T) {\n  candidate := min_Jumps\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{3, 4}, 11), expected: 3.5 },\n     { actual: candidate([]interface{}{3, 4}, 0), expected: 0 },\n     { actual: candidate([]interface{}{11, 14}, 11), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123332,
      "stdout": "--- FAIL: TestMin_Jumps (0.00s)\n    --- FAIL: TestMin_Jumps/test_num__0 (0.00s)\n        tmpnsroo_bf_test.go:53: expected '%!s(float64=3.5)', got '%!s(float64=-1)'\n    --- FAIL: TestMin_Jumps/test_num__1 (0.00s)\n        tmpnsroo_bf_test.go:53: expected '%!s(int=0)', got '%!s(float64=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}