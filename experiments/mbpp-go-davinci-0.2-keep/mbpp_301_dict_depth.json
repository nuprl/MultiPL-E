{
  "name": "mbpp_301_dict_depth",
  "language": "go_test.go",
  "prompt": "package dict_depth_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the depth of a dictionary.\nfunc dict_depth(d interface{}) int {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_301_dict_depth.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestDict_Depth(t *testing.T) {\n  candidate := dict_depth\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]interface{}{\"a\": 1, \"b\": map[string]UNKNOWN{\"c\": map[string]UNKNOWN{\"d\": map[interface{}]interface{}{}}}}), expected: 4 },\n     { actual: candidate(map[string]interface{}{\"a\": 1, \"b\": map[string]string{\"c\": \"python\"}}), expected: 2 },\n     { actual: candidate(map[int]interface{}{1: \"Sun\", 2: map[int]UNKNOWN{3: map[int]string{4: \"Mon\"}}}), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if dict_depth(v) > max {\n                max = dict_depth(v)\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            if dict_depth(v) > max {\n                max = dict_depth(v)\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n        case map[string]interface{}:\n            max_depth := 0\n            for _, v := range d.(map[string]interface{}) {\n                depth := dict_depth(v)\n                if depth > max_depth {\n                    max_depth = depth\n                }\n            }\n            return max_depth + 1\n        default:\n            return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        m := d.(map[string]interface{})\n        max := 0\n        for _, v := range m {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max + 1\n    case []interface{}:\n        a := d.([]interface{})\n        max := 0\n        for _, v := range a {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max_depth(d.(map[string]interface{}))\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        m := d.(map[string]interface{})\n        max := 0\n        for _, v := range m {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        a := d.([]interface{})\n        max := 0\n        for _, v := range a {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        m := d.(map[string]interface{})\n        max := 0\n        for _, v := range m {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch v := d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, value := range v {\n            depth := dict_depth(value)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch v := d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, value := range v {\n            depth := dict_depth(value)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n        case map[string]interface{}:\n            max := 0\n            for _, v := range d.(map[string]interface{}) {\n                depth := dict_depth(v)\n                if depth > max {\n                    max = depth\n                }\n            }\n            return max + 1\n        default:\n            return 0\n    }\n}\n",
    "    switch v := d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, val := range v {\n            depth := dict_depth(val)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[\"a\"]), dict_depth(d.(map[string]interface{})[\"b\"]))\n    case map[string]string:\n        return 1 + max(dict_depth(d.(map[string]string)[\"a\"]), dict_depth(d.(map[string]string)[\"b\"]))\n    case string:\n        return 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        depth := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth = max(depth, dict_depth(v))\n        }\n        return depth + 1\n    case []interface{}:\n        depth := 0\n        for _, v := range d.([]interface{}) {\n            depth = max(depth, dict_depth(v))\n        }\n        return depth + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max_depth(d.(map[string]interface{}))\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(v) for _, v := range d.(map[string]interface{}))\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[k]) for k in d.(map[string]interface{}))\n    case []interface{}:\n        return 1 + max(dict_depth(d.([]interface{})[i]) for i in range(len(d.([]interface{}))))\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        depth := 0\n        for _, v := range d.(map[string]interface{}) {\n            d := dict_depth(v)\n            if d > depth {\n                depth = d\n            }\n        }\n        return depth + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n        case map[string]interface{}:\n            max := 0\n            for _, v := range d.(map[string]interface{}) {\n                d := dict_depth(v)\n                if d > max {\n                    max = d\n                }\n            }\n            return max + 1\n        case []interface{}:\n            max := 0\n            for _, v := range d.([]interface{}) {\n                d := dict_depth(v)\n                if d > max {\n                    max = d\n                }\n            }\n            return max\n        default:\n            return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[k]) for k := range d.(map[string]interface{}))\n    case []interface{}:\n        return 1 + max(dict_depth(v) for _, v := range d.([]interface{}))\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[k]) for k := range d.(map[string]interface{}))\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max_depth(d.(map[string]interface{}))\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n        case map[string]interface{}:\n            max := 0\n            for _, v := range d.(map[string]interface{}) {\n                depth := dict_depth(v)\n                if depth > max {\n                    max = depth\n                }\n            }\n            return max + 1\n        default:\n            return 0\n    }\n}\n",
    "    switch d.(type) {\n        case map[string]interface{}:\n            max := 0\n            for _, v := range d.(map[string]interface{}) {\n                depth := dict_depth(v)\n                if depth > max {\n                    max = depth\n                }\n            }\n            return max + 1\n        case []interface{}:\n            max := 0\n            for _, v := range d.([]interface{}) {\n                depth := dict_depth(v)\n                if depth > max {\n                    max = depth\n                }\n            }\n            return max\n        default:\n            return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[k]) for k := range d.(map[string]interface{}))\n    case []interface{}:\n        return 1 + max(dict_depth(v) for _, v := range d.([]interface{}))\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        depth := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth = max(depth, dict_depth(v))\n        }\n        return depth + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[k]) for k, _ := range d.(map[string]interface{}))\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        m := d.(map[string]interface{})\n        max := 0\n        for _, v := range m {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        depth := 0\n        for _, v := range d.(map[string]interface{}) {\n            d := dict_depth(v)\n            if d > depth {\n                depth = d\n            }\n        }\n        return depth + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if max < dict_depth(v) {\n                max = dict_depth(v)\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[\"a\"]), dict_depth(d.(map[string]interface{})[\"b\"]))\n    case map[string]string:\n        return 1 + max(dict_depth(d.(map[string]string)[\"a\"]), dict_depth(d.(map[string]string)[\"b\"]))\n    case string:\n        return 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if t := dict_depth(v); t > max {\n                max = t\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        var max int\n        for _, v := range d.(map[string]interface{}) {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        depth := 0\n        for _, v := range d.(map[string]interface{}) {\n            d := dict_depth(v)\n            if d > depth {\n                depth = d\n            }\n        }\n        return depth + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if cur := dict_depth(v); cur > max {\n                max = cur\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[k]) for k := range d.(map[string]interface{}))\n    case []interface{}:\n        return 1 + max(dict_depth(d.([]interface{})[i]) for i := range d.([]interface{}))\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max_depth := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max_depth {\n                max_depth = depth\n            }\n        }\n        return max_depth + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max_depth(d.(map[string]interface{}))\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        depth := 0\n        for _, v := range d.(map[string]interface{}) {\n            d := dict_depth(v)\n            if d > depth {\n                depth = d\n            }\n        }\n        return depth + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[k]) for k, _ := range d.(map[string]interface{}))\n    case []interface{}:\n        return 1 + max(dict_depth(d.([]interface{})[i]) for i := range d.([]interface{}))\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[k]) for k := range d.(map[string]interface{}))\n    case []interface{}:\n        return 1 + max(dict_depth(d.([]interface{})[i]) for i := range d.([]interface{}))\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max_depth := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max_depth {\n                max_depth = depth\n            }\n        }\n        return max_depth + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max_depth := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max_depth {\n                max_depth = depth\n            }\n        }\n        return max_depth + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[k]) for k, _ := range d.(map[string]interface{}))\n    case []interface{}:\n        return 1 + max(dict_depth(v) for _, v := range d.([]interface{}))\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[k]) for k, _ := range d.(map[string]interface{}))\n    case []interface{}:\n        return 1 + max(dict_depth(e) for _, e := range d.([]interface{}))\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        depth := 0\n        for _, v := range d.(map[string]interface{}) {\n            d := dict_depth(v)\n            if d > depth {\n                depth = d\n            }\n        }\n        return depth + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return 1 + max\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[\"a\"]), dict_depth(d.(map[string]interface{})[\"b\"]))\n    case map[string]string:\n        return 1 + max(dict_depth(d.(map[string]string)[\"a\"]), dict_depth(d.(map[string]string)[\"b\"]))\n    case string:\n        return 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[k]) for k, _ := range d.(map[string]interface{}))\n    case []interface{}:\n        return 1 + max(dict_depth(e) for _, e := range d.([]interface{}))\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n        case map[string]interface{}:\n            max_depth := 0\n            for _, v := range d.(map[string]interface{}) {\n                depth := dict_depth(v)\n                if depth > max_depth {\n                    max_depth = depth\n                }\n            }\n            return max_depth + 1\n        case []interface{}:\n            max_depth := 0\n            for _, v := range d.([]interface{}) {\n                depth := dict_depth(v)\n                if depth > max_depth {\n                    max_depth = depth\n                }\n            }\n            return max_depth\n        default:\n            return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(v) for _, v := range d.(map[string]interface{}))\n    case []interface{}:\n        return 1 + max(dict_depth(v) for _, v := range d.([]interface{}))\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        depth := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth = max(depth, dict_depth(v))\n        }\n        return depth + 1\n    case []interface{}:\n        depth := 0\n        for _, v := range d.([]interface{}) {\n            depth = max(depth, dict_depth(v))\n        }\n        return depth + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch v := d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, val := range v {\n            depth := dict_depth(val)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, val := range v {\n            depth := dict_depth(val)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max_depth(d.(map[string]interface{}))\n    case []interface{}:\n        return 1 + max_depth(d.([]interface{}))\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n        case map[string]interface{}:\n            max := 0\n            for _, v := range d.(map[string]interface{}) {\n                if max < dict_depth(v) {\n                    max = dict_depth(v)\n                }\n            }\n            return max + 1\n        default:\n            return 0\n    }\n}\n",
    "    switch v := d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, val := range v {\n            depth := dict_depth(val)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[k]) for k, _ := range d.(map[string]interface{}))\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            max = max_int(max, dict_depth(v))\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            max = max_int(max, dict_depth(v))\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if max < dict_depth(v) {\n                max = dict_depth(v)\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch v := d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range v {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range v {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if dict_depth(v) > max {\n                max = dict_depth(v)\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        return 1 + max(dict_depth(d.(map[string]interface{})[k]) for k, _ := range d.(map[string]interface{}))\n    case []interface{}:\n        return 1 + max(dict_depth(e) for _, e := range d.([]interface{}))\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        depth := 0\n        for _, v := range d.(map[string]interface{}) {\n            d := dict_depth(v)\n            if d > depth {\n                depth = d\n            }\n        }\n        return depth + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n        case map[string]interface{}:\n            max := 0\n            for _, v := range d.(map[string]interface{}) {\n                depth := dict_depth(v)\n                if depth > max {\n                    max = depth\n                }\n            }\n            return max + 1\n        default:\n            return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        m := d.(map[string]interface{})\n        max := 0\n        for _, v := range m {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        depth := 0\n        for _, v := range d.(map[string]interface{}) {\n            d := dict_depth(v)\n            if d > depth {\n                depth = d\n            }\n        }\n        return depth + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if d := dict_depth(v); d > max {\n                max = d\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if dict_depth(v) > max {\n                max = dict_depth(v)\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n        case map[string]interface{}:\n            return 1 + max(dict_depth(d.(map[string]interface{})[\"a\"]), dict_depth(d.(map[string]interface{})[\"b\"]))\n        case map[string]string:\n            return 1 + max(dict_depth(d.(map[string]string)[\"a\"]), dict_depth(d.(map[string]string)[\"b\"]))\n        case map[string]int:\n            return 1 + max(dict_depth(d.(map[string]int)[\"a\"]), dict_depth(d.(map[string]int)[\"b\"]))\n        case map[string]float64:\n            return 1 + max(dict_depth(d.(map[string]float64)[\"a\"]), dict_depth(d.(map[string]float64)[\"b\"]))\n        case map[string]bool:\n            return 1 + max(dict_depth(d.(map[string]bool)[\"a\"]), dict_depth(d.(map[string]bool)[\"b\"]))\n        case string:\n            return 0\n        case int:\n            return 0\n        case float64:\n            return 0\n        case bool:\n            return 0\n        default:\n            return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            if depth := dict_depth(v); depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        depth := 0\n        for _, v := range d.(map[string]interface{}) {\n            if d := dict_depth(v); d > depth {\n                depth = d\n            }\n        }\n        return depth + 1\n    default:\n        return 0\n    }\n}\n",
    "    switch d.(type) {\n        case map[string]interface{}:\n            max := 0\n            for _, v := range d.(map[string]interface{}) {\n                depth := dict_depth(v)\n                if depth > max {\n                    max = depth\n                }\n            }\n            return max + 1\n        default:\n            return 0\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    case []interface{}:\n        max := 0\n        for _, v := range d.([]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n",
    "    switch d.(type) {\n    case map[string]interface{}:\n        max := 0\n        for _, v := range d.(map[string]interface{}) {\n            depth := dict_depth(v)\n            if depth > max {\n                max = depth\n            }\n        }\n        return max + 1\n    default:\n        return 1\n    }\n}\n"
  ]
}