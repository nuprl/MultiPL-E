{
  "name": "mbpp_297_flatten_list",
  "language": "go_test.go",
  "prompt": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_297_flatten_list.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    case int:\n        list2 = append(list2, list1.(int))\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    case int:\n        list2 = append(list2, list1.(int))\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []int:\n        for _, v := range list1.([]int) {\n            result = append(result, v)\n        }\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpw6sh3eyj_test.go:39: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=20) %!s(int=30) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpw6sh3eyj_test.go:39: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpw6sh3eyj_test.go:39: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch v := list1.(type) {\n    case []interface{}:\n        for _, u := range v {\n            result = append(result, flatten_list(u)...)\n        }\n    case int:\n        result = append(result, v)\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpcuoi2z9f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpcuoi2z9f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpcuoi2z9f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    case int:\n        list2 = append(list2, list1.(int))\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    case int:\n        list2 = append(list2, list1.(int))\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    case int:\n        list2 = append(list2, list1.(int))\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch v := list1.(type) {\n    case int:\n        list2 = append(list2, v)\n    case []interface{}:\n        for _, vv := range v {\n            list2 = append(list2, flatten_list(vv)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123868,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp47xyxd33_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp47xyxd33_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp47xyxd33_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list []int\n    switch list1.(type) {\n    case int:\n        list = append(list, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list = append(list, flatten_list(v)...)\n        }\n    }\n    return list\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmphb5nr3rm_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmphb5nr3rm_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmphb5nr3rm_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, value := range list1.([]interface{}) {\n            result = append(result, flatten_list(value)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123868,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpyj9x9q12_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpyj9x9q12_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpyj9x9q12_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    case int:\n        list2 = append(list2, list1.(int))\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch v := list1.(type) {\n    case int:\n        result = append(result, v)\n    case []interface{}:\n        for _, u := range v {\n            result = append(result, flatten_list(u)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123866,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp6bkk77m3_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp6bkk77m3_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp6bkk77m3_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list []int\n    switch list1.(type) {\n    case int:\n        list = append(list, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list = append(list, flatten_list(v)...)\n        }\n    }\n    return list\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmphb5nr3rm_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmphb5nr3rm_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmphb5nr3rm_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch v := list1.(type) {\n    case int:\n        list2 = append(list2, v)\n    case []interface{}:\n        for _, u := range v {\n            list2 = append(list2, flatten_list(u)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123868,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp7wr2ybas_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp7wr2ybas_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp7wr2ybas_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []int:\n        for _, v := range list1.([]int) {\n            result = append(result, v)\n        }\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpw6sh3eyj_test.go:39: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=20) %!s(int=30) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpw6sh3eyj_test.go:39: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpw6sh3eyj_test.go:39: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    case int:\n        list2 = append(list2, list1.(int))\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list []int\n    switch list1.(type) {\n    case int:\n        list = append(list, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list = append(list, flatten_list(v)...)\n        }\n    }\n    return list\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmphb5nr3rm_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmphb5nr3rm_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmphb5nr3rm_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    case int:\n        list2 = append(list2, list1.(int))\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    case int:\n        list2 = append(list2, list1.(int))\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch v := list1.(type) {\n    case int:\n        list2 = append(list2, v)\n    case []interface{}:\n        for _, u := range v {\n            list2 = append(list2, flatten_list(u)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123868,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp7wr2ybas_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp7wr2ybas_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp7wr2ybas_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    case int:\n        list2 = append(list2, list1.(int))\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, item := range list1.([]interface{}) {\n            result = append(result, flatten_list(item)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123868,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpwt53g6ab_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpwt53g6ab_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpwt53g6ab_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    case int:\n        list2 = append(list2, list1.(int))\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    case int:\n        list2 = append(list2, list1.(int))\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    if list1 == nil {\n        return result\n    }\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123868,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp7n9e374h_test.go:40: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp7n9e374h_test.go:40: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp7n9e374h_test.go:40: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    result := []int{}\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123868,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpzqmhhdkb_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpzqmhhdkb_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpzqmhhdkb_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, item := range list1.([]interface{}) {\n            result = append(result, flatten_list(item)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123868,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp3yg0yobz_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp3yg0yobz_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp3yg0yobz_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    case int:\n        list2 = append(list2, list1.(int))\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    for _, v := range list1.([]interface{}) {\n        if vv, ok := v.([]interface{}); ok {\n            result = append(result, flatten_list(vv)...)\n        } else {\n            result = append(result, v.(int))\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123868,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\npanic: interface conversion: interface {} is []int, not int [recovered]\n\tpanic: interface conversion: interface {} is []int, not int\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x523ae0, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x523ae0, 0xc0001242a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.flatten_list(0x51a5a0, 0xc00011ad50, 0x0, 0x0, 0x0)\n\t/tmp/tmph6tuktc1_test.go:15 +0x2b7\ncommand-line-arguments_test.TestFlatten_List(0xc000102600)\n\t/tmp/tmph6tuktc1_test.go:28 +0x24f\ntesting.tRunner(0xc000102600, 0x54f5a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list []int\n    switch list1.(type) {\n    case int:\n        list = append(list, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list = append(list, flatten_list(v)...)\n        }\n    }\n    return list\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmphb5nr3rm_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmphb5nr3rm_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmphb5nr3rm_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case int:\n        list2 = append(list2, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpxqe4nq3f_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list = append(list, flatten_list(v)...)\n        }\n    case int:\n        list = append(list, list1.(int))\n    }\n    return list\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123868,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpx3t1dj5u_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpx3t1dj5u_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpx3t1dj5u_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var list2 []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            list2 = append(list2, flatten_list(v)...)\n        }\n    case int:\n        list2 = append(list2, list1.(int))\n    }\n    return list2\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpaoyypclk_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    case int:\n        result = append(result, list1.(int))\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmpsyqojbyv_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package flatten_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1 interface{}) []int {\n    var result []int\n    switch list1.(type) {\n    case int:\n        result = append(result, list1.(int))\n    case []interface{}:\n        for _, v := range list1.([]interface{}) {\n            result = append(result, flatten_list(v)...)\n        }\n    }\n    return result\n}\n\nfunc TestFlatten_List(t *testing.T) {\n  candidate := flatten_list\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{0, 10, []int{20, 30}, 40, 50, []int{60, 70, 80}, []int{90, 100, 110, 120}}), expected: []int{0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120} },\n     { actual: candidate([][]int{[]int{10, 20}, []int{40}, []int{30, 56, 25}, []int{10, 20}, []int{33}, []int{40}}), expected: []int{10, 20, 40, 30, 56, 25, 10, 20, 33, 40} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{4, 5, 6}, []int{10, 11, 12}, []int{7, 8, 9}}), expected: []int{1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510613,
      "stdout": "--- FAIL: TestFlatten_List (0.00s)\n    --- FAIL: TestFlatten_List/test_num__0 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=0) %!s(int=10) %!s(int=20) %!s(int=30) %!s(int=40) %!s(int=50) %!s(int=60) %!s(int=70) %!s(int=80) %!s(int=90) %!s(int=100) %!s(int=110) %!s(int=120)]', got '[%!s(int=0) %!s(int=10) %!s(int=40) %!s(int=50)]'\n    --- FAIL: TestFlatten_List/test_num__1 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=10) %!s(int=20) %!s(int=40) %!s(int=30) %!s(int=56) %!s(int=25) %!s(int=10) %!s(int=20) %!s(int=33) %!s(int=40)]', got '[]'\n    --- FAIL: TestFlatten_List/test_num__2 (0.00s)\n        tmp1t6uecpx_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4) %!s(int=5) %!s(int=6) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=7) %!s(int=8) %!s(int=9)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}