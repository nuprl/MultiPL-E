{
  "name": "mbpp_12_sort_matrix",
  "language": "go_test.go",
  "prompt": "package sort_matrix_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a given matrix in ascending order according to the sum of its rows.\nfunc sort_matrix(M [][]int) [][]int {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_12_sort_matrix.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestSort_Matrix(t *testing.T) {\n  candidate := sort_matrix\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{2, 4, 5}, []int{1, 1, 1}}), expected: [][]int{[]int{1, 1, 1}, []int{1, 2, 3}, []int{2, 4, 5}} },\n     { actual: candidate([][]int{[]int{1, 2, 3}, []int{-2, 4, -5}, []int{1, -1, 1}}), expected: [][]int{[]int{-2, 4, -5}, []int{1, -1, 1}, []int{1, 2, 3}} },\n     { actual: candidate([][]int{[]int{5, 8, 9}, []int{6, 4, 3}, []int{2, 1, 4}}), expected: [][]int{[]int{2, 1, 4}, []int{6, 4, 3}, []int{5, 8, 9}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    // sort by row sum\n    sums := make([]int, len(M))\n    for i := 0; i < len(M); i++ {\n        for j := 0; j < len(M[i]); j++ {\n            sums[i] += M[i][j]\n        }\n    }\n    for i := 0; i < len(M); i++ {\n        for j := i + 1; j < len(M); j++ {\n            if sums[i] > sums[j] {\n                sums[i], sums[j] = sums[j], sums[i]\n                M[i], M[j] = M[j], M[i]\n            }\n        }\n    }\n    return M\n}\n",
    "    // sort rows by sum\n    sums := make([]int, len(M))\n    for i := 0; i < len(M); i++ {\n        for j := 0; j < len(M[i]); j++ {\n            sums[i] += M[i][j]\n        }\n    }\n    for i := 0; i < len(M); i++ {\n        for j := i + 1; j < len(M); j++ {\n            if sums[i] > sums[j] {\n                sums[i], sums[j] = sums[j], sums[i]\n                M[i], M[j] = M[j], M[i]\n            }\n        }\n    }\n    return M\n}\n",
    "    // sort by row sum\n    for i := 0; i < len(M); i++ {\n        for j := i + 1; j < len(M); j++ {\n            if sum(M[i]) > sum(M[j]) {\n                M[i], M[j] = M[j], M[i]\n            }\n        }\n    }\n    return M\n}\n",
    "    // sort by row sum\n    for i := 0; i < len(M); i++ {\n        for j := i + 1; j < len(M); j++ {\n            if sum(M[i]) > sum(M[j]) {\n                M[i], M[j] = M[j], M[i]\n            }\n        }\n    }\n    return M\n}\n",
    "    // sort the rows by the sum of the row\n    // sort.Slice(M, func(i, j int) bool {\n    //     return sum(M[i]) < sum(M[j])\n    // })\n\n    // sort the rows by the sum of the row\n    for i := 0; i < len(M); i++ {\n        for j := i + 1; j < len(M); j++ {\n            if sum(M[i]) > sum(M[j]) {\n                M[i], M[j] = M[j], M[i]\n            }\n        }\n    }\n\n    return M\n}\n",
    "    // TODO - Add your code here\n    return nil\n}\n",
    "    N := len(M)\n    sums := make([]int, N)\n    for i := 0; i < N; i++ {\n        for j := 0; j < N; j++ {\n            sums[i] += M[i][j]\n        }\n    }\n\n    for i := 0; i < N; i++ {\n        for j := i + 1; j < N; j++ {\n            if sums[i] > sums[j] {\n                sums[i], sums[j] = sums[j], sums[i]\n                M[i], M[j] = M[j], M[i]\n            }\n        }\n    }\n    return M\n}\n",
    "    // sort by row sum\n    row_sums := make([]int, len(M))\n    for i := 0; i < len(M); i++ {\n        row_sums[i] = 0\n        for j := 0; j < len(M[i]); j++ {\n            row_sums[i] += M[i][j]\n        }\n    }\n    for i := 0; i < len(M); i++ {\n        for j := i + 1; j < len(M); j++ {\n            if row_sums[i] > row_sums[j] {\n                row_sums[i], row_sums[j] = row_sums[j], row_sums[i]\n                M[i], M[j] = M[j], M[i]\n            }\n        }\n    }\n    return M\n}\n",
    "    if len(M) == 0 {\n        return M\n    }\n    // sort by row sum\n    sums := make([]int, len(M))\n    for i := 0; i < len(M); i++ {\n        for j := 0; j < len(M[i]); j++ {\n            sums[i] += M[i][j]\n        }\n    }\n    for i := 0; i < len(M); i++ {\n        for j := i + 1; j < len(M); j++ {\n            if sums[i] > sums[j] {\n                M[i], M[j] = M[j], M[i]\n                sums[i], sums[j] = sums[j], sums[i]\n            }\n        }\n    }\n    return M\n}\n",
    "    // TODO - Add your code here\n    return nil\n}\n",
    "    // TODO - Add your code here\n    return nil\n}\n",
    "    var sums []int\n    var rows [][]int\n    for _, row := range M {\n        sum := 0\n        for _, val := range row {\n            sum += val\n        }\n        sums = append(sums, sum)\n        rows = append(rows, row)\n    }\n    for i := 0; i < len(sums); i++ {\n        for j := i + 1; j < len(sums); j++ {\n            if sums[i] > sums[j] {\n                sums[i], sums[j] = sums[j], sums[i]\n                rows[i], rows[j] = rows[j], rows[i]\n            }\n        }\n    }\n    return rows\n}\n",
    "    if len(M) == 0 {\n        return M\n    }\n    if len(M[0]) == 0 {\n        return M\n    }\n\n    sums := make([]int, len(M))\n    for i := 0; i < len(M); i++ {\n        for j := 0; j < len(M[i]); j++ {\n            sums[i] += M[i][j]\n        }\n    }\n\n    for i := 0; i < len(M); i++ {\n        for j := i+1; j < len(M); j++ {\n            if sums[i] > sums[j] {\n                sums[i], sums[j] = sums[j], sums[i]\n                M[i], M[j] = M[j], M[i]\n            }\n        }\n    }\n\n    return M\n}\n",
    "    var row_sums []int\n    for i := 0; i < len(M); i++ {\n        sum := 0\n        for j := 0; j < len(M[i]); j++ {\n            sum += M[i][j]\n        }\n        row_sums = append(row_sums, sum)\n    }\n    for i := 0; i < len(row_sums); i++ {\n        for j := i + 1; j < len(row_sums); j++ {\n            if row_sums[i] > row_sums[j] {\n                row_sums[i], row_sums[j] = row_sums[j], row_sums[i]\n                M[i], M[j] = M[j], M[i]\n            }\n        }\n    }\n    return M\n}\n",
    "    var sums []int\n    for _, row := range M {\n        sum := 0\n        for _, val := range row {\n            sum += val\n        }\n        sums = append(sums, sum)\n    }\n    for i := 0; i < len(sums); i++ {\n        for j := i + 1; j < len(sums); j++ {\n            if sums[i] > sums[j] {\n                sums[i], sums[j] = sums[j], sums[i]\n                M[i], M[j] = M[j], M[i]\n            }\n        }\n    }\n    return M\n}\n",
    "    // TODO - Add your code here\n    return nil\n}\n",
    "    // sort by row sum\n    sums := make([]int, len(M))\n    for i := 0; i < len(M); i++ {\n        for j := 0; j < len(M[i]); j++ {\n            sums[i] += M[i][j]\n        }\n    }\n    for i := 0; i < len(M); i++ {\n        for j := i + 1; j < len(M); j++ {\n            if sums[i] > sums[j] {\n                M[i], M[j] = M[j], M[i]\n                sums[i], sums[j] = sums[j], sums[i]\n            }\n        }\n    }\n    return M\n}\n",
    "    // sort matrix by row sum\n    for i := 0; i < len(M); i++ {\n        for j := i + 1; j < len(M); j++ {\n            if sum(M[i]) > sum(M[j]) {\n                M[i], M[j] = M[j], M[i]\n            }\n        }\n    }\n    return M\n}\n",
    "    // sort by row sum\n    // bubble sort\n    for i := 0; i < len(M); i++ {\n        for j := i + 1; j < len(M); j++ {\n            if sum(M[i]) > sum(M[j]) {\n                M[i], M[j] = M[j], M[i]\n            }\n        }\n    }\n    return M\n}\n",
    "    // sort matrix by row sum\n    for i := 0; i < len(M); i++ {\n        for j := i + 1; j < len(M); j++ {\n            if sum(M[i]) > sum(M[j]) {\n                M[i], M[j] = M[j], M[i]\n            }\n        }\n    }\n    return M\n}\n"
  ]
}