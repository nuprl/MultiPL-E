{
  "name": "mbpp_457_Find_Min",
  "language": "go_test.go",
  "prompt": "package Find_Min_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst interface{}) interface{} {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_457_Find_Min.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestFind_Min(t *testing.T) {\n  candidate := Find_Min\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1}, []int{1, 2}, []int{1, 2, 3}}), expected: []int{1} },\n     { actual: candidate([][]int{[]int{1, 1}, []int{1, 1, 1}, []int{1, 2, 7, 8}}), expected: []int{1, 1} },\n     { actual: candidate([][]int{[]string{\"x\"}, []string{\"x\", \"y\"}, []string{\"x\", \"y\", \"z\"}}), expected: []string{\"x\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n                min_len = len(v.([]interface{}))\n            } else {\n                if len(v.([]interface{})) < min_len {\n                    min = v\n                    min_len = len(v.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            lst_lst := lst.([]interface{})\n            min_lst := lst_lst[0]\n            for _, lst := range lst_lst {\n                if len(lst.([]interface{})) < len(min_lst.([]interface{})) {\n                    min_lst = lst\n                }\n            }\n            return min_lst\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst := lst.([]int)\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case []string:\n        lst := lst.([]string)\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case [][]int:\n        lst := lst.([][]int)\n        min := lst[0]\n        for _, v := range lst {\n            if len(v) < len(min) {\n                min = v\n            }\n        }\n        return min\n    case [][]string:\n        lst := lst.([][]string)\n        min := lst[0]\n        for _, v := range lst {\n            if len(v) < len(min) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []int:\n            return Find_Min_int(lst.([]int))\n        case []string:\n            return Find_Min_string(lst.([]string))\n        case []interface{}:\n            return Find_Min_interface(lst.([]interface{}))\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_lst := lst.([]interface{})\n        min_lst := lst_lst[0]\n        for _, lst := range lst_lst {\n            if len(lst.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = lst\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, item := range lst.([]interface{}) {\n            if len(item.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = item\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min_len := len(lst.([]interface{}))\n        for _, item := range lst.([]interface{}) {\n            if len(item.([]interface{})) < min_len {\n                min = item\n                min_len = len(item.([]interface{}))\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min_len := len(lst.([]interface{}))\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < min_len {\n                min = v\n                min_len = len(v.([]interface{}))\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case []float64:\n        return Find_Min_float64(lst.([]float64))\n    case []interface{}:\n        return Find_Min_interface(lst.([]interface{}))\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        min_int := lst_int[0]\n        for _, v := range lst_int {\n            if v < min_int {\n                min_int = v\n            }\n        }\n        return min_int\n    case []string:\n        lst_str := lst.([]string)\n        min_str := lst_str[0]\n        for _, v := range lst_str {\n            if v < min_str {\n                min_str = v\n            }\n        }\n        return min_str\n    case [][]int:\n        lst_lst := lst.([][]int)\n        min_lst := lst_lst[0]\n        for _, v := range lst_lst {\n            if len(v) < len(min_lst) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min_len := len(lst.([]interface{}))\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < min_len {\n                min = v\n                min_len = len(v.([]interface{}))\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min_len := len(lst.([]interface{}))\n        for _, v := range lst.([]interface{}) {\n            if v_len := len(Find_Min(v).([]interface{})); v_len < min_len {\n                min = v\n                min_len = v_len\n            }\n        }\n        return min\n    case int:\n        return lst\n    default:\n        return nil\n    }\n}\n",
    "    var min_lst interface{}\n    min_len := len(lst.([]interface{}))\n    for _, item := range lst.([]interface{}) {\n        if len(item.([]interface{})) < min_len {\n            min_lst = item\n            min_len = len(item.([]interface{}))\n        }\n    }\n    return min_lst\n}\n",
    "    switch lst.(type) {\n    case []int:\n        var min_lst []int\n        var min_len int\n        for _, v := range lst.([]int) {\n            if min_len == 0 || len(v) < min_len {\n                min_lst = v\n                min_len = len(v)\n            }\n        }\n        return min_lst\n    case []string:\n        var min_lst []string\n        var min_len int\n        for _, v := range lst.([]string) {\n            if min_len == 0 || len(v) < min_len {\n                min_lst = v\n                min_len = len(v)\n            }\n        }\n        return min_lst\n    case []interface{}:\n        var min_lst []interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min_len == 0 || len(v) < min_len {\n                min_lst = v\n                min_len = len(v)\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch v := lst.(type) {\n    case []interface{}:\n        min := v[0]\n        for _, i := range v {\n            if len(i.([]interface{})) < len(min.([]interface{})) {\n                min = i\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return lst\n        }\n        min_lst := lst.([]interface{})[0]\n        for _, item := range lst.([]interface{}) {\n            if len(Find_Min(item).([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = item\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            lst_lst := lst.([]interface{})\n            min_lst := lst_lst[0]\n            for _, lst := range lst_lst {\n                if len(lst.([]interface{})) < len(min_lst.([]interface{})) {\n                    min_lst = lst\n                }\n            }\n            return min_lst\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_lst := lst.([]interface{})\n        min_lst := lst_lst[0]\n        for _, lst := range lst_lst {\n            if len(lst.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = lst\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    var min interface{}\n    switch lst.(type) {\n    case []int:\n        min = lst.([]int)[0]\n        for _, v := range lst.([]int) {\n            if v < min.(int) {\n                min = v\n            }\n        }\n    case []string:\n        min = lst.([]string)[0]\n        for _, v := range lst.([]string) {\n            if v < min.(string) {\n                min = v\n            }\n        }\n    case []float64:\n        min = lst.([]float64)[0]\n        for _, v := range lst.([]float64) {\n            if v < min.(float64) {\n                min = v\n            }\n        }\n    }\n    return min\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_lst := lst.([]interface{})\n        min_lst := lst_lst[0]\n        for _, lst := range lst_lst {\n            if len(lst.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = lst\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case [][]int:\n        return Find_Min_int_slice(lst.([][]int))\n    case [][]string:\n        return Find_Min_string_slice(lst.([][]string))\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return []interface{}{}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int = len(lst.([]interface{}))\n        for _, v := range lst.([]interface{}) {\n            if v_len := len(Find_Min(v).([]interface{})); v_len < min_len {\n                min = v\n                min_len = v_len\n            }\n        }\n        return min\n    default:\n        return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        min := lst.([]int)[0]\n        for _, v := range lst.([]int) {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case []string:\n        min := lst.([]string)[0]\n        for _, v := range lst.([]string) {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case [][]int:\n        min := lst.([][]int)[0]\n        for _, v := range lst.([][]int) {\n            if len(v) < len(min) {\n                min = v\n            }\n        }\n        return min\n    case [][]string:\n        min := lst.([][]string)[0]\n        for _, v := range lst.([][]string) {\n            if len(v) < len(min) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(min_lst.([]interface{})) > len(v.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return lst\n        }\n        min_len := lst_len\n        min_lst := lst\n        for _, item := range lst.([]interface{}) {\n            sub_lst := Find_Min(item)\n            sub_lst_len := len(sub_lst.([]interface{}))\n            if sub_lst_len < min_len {\n                min_len = sub_lst_len\n                min_lst = sub_lst\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{}\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            lst_lst := lst.([]interface{})\n            min_lst := lst_lst[0]\n            for _, lst := range lst_lst {\n                if len(lst.([]interface{})) < len(min_lst.([]interface{})) {\n                    min_lst = lst\n                }\n            }\n            return min_lst\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        min := lst.([]int)[0]\n        for _, v := range lst.([]int) {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case []string:\n        min := lst.([]string)[0]\n        for _, v := range lst.([]string) {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case [][]int:\n        min := lst.([][]int)[0]\n        for _, v := range lst.([][]int) {\n            if len(v) < len(min) {\n                min = v\n            }\n        }\n        return min\n    case [][]string:\n        min := lst.([][]string)[0]\n        for _, v := range lst.([][]string) {\n            if len(v) < len(min) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_ := lst.([]interface{})\n        min_ := lst_[0]\n        for _, v := range lst_ {\n            if len(v.([]interface{})) < len(min_.([]interface{})) {\n                min_ = v\n            }\n        }\n        return min_\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        min_int := lst_int[0]\n        for _, v := range lst_int {\n            if v < min_int {\n                min_int = v\n            }\n        }\n        return min_int\n    case []string:\n        lst_string := lst.([]string)\n        min_string := lst_string[0]\n        for _, v := range lst_string {\n            if v < min_string {\n                min_string = v\n            }\n        }\n        return min_string\n    case []float64:\n        lst_float := lst.([]float64)\n        min_float := lst_float[0]\n        for _, v := range lst_float {\n            if v < min_float {\n                min_float = v\n            }\n        }\n        return min_float\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst := lst.([]int)\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case [][]int:\n        lst := lst.([][]int)\n        min := lst[0]\n        for _, v := range lst {\n            if len(v) < len(min) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{} = lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return lst\n        }\n        min_lst := lst.([]interface{})[0]\n        for _, item := range lst.([]interface{}) {\n            if len(Find_Min(item).([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = item\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n                min_len = len(v.([]interface{}))\n            } else if len(v.([]interface{})) < min_len {\n                min = v\n                min_len = len(v.([]interface{}))\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return nil\n        }\n        min_lst := lst.([]interface{})[0]\n        for i := 1; i < lst_len; i++ {\n            if len(Find_Min(lst.([]interface{})[i]).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                min_lst = lst.([]interface{})[i]\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        min := l[0]\n        for _, v := range l {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []int:\n            var min int = len(lst.([]int))\n            var sublist []int\n            for _, v := range lst.([]int) {\n                if len(v) < min {\n                    min = len(v)\n                    sublist = v\n                }\n            }\n            return sublist\n        case []string:\n            var min int = len(lst.([]string))\n            var sublist []string\n            for _, v := range lst.([]string) {\n                if len(v) < min {\n                    min = len(v)\n                    sublist = v\n                }\n            }\n            return sublist\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{}\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return []interface{}{}\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case []float64:\n        return Find_Min_float64(lst.([]float64))\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_len := -1\n        for _, v := range lst.([]interface{}) {\n            if min_len == -1 || len(v.([]interface{})) < min_len {\n                min_lst = v\n                min_len = len(v.([]interface{}))\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    // TODO: Implement me!\n    return nil\n}\n",
    "    switch lst.(type) {\n        case []int:\n            var min_lst []int\n            for _, v := range lst.([]int) {\n                if len(min_lst) == 0 || len(v) < len(min_lst) {\n                    min_lst = v\n                }\n            }\n            return min_lst\n        case []string:\n            var min_lst []string\n            for _, v := range lst.([]string) {\n                if len(min_lst) == 0 || len(v) < len(min_lst) {\n                    min_lst = v\n                }\n            }\n            return min_lst\n        case []float64:\n            var min_lst []float64\n            for _, v := range lst.([]float64) {\n                if len(min_lst) == 0 || len(v) < len(min_lst) {\n                    min_lst = v\n                }\n            }\n            return min_lst\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, item := range lst.([]interface{}) {\n            if min == nil {\n                min = item\n                min_len = len(item.([]interface{}))\n            } else {\n                if len(item.([]interface{})) < min_len {\n                    min = item\n                    min_len = len(item.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst := lst.([]int)\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case [][]int:\n        lst := lst.([][]int)\n        min := len(lst[0])\n        for _, v := range lst {\n            if len(v) < min {\n                min = len(v)\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            min := lst.([]interface{})[0]\n            for _, v := range lst.([]interface{}) {\n                if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                    min = v\n                }\n            }\n            return min\n        default:\n            return lst\n    }\n}\n",
    "    if lst == nil {\n        return nil\n    }\n    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case []interface{}:\n        return Find_Min_interface(lst.([]interface{}))\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        min_int := lst_int[0]\n        for _, v := range lst_int {\n            if v < min_int {\n                min_int = v\n            }\n        }\n        return min_int\n    case []string:\n        lst_str := lst.([]string)\n        min_str := lst_str[0]\n        for _, v := range lst_str {\n            if v < min_str {\n                min_str = v\n            }\n        }\n        return min_str\n    case []float64:\n        lst_float := lst.([]float64)\n        min_float := lst_float[0]\n        for _, v := range lst_float {\n            if v < min_float {\n                min_float = v\n            }\n        }\n        return min_float\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            var min_lst interface{} = lst\n            for _, v := range lst.([]interface{}) {\n                if len(Find_Min(v).([]interface{})) < len(min_lst.([]interface{})) {\n                    min_lst = v\n                }\n            }\n            return min_lst\n        default:\n            return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            var min_lst interface{}\n            min_len := len(lst.([]interface{}))\n            for _, item := range lst.([]interface{}) {\n                if len(item.([]interface{})) < min_len {\n                    min_len = len(item.([]interface{}))\n                    min_lst = item\n                }\n            }\n            return min_lst\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n                min_len = len(v.([]interface{}))\n            } else {\n                if len(v.([]interface{})) < min_len {\n                    min = v\n                    min_len = len(v.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_ := lst.([]interface{})\n        if len(lst_) == 0 {\n            return nil\n        }\n        min_ := lst_[0]\n        for _, v := range lst_ {\n            if len(v.([]interface{})) < len(min_.([]interface{})) {\n                min_ = v\n            }\n        }\n        return min_\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        return lst.([]int)\n    case [][]int:\n        return lst.([][]int)\n    case []string:\n        return lst.([]string)\n    case [][]string:\n        return lst.([][]string)\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            var min interface{}\n            min_len := len(lst.([]interface{}))\n            for _, v := range lst.([]interface{}) {\n                if v_len := len(v.([]interface{})); v_len < min_len {\n                    min = v\n                    min_len = v_len\n                }\n            }\n            return min\n        default:\n            return lst\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            min_lst := lst.([]interface{})\n            for _, v := range lst.([]interface{}) {\n                if len(v.([]interface{})) < len(min_lst) {\n                    min_lst = v.([]interface{})\n                }\n            }\n            return min_lst\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            if len(lst.([]interface{})) == 0 {\n                return nil\n            }\n            min_lst := lst.([]interface{})[0]\n            for _, item := range lst.([]interface{}) {\n                if len(Find_Min(item).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                    min_lst = item\n                }\n            }\n            return min_lst\n        case int:\n            return []interface{}{lst}\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        return []int{}\n    case [][]int:\n        return [][]int{}\n    case []string:\n        return []string{}\n    case [][]string:\n        return [][]string{}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        min := lst.([]int)[0]\n        for _, v := range lst.([]int) {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case [][]int:\n        min := lst.([][]int)[0]\n        for _, v := range lst.([][]int) {\n            if len(v) < len(min) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            var min interface{}\n            var min_len int\n            for _, v := range lst.([]interface{}) {\n                if min == nil {\n                    min = v\n                    min_len = len(v.([]interface{}))\n                } else {\n                    if len(v.([]interface{})) < min_len {\n                        min = v\n                        min_len = len(v.([]interface{}))\n                    }\n                }\n            }\n            return min\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_ := lst.([]interface{})\n        min_ := lst_[0]\n        for _, v := range lst_ {\n            if len(v.([]interface{})) < len(min_.([]interface{})) {\n                min_ = v\n            }\n        }\n        return min_\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return nil\n        }\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    var min interface{}\n    switch lst.(type) {\n    case []interface{}:\n        min = lst\n        for _, item := range lst.([]interface{}) {\n            if len(Find_Min(item).([]interface{})) < len(min.([]interface{})) {\n                min = item\n            }\n        }\n    default:\n        min = []interface{}{}\n    }\n    return min\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n            } else if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_lst := lst.([]interface{})\n        min_lst := lst_lst[0]\n        for _, lst := range lst_lst {\n            if len(lst.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = lst\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    var min interface{}\n    switch lst.(type) {\n    case []interface{}:\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n    default:\n        min = []interface{}{}\n    }\n    return min\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int = len(lst.([]interface{}))\n        for _, v := range lst.([]interface{}) {\n            if v_len := len(Find_Min(v).([]interface{})); v_len < min_len {\n                min_len = v_len\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, v := range lst {\n            min = Find_Min([]interface{}{min, v})\n        }\n        return min\n    case string:\n        return lst.(string)\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n                min_len = len(v.([]interface{}))\n            } else {\n                if len(v.([]interface{})) < min_len {\n                    min = v\n                    min_len = len(v.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min_len := len(lst.([]interface{}))\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < min_len {\n                min = v\n                min_len = len(v.([]interface{}))\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return nil\n        }\n        min_lst := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n                min_len = len(v.([]interface{}))\n            } else {\n                if len(v.([]interface{})) < min_len {\n                    min = v\n                    min_len = len(v.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, item := range lst.([]interface{}) {\n            if len(item.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = item\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            lst_len := len(lst.([]interface{}))\n            if lst_len == 0 {\n                return nil\n            }\n            min_lst := lst.([]interface{})[0]\n            for _, v := range lst.([]interface{}) {\n                if len(Find_Min(v).([]interface{})) < len(min_lst.([]interface{})) {\n                    min_lst = v\n                }\n            }\n            return min_lst\n        default:\n            return []interface{}{}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_lst = lst\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            min := lst.([]interface{})[0]\n            for _, item := range lst.([]interface{}) {\n                if len(Find_Min(item).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                    min = item\n                }\n            }\n            return min\n        default:\n            return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_lst := lst.([]interface{})\n        if len(lst_lst) == 0 {\n            return nil\n        }\n        min_lst := lst_lst[0]\n        for _, lst := range lst_lst {\n            if len(lst.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = lst\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_ := lst.([]interface{})\n        if len(lst_) == 0 {\n            return nil\n        }\n        min_ := lst_[0]\n        for _, v := range lst_[1:] {\n            if len(v.([]interface{})) < len(min_.([]interface{})) {\n                min_ = v\n            }\n        }\n        return min_\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        min_int := lst_int[0]\n        for _, v := range lst_int {\n            if v < min_int {\n                min_int = v\n            }\n        }\n        return min_int\n    case []string:\n        lst_string := lst.([]string)\n        min_string := lst_string[0]\n        for _, v := range lst_string {\n            if len(v) < len(min_string) {\n                min_string = v\n            }\n        }\n        return min_string\n    case []float64:\n        lst_float := lst.([]float64)\n        min_float := lst_float[0]\n        for _, v := range lst_float {\n            if v < min_float {\n                min_float = v\n            }\n        }\n        return min_float\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        var min_lst []int\n        min_lst = lst.([]int)\n        for _, v := range lst.([]int) {\n            if len(v) < len(min_lst) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    case []string:\n        var min_lst []string\n        min_lst = lst.([]string)\n        for _, v := range lst.([]string) {\n            if len(v) < len(min_lst) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return nil\n        }\n        min_len := lst_len\n        min_lst := lst\n        for _, v := range lst.([]interface{}) {\n            if v_len := len(Find_Min(v).([]interface{})); v_len < min_len {\n                min_len = v_len\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case [][]int:\n        return Find_Min_int_slice(lst.([][]int))\n    case [][]string:\n        return Find_Min_string_slice(lst.([][]string))\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_lst = lst\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, item := range lst.([]interface{}) {\n            if len(item.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = item\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    if lst == nil {\n        return nil\n    }\n    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_len := len(lst.([]interface{}))\n        for _, item := range lst.([]interface{}) {\n            if item == nil {\n                continue\n            }\n            switch item.(type) {\n            case []interface{}:\n                if len(item.([]interface{})) < min_len {\n                    min_lst = item\n                    min_len = len(item.([]interface{}))\n                }\n            case int:\n                if min_lst == nil {\n                    min_lst = item\n                    min_len = 1\n                }\n            }\n        }\n        return min_lst\n    case int:\n        return lst\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        min_int := lst_int[0]\n        for _, v := range lst_int {\n            if v < min_int {\n                min_int = v\n            }\n        }\n        return min_int\n    case []string:\n        lst_str := lst.([]string)\n        min_str := lst_str[0]\n        for _, v := range lst_str {\n            if v < min_str {\n                min_str = v\n            }\n        }\n        return min_str\n    case []float64:\n        lst_float := lst.([]float64)\n        min_float := lst_float[0]\n        for _, v := range lst_float {\n            if v < min_float {\n                min_float = v\n            }\n        }\n        return min_float\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst := lst.([]int)\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case [][]int:\n        lst := lst.([][]int)\n        min := lst[0]\n        for _, v := range lst {\n            if len(v) < len(min) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        var min_lst []int\n        for _, v := range lst.([]int) {\n            if len(min_lst) == 0 {\n                min_lst = append(min_lst, v)\n            } else if len(min_lst) > 0 && len(min_lst) > len(v) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    case []string:\n        var min_lst []string\n        for _, v := range lst.([]string) {\n            if len(min_lst) == 0 {\n                min_lst = append(min_lst, v)\n            } else if len(min_lst) > 0 && len(min_lst) > len(v) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    case []interface{}:\n        var min_lst []interface{}\n        for _, v := range lst.([]interface{}) {\n            if len(min_lst) == 0 {\n                min_lst = append(min_lst, v)\n            } else if len(min_lst) > 0 && len(min_lst) > len(v) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        min_lst := lst[0]\n        min_len := len(min_lst.([]interface{}))\n        for _, item := range lst {\n            if len(item.([]interface{})) < min_len {\n                min_lst = item\n                min_len = len(item.([]interface{}))\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            var min interface{}\n            min = lst\n            for _, v := range lst.([]interface{}) {\n                if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n            return min\n        default:\n            return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_len := len(lst.([]interface{}))\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < min_len {\n                min_len = len(v.([]interface{}))\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []int:\n            return Find_Min_int(lst.([]int))\n        case []string:\n            return Find_Min_string(lst.([]string))\n        case []interface{}:\n            return Find_Min_interface(lst.([]interface{}))\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_lst := lst.([]interface{})\n        min_lst := lst_lst[0]\n        for _, sub_lst := range lst_lst[1:] {\n            if len(sub_lst.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = sub_lst\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        return find_min_int(lst.([]int))\n    case []string:\n        return find_min_string(lst.([]string))\n    case [][]int:\n        return find_min_int_slice(lst.([][]int))\n    case [][]string:\n        return find_min_string_slice(lst.([][]string))\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        min_int := lst_int[0]\n        for _, v := range lst_int {\n            if v < min_int {\n                min_int = v\n            }\n        }\n        return min_int\n    case []string:\n        lst_str := lst.([]string)\n        min_str := lst_str[0]\n        for _, v := range lst_str {\n            if len(v) < len(min_str) {\n                min_str = v\n            }\n        }\n        return min_str\n    case [][]int:\n        lst_lst := lst.([][]int)\n        min_lst := lst_lst[0]\n        for _, v := range lst_lst {\n            if len(v) < len(min_lst) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})\n        for _, item := range lst.([]interface{}) {\n            if len(Find_Min(item).([]interface{})) < len(min_lst) {\n                min_lst = Find_Min(item).([]interface{})\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, item := range lst.([]interface{}) {\n            if len(Find_Min(item).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                min_lst = item\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        min := lst_int[0]\n        for _, v := range lst_int {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case []string:\n        lst_str := lst.([]string)\n        min := lst_str[0]\n        for _, v := range lst_str {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case [][]int:\n        lst_lst := lst.([][]int)\n        min := len(lst_lst[0])\n        for _, v := range lst_lst {\n            if len(v) < min {\n                min = len(v)\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case [][]int:\n        return Find_Min_int_slice(lst.([][]int))\n    case [][]string:\n        return Find_Min_string_slice(lst.([][]string))\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case [][]int:\n        return Find_Min_int_slice(lst.([][]int))\n    case [][]string:\n        return Find_Min_string_slice(lst.([][]string))\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n                min_len = len(v.([]interface{}))\n            } else {\n                if len(v.([]interface{})) < min_len {\n                    min = v\n                    min_len = len(v.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case [][]int:\n        return Find_Min_int_slice(lst.([][]int))\n    case [][]string:\n        return Find_Min_string_slice(lst.([][]string))\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min_len == 0 {\n                min = v\n                min_len = len(v.([]interface{}))\n            } else {\n                if len(v.([]interface{})) < min_len {\n                    min = v\n                    min_len = len(v.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min_len == 0 {\n                min = v\n                min_len = len(v.([]interface{}))\n            } else {\n                if len(v.([]interface{})) < min_len {\n                    min = v\n                    min_len = len(v.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst_int := lst.([]int)\n        min_int := lst_int[0]\n        for _, v := range lst_int {\n            if v < min_int {\n                min_int = v\n            }\n        }\n        return min_int\n    case []string:\n        lst_str := lst.([]string)\n        min_str := lst_str[0]\n        for _, v := range lst_str {\n            if v < min_str {\n                min_str = v\n            }\n        }\n        return min_str\n    case [][]int:\n        lst_lst := lst.([][]int)\n        min_lst := lst_lst[0]\n        for _, v := range lst_lst {\n            if len(v) < len(min_lst) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})\n        for _, item := range lst.([]interface{}) {\n            if len(Find_Min(item).([]interface{})) < len(min_lst) {\n                min_lst = Find_Min(item).([]interface{})\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n        case []int:\n            return Find_Min_int(lst.([]int))\n        case []string:\n            return Find_Min_string(lst.([]string))\n        case []interface{}:\n            return Find_Min_interface(lst.([]interface{}))\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return []interface{}{}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        min_lst := lst[0]\n        for _, v := range lst {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_ := lst.([]interface{})\n        min_ := lst_[0]\n        for _, v := range lst_ {\n            if len(v.([]interface{})) < len(min_.([]interface{})) {\n                min_ = v\n            }\n        }\n        return min_\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min_len int = len(lst.([]interface{}))\n        var min_lst interface{} = lst\n        for _, v := range lst.([]interface{}) {\n            if v_len := len(Find_Min(v).([]interface{})); v_len < min_len {\n                min_len = v_len\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    case int:\n        return lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_lst = lst\n        for _, item := range lst.([]interface{}) {\n            if len(item.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = item\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        min_lst := lst.([]int)\n        for _, l := range lst.([]int) {\n            if len(l) < len(min_lst) {\n                min_lst = l\n            }\n        }\n        return min_lst\n    case []string:\n        min_lst := lst.([]string)\n        for _, l := range lst.([]string) {\n            if len(l) < len(min_lst) {\n                min_lst = l\n            }\n        }\n        return min_lst\n    case []float64:\n        min_lst := lst.([]float64)\n        for _, l := range lst.([]float64) {\n            if len(l) < len(min_lst) {\n                min_lst = l\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            var min interface{}\n            min_len := len(lst.([]interface{}))\n            for _, v := range lst.([]interface{}) {\n                if len(v.([]interface{})) < min_len {\n                    min = v\n                    min_len = len(v.([]interface{}))\n                }\n            }\n            return min\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        var min_lst []int\n        for _, v := range lst.([]int) {\n            if len(min_lst) == 0 {\n                min_lst = append(min_lst, v)\n            } else if len(min_lst) > len(v) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    case []string:\n        var min_lst []string\n        for _, v := range lst.([]string) {\n            if len(min_lst) == 0 {\n                min_lst = append(min_lst, v)\n            } else if len(min_lst) > len(v) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min_sublist interface{}\n        min_sublist = lst\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min_sublist.([]interface{})) {\n                min_sublist = v\n            }\n        }\n        return min_sublist\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_len := len(lst.([]interface{}))\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < min_len {\n                min_lst = v\n                min_len = len(v.([]interface{}))\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        return Find_Min_Int(lst.([]int))\n    case []string:\n        return Find_Min_String(lst.([]string))\n    case []float64:\n        return Find_Min_Float64(lst.([]float64))\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    var min interface{}\n    switch lst.(type) {\n    case []interface{}:\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n    }\n    return min\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            min := lst.([]interface{})[0]\n            for _, v := range lst.([]interface{}) {\n                if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                    min = v\n                }\n            }\n            return min\n        default:\n            return []interface{}{}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_len := len(lst.([]interface{}))\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < min_len {\n                min_len = len(v.([]interface{}))\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        min_lst := lst[0]\n        for _, item := range lst {\n            min_lst = Find_Min(min_lst).([]interface{})\n            item = Find_Min(item).([]interface{})\n            if len(item) < len(min_lst) {\n                min_lst = item\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n            } else {\n                if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case [][]int:\n        return Find_Min_int_slice(lst.([][]int))\n    case [][]string:\n        return Find_Min_string_slice(lst.([][]string))\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        }\n        min_lst := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            var min interface{}\n            min_len := len(lst.([]interface{}))\n            for _, item := range lst.([]interface{}) {\n                if len(item.([]interface{})) < min_len {\n                    min = item\n                    min_len = len(item.([]interface{}))\n                }\n            }\n            return min\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        min := lst.([]int)[0]\n        for _, v := range lst.([]int) {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case []string:\n        min := lst.([]string)[0]\n        for _, v := range lst.([]string) {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case [][]int:\n        min := lst.([][]int)[0]\n        for _, v := range lst.([][]int) {\n            if len(v) < len(min) {\n                min = v\n            }\n        }\n        return min\n    case [][]string:\n        min := lst.([][]string)[0]\n        for _, v := range lst.([][]string) {\n            if len(v) < len(min) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_lst = lst\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            lst_l := lst.([]interface{})\n            min_l := lst_l[0]\n            for _, v := range lst_l {\n                if len(v.([]interface{})) < len(min_l.([]interface{})) {\n                    min_l = v\n                }\n            }\n            return min_l\n        default:\n            return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n            } else {\n                if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []int:\n            return lst.([]int)\n        case []string:\n            return lst.([]string)\n        case [][]int:\n            return lst.([][]int)\n        case [][]string:\n            return lst.([][]string)\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        var min_lst []int\n        var min_len = len(lst.([]int))\n        for _, v := range lst.([]int) {\n            if len(v) < min_len {\n                min_lst = v\n                min_len = len(v)\n            }\n        }\n        return min_lst\n    case []string:\n        var min_lst []string\n        var min_len = len(lst.([]string))\n        for _, v := range lst.([]string) {\n            if len(v) < min_len {\n                min_lst = v\n                min_len = len(v)\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []int:\n            lst_int := lst.([]int)\n            min_int := lst_int[0]\n            for _, v := range lst_int {\n                if v < min_int {\n                    min_int = v\n                }\n            }\n            return min_int\n        case []string:\n            lst_string := lst.([]string)\n            min_string := lst_string[0]\n            for _, v := range lst_string {\n                if v < min_string {\n                    min_string = v\n                }\n            }\n            return min_string\n        case []float64:\n            lst_float := lst.([]float64)\n            min_float := lst_float[0]\n            for _, v := range lst_float {\n                if v < min_float {\n                    min_float = v\n                }\n            }\n            return min_float\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            min_lst := lst.([]interface{})\n            for _, v := range lst.([]interface{}) {\n                if len(v.([]interface{})) < len(min_lst) {\n                    min_lst = v.([]interface{})\n                }\n            }\n            return min_lst\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n                min_len = len(v.([]interface{}))\n            } else {\n                if len(v.([]interface{})) < min_len {\n                    min = v\n                    min_len = len(v.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    var min_len int = len(lst.([]interface{}))\n    var min_lst interface{} = lst\n    for _, item := range lst.([]interface{}) {\n        if len(item.([]interface{})) < min_len {\n            min_len = len(item.([]interface{}))\n            min_lst = item\n        }\n    }\n    return min_lst\n}\n",
    "    switch lst.(type) {\n    case []int:\n        lst := lst.([]int)\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case []string:\n        lst := lst.([]string)\n        min := lst[0]\n        for _, v := range lst {\n            if v < min {\n                min = v\n            }\n        }\n        return min\n    case [][]int:\n        lst := lst.([][]int)\n        min := lst[0]\n        for _, v := range lst {\n            if len(v) < len(min) {\n                min = v\n            }\n        }\n        return min\n    case [][]string:\n        lst := lst.([][]string)\n        min := lst[0]\n        for _, v := range lst {\n            if len(v) < len(min) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        }\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_lst = lst\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    var min interface{}\n    min = lst\n    switch lst.(type) {\n    case []interface{}:\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n    case [][]interface{}:\n        for _, v := range lst.([][]interface{}) {\n            if len(v) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n    }\n    return min\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return nil\n        }\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case [][]int:\n        return Find_Min_int_slice(lst.([][]int))\n    case [][]string:\n        return Find_Min_string_slice(lst.([][]string))\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, item := range lst.([]interface{}) {\n            if len(Find_Min(item).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                min_lst = item\n            }\n        }\n        return min_lst\n    case int:\n        return []interface{}{lst}\n    default:\n        return []interface{}{}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n                min_len = len(v.([]interface{}))\n            } else {\n                if len(v.([]interface{})) < min_len {\n                    min = v\n                    min_len = len(v.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_lst := lst.([]interface{})\n        min_lst := lst_lst[0]\n        for _, lst := range lst_lst {\n            if len(lst.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = lst\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min_len int = len(lst.([]interface{}))\n        var min_lst interface{} = lst\n        for _, v := range lst.([]interface{}) {\n            if v_lst := Find_Min(v); v_lst != nil {\n                if v_len := len(v_lst.([]interface{})); v_len < min_len {\n                    min_len = v_len\n                    min_lst = v_lst\n                }\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min_len := len(lst.([]interface{}))\n        for _, item := range lst.([]interface{}) {\n            if len(item.([]interface{})) < min_len {\n                min = item\n                min_len = len(item.([]interface{}))\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_l := lst.([]interface{})\n        min_l := lst_l[0]\n        for _, v := range lst_l {\n            if len(v.([]interface{})) < len(min_l.([]interface{})) {\n                min_l = v\n            }\n        }\n        return min_l\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case [][]int:\n        return Find_Min_int_slice(lst.([][]int))\n    case [][]string:\n        return Find_Min_string_slice(lst.([][]string))\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n            } else {\n                if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        if len(lst.([]interface{})) == 0 {\n            return lst\n        } else {\n            return Find_Min(lst.([]interface{})[0])\n        }\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n            } else {\n                if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case []float64:\n        return Find_Min_float64(lst.([]float64))\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min).([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        min = lst\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int = len(lst.([]interface{}))\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < min_len {\n                min = v\n                min_len = len(v.([]interface{}))\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            min_lst := lst.([]interface{})[0]\n            for _, v := range lst.([]interface{}) {\n                if len(Find_Min(v).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                    min_lst = v\n                }\n            }\n            return min_lst\n        default:\n            return lst\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            min_len := len(lst.([]interface{}))\n            min_lst := lst.([]interface{})\n            for _, v := range lst.([]interface{}) {\n                if len(v.([]interface{})) < min_len {\n                    min_len = len(v.([]interface{}))\n                    min_lst = v.([]interface{})\n                }\n            }\n            return min_lst\n        default:\n            return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n            } else {\n                if len(min.([]interface{})) > len(v.([]interface{})) {\n                    min = v\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    var min interface{}\n    min = lst\n    switch lst.(type) {\n    case []interface{}:\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n    }\n    return min\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n            } else {\n                if len(v.([]interface{})) < len(min.([]interface{})) {\n                    min = v\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        var min_lst []int\n        min_lst_len := len(lst.([]int))\n        for _, v := range lst.([]int) {\n            if len(v) < min_lst_len {\n                min_lst = v\n                min_lst_len = len(v)\n            }\n        }\n        return min_lst\n    case []string:\n        var min_lst []string\n        min_lst_len := len(lst.([]string))\n        for _, v := range lst.([]string) {\n            if len(v) < min_lst_len {\n                min_lst = v\n                min_lst_len = len(v)\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []int:\n            lst_int := lst.([]int)\n            min_int := lst_int[0]\n            for _, val := range lst_int {\n                if val < min_int {\n                    min_int = val\n                }\n            }\n            return min_int\n        case []string:\n            lst_str := lst.([]string)\n            min_str := lst_str[0]\n            for _, val := range lst_str {\n                if len(val) < len(min_str) {\n                    min_str = val\n                }\n            }\n            return min_str\n        case []float64:\n            lst_float := lst.([]float64)\n            min_float := lst_float[0]\n            for _, val := range lst_float {\n                if val < min_float {\n                    min_float = val\n                }\n            }\n            return min_float\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        min_lst := lst.([]int)\n        for _, v := range lst.([]int) {\n            if len(v) < len(min_lst) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    case []string:\n        min_lst := lst.([]string)\n        for _, v := range lst.([]string) {\n            if len(v) < len(min_lst) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(Find_Min(v).([]interface{})) < len(Find_Min(min_lst).([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_len := len(lst.([]interface{}))\n        if lst_len == 0 {\n            return nil\n        }\n        min_lst := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        min_lst := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})[0]\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        min_lst := lst.([]interface{})\n        for _, item := range lst.([]interface{}) {\n            if len(Find_Min(item).([]interface{})) < len(min_lst) {\n                min_lst = Find_Min(item).([]interface{})\n            }\n        }\n        return min_lst\n    default:\n        return []interface{}{lst}\n    }\n}\n",
    "    switch lst.(type) {\n        case []int:\n            lst_int := lst.([]int)\n            min_int := lst_int[0]\n            for _, v := range lst_int {\n                if v < min_int {\n                    min_int = v\n                }\n            }\n            return min_int\n        case []string:\n            lst_str := lst.([]string)\n            min_str := lst_str[0]\n            for _, v := range lst_str {\n                if len(v) < len(min_str) {\n                    min_str = v\n                }\n            }\n            return min_str\n        case []interface{}:\n            lst_interface := lst.([]interface{})\n            min_interface := lst_interface[0]\n            for _, v := range lst_interface {\n                if len(v.([]interface{})) < len(min_interface.([]interface{})) {\n                    min_interface = v\n                }\n            }\n            return min_interface\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst_ := lst.([]interface{})\n        min_ := lst_[0]\n        for _, v := range lst_ {\n            if len(v.([]interface{})) < len(min_.([]interface{})) {\n                min_ = v\n            }\n        }\n        return min_\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min_lst interface{}\n        min_lst = lst\n        for _, v := range lst.([]interface{}) {\n            if len(v.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var min interface{}\n        var min_len int\n        for _, v := range lst.([]interface{}) {\n            if min == nil {\n                min = v\n                min_len = len(v.([]interface{}))\n            } else {\n                if len(v.([]interface{})) < min_len {\n                    min = v\n                    min_len = len(v.([]interface{}))\n                }\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            var min_len int\n            var min_lst interface{}\n            for _, v := range lst.([]interface{}) {\n                if min_lst == nil {\n                    min_lst = v\n                    min_len = len(v.([]interface{}))\n                } else {\n                    if len(v.([]interface{})) < min_len {\n                        min_lst = v\n                        min_len = len(v.([]interface{}))\n                    }\n                }\n            }\n            return min_lst\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []int:\n        return Find_Min_int(lst.([]int))\n    case []string:\n        return Find_Min_string(lst.([]string))\n    case []float64:\n        return Find_Min_float64(lst.([]float64))\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return nil\n        }\n        min_lst := l[0]\n        for _, v := range l {\n            if len(v.([]interface{})) < len(min_lst.([]interface{})) {\n                min_lst = v\n            }\n        }\n        return min_lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        min := lst[0]\n        for _, v := range lst {\n            if len(v.([]interface{})) < len(min.([]interface{})) {\n                min = v\n            }\n        }\n        return min\n    default:\n        return nil\n    }\n}\n"
  ]
}