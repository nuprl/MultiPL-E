{
  "name": "mbpp_417_group_tuples",
  "language": "go_test.go",
  "prompt": "package group_tuples_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find common first element in given list of tuple.\nfunc group_tuples(Input [][]interface{}) [][]interface{} {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_417_group_tuples.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestGroup_Tuples(t *testing.T) {\n  candidate := group_tuples\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{\"x\", \"y\"}, []interface{}{\"x\", \"z\"}, []interface{}{\"w\", \"t\"}}), expected: [][]int{[]interface{}{\"x\", \"y\", \"z\"}, []interface{}{\"w\", \"t\"}} },\n     { actual: candidate([][]int{[]interface{}{\"a\", \"b\"}, []interface{}{\"a\", \"c\"}, []interface{}{\"d\", \"e\"}}), expected: [][]int{[]interface{}{\"a\", \"b\", \"c\"}, []interface{}{\"d\", \"e\"}} },\n     { actual: candidate([][]int{[]interface{}{\"f\", \"g\"}, []interface{}{\"f\", \"g\"}, []interface{}{\"h\", \"i\"}}), expected: [][]int{[]interface{}{\"f\", \"g\", \"g\"}, []interface{}{\"h\", \"i\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_index int\n    var temp_count int\n    var temp_count_max int\n    var temp_count_max_index int\n    var temp_count_max_index_count int\n    var temp_count_max_index_count_max int\n    var temp_count_max_index_count_max_index int\n    var temp_count_max_index_count_max_index_count int\n    var temp_count_max_index_count_max_index_count_max int\n    var temp_count_max_index_count_max_index_count_max_index int\n    var temp_count_max_index_count_max_index_count_max_index_count int\n    var temp_count_max_index_count_max_index_count_max_index_count_max int\n    var temp_count_max_index_count_max_index_count_max_index_count_max_index int\n    var temp_count_max_index_count_max_index_count_max_index_count_max_index_count int\n    var temp_count_max_index_count_max_index_count_max_index_count_max_index_count_max int\n    var temp_count_max_index_count_max_index_count_max_index_count_max_index_count_max_index int\n    var temp_count_max_index_count_max_index_count_max_index_count_max_index_count_max_index_count int\n    var temp_count_max_index_count_max_index_count_max_index_count_max_index_count_max_index_count_max int\n    var temp_count_max_index_count_max_index_count_max_index_count_max_index_count_max_index_count_max_index int\n    var temp_count_max_index_count_max_index_count_max_index_count_max_index_count_max_index_count_max_index_count int\n    var temp_count_max_index_count",
    "    var Output [][]interface{}\n    for _, tuple := range Input {\n        var found bool\n        for i, group := range Output {\n            if group[0] == tuple[0] {\n                Output[i] = append(Output[i], tuple[1])\n                found = true\n                break\n            }\n        }\n        if !found {\n            Output = append(Output, tuple)\n        }\n    }\n    return Output\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var temp_tuple []interface{}\n    var flag bool\n    for _, tuple := range Input {\n        if len(Output) == 0 {\n            temp = append(temp, tuple[0])\n            temp_tuple = append(temp_tuple, tuple)\n            Output = append(Output, temp_tuple)\n        } else {\n            flag = false\n            for i, _ := range Output {\n                if Output[i][0] == tuple[0] {\n                    Output[i] = append(Output[i], tuple)\n                    flag = true\n                }\n            }\n            if flag == false {\n                temp = append(temp, tuple[0])\n                temp_tuple = append(temp_tuple, tuple)\n                Output = append(Output, temp_tuple)\n            }\n        }\n    }\n    return Output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_map map[interface{}]int\n    temp_map = make(map[interface{}]int)\n    for _, tuple := range Input {\n        temp_map[tuple[0]]++\n    }\n    for key, value := range temp_map {\n        temp = append(temp, key, value)\n        result = append(result, temp)\n        temp = nil\n    }\n    return result\n}\n",
    "    var Output [][]interface{}\n    for _, tuple := range Input {\n        var found bool\n        for i, output := range Output {\n            if output[0] == tuple[0] {\n                Output[i] = append(Output[i], tuple[1])\n                found = true\n                break\n            }\n        }\n        if !found {\n            Output = append(Output, []interface{}{tuple[0], tuple[1]})\n        }\n    }\n    return Output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_map = make(map[interface{}][]interface{})\n    for _, v := range Input {\n        temp_map[v[0]] = append(temp_map[v[0]], v[1])\n    }\n    for k, v := range temp_map {\n        temp = append(temp, k)\n        temp = append(temp, v)\n        result = append(result, temp)\n        temp = nil\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_result []interface{}\n    for i := 0; i < len(Input); i++ {\n        temp = Input[i]\n        temp_result = append(temp_result, temp[0])\n    }\n    result = append(result, temp_result)\n    return result\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    for _, v := range Input {\n        if len(temp) == 0 {\n            temp = append(temp, v[0])\n            Output = append(Output, temp)\n        } else {\n            if temp[0] == v[0] {\n                Output = append(Output, temp)\n            } else {\n                temp = append(temp, v[0])\n                Output = append(Output, temp)\n            }\n        }\n    }\n    return Output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_slice []interface{}\n    var temp_slice_2 []interface{}\n    var temp_slice_3 []interface{}\n    var temp_slice_4 []interface{}\n    var temp_slice_5 []interface{}\n    var temp_slice_6 []interface{}\n    var temp_slice_7 []interface{}\n    var temp_slice_8 []interface{}\n    var temp_slice_9 []interface{}\n    var temp_slice_10 []interface{}\n    var temp_slice_11 []interface{}\n    var temp_slice_12 []interface{}\n    var temp_slice_13 []interface{}\n    var temp_slice_14 []interface{}\n    var temp_slice_15 []interface{}\n    var temp_slice_16 []interface{}\n    var temp_slice_17 []interface{}\n    var temp_slice_18 []interface{}\n    var temp_slice_19 []interface{}\n    var temp_slice_20 []interface{}\n    var temp_slice_21 []interface{}\n    var temp_slice_22 []interface{}\n    var temp_slice_23 []interface{}\n    var temp_slice_24 []interface{}\n    var temp_slice_25 []interface{}\n    var temp_slice_26 []interface{}\n    var temp_slice_27 []interface{}\n    var temp_slice_28 []interface{}\n    var temp_slice_29 []interface{}\n    var temp_slice_30 []interface{}\n    var temp_slice_31 []interface{}\n    var temp_slice_32 []interface{}\n    var temp_slice_33 []interface{}\n    var temp_slice_34 []interface{}\n    var temp_slice_35 []interface{}\n    var temp_slice_36 []interface{}\n    var temp_slice_37 []interface{}\n    var temp_slice_38 []interface{}\n    var temp_slice_39 []interface{}\n    var temp_slice_40 []interface{}\n    var temp_slice_41 []interface{}\n    var temp",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_slice []interface{}\n    var temp_slice_2 []interface{}\n    var temp_slice_3 []interface{}\n    var temp_slice_4 []interface{}\n    var temp_slice_5 []interface{}\n    var temp_slice_6 []interface{}\n    var temp_slice_7 []interface{}\n    var temp_slice_8 []interface{}\n    var temp_slice_9 []interface{}\n    var temp_slice_10 []interface{}\n    var temp_slice_11 []interface{}\n    var temp_slice_12 []interface{}\n    var temp_slice_13 []interface{}\n    var temp_slice_14 []interface{}\n    var temp_slice_15 []interface{}\n    var temp_slice_16 []interface{}\n    var temp_slice_17 []interface{}\n    var temp_slice_18 []interface{}\n    var temp_slice_19 []interface{}\n    var temp_slice_20 []interface{}\n    var temp_slice_21 []interface{}\n    var temp_slice_22 []interface{}\n    var temp_slice_23 []interface{}\n    var temp_slice_24 []interface{}\n    var temp_slice_25 []interface{}\n    var temp_slice_26 []interface{}\n    var temp_slice_27 []interface{}\n    var temp_slice_28 []interface{}\n    var temp_slice_29 []interface{}\n    var temp_slice_30 []interface{}\n    var temp_slice_31 []interface{}\n    var temp_slice_32 []interface{}\n    var temp_slice_33 []interface{}\n    var temp_slice_34 []interface{}\n    var temp_slice_35 []interface{}\n    var temp_slice_36 []interface{}\n    var temp_slice_37 []interface{}\n    var temp_slice_38 []interface{}\n    var temp_slice_39 []interface{}\n    var temp_slice_40 []interface{}\n    var temp_slice_41 []interface{}\n    var temp",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_index int\n    var temp_flag bool\n    for _, v := range Input {\n        temp_flag = false\n        for i, t := range result {\n            if v[0] == t[0] {\n                temp_flag = true\n                temp_index = i\n                break\n            }\n        }\n        if temp_flag {\n            temp = result[temp_index]\n            temp = append(temp, v[1])\n            result[temp_index] = temp\n        } else {\n            temp = []interface{}{v[0], v[1]}\n            result = append(result, temp)\n        }\n    }\n    return result\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var temp_slice []interface{}\n    var temp_slice_2 []interface{}\n    var temp_slice_3 []interface{}\n    var temp_slice_4 []interface{}\n    var temp_slice_5 []interface{}\n    var temp_slice_6 []interface{}\n    var temp_slice_7 []interface{}\n    var temp_slice_8 []interface{}\n    var temp_slice_9 []interface{}\n    var temp_slice_10 []interface{}\n    var temp_slice_11 []interface{}\n    var temp_slice_12 []interface{}\n    var temp_slice_13 []interface{}\n    var temp_slice_14 []interface{}\n    var temp_slice_15 []interface{}\n    var temp_slice_16 []interface{}\n    var temp_slice_17 []interface{}\n    var temp_slice_18 []interface{}\n    var temp_slice_19 []interface{}\n    var temp_slice_20 []interface{}\n    var temp_slice_21 []interface{}\n    var temp_slice_22 []interface{}\n    var temp_slice_23 []interface{}\n    var temp_slice_24 []interface{}\n    var temp_slice_25 []interface{}\n    var temp_slice_26 []interface{}\n    var temp_slice_27 []interface{}\n    var temp_slice_28 []interface{}\n    var temp_slice_29 []interface{}\n    var temp_slice_30 []interface{}\n    var temp_slice_31 []interface{}\n    var temp_slice_32 []interface{}\n    var temp_slice_33 []interface{}\n    var temp_slice_34 []interface{}\n    var temp_slice_35 []interface{}\n    var temp_slice_36 []interface{}\n    var temp_slice_37 []interface{}\n    var temp_slice_38 []interface{}\n    var temp_slice_39 []interface{}\n    var temp_slice_40 []interface{}\n    var temp_slice_41 []interface{}\n    var temp",
    "    var output [][]interface{}\n    var first_element_list []interface{}\n    for _, tuple := range Input {\n        if len(tuple) > 0 {\n            first_element_list = append(first_element_list, tuple[0])\n        }\n    }\n    for _, first_element := range first_element_list {\n        var tuple_list []interface{}\n        for _, tuple := range Input {\n            if len(tuple) > 0 && first_element == tuple[0] {\n                tuple_list = append(tuple_list, tuple)\n            }\n        }\n        if len(tuple_list) > 0 {\n            output = append(output, tuple_list)\n        }\n    }\n    return output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_map = make(map[interface{}]int)\n    for _, tuple := range Input {\n        if _, ok := temp_map[tuple[0]]; ok {\n            temp_map[tuple[0]] += 1\n        } else {\n            temp_map[tuple[0]] = 1\n        }\n    }\n    for key, value := range temp_map {\n        temp = append(temp, key, value)\n        result = append(result, temp)\n        temp = nil\n    }\n    return result\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var first_element interface{}\n    var first_element_count int\n    var first_element_index int\n    var first_element_flag bool\n    var first_element_flag_index int\n    var first_element_flag_count int\n    var first_element_flag_index_count int\n    var first_element_flag_index_count_flag bool\n    var first_element_flag_index_count_flag_index int\n    var first_element_flag_index_count_flag_count int\n    var first_element_flag_index_count_flag_index_count int\n    var first_element_flag_index_count_flag_index_count_flag bool\n    var first_element_flag_index_count_flag_index_count_flag_index int\n    var first_element_flag_index_count_flag_index_count_flag_count int\n    var first_element_flag_index_count_flag_index_count_flag_index_count int\n    var first_element_flag_index_count_flag_index_count_flag_index_count_flag bool\n    var first_element_flag_index_count_flag_index_count_flag_index_count_flag_index int\n    var first_element_flag_index_count_flag_index_count_flag_index_count_flag_count int\n    var first_element_flag_index_count_flag_index_count_flag_index_count_flag_index_count int\n    var first_element_flag_index_count_flag_index_count_flag_index_count_flag_index_count_flag bool\n    var first_element_flag_index_count_flag_index_count_flag_index_count_flag_index_count_flag_index int\n    var first_element_flag_index_count_flag_index_count_flag_index_count_flag_index_count_flag_count int\n    var first_element_flag_index_count_flag_index_count_flag_index_count_flag_index_count_flag_index_count int\n    var first_element_",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_slice []interface{}\n    var temp_slice_2 []interface{}\n    var temp_slice_3 []interface{}\n    var temp_slice_4 []interface{}\n    var temp_slice_5 []interface{}\n    var temp_slice_6 []interface{}\n    var temp_slice_7 []interface{}\n    var temp_slice_8 []interface{}\n    var temp_slice_9 []interface{}\n    var temp_slice_10 []interface{}\n    var temp_slice_11 []interface{}\n    var temp_slice_12 []interface{}\n    var temp_slice_13 []interface{}\n    var temp_slice_14 []interface{}\n    var temp_slice_15 []interface{}\n    var temp_slice_16 []interface{}\n    var temp_slice_17 []interface{}\n    var temp_slice_18 []interface{}\n    var temp_slice_19 []interface{}\n    var temp_slice_20 []interface{}\n    var temp_slice_21 []interface{}\n    var temp_slice_22 []interface{}\n    var temp_slice_23 []interface{}\n    var temp_slice_24 []interface{}\n    var temp_slice_25 []interface{}\n    var temp_slice_26 []interface{}\n    var temp_slice_27 []interface{}\n    var temp_slice_28 []interface{}\n    var temp_slice_29 []interface{}\n    var temp_slice_30 []interface{}\n    var temp_slice_31 []interface{}\n    var temp_slice_32 []interface{}\n    var temp_slice_33 []interface{}\n    var temp_slice_34 []interface{}\n    var temp_slice_35 []interface{}\n    var temp_slice_36 []interface{}\n    var temp_slice_37 []interface{}\n    var temp_slice_38 []interface{}\n    var temp_slice_39 []interface{}\n    var temp_slice_40 []interface{}\n    var temp_slice_41 []interface{}\n    var temp",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_map = make(map[interface{}][]interface{})\n    for _, v := range Input {\n        if _, ok := temp_map[v[0]]; ok {\n            temp_map[v[0]] = append(temp_map[v[0]], v[1])\n        } else {\n            temp_map[v[0]] = []interface{}{v[1]}\n        }\n    }\n    for k, v := range temp_map {\n        temp = append(temp, k)\n        temp = append(temp, v)\n        result = append(result, temp)\n        temp = []interface{}{}\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    for _, v := range Input {\n        if len(v) == 0 {\n            continue\n        }\n        var found bool\n        for i, r := range result {\n            if r[0] == v[0] {\n                result[i] = append(result[i], v[1:]...)\n                found = true\n                break\n            }\n        }\n        if !found {\n            result = append(result, v)\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    for _, v := range Input {\n        if len(temp) == 0 {\n            temp = append(temp, v[0])\n            temp = append(temp, v[1])\n        } else {\n            if temp[0] == v[0] {\n                temp = append(temp, v[1])\n            } else {\n                result = append(result, temp)\n                temp = []interface{}{}\n                temp = append(temp, v[0])\n                temp = append(temp, v[1])\n            }\n        }\n    }\n    result = append(result, temp)\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var first_element interface{}\n    var first_element_index int\n    var first_element_count int\n    var first_element_index_count int\n    var first_element_count_max int\n    var first_element_index_count_max int\n    for i, v := range Input {\n        if i == 0 {\n            temp = append(temp, v[0])\n            first_element = v[0]\n            first_element_index = i\n            first_element_count = 1\n            first_element_index_count = 1\n            first_element_count_max = 1\n            first_element_index_count_max = 1\n        } else {\n            if v[0] == first_element {\n                first_element_count++\n                first_element_index_count++\n                if first_element_count > first_element_count_max {\n                    first_element_count_max = first_element_count\n                    first_element_index_count_max = first_element_index_count\n                }\n            } else {\n                first_element = v[0]\n                first_element_index = i\n                first_element_count = 1\n                first_element_index_count = 1\n            }\n            temp = append(temp, v[0])\n        }\n    }\n    for i, v := range Input {\n        if i == first_element_index_count_max - 1 {\n            result = append(result, v)\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_map = make(map[interface{}][]interface{})\n    for _, v := range Input {\n        temp_map[v[0]] = append(temp_map[v[0]], v[1])\n    }\n    for k, v := range temp_map {\n        temp = append(temp, k)\n        temp = append(temp, v)\n        result = append(result, temp)\n        temp = nil\n    }\n    return result\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, v := range Input {\n        flag = false\n        for i, w := range Output {\n            if v[0] == w[0] {\n                flag = true\n                Output[i] = append(Output[i], v[1])\n                break\n            }\n        }\n        if !flag {\n            temp = []interface{}{v[0], v[1]}\n            Output = append(Output, temp)\n        }\n    }\n    return Output\n}\n",
    "    var output [][]interface{}\n    var temp []interface{}\n    var first interface{}\n    var first_index int\n    var first_count int\n    var first_flag bool\n    var first_flag_index int\n    var first_flag_count int\n    var first_flag_temp []interface{}\n    var first_flag_temp_index int\n    var first_flag_temp_count int\n    var first_flag_temp_flag bool\n    var first_flag_temp_flag_index int\n    var first_flag_temp_flag_count int\n    var first_flag_temp_flag_temp []interface{}\n    var first_flag_temp_flag_temp_index int\n    var first_flag_temp_flag_temp_count int\n    var first_flag_temp_flag_temp_flag bool\n    var first_flag_temp_flag_temp_flag_index int\n    var first_flag_temp_flag_temp_flag_count int\n    var first_flag_temp_flag_temp_flag_temp []interface{}\n    var first_flag_temp_flag_temp_flag_temp_index int\n    var first_flag_temp_flag_temp_flag_temp_count int\n    var first_flag_temp_flag_temp_flag_temp_flag bool\n    var first_flag_temp_flag_temp_flag_temp_flag_index int\n    var first_flag_temp_flag_temp_flag_temp_flag_count int\n    var first_flag_temp_flag_temp_flag_temp_flag_temp []interface{}\n    var first_flag_temp_flag_temp_flag_temp_flag_temp_index int\n    var first_flag_temp_flag_temp_flag_temp_flag_temp_count int\n    var first_flag_temp_flag_temp_flag_temp_flag_temp_flag bool\n    var first_flag_temp_flag_temp_flag_temp_flag_temp_flag_index int\n    var first_flag_temp_flag_temp_flag_temp_flag_temp_flag_count int\n    var first_flag_temp_flag_temp_flag_temp_flag_temp",
    "    var Output [][]interface{}\n    for _, tuple := range Input {\n        var found bool\n        for i, group := range Output {\n            if group[0] == tuple[0] {\n                Output[i] = append(group, tuple[1])\n                found = true\n                break\n            }\n        }\n        if !found {\n            Output = append(Output, []interface{}{tuple[0], tuple[1]})\n        }\n    }\n    return Output\n}\n",
    "    var Output [][]interface{}\n    var first_element interface{}\n    var first_element_index int\n    var first_element_index_list []int\n    var first_element_list []interface{}\n    var first_element_list_index int\n    var first_element_list_index_list []int\n    var first_element_list_index_list_index int\n    var first_element_list_index_list_index_list []int\n    var first_element_list_index_list_index_list_index int\n    var first_element_list_index_list_index_list_index_list []int\n    var first_element_list_index_list_index_list_index_list_index int\n    var first_element_list_index_list_index_list_index_list_index_list []int\n    var first_element_list_index_list_index_list_index_list_index_list_index int\n    var first_element_list_index_list_index_list_index_list_index_list_index_list []int\n    var first_element_list_index_list_index_list_index_list_index_list_index_list_index int\n    var first_element_list_index_list_index_list_index_list_index_list_index_list_index_list []int\n    var first_element_list_index_list_index_list_index_list_index_list_index_list_index_list_index int\n    var first_element_list_index_list_index_list_index_list_index_list_index_list_index_list_index_list []int\n    var first_element_list_index_list_index_list_index_list_index_list_index_list_index_list_index_list_index int\n    var first_element_list_index_list_index_list_index_list_index_list_index_list_index_list_index_list_index_list []int\n    var first_element_list_index_list_index_list_index_list_index_list_index_list_index_list_index_list",
    "    var result [][]interface{}\n    var tmp []interface{}\n    for i := 0; i < len(Input); i++ {\n        tmp = append(tmp, Input[i][0])\n    }\n    result = append(result, tmp)\n    return result\n}\n",
    "    var Output [][]interface{}\n    for _, v := range Input {\n        if len(Output) == 0 {\n            Output = append(Output, v)\n        } else {\n            for i, v2 := range Output {\n                if v[0] == v2[0] {\n                    Output[i] = append(Output[i], v[1])\n                    break\n                } else if i == len(Output) - 1 {\n                    Output = append(Output, v)\n                }\n            }\n        }\n    }\n    return Output\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    for i := 0; i < len(Input); i++ {\n        if i == 0 {\n            temp = append(temp, Input[i][0])\n            temp = append(temp, Input[i][1])\n            Output = append(Output, temp)\n        } else {\n            for j := 0; j < len(Output); j++ {\n                if Input[i][0] == Output[j][0] {\n                    Output[j] = append(Output[j], Input[i][1])\n                    break\n                } else if j == len(Output) - 1 {\n                    temp = append(temp, Input[i][0])\n                    temp = append(temp, Input[i][1])\n                    Output = append(Output, temp)\n                }\n            }\n        }\n    }\n    return Output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    for i := 0; i < len(Input); i++ {\n        if i == 0 {\n            temp = append(temp, Input[i][0])\n            temp = append(temp, Input[i][1])\n            continue\n        }\n        if Input[i][0] == Input[i-1][0] {\n            temp = append(temp, Input[i][1])\n        } else {\n            result = append(result, temp)\n            temp = nil\n            temp = append(temp, Input[i][0])\n            temp = append(temp, Input[i][1])\n        }\n    }\n    result = append(result, temp)\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, v := range Input {\n        flag = false\n        for _, v1 := range result {\n            if v1[0] == v[0] {\n                flag = true\n                temp = v1\n                break\n            }\n        }\n        if flag {\n            temp = append(temp, v[1])\n        } else {\n            temp = append(temp, v[0], v[1])\n            result = append(result, temp)\n        }\n    }\n    return result\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var temp_tuple []interface{}\n    var temp_tuple_list [][]interface{}\n    var temp_tuple_list_list [][][]interface{}\n    var temp_tuple_list_list_list [][][][]interface{}\n    var temp_tuple_list_list_list_list [][][][][]interface{}\n    var temp_tuple_list_list_list_list_list [][][][][][]interface{}\n    var temp_tuple_list_list_list_list_list_list [][][][][][][]interface{}\n    var temp_tuple_list_list_list_list_list_list_list [][][][][][][][]interface{}\n    var temp_tuple_list_list_list_list_list_list_list_list [][][][][][][][][]interface{}\n    var temp_tuple_list_list_list_list_list_list_list_list_list [][][][][][][][][][]interface{}\n    var temp_tuple_list_list_list_list_list_list_list_list_list_list [][][][][][][][][][][]interface{}\n    var temp_tuple_list_list_list_list_list_list_list_list_list_list_list [][][][][][][][][][][][]interface{}\n    var temp_tuple_list_list_list_list_list_list_list_list_list_list_list_list [][][][][][][][][][][][][]interface{}\n    var temp_tuple_list_list_list_list_list_list_list_list_list_list_list_list_list [][][][][][][][][][][][][][]interface{}\n    var temp_tuple_list_list_list_list_list_list_list_list_list_list_list_list_list_list [][][][][][][][][][][][][][][]interface{}",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, v := range Input {\n        flag = false\n        for _, v1 := range Output {\n            if v[0] == v1[0] {\n                flag = true\n                v1 = append(v1, v[1])\n            }\n        }\n        if flag == false {\n            temp = append(temp, v[0])\n            temp = append(temp, v[1])\n            Output = append(Output, temp)\n            temp = nil\n        }\n    }\n    return Output\n}\n",
    "    var Output [][]interface{}\n    for _, tuple := range Input {\n        if len(tuple) > 0 {\n            Output = append(Output, []interface{}{tuple[0], []interface{}{}})\n        }\n    }\n    for _, tuple := range Input {\n        if len(tuple) > 0 {\n            for i, group := range Output {\n                if group[0] == tuple[0] {\n                    Output[i][1] = append(group[1].([]interface{}), tuple[1])\n                }\n            }\n        }\n    }\n    return Output\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, i := range Input {\n        flag = false\n        for _, j := range Output {\n            if i[0] == j[0] {\n                flag = true\n                j = append(j, i[1])\n                break\n            }\n        }\n        if !flag {\n            temp = append(temp, i[0])\n            temp = append(temp, i[1])\n            Output = append(Output, temp)\n            temp = []interface{}{}\n        }\n    }\n    return Output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    for _, v := range Input {\n        if len(temp) == 0 {\n            temp = append(temp, v[0])\n            temp = append(temp, v[1])\n        } else {\n            if temp[0] == v[0] {\n                temp = append(temp, v[1])\n            } else {\n                result = append(result, temp)\n                temp = nil\n                temp = append(temp, v[0])\n                temp = append(temp, v[1])\n            }\n        }\n    }\n    result = append(result, temp)\n    return result\n}\n",
    "    var output [][]interface{}\n    var first_element_list []interface{}\n    for _, tuple := range Input {\n        if !contains(first_element_list, tuple[0]) {\n            first_element_list = append(first_element_list, tuple[0])\n            output = append(output, tuple)\n        }\n    }\n    return output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var first_element interface{}\n    var temp_list []interface{}\n    var temp_list_2 []interface{}\n    var temp_list_3 []interface{}\n    var temp_list_4 []interface{}\n    var temp_list_5 []interface{}\n    var temp_list_6 []interface{}\n    var temp_list_7 []interface{}\n    var temp_list_8 []interface{}\n    var temp_list_9 []interface{}\n    var temp_list_10 []interface{}\n    var temp_list_11 []interface{}\n    var temp_list_12 []interface{}\n    var temp_list_13 []interface{}\n    var temp_list_14 []interface{}\n    var temp_list_15 []interface{}\n    var temp_list_16 []interface{}\n    var temp_list_17 []interface{}\n    var temp_list_18 []interface{}\n    var temp_list_19 []interface{}\n    var temp_list_20 []interface{}\n    var temp_list_21 []interface{}\n    var temp_list_22 []interface{}\n    var temp_list_23 []interface{}\n    var temp_list_24 []interface{}\n    var temp_list_25 []interface{}\n    var temp_list_26 []interface{}\n    var temp_list_27 []interface{}\n    var temp_list_28 []interface{}\n    var temp_list_29 []interface{}\n    var temp_list_30 []interface{}\n    var temp_list_31 []interface{}\n    var temp_list_32 []interface{}\n    var temp_list_33 []interface{}\n    var temp_list_34 []interface{}\n    var temp_list_35 []interface{}\n    var temp_list_36 []interface{}\n    var temp_list_37 []interface{}\n    var temp_list_38 []interface{}\n    var temp_list_39 []interface{}\n    var temp_list_40 []interface{}\n    var temp_list_",
    "    var result [][]interface{}\n    for _, tuple := range Input {\n        if len(tuple) == 0 {\n            continue\n        }\n        var found bool\n        for _, result_tuple := range result {\n            if result_tuple[0] == tuple[0] {\n                found = true\n                result_tuple = append(result_tuple, tuple[1:]...)\n                break\n            }\n        }\n        if !found {\n            result = append(result, tuple)\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    for i := 0; i < len(Input); i++ {\n        if i == 0 {\n            temp = append(temp, Input[i][0])\n        } else {\n            if Input[i][0] == Input[i-1][0] {\n                temp = append(temp, Input[i][1])\n            } else {\n                result = append(result, temp)\n                temp = []interface{}{}\n                temp = append(temp, Input[i][0])\n                temp = append(temp, Input[i][1])\n            }\n        }\n    }\n    result = append(result, temp)\n    return result\n}\n",
    "    var Output [][]interface{}\n    for _, tuple := range Input {\n        var found bool\n        for i, group := range Output {\n            if group[0] == tuple[0] {\n                Output[i] = append(Output[i], tuple[1])\n                found = true\n                break\n            }\n        }\n        if !found {\n            Output = append(Output, tuple)\n        }\n    }\n    return Output\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var first_element interface{}\n    var first_element_count int\n    var first_element_index int\n    var first_element_flag bool\n    var first_element_index_flag bool\n    var first_element_count_flag bool\n\n    for i := 0; i < len(Input); i++ {\n        if i == 0 {\n            first_element = Input[i][0]\n            first_element_count = 1\n            first_element_index = i\n            first_element_flag = true\n            first_element_index_flag = true\n            first_element_count_flag = true\n        } else {\n            if first_element == Input[i][0] {\n                first_element_count++\n                first_element_index = i\n                first_element_flag = true\n                first_element_index_flag = true\n                first_element_count_flag = true\n            } else {\n                if first_element_flag {\n                    temp = append(temp, first_element)\n                    first_element_flag = false\n                }\n                if first_element_index_flag {\n                    temp = append(temp, first_element_index)\n                    first_element_index_flag = false\n                }\n                if first_element_count_flag {\n                    temp = append(temp, first_element_count)\n                    first_element_count_flag = false\n                }\n                Output = append(Output, temp)\n                temp = []interface{}{}\n                first_element = Input[i][0]\n                first_element_count = 1\n                first_element_index = i\n                first_element_flag = true\n                first_element_index_flag = true\n                first_element_count_flag = true\n            }\n        }\n    }\n    if first_element_flag {\n        temp = append(temp, first_element)\n        first_element_flag = false\n    }\n    if first_element_index_flag {\n        temp = append(temp, first_element_index)\n        first_element_index_flag = false\n    }\n    if first_element_count",
    "    var output [][]interface{}\n    var temp []interface{}\n    var first_element interface{}\n    var temp_list []interface{}\n    var temp_list_2 []interface{}\n    var temp_list_3 []interface{}\n    var temp_list_4 []interface{}\n    var temp_list_5 []interface{}\n    var temp_list_6 []interface{}\n    var temp_list_7 []interface{}\n    var temp_list_8 []interface{}\n    var temp_list_9 []interface{}\n    var temp_list_10 []interface{}\n    var temp_list_11 []interface{}\n    var temp_list_12 []interface{}\n    var temp_list_13 []interface{}\n    var temp_list_14 []interface{}\n    var temp_list_15 []interface{}\n    var temp_list_16 []interface{}\n    var temp_list_17 []interface{}\n    var temp_list_18 []interface{}\n    var temp_list_19 []interface{}\n    var temp_list_20 []interface{}\n    var temp_list_21 []interface{}\n    var temp_list_22 []interface{}\n    var temp_list_23 []interface{}\n    var temp_list_24 []interface{}\n    var temp_list_25 []interface{}\n    var temp_list_26 []interface{}\n    var temp_list_27 []interface{}\n    var temp_list_28 []interface{}\n    var temp_list_29 []interface{}\n    var temp_list_30 []interface{}\n    var temp_list_31 []interface{}\n    var temp_list_32 []interface{}\n    var temp_list_33 []interface{}\n    var temp_list_34 []interface{}\n    var temp_list_35 []interface{}\n    var temp_list_36 []interface{}\n    var temp_list_37 []interface{}\n    var temp_list_38 []interface{}\n    var temp_list_39 []interface{}\n    var temp_list_40 []interface{}\n    var temp_list_",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for i := 0; i < len(Input); i++ {\n        flag = false\n        for j := 0; j < len(Output); j++ {\n            if Input[i][0] == Output[j][0] {\n                flag = true\n                Output[j] = append(Output[j], Input[i][1])\n            }\n        }\n        if flag == false {\n            temp = append(temp, Input[i][0])\n            temp = append(temp, Input[i][1])\n            Output = append(Output, temp)\n            temp = []interface{}{}\n        }\n    }\n    return Output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_map = make(map[interface{}][]interface{})\n    for _, tuple := range Input {\n        temp_map[tuple[0]] = append(temp_map[tuple[0]], tuple[1])\n    }\n    for key, value := range temp_map {\n        temp = append(temp, key)\n        temp = append(temp, value)\n        result = append(result, temp)\n        temp = nil\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_map = make(map[interface{}][]interface{})\n    for _, v := range Input {\n        temp_map[v[0]] = append(temp_map[v[0]], v[1])\n    }\n    for k, v := range temp_map {\n        temp = append(temp, k)\n        temp = append(temp, v)\n        result = append(result, temp)\n        temp = nil\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_map = make(map[interface{}][]interface{})\n    for _, v := range Input {\n        temp_map[v[0]] = append(temp_map[v[0]], v[1])\n    }\n    for k, v := range temp_map {\n        temp = append(temp, k)\n        temp = append(temp, v)\n        result = append(result, temp)\n        temp = nil\n    }\n    return result\n}\n",
    "    // Write your code here\n    var result [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for i := 0; i < len(Input); i++ {\n        flag = false\n        for j := 0; j < len(result); j++ {\n            if Input[i][0] == result[j][0] {\n                flag = true\n                temp = append(result[j], Input[i][1])\n                result[j] = temp\n            }\n        }\n        if flag == false {\n            temp = []interface{}{Input[i][0], Input[i][1]}\n            result = append(result, temp)\n        }\n    }\n    return result\n}\n",
    "    var output [][]interface{}\n    var temp []interface{}\n    var temp_map = make(map[interface{}][]interface{})\n    for _, v := range Input {\n        temp_map[v[0]] = append(temp_map[v[0]], v[1])\n    }\n    for k, v := range temp_map {\n        temp = append(temp, k)\n        temp = append(temp, v)\n        output = append(output, temp)\n        temp = nil\n    }\n    return output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_map = make(map[interface{}]int)\n    for _, v := range Input {\n        temp_map[v[0]] = 1\n    }\n    for k, _ := range temp_map {\n        temp = append(temp, k)\n    }\n    result = append(result, temp)\n    return result\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var first_element interface{}\n    var first_element_count int\n    var first_element_index int\n    var first_element_index_count int\n    var first_element_index_count_temp int\n    var first_element_index_count_temp_index int\n    var first_element_index_count_temp_index_count int\n    var first_element_index_count_temp_index_count_temp int\n    var first_element_index_count_temp_index_count_temp_index int\n    var first_element_index_count_temp_index_count_temp_index_count int\n    var first_element_index_count_temp_index_count_temp_index_count_temp int\n    var first_element_index_count_temp_index_count_temp_index_count_temp_index int\n    var first_element_index_count_temp_index_count_temp_index_count_temp_index_count int\n    var first_element_index_count_temp_index_count_temp_index_count_temp_index_count_temp int\n    var first_element_index_count_temp_index_count_temp_index_count_temp_index_count_temp_index int\n    var first_element_index_count_temp_index_count_temp_index_count_temp_index_count_temp_index_count int\n    var first_element_index_count_temp_index_count_temp_index_count_temp_index_count_temp_index_count_temp int\n    var first_element_index_count_temp_index_count_temp_index_count_temp_index_count_temp_index_count_temp_index int\n    var first_element_index_count_temp_index_count_temp_index_count_temp_index_count_temp_index_count_temp_index_count int\n    var first_element_index_count_temp_index_count_temp_index_count_temp_index_count_temp_index_count_temp_index_count_temp int\n    var first_element_index",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_map = make(map[interface{}][]interface{})\n    for _, v := range Input {\n        temp_map[v[0]] = append(temp_map[v[0]], v[1])\n    }\n    for k, v := range temp_map {\n        temp = append(temp, k)\n        temp = append(temp, v)\n        result = append(result, temp)\n        temp = nil\n    }\n    return result\n}\n",
    "    var Output [][]interface{}\n    for i := 0; i < len(Input); i++ {\n        var temp []interface{}\n        temp = append(temp, Input[i][0])\n        for j := i + 1; j < len(Input); j++ {\n            if Input[i][0] == Input[j][0] {\n                temp = append(temp, Input[j][1])\n            }\n        }\n        Output = append(Output, temp)\n    }\n    return Output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, v := range Input {\n        flag = false\n        for i, v2 := range result {\n            if v[0] == v2[0] {\n                flag = true\n                result[i] = append(result[i], v[1])\n                break\n            }\n        }\n        if !flag {\n            temp = []interface{}{v[0]}\n            temp = append(temp, v[1])\n            result = append(result, temp)\n        }\n    }\n    return result\n}\n",
    "    var output [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, v := range Input {\n        flag = false\n        for i, v2 := range output {\n            if v[0] == v2[0] {\n                flag = true\n                output[i] = append(output[i], v[1])\n                break\n            }\n        }\n        if !flag {\n            temp = append(temp, v[0])\n            temp = append(temp, v[1])\n            output = append(output, temp)\n            temp = []interface{}{}\n        }\n    }\n    return output\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, tuple := range Input {\n        if len(Output) == 0 {\n            Output = append(Output, tuple)\n        } else {\n            flag = false\n            for _, t := range Output {\n                if tuple[0] == t[0] {\n                    flag = true\n                    temp = append(t, tuple[1:]...)\n                    Output = append(Output[:tuple[0]], Output[tuple[0]+1:]...)\n                    Output = append(Output, temp)\n                    break\n                }\n            }\n            if !flag {\n                Output = append(Output, tuple)\n            }\n        }\n    }\n    return Output\n}\n",
    "    var Output [][]interface{}\n    for _, tuple := range Input {\n        var found bool\n        for _, group := range Output {\n            if group[0] == tuple[0] {\n                group = append(group, tuple[1])\n                found = true\n                break\n            }\n        }\n        if !found {\n            Output = append(Output, tuple)\n        }\n    }\n    return Output\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, v := range Input {\n        flag = false\n        for i, w := range Output {\n            if v[0] == w[0] {\n                flag = true\n                Output[i] = append(Output[i], v[1])\n            }\n        }\n        if flag == false {\n            temp = append(temp, v[0])\n            temp = append(temp, v[1])\n            Output = append(Output, temp)\n            temp = nil\n        }\n    }\n    return Output\n}\n",
    "    // Write your code here\n    var Output [][]interface{}\n    var temp []interface{}\n    for i := 0; i < len(Input); i++ {\n        if i == 0 {\n            temp = append(temp, Input[i][0])\n            Output = append(Output, temp)\n        } else {\n            for j := 0; j < len(Output); j++ {\n                if Input[i][0] == Output[j][0] {\n                    Output[j] = append(Output[j], Input[i][1])\n                    break\n                }\n                if j == len(Output)-1 {\n                    temp = append(temp, Input[i][0])\n                    Output = append(Output, temp)\n                }\n            }\n        }\n    }\n    return Output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    for i := 0; i < len(Input); i++ {\n        temp = append(temp, Input[i][0])\n    }\n    result = append(result, temp)\n    return result\n}\n",
    "    var output [][]interface{}\n    var temp []interface{}\n    for i := 0; i < len(Input); i++ {\n        temp = append(temp, Input[i][0])\n    }\n    output = append(output, temp)\n    return output\n}\n",
    "    var output [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, v := range Input {\n        flag = false\n        for _, vv := range output {\n            if v[0] == vv[0] {\n                flag = true\n                temp = append(vv, v[1])\n                output = append(output[:len(output)-1], temp)\n                break\n            }\n        }\n        if !flag {\n            output = append(output, v)\n        }\n    }\n    return output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    for _, v := range Input {\n        if len(temp) == 0 {\n            temp = append(temp, v[0])\n            result = append(result, temp)\n        } else {\n            if temp[0] == v[0] {\n                result[len(result)-1] = append(result[len(result)-1], v[1])\n            } else {\n                temp = append(temp, v[0])\n                result = append(result, temp)\n            }\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_index int\n    var temp_count int\n    var temp_count_index int\n    var temp_count_max int\n    var temp_count_max_index int\n    var temp_count_max_index_count int\n    var temp_count_max_index_count_index int\n    var temp_count_max_index_count_index_count int\n    var temp_count_max_index_count_index_count_index int\n    var temp_count_max_index_count_index_count_index_count int\n    var temp_count_max_index_count_index_count_index_count_index int\n    var temp_count_max_index_count_index_count_index_count_index_count int\n    var temp_count_max_index_count_index_count_index_count_index_count_index int\n    var temp_count_max_index_count_index_count_index_count_index_count_index_count int\n    var temp_count_max_index_count_index_count_index_count_index_count_index_count_index int\n    var temp_count_max_index_count_index_count_index_count_index_count_index_count_index_count int\n    var temp_count_max_index_count_index_count_index_count_index_count_index_count_index_count_index int\n    var temp_count_max_index_count_index_count_index_count_index_count_index_count_index_count_index_count int\n    var temp_count_max_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index int\n    var temp_count_max_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count int\n    var temp_count_max_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index int\n    var",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_index int\n    var temp_flag bool\n    for i := 0; i < len(Input); i++ {\n        temp_flag = false\n        for j := 0; j < len(result); j++ {\n            if Input[i][0] == result[j][0] {\n                temp_flag = true\n                temp_index = j\n                break\n            }\n        }\n        if temp_flag {\n            result[temp_index] = append(result[temp_index], Input[i][1])\n        } else {\n            temp = append(temp, Input[i][0])\n            temp = append(temp, Input[i][1])\n            result = append(result, temp)\n            temp = nil\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_map map[interface{}][]interface{} = make(map[interface{}][]interface{})\n    for _, v := range Input {\n        temp_map[v[0]] = append(temp_map[v[0]], v[1])\n    }\n    for k, v := range temp_map {\n        temp = append(temp, k)\n        temp = append(temp, v)\n        result = append(result, temp)\n        temp = nil\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_map map[interface{}]int\n    temp_map = make(map[interface{}]int)\n    for _, v := range Input {\n        temp_map[v[0]]++\n    }\n    for k, v := range temp_map {\n        if v > 1 {\n            temp = append(temp, k)\n        }\n    }\n    result = append(result, temp)\n    return result\n}\n",
    "    var result [][]interface{}\n    for _, tuple := range Input {\n        if len(tuple) == 0 {\n            continue\n        }\n        var found bool\n        for i, r := range result {\n            if r[0] == tuple[0] {\n                result[i] = append(result[i], tuple[1:]...)\n                found = true\n                break\n            }\n        }\n        if !found {\n            result = append(result, tuple)\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_map = make(map[interface{}]int)\n    for _, v := range Input {\n        if _, ok := temp_map[v[0]]; ok {\n            temp = append(temp, v[1])\n        } else {\n            if len(temp) > 0 {\n                result = append(result, temp)\n            }\n            temp = []interface{}{v[0], v[1]}\n            temp_map[v[0]] = 1\n        }\n    }\n    if len(temp) > 0 {\n        result = append(result, temp)\n    }\n    return result\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, tuple := range Input {\n        flag = false\n        for _, group := range Output {\n            if group[0] == tuple[0] {\n                flag = true\n                temp = group\n                break\n            }\n        }\n        if flag {\n            temp = append(temp, tuple[1])\n        } else {\n            temp = []interface{}{tuple[0], tuple[1]}\n            Output = append(Output, temp)\n        }\n    }\n    return Output\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for i := 0; i < len(Input); i++ {\n        flag = false\n        for j := 0; j < len(Output); j++ {\n            if Input[i][0] == Output[j][0] {\n                Output[j] = append(Output[j], Input[i][1])\n                flag = true\n            }\n        }\n        if !flag {\n            temp = append(temp, Input[i][0])\n            temp = append(temp, Input[i][1])\n            Output = append(Output, temp)\n            temp = nil\n        }\n    }\n    return Output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_list []interface{}\n    var temp_list_list [][]interface{}\n    var temp_list_list_list [][][]interface{}\n    var temp_list_list_list_list [][][][]interface{}\n    var temp_list_list_list_list_list [][][][][]interface{}\n    var temp_list_list_list_list_list_list [][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list [][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list [][][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list_list [][][][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list_list_list [][][][][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list_list_list_list [][][][][][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list_list_list_list_list [][][][][][][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list_list_list_list_list_list [][][][][][][][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list_list_list_list_list_list_list [][][][][][][][][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list [][][][][][][][][][][][][][][]interface{}\n    var temp_list_list_list_list_list_",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_slice []interface{}\n    for _, v := range Input {\n        temp = append(temp, v[0])\n    }\n    for i := 0; i < len(temp); i++ {\n        for j := i + 1; j < len(temp); j++ {\n            if temp[i] == temp[j] {\n                temp[j] = nil\n            }\n        }\n    }\n    for _, v := range temp {\n        if v != nil {\n            temp_slice = append(temp_slice, v)\n        }\n    }\n    for _, v := range temp_slice {\n        for _, v1 := range Input {\n            if v == v1[0] {\n                result = append(result, v1)\n            }\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, v := range Input {\n        flag = false\n        for i, v2 := range result {\n            if v[0] == v2[0] {\n                flag = true\n                result[i] = append(result[i], v[1])\n            }\n        }\n        if !flag {\n            temp = []interface{}{v[0]}\n            temp = append(temp, v[1])\n            result = append(result, temp)\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, tuple := range Input {\n        flag = false\n        for _, group := range result {\n            if group[0] == tuple[0] {\n                group = append(group, tuple[1])\n                flag = true\n                break\n            }\n        }\n        if !flag {\n            temp = []interface{}{tuple[0]}\n            temp = append(temp, tuple[1])\n            result = append(result, temp)\n        }\n    }\n    return result\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var count int\n    for i := 0; i < len(Input); i++ {\n        if i == 0 {\n            temp = append(temp, Input[i][0])\n            temp = append(temp, Input[i][1])\n            count++\n        } else {\n            if Input[i][0] == Input[i-1][0] {\n                temp = append(temp, Input[i][1])\n                count++\n            } else {\n                temp = append(temp, count)\n                Output = append(Output, temp)\n                temp = nil\n                temp = append(temp, Input[i][0])\n                temp = append(temp, Input[i][1])\n                count = 1\n            }\n        }\n    }\n    temp = append(temp, count)\n    Output = append(Output, temp)\n    return Output\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for i := 0; i < len(Input); i++ {\n        flag = false\n        for j := 0; j < len(Output); j++ {\n            if Input[i][0] == Output[j][0] {\n                flag = true\n                Output[j] = append(Output[j], Input[i][1])\n            }\n        }\n        if flag == false {\n            temp = append(temp, Input[i][0])\n            temp = append(temp, Input[i][1])\n            Output = append(Output, temp)\n            temp = nil\n        }\n    }\n    return Output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    for _, tuple := range Input {\n        if len(temp) == 0 {\n            temp = append(temp, tuple[0])\n            result = append(result, temp)\n        } else {\n            if temp[0] == tuple[0] {\n                continue\n            } else {\n                temp = append(temp, tuple[0])\n                result = append(result, temp)\n            }\n        }\n    }\n    return result\n}\n",
    "    var output [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, v := range Input {\n        flag = false\n        for _, v2 := range output {\n            if v[0] == v2[0] {\n                flag = true\n                break\n            }\n        }\n        if !flag {\n            temp = append(temp, v[0])\n            output = append(output, temp)\n            temp = nil\n        }\n    }\n    return output\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    for i := 0; i < len(Input); i++ {\n        if i == 0 {\n            temp = append(temp, Input[i][0])\n            temp = append(temp, Input[i][1])\n        } else {\n            if Input[i][0] == Input[i-1][0] {\n                temp = append(temp, Input[i][1])\n            } else {\n                Output = append(Output, temp)\n                temp = nil\n                temp = append(temp, Input[i][0])\n                temp = append(temp, Input[i][1])\n            }\n        }\n    }\n    Output = append(Output, temp)\n    return Output\n}\n",
    "    var output [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for i := 0; i < len(Input); i++ {\n        flag = false\n        for j := 0; j < len(output); j++ {\n            if Input[i][0] == output[j][0] {\n                output[j] = append(output[j], Input[i][1])\n                flag = true\n                break\n            }\n        }\n        if flag == false {\n            temp = append(temp, Input[i][0])\n            temp = append(temp, Input[i][1])\n            output = append(output, temp)\n            temp = nil\n        }\n    }\n    return output\n}\n",
    "    var output [][]interface{}\n    var temp []interface{}\n    var temp_map map[interface{}]bool\n    temp_map = make(map[interface{}]bool)\n    for _, tuple := range Input {\n        if _, ok := temp_map[tuple[0]]; !ok {\n            temp_map[tuple[0]] = true\n            temp = append(temp, tuple[0])\n        }\n    }\n    for _, key := range temp {\n        var temp_tuple []interface{}\n        for _, tuple := range Input {\n            if tuple[0] == key {\n                temp_tuple = append(temp_tuple, tuple)\n            }\n        }\n        output = append(output, temp_tuple)\n    }\n    return output\n}\n",
    "    // Create a map to store the result\n    result := make(map[interface{}][]interface{})\n    // Iterate over the input\n    for _, v := range Input {\n        // Check if the first element of the tuple is already in the map\n        if _, ok := result[v[0]]; ok {\n            // Append the second element of the tuple to the list\n            result[v[0]] = append(result[v[0]], v[1])\n        } else {\n            // Create a new list and append the second element of the tuple\n            result[v[0]] = []interface{}{v[1]}\n        }\n    }\n    // Create a list to store the result\n    result_list := make([][]interface{}, 0)\n    // Iterate over the map\n    for k, v := range result {\n        // Append the key and the list to the result list\n        result_list = append(result_list, []interface{}{k, v})\n    }\n    // Return the result list\n    return result_list\n}\n",
    "    var Output [][]interface{}\n    var FirstElement interface{}\n    var Group []interface{}\n    var Grouped bool\n    for _, Tuple := range Input {\n        if len(Tuple) > 0 {\n            FirstElement = Tuple[0]\n            Grouped = false\n            for _, Group = range Output {\n                if Group[0] == FirstElement {\n                    Group = append(Group, Tuple[1:]...)\n                    Grouped = true\n                    break\n                }\n            }\n            if !Grouped {\n                Output = append(Output, Tuple)\n            }\n        }\n    }\n    return Output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, v := range Input {\n        flag = false\n        for _, v2 := range result {\n            if v[0] == v2[0] {\n                flag = true\n                v2 = append(v2, v[1])\n                break\n            }\n        }\n        if flag == false {\n            temp = []interface{}{v[0], v[1]}\n            result = append(result, temp)\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, v := range Input {\n        flag = false\n        for i, r := range result {\n            if v[0] == r[0] {\n                result[i] = append(result[i], v[1])\n                flag = true\n                break\n            }\n        }\n        if !flag {\n            temp = append(temp, v[0])\n            temp = append(temp, v[1])\n            result = append(result, temp)\n            temp = []interface{}{}\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    for _, tuple := range Input {\n        if len(temp) == 0 {\n            temp = append(temp, tuple[0])\n            temp = append(temp, tuple[1])\n        } else {\n            if temp[0] == tuple[0] {\n                temp = append(temp, tuple[1])\n            } else {\n                result = append(result, temp)\n                temp = nil\n                temp = append(temp, tuple[0])\n                temp = append(temp, tuple[1])\n            }\n        }\n    }\n    result = append(result, temp)\n    return result\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, val := range Input {\n        flag = false\n        for _, val1 := range Output {\n            if val[0] == val1[0] {\n                val1 = append(val1, val[1])\n                flag = true\n            }\n        }\n        if flag == false {\n            temp = append(temp, val[0])\n            temp = append(temp, val[1])\n            Output = append(Output, temp)\n            temp = nil\n        }\n    }\n    return Output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    for i := 0; i < len(Input); i++ {\n        if i == 0 {\n            temp = append(temp, Input[i][0])\n            temp = append(temp, Input[i][1])\n        } else {\n            if Input[i][0] == Input[i-1][0] {\n                temp = append(temp, Input[i][1])\n            } else {\n                result = append(result, temp)\n                temp = []interface{}{}\n                temp = append(temp, Input[i][0])\n                temp = append(temp, Input[i][1])\n            }\n        }\n    }\n    result = append(result, temp)\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, v := range Input {\n        flag = false\n        for _, v1 := range result {\n            if v[0] == v1[0] {\n                flag = true\n                v1 = append(v1, v[1])\n            }\n        }\n        if !flag {\n            temp = append(temp, v[0])\n            temp = append(temp, v[1])\n            result = append(result, temp)\n            temp = nil\n        }\n    }\n    return result\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    for _, v := range Input {\n        if len(temp) == 0 {\n            temp = append(temp, v[0])\n            temp = append(temp, v[1])\n        } else {\n            if v[0] == temp[0] {\n                temp = append(temp, v[1])\n            } else {\n                Output = append(Output, temp)\n                temp = []interface{}{}\n                temp = append(temp, v[0])\n                temp = append(temp, v[1])\n            }\n        }\n    }\n    Output = append(Output, temp)\n    return Output\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var temp_map = make(map[interface{}]int)\n    for _, v := range Input {\n        temp_map[v[0]]++\n    }\n    for k, v := range temp_map {\n        temp = append(temp, k)\n        temp = append(temp, v)\n        Output = append(Output, temp)\n        temp = nil\n    }\n    return Output\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, v := range Input {\n        flag = false\n        for _, vv := range Output {\n            if v[0] == vv[0] {\n                flag = true\n                vv = append(vv, v[1])\n                break\n            }\n        }\n        if !flag {\n            temp = append(temp, v[0])\n            temp = append(temp, v[1])\n            Output = append(Output, temp)\n            temp = []interface{}{}\n        }\n    }\n    return Output\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var temp_map = make(map[interface{}][]interface{})\n    for _, v := range Input {\n        temp_map[v[0]] = append(temp_map[v[0]], v[1])\n    }\n    for k, v := range temp_map {\n        temp = append(temp, k)\n        temp = append(temp, v)\n        Output = append(Output, temp)\n        temp = nil\n    }\n    return Output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_tuple []interface{}\n    var flag bool\n    for _, tuple := range Input {\n        if len(temp) == 0 {\n            temp = append(temp, tuple[0])\n            temp_tuple = append(temp_tuple, tuple)\n        } else {\n            flag = false\n            for _, t := range temp {\n                if t == tuple[0] {\n                    flag = true\n                    break\n                }\n            }\n            if flag {\n                temp_tuple = append(temp_tuple, tuple)\n            } else {\n                result = append(result, temp_tuple)\n                temp = append(temp, tuple[0])\n                temp_tuple = []interface{}{tuple}\n            }\n        }\n    }\n    result = append(result, temp_tuple)\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var first interface{}\n    var second []interface{}\n    var flag bool\n    for _, v := range Input {\n        if len(v) == 0 {\n            continue\n        }\n        first = v[0]\n        second = v[1:]\n        flag = false\n        for i, r := range result {\n            if r[0] == first {\n                result[i] = append(result[i], second...)\n                flag = true\n                break\n            }\n        }\n        if !flag {\n            temp = append(temp, first)\n            temp = append(temp, second...)\n            result = append(result, temp)\n            temp = []interface{}{}\n        }\n    }\n    return result\n}\n",
    "    var Output [][]interface{}\n    for _, tuple := range Input {\n        var found bool\n        for i, group := range Output {\n            if group[0] == tuple[0] {\n                Output[i] = append(Output[i], tuple[1])\n                found = true\n                break\n            }\n        }\n        if !found {\n            Output = append(Output, tuple)\n        }\n    }\n    return Output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_map = make(map[interface{}][]interface{})\n\n    for _, tuple := range Input {\n        if _, ok := temp_map[tuple[0]]; ok {\n            temp_map[tuple[0]] = append(temp_map[tuple[0]], tuple[1])\n        } else {\n            temp_map[tuple[0]] = []interface{}{tuple[1]}\n        }\n    }\n\n    for key, value := range temp_map {\n        temp = append(temp, key)\n        temp = append(temp, value)\n        result = append(result, temp)\n        temp = []interface{}{}\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, v := range Input {\n        if len(result) == 0 {\n            result = append(result, v)\n        } else {\n            flag = false\n            for _, v1 := range result {\n                if v[0] == v1[0] {\n                    temp = append(temp, v[1])\n                    flag = true\n                    break\n                }\n            }\n            if !flag {\n                result = append(result, v)\n            }\n        }\n    }\n    return result\n}\n",
    "    // Write your code here\n    var output [][]interface{}\n    var temp []interface{}\n    var temp_list []interface{}\n    var temp_list_list [][]interface{}\n    for i := 0; i < len(Input); i++ {\n        temp = Input[i]\n        if len(temp) > 0 {\n            temp_list = append(temp_list, temp[0])\n        }\n    }\n    for i := 0; i < len(temp_list); i++ {\n        temp_list_list = append(temp_list_list, []interface{}{temp_list[i]})\n    }\n    output = temp_list_list\n    return output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for i, v := range Input {\n        flag = false\n        for j, vv := range result {\n            if v[0] == vv[0] {\n                flag = true\n                temp = append(temp, v[1])\n                result[j] = append(result[j], temp...)\n                temp = nil\n            }\n        }\n        if !flag {\n            temp = append(temp, v[1])\n            result = append(result, append([]interface{}{v[0]}, temp...))\n            temp = nil\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    for _, v := range Input {\n        if len(temp) == 0 {\n            temp = append(temp, v[0])\n            temp = append(temp, v[1])\n        } else {\n            if temp[0] == v[0] {\n                temp = append(temp, v[1])\n            } else {\n                result = append(result, temp)\n                temp = []interface{}{}\n                temp = append(temp, v[0])\n                temp = append(temp, v[1])\n            }\n        }\n    }\n    if len(temp) != 0 {\n        result = append(result, temp)\n    }\n    return result\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var aa int\n    var bb int\n    var cc int\n    var dd int\n    var ee int\n    var ff int\n    var gg int\n    var hh int\n    var ii int\n    var jj int\n    var kk int\n    var ll int\n    var mm int\n    var nn int\n    var oo int\n    var pp int\n    var qq int\n    var rr int\n    var ss int\n    var tt int\n    var uu int\n    var vv int\n    var ww int\n    var xx int\n    var yy int\n    var zz int\n    var aaa int\n    var bbb int\n    var ccc int\n    var ddd int\n    var eee int\n    var fff int\n    var ggg int\n    var hhh int\n    var iii int\n    var jjj int\n    var kkk int\n    var lll int\n    var mmm int\n    var nnn int\n    var ooo int\n    var ppp int\n    var qqq int\n    var rrr int\n    var sss int\n    var ttt int\n    var uuu int\n    var vvv int\n    var www int\n    var xxx int\n    var yyy int\n    var zzz int\n    var aaaa int\n    var bbbb int\n    var cccc int\n    var dddd int\n    var eeee int\n    var ffff int\n    var gggg int\n    var hhhh int\n    var iiii int\n    var jjjj int\n    var kkkk int\n    var llll int\n    var mmmm int\n    var nnnn int\n    var oooo int\n    var ppp",
    "    var output [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, tuple := range Input {\n        flag = false\n        for _, t := range output {\n            if tuple[0] == t[0] {\n                flag = true\n                t[1] = append(t[1].([]interface{}), tuple[1])\n            }\n        }\n        if !flag {\n            temp = []interface{}{tuple[0], []interface{}{tuple[1]}}\n            output = append(output, temp)\n        }\n    }\n    return output\n}\n",
    "    var result [][]interface{}\n    for _, v := range Input {\n        if len(v) > 0 {\n            result = append(result, v)\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, v := range Input {\n        flag = false\n        for i, v1 := range result {\n            if v[0] == v1[0] {\n                flag = true\n                result[i] = append(result[i], v[1])\n            }\n        }\n        if !flag {\n            temp = []interface{}{v[0]}\n            temp = append(temp, v[1])\n            result = append(result, temp)\n        }\n    }\n    return result\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, tuple := range Input {\n        flag = false\n        for i, t := range Output {\n            if tuple[0] == t[0] {\n                flag = true\n                Output[i] = append(Output[i], tuple[1])\n            }\n        }\n        if !flag {\n            temp = append(temp, tuple[0])\n            temp = append(temp, tuple[1])\n            Output = append(Output, temp)\n            temp = []interface{}{}\n        }\n    }\n    return Output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, value := range Input {\n        flag = false\n        for _, value2 := range result {\n            if value[0] == value2[0] {\n                flag = true\n                temp = value2\n                break\n            }\n        }\n        if flag {\n            temp = append(temp, value[1])\n        } else {\n            temp = []interface{}{value[0], value[1]}\n            result = append(result, temp)\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var first_element_map = make(map[interface{}][]interface{})\n    for _, tuple := range Input {\n        first_element_map[tuple[0]] = append(first_element_map[tuple[0]], tuple[1])\n    }\n    for key, value := range first_element_map {\n        result = append(result, []interface{}{key, value})\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, tuple := range Input {\n        flag = false\n        for _, group := range result {\n            if group[0] == tuple[0] {\n                group = append(group, tuple[1])\n                flag = true\n                break\n            }\n        }\n        if !flag {\n            temp = append(temp, tuple[0])\n            temp = append(temp, tuple[1])\n            result = append(result, temp)\n            temp = []interface{}{}\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_result []interface{}\n    var temp_result_1 []interface{}\n    var temp_result_2 []interface{}\n    var temp_result_3 []interface{}\n    var temp_result_4 []interface{}\n    var temp_result_5 []interface{}\n    var temp_result_6 []interface{}\n    var temp_result_7 []interface{}\n    var temp_result_8 []interface{}\n    var temp_result_9 []interface{}\n    var temp_result_10 []interface{}\n    var temp_result_11 []interface{}\n    var temp_result_12 []interface{}\n    var temp_result_13 []interface{}\n    var temp_result_14 []interface{}\n    var temp_result_15 []interface{}\n    var temp_result_16 []interface{}\n    var temp_result_17 []interface{}\n    var temp_result_18 []interface{}\n    var temp_result_19 []interface{}\n    var temp_result_20 []interface{}\n    var temp_result_21 []interface{}\n    var temp_result_22 []interface{}\n    var temp_result_23 []interface{}\n    var temp_result_24 []interface{}\n    var temp_result_25 []interface{}\n    var temp_result_26 []interface{}\n    var temp_result_27 []interface{}\n    var temp_result_28 []interface{}\n    var temp_result_29 []interface{}\n    var temp_result_30 []interface{}\n    var temp_result_31 []interface{}\n    var temp_result_32 []interface{}\n    var temp_result_33 []interface{}\n    var temp_result_34 []interface{}\n    var temp_result_35 []interface{}\n    var temp_result_36 []interface{}\n    var temp_result_37 []interface{}\n    var temp_result_38 []interface{}\n    var temp_result_39 []interface{}\n    var temp_result_40 []interface{}\n    var temp",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, tuple := range Input {\n        flag = false\n        for _, group := range Output {\n            if group[0] == tuple[0] {\n                flag = true\n                temp = group\n                break\n            }\n        }\n        if flag {\n            temp = append(temp, tuple[1])\n        } else {\n            temp = append(temp, tuple[0], tuple[1])\n            Output = append(Output, temp)\n        }\n    }\n    return Output\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var aa int\n    var ab int\n    var ac int\n    var ad int\n    var ae int\n    var af int\n    var ag int\n    var ah int\n    var ai int\n    var aj int\n    var ak int\n    var al int\n    var am int\n    var an int\n    var ao int\n    var ap int\n    var aq int\n    var ar int\n    var as int\n    var at int\n    var au int\n    var av int\n    var aw int\n    var ax int\n    var ay int\n    var az int\n    var ba int\n    var bb int\n    var bc int\n    var bd int\n    var be int\n    var bf int\n    var bg int\n    var bh int\n    var bi int\n    var bj int\n    var bk int\n    var bl int\n    var bm int\n    var bn int\n    var bo int\n    var bp int\n    var bq int\n    var br int\n    var bs int\n    var bt int\n    var bu int\n    var bv int\n    var bw int\n    var bx int\n    var by int\n    var bz int\n    var ca int\n    var cb int\n    var cc int\n    var cd int\n    var ce int\n    var cf int\n    var cg int\n    var ch int\n    var ci int\n    var cj int\n    var ck int\n    var cl int\n    var cm int\n    var cn int\n    var co int\n    var cp int\n    var cq int\n    var cr int\n    var cs int\n    var ct int\n    var cu int\n    var cv int\n   ",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var temp_list []interface{}\n    var temp_list_list [][]interface{}\n    var temp_list_list_list [][][]interface{}\n    var temp_list_list_list_list [][][][]interface{}\n    var temp_list_list_list_list_list [][][][][]interface{}\n    var temp_list_list_list_list_list_list [][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list [][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list [][][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list_list [][][][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list_list_list [][][][][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list_list_list_list [][][][][][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list_list_list_list_list [][][][][][][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list_list_list_list_list_list [][][][][][][][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list_list_list_list_list_list_list [][][][][][][][][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list [][][][][][][][][][][][][][][]interface{}\n    var temp_list_list_list_list_list_",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, v := range Input {\n        flag = false\n        for i, v2 := range Output {\n            if v[0] == v2[0] {\n                flag = true\n                Output[i] = append(Output[i], v[1])\n            }\n        }\n        if !flag {\n            temp = append(temp, v[0])\n            temp = append(temp, v[1])\n            Output = append(Output, temp)\n            temp = []interface{}{}\n        }\n    }\n    return Output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    for i, v := range Input {\n        if i == 0 {\n            temp = append(temp, v[0])\n            temp = append(temp, v[1])\n        } else {\n            if v[0] == Input[i-1][0] {\n                temp = append(temp, v[1])\n            } else {\n                result = append(result, temp)\n                temp = []interface{}{}\n                temp = append(temp, v[0])\n                temp = append(temp, v[1])\n            }\n        }\n    }\n    result = append(result, temp)\n    return result\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, v := range Input {\n        flag = false\n        for _, v2 := range Output {\n            if v[0] == v2[0] {\n                v2 = append(v2, v[1])\n                flag = true\n            }\n        }\n        if !flag {\n            temp = append(temp, v[0])\n            temp = append(temp, v[1])\n            Output = append(Output, temp)\n            temp = []interface{}{}\n        }\n    }\n    return Output\n}\n",
    "    var Output [][]interface{}\n    var FirstElement interface{}\n    var Group []interface{}\n    for _, Tuple := range Input {\n        if FirstElement == nil {\n            FirstElement = Tuple[0]\n            Group = append(Group, Tuple)\n        } else if FirstElement == Tuple[0] {\n            Group = append(Group, Tuple)\n        } else {\n            Output = append(Output, Group)\n            FirstElement = Tuple[0]\n            Group = []interface{}{Tuple}\n        }\n    }\n    Output = append(Output, Group)\n    return Output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_map map[interface{}]bool = make(map[interface{}]bool)\n    for _, tuple := range Input {\n        if _, ok := temp_map[tuple[0]]; !ok {\n            temp_map[tuple[0]] = true\n            temp = append(temp, tuple[0])\n        }\n    }\n    for _, t := range temp {\n        var temp_tuple []interface{}\n        for _, tuple := range Input {\n            if tuple[0] == t {\n                temp_tuple = append(temp_tuple, tuple[1])\n            }\n        }\n        result = append(result, temp_tuple)\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_map map[interface{}]bool\n    temp_map = make(map[interface{}]bool)\n\n    for _, tuple := range Input {\n        if _, ok := temp_map[tuple[0]]; !ok {\n            temp_map[tuple[0]] = true\n            temp = append(temp, tuple[0])\n        }\n    }\n\n    for _, key := range temp {\n        var temp_tuple []interface{}\n        for _, tuple := range Input {\n            if key == tuple[0] {\n                temp_tuple = append(temp_tuple, tuple)\n            }\n        }\n        result = append(result, temp_tuple)\n    }\n\n    return result\n}\n",
    "    var Output [][]interface{}\n    var FirstElement interface{}\n    var FirstElementIndex int\n    var FirstElementFound bool\n    var FirstElementTuple []interface{}\n    var FirstElementTupleIndex int\n    var FirstElementTupleFound bool\n    var Tuple []interface{}\n    var TupleIndex int\n    var TupleFound bool\n    var TupleElement interface{}\n    var TupleElementIndex int\n    var TupleElementFound bool\n    var TupleElementTuple []interface{}\n    var TupleElementTupleIndex int\n    var TupleElementTupleFound bool\n    var TupleElementTupleElement interface{}\n    var TupleElementTupleElementIndex int\n    var TupleElementTupleElementFound bool\n    var TupleElementTupleElementTuple []interface{}\n    var TupleElementTupleElementTupleIndex int\n    var TupleElementTupleElementTupleFound bool\n    var TupleElementTupleElementTupleElement interface{}\n    var TupleElementTupleElementTupleElementIndex int\n    var TupleElementTupleElementTupleElementFound bool\n    var TupleElementTupleElementTupleElementTuple []interface{}\n    var TupleElementTupleElementTupleElementTupleIndex int\n    var TupleElementTupleElementTupleElementTupleFound bool\n    var TupleElementTupleElementTupleElementTupleElement interface{}\n    var TupleElementTupleElementTupleElementTupleElementIndex int\n    var TupleElementTupleElementTupleElementTupleElementFound bool\n    var TupleElementTupleElementTupleElementTupleElementTuple []interface{}\n    var TupleElementTupleElementTupleElementTupleElementTupleIndex int\n    var TupleElementTupleElementTupleElementTupleElementTupleFound bool\n    var TupleElementTupleElementTupleElementTupleElementTupleElement interface{}\n    var TupleElementTupleElementTupleElementTupleElementTupleElementIndex int\n    var TupleElementTupleElementTupleElementTupleElementTupleElementFound bool\n    var TupleElementTupleElementTupleElementTupleElementTupleElementTuple []interface{}\n    var TupleElementT",
    "    var result [][]interface{}\n    var temp []interface{}\n    var count int\n    for i := 0; i < len(Input); i++ {\n        count = 0\n        for j := 0; j < len(Input); j++ {\n            if Input[i][0] == Input[j][0] {\n                count++\n            }\n        }\n        if count > 1 {\n            temp = append(temp, Input[i][0])\n            temp = append(temp, count)\n            result = append(result, temp)\n            temp = nil\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, v := range Input {\n        if len(result) == 0 {\n            result = append(result, v)\n        } else {\n            flag = false\n            for _, v1 := range result {\n                if v1[0] == v[0] {\n                    flag = true\n                    temp = append(temp, v[1])\n                    v1[1] = temp\n                    break\n                }\n            }\n            if !flag {\n                result = append(result, v)\n            }\n        }\n    }\n    return result\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var temp_slice []interface{}\n    var temp_slice_slice [][]interface{}\n    var temp_slice_slice_slice [][][]interface{}\n    var temp_slice_slice_slice_slice [][][][]interface{}\n    var temp_slice_slice_slice_slice_slice [][][][][]interface{}\n    var temp_slice_slice_slice_slice_slice_slice [][][][][][]interface{}\n    var temp_slice_slice_slice_slice_slice_slice_slice [][][][][][][]interface{}\n    var temp_slice_slice_slice_slice_slice_slice_slice_slice [][][][][][][][]interface{}\n    var temp_slice_slice_slice_slice_slice_slice_slice_slice_slice [][][][][][][][][]interface{}\n    var temp_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice [][][][][][][][][][]interface{}\n    var temp_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice [][][][][][][][][][][]interface{}\n    var temp_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice [][][][][][][][][][][][]interface{}\n    var temp_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice [][][][][][][][][][][][][]interface{}\n    var temp_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice [][][][][][][][][][][][][][]interface{}\n    var temp_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice [][][][][][][][][][][][][][][]interface{}\n    var temp_slice_slice_slice_slice_slice_",
    "    var Output [][]interface{}\n    for _, tuple := range Input {\n        var found bool\n        for i, group := range Output {\n            if group[0] == tuple[0] {\n                Output[i] = append(Output[i], tuple[1])\n                found = true\n                break\n            }\n        }\n        if !found {\n            Output = append(Output, tuple)\n        }\n    }\n    return Output\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    for i := 0; i < len(Input); i++ {\n        temp = append(temp, Input[i][0])\n    }\n    for i := 0; i < len(temp); i++ {\n        var temp2 []interface{}\n        for j := 0; j < len(Input); j++ {\n            if temp[i] == Input[j][0] {\n                temp2 = append(temp2, Input[j])\n            }\n        }\n        Output = append(Output, temp2)\n    }\n    return Output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_map = make(map[interface{}][]interface{})\n    for _, v := range Input {\n        temp_map[v[0]] = append(temp_map[v[0]], v[1])\n    }\n    for k, v := range temp_map {\n        temp = append(temp, k)\n        temp = append(temp, v)\n        result = append(result, temp)\n        temp = nil\n    }\n    return result\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var temp_map map[interface{}]int\n    temp_map = make(map[interface{}]int)\n    for _, tuple := range Input {\n        if _, ok := temp_map[tuple[0]]; ok {\n            temp_map[tuple[0]] += 1\n        } else {\n            temp_map[tuple[0]] = 1\n        }\n    }\n    for key, value := range temp_map {\n        temp = append(temp, key, value)\n        Output = append(Output, temp)\n        temp = nil\n    }\n    return Output\n}\n",
    "    // Write your code here\n    var result [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for i := 0; i < len(Input); i++ {\n        flag = false\n        for j := 0; j < len(result); j++ {\n            if Input[i][0] == result[j][0] {\n                flag = true\n                result[j] = append(result[j], Input[i][1])\n            }\n        }\n        if !flag {\n            temp = []interface{}{Input[i][0]}\n            temp = append(temp, Input[i][1])\n            result = append(result, temp)\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var tmp []interface{}\n    for _, t := range Input {\n        if len(tmp) == 0 {\n            tmp = append(tmp, t[0])\n        } else if tmp[0] == t[0] {\n            tmp = append(tmp, t[1])\n        } else {\n            result = append(result, tmp)\n            tmp = []interface{}{t[0], t[1]}\n        }\n    }\n    result = append(result, tmp)\n    return result\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var temp_map = make(map[interface{}]int)\n    for _, v := range Input {\n        temp_map[v[0]] = 1\n    }\n    for k, _ := range temp_map {\n        temp = append(temp, k)\n    }\n    Output = append(Output, temp)\n    return Output\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, tuple := range Input {\n        flag = false\n        for _, group := range Output {\n            if tuple[0] == group[0] {\n                flag = true\n                group = append(group, tuple[1])\n                break\n            }\n        }\n        if flag == false {\n            temp = []interface{}{tuple[0]}\n            temp = append(temp, tuple[1])\n            Output = append(Output, temp)\n        }\n    }\n    return Output\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var flag bool\n\n    for _, v := range Input {\n        flag = false\n        for _, vv := range Output {\n            if v[0] == vv[0] {\n                flag = true\n                vv = append(vv, v[1])\n            }\n        }\n        if !flag {\n            temp = append(temp, v[0])\n            temp = append(temp, v[1])\n            Output = append(Output, temp)\n            temp = []interface{}{}\n        }\n    }\n    return Output\n}\n",
    "    var result [][]interface{}\n    for i := 0; i < len(Input); i++ {\n        var temp []interface{}\n        for j := 0; j < len(Input); j++ {\n            if Input[i][0] == Input[j][0] {\n                temp = append(temp, Input[j][1])\n            }\n        }\n        result = append(result, temp)\n    }\n    return result\n}\n",
    "    // Write your code here\n    var result [][]interface{}\n    var temp []interface{}\n    var temp_map map[interface{}]int\n    temp_map = make(map[interface{}]int)\n    for _, v := range Input {\n        if _, ok := temp_map[v[0]]; ok {\n            temp_map[v[0]]++\n        } else {\n            temp_map[v[0]] = 1\n        }\n    }\n    for k, v := range temp_map {\n        if v > 1 {\n            temp = append(temp, k)\n        }\n    }\n    result = append(result, temp)\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    for i := 0; i < len(Input); i++ {\n        if i == 0 {\n            temp = append(temp, Input[i][0])\n            result = append(result, temp)\n        } else {\n            if Input[i][0] == Input[i-1][0] {\n                result[len(result)-1] = append(result[len(result)-1], Input[i][1])\n            } else {\n                temp = append(temp, Input[i][0])\n                result = append(result, temp)\n            }\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, v := range Input {\n        if len(temp) == 0 {\n            temp = append(temp, v[0])\n            temp = append(temp, v[1])\n            continue\n        }\n        flag = false\n        for i, v1 := range temp {\n            if v[0] == v1 {\n                temp[i+1] = v[1]\n                flag = true\n                break\n            }\n        }\n        if !flag {\n            result = append(result, temp)\n            temp = []interface{}{}\n            temp = append(temp, v[0])\n            temp = append(temp, v[1])\n        }\n    }\n    result = append(result, temp)\n    return result\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    for i := 0; i < len(Input); i++ {\n        if i == 0 {\n            temp = append(temp, Input[i][0])\n        } else {\n            if Input[i][0] == Input[i-1][0] {\n                temp = append(temp, Input[i][1])\n            } else {\n                Output = append(Output, temp)\n                temp = []interface{}{Input[i][0], Input[i][1]}\n            }\n        }\n    }\n    Output = append(Output, temp)\n    return Output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, v := range Input {\n        if len(result) == 0 {\n            result = append(result, v)\n        } else {\n            flag = false\n            for i, v1 := range result {\n                if v[0] == v1[0] {\n                    temp = append(temp, v[1])\n                    result[i] = append(result[i], temp...)\n                    flag = true\n                    break\n                }\n            }\n            if !flag {\n                result = append(result, v)\n            }\n        }\n    }\n    return result\n}\n",
    "    var Output [][]interface{}\n    var FirstElement interface{}\n    var Group []interface{}\n    for i := 0; i < len(Input); i++ {\n        if i == 0 {\n            FirstElement = Input[i][0]\n            Group = append(Group, Input[i])\n        } else {\n            if Input[i][0] == FirstElement {\n                Group = append(Group, Input[i])\n            } else {\n                Output = append(Output, Group)\n                Group = nil\n                Group = append(Group, Input[i])\n                FirstElement = Input[i][0]\n            }\n        }\n    }\n    Output = append(Output, Group)\n    return Output\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var temp_map = make(map[interface{}][]interface{})\n    for _, v := range Input {\n        temp_map[v[0]] = append(temp_map[v[0]], v[1])\n    }\n    for k, v := range temp_map {\n        temp = append(temp, k)\n        temp = append(temp, v)\n        Output = append(Output, temp)\n        temp = temp[:0]\n    }\n    return Output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_map = make(map[interface{}][]interface{})\n    for _, v := range Input {\n        temp_map[v[0]] = append(temp_map[v[0]], v[1])\n    }\n    for k, v := range temp_map {\n        temp = append(temp, k)\n        temp = append(temp, v)\n        result = append(result, temp)\n        temp = nil\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, v := range Input {\n        flag = false\n        for _, v1 := range result {\n            if v1[0] == v[0] {\n                flag = true\n                v1 = append(v1, v[1])\n                break\n            }\n        }\n        if !flag {\n            temp = append(temp, v[0])\n            temp = append(temp, v[1])\n            result = append(result, temp)\n            temp = []interface{}{}\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_map map[interface{}]interface{}\n    temp_map = make(map[interface{}]interface{})\n    for _, v := range Input {\n        if _, ok := temp_map[v[0]]; !ok {\n            temp_map[v[0]] = v[0]\n            temp = append(temp, v[0])\n        }\n    }\n    for _, v := range temp {\n        var temp_slice []interface{}\n        for _, v1 := range Input {\n            if v == v1[0] {\n                temp_slice = append(temp_slice, v1[1])\n            }\n        }\n        result = append(result, []interface{}{v, temp_slice})\n    }\n    return result\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var temp_map map[interface{}]bool\n    temp_map = make(map[interface{}]bool)\n    for _, v := range Input {\n        if _, ok := temp_map[v[0]]; !ok {\n            temp_map[v[0]] = true\n            temp = append(temp, v[0])\n        }\n    }\n    for _, v := range temp {\n        var temp_list []interface{}\n        for _, vv := range Input {\n            if vv[0] == v {\n                temp_list = append(temp_list, vv[1])\n            }\n        }\n        Output = append(Output, []interface{}{v, temp_list})\n    }\n    return Output\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, tuple := range Input {\n        flag = false\n        for _, group := range Output {\n            if group[0] == tuple[0] {\n                flag = true\n                temp = append(group, tuple[1])\n                Output = append(Output[:len(Output)-1], temp)\n                break\n            }\n        }\n        if flag == false {\n            Output = append(Output, tuple)\n        }\n    }\n    return Output\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var temp2 []interface{}\n    var temp3 []interface{}\n    var temp4 []interface{}\n    var temp5 []interface{}\n    var temp6 []interface{}\n    var temp7 []interface{}\n    var temp8 []interface{}\n    var temp9 []interface{}\n    var temp10 []interface{}\n    var temp11 []interface{}\n    var temp12 []interface{}\n    var temp13 []interface{}\n    var temp14 []interface{}\n    var temp15 []interface{}\n    var temp16 []interface{}\n    var temp17 []interface{}\n    var temp18 []interface{}\n    var temp19 []interface{}\n    var temp20 []interface{}\n    var temp21 []interface{}\n    var temp22 []interface{}\n    var temp23 []interface{}\n    var temp24 []interface{}\n    var temp25 []interface{}\n    var temp26 []interface{}\n    var temp27 []interface{}\n    var temp28 []interface{}\n    var temp29 []interface{}\n    var temp30 []interface{}\n    var temp31 []interface{}\n    var temp32 []interface{}\n    var temp33 []interface{}\n    var temp34 []interface{}\n    var temp35 []interface{}\n    var temp36 []interface{}\n    var temp37 []interface{}\n    var temp38 []interface{}\n    var temp39 []interface{}\n    var temp40 []interface{}\n    var temp41 []interface{}\n    var temp42 []interface{}\n    var temp43 []interface{}\n    var temp44 []interface{}\n    var temp45 []interface{}\n    var temp46 []interface{}\n    var temp47 []interface{}\n    var temp48 []interface{}\n    var temp49 []interface{}\n    var temp50 []interface{}\n    var temp51 []interface{}\n    var temp52 []interface{}\n    var temp53 []interface{}\n    var temp54 []interface{}\n    var temp55 []interface{}\n    var temp56 []interface{",
    "    var result [][]interface{}\n    var temp []interface{}\n    for i := 0; i < len(Input); i++ {\n        if i == 0 {\n            temp = append(temp, Input[i][0])\n            result = append(result, temp)\n            temp = []interface{}{}\n        } else {\n            for j := 0; j < len(result); j++ {\n                if Input[i][0] == result[j][0] {\n                    result[j] = append(result[j], Input[i][1])\n                    break\n                } else if j == len(result)-1 {\n                    temp = append(temp, Input[i][0])\n                    result = append(result, temp)\n                    temp = []interface{}{}\n                }\n            }\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    for i := 0; i < len(Input); i++ {\n        if i == 0 {\n            temp = append(temp, Input[i][0])\n            temp = append(temp, Input[i][1])\n            result = append(result, temp)\n        } else {\n            for j := 0; j < len(result); j++ {\n                if Input[i][0] == result[j][0] {\n                    result[j] = append(result[j], Input[i][1])\n                    break\n                } else if j == len(result) - 1 {\n                    temp = append(temp, Input[i][0])\n                    temp = append(temp, Input[i][1])\n                    result = append(result, temp)\n                    break\n                }\n            }\n        }\n    }\n    return result\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var temp_index int\n    var temp_flag bool\n    for _, v := range Input {\n        temp_flag = false\n        for i, v1 := range Output {\n            if v[0] == v1[0] {\n                temp_flag = true\n                temp_index = i\n            }\n        }\n        if temp_flag {\n            temp = Output[temp_index]\n            temp = append(temp, v[1])\n            Output[temp_index] = temp\n        } else {\n            temp = []interface{}{v[0]}\n            temp = append(temp, v[1])\n            Output = append(Output, temp)\n        }\n    }\n    return Output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_map = make(map[interface{}]int)\n    for _, v := range Input {\n        if _, ok := temp_map[v[0]]; ok {\n            temp = append(temp, v[1])\n            temp_map[v[0]] = 1\n        } else {\n            if len(temp) > 0 {\n                result = append(result, temp)\n            }\n            temp = []interface{}{v[0], v[1]}\n            temp_map[v[0]] = 1\n        }\n    }\n    if len(temp) > 0 {\n        result = append(result, temp)\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp2 []interface{}\n    for i := 0; i < len(Input); i++ {\n        temp = append(temp, Input[i][0])\n    }\n    for i := 0; i < len(temp); i++ {\n        for j := i + 1; j < len(temp); j++ {\n            if temp[i] == temp[j] {\n                temp2 = append(temp2, temp[i])\n            }\n        }\n    }\n    for i := 0; i < len(temp2); i++ {\n        for j := 0; j < len(Input); j++ {\n            if temp2[i] == Input[j][0] {\n                result = append(result, Input[j])\n            }\n        }\n    }\n    return result\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var temp_list []interface{}\n    var temp_list_list [][]interface{}\n    var temp_list_list_list [][][]interface{}\n    var temp_list_list_list_list [][][][]interface{}\n    var temp_list_list_list_list_list [][][][][]interface{}\n    var temp_list_list_list_list_list_list [][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list [][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list [][][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list_list [][][][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list_list_list [][][][][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list_list_list_list [][][][][][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list_list_list_list_list [][][][][][][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list_list_list_list_list_list [][][][][][][][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list_list_list_list_list_list_list [][][][][][][][][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list [][][][][][][][][][][][][][][]interface{}\n    var temp_list_list_list_list_list_",
    "    var result [][]interface{}\n    var first_elements []interface{}\n    for _, tuple := range Input {\n        if !contains(first_elements, tuple[0]) {\n            first_elements = append(first_elements, tuple[0])\n        }\n    }\n    for _, first_element := range first_elements {\n        var group []interface{}\n        for _, tuple := range Input {\n            if tuple[0] == first_element {\n                group = append(group, tuple)\n            }\n        }\n        result = append(result, group)\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, v := range Input {\n        if len(temp) == 0 {\n            temp = append(temp, v[0])\n            temp = append(temp, v[1])\n            result = append(result, temp)\n            temp = temp[:0]\n        } else {\n            flag = false\n            for _, v1 := range result {\n                if v[0] == v1[0] {\n                    v1 = append(v1, v[1])\n                    flag = true\n                }\n            }\n            if !flag {\n                temp = append(temp, v[0])\n                temp = append(temp, v[1])\n                result = append(result, temp)\n                temp = temp[:0]\n            }\n        }\n    }\n    return result\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, tuple := range Input {\n        flag = false\n        for _, group := range Output {\n            if group[0] == tuple[0] {\n                flag = true\n                temp = append(group, tuple[1])\n                Output = append(Output[:len(Output)-1], temp)\n            }\n        }\n        if !flag {\n            Output = append(Output, tuple)\n        }\n    }\n    return Output\n}\n",
    "    var output [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, v := range Input {\n        flag = false\n        for i, v2 := range output {\n            if v[0] == v2[0] {\n                output[i] = append(output[i], v[1])\n                flag = true\n                break\n            }\n        }\n        if !flag {\n            temp = append(temp, v[0])\n            temp = append(temp, v[1])\n            output = append(output, temp)\n            temp = []interface{}{}\n        }\n    }\n    return output\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, tuple := range Input {\n        flag = false\n        for _, group := range Output {\n            if tuple[0] == group[0] {\n                flag = true\n                group = append(group, tuple[1])\n            }\n        }\n        if !flag {\n            temp = append(temp, tuple[0])\n            temp = append(temp, tuple[1])\n            Output = append(Output, temp)\n            temp = nil\n        }\n    }\n    return Output\n}\n",
    "    var Output [][]interface{}\n    var FirstElement interface{}\n    var FirstElementIndex int\n    var FirstElementCount int\n    var FirstElementTuple []interface{}\n    var FirstElementTupleIndex int\n    var FirstElementTupleCount int\n    var FirstElementTupleIndexCount int\n    var FirstElementTupleIndexCountIndex int\n    var FirstElementTupleIndexCountIndexCount int\n    var FirstElementTupleIndexCountIndexCountIndex int\n    var FirstElementTupleIndexCountIndexCountIndexCount int\n    var FirstElementTupleIndexCountIndexCountIndexCountIndex int\n    var FirstElementTupleIndexCountIndexCountIndexCountIndexCount int\n    var FirstElementTupleIndexCountIndexCountIndexCountIndexCountIndex int\n    var FirstElementTupleIndexCountIndexCountIndexCountIndexCountIndexCount int\n    var FirstElementTupleIndexCountIndexCountIndexCountIndexCountIndexCountIndex int\n    var FirstElementTupleIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount int\n    var FirstElementTupleIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex int\n    var FirstElementTupleIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount int\n    var FirstElementTupleIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex int\n    var FirstElementTupleIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount int\n    var FirstElementTupleIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex int\n    var FirstElementTupleIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount int\n    var FirstElementTupleIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex int\n    var FirstElementTupleIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount int\n    var FirstElementTupleIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex int\n    var FirstElementTupleIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount int\n    var FirstElementTupleIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex int",
    "    // Write your code here\n    var result [][]interface{}\n    var temp []interface{}\n    var first_element interface{}\n    for _, tuple := range Input {\n        if first_element == nil {\n            first_element = tuple[0]\n            temp = append(temp, tuple[1])\n        } else if first_element == tuple[0] {\n            temp = append(temp, tuple[1])\n        } else {\n            result = append(result, []interface{}{first_element, temp})\n            first_element = tuple[0]\n            temp = []interface{}{tuple[1]}\n        }\n    }\n    result = append(result, []interface{}{first_element, temp})\n    return result\n}\n",
    "    // Write your code here\n    var result [][]interface{}\n    var temp []interface{}\n    for i := 0; i < len(Input); i++ {\n        if i == 0 {\n            temp = append(temp, Input[i][0])\n            temp = append(temp, Input[i][1])\n        } else {\n            if Input[i][0] == Input[i-1][0] {\n                temp = append(temp, Input[i][1])\n            } else {\n                result = append(result, temp)\n                temp = []interface{}{}\n                temp = append(temp, Input[i][0])\n                temp = append(temp, Input[i][1])\n            }\n        }\n    }\n    result = append(result, temp)\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_map = make(map[interface{}][]interface{})\n    for _, v := range Input {\n        temp_map[v[0]] = append(temp_map[v[0]], v[1])\n    }\n    for k, v := range temp_map {\n        temp = append(temp, k)\n        temp = append(temp, v)\n        result = append(result, temp)\n        temp = nil\n    }\n    return result\n}\n",
    "    var output [][]interface{}\n    var temp []interface{}\n    var temp_map map[interface{}]int\n    temp_map = make(map[interface{}]int)\n    for _, v := range Input {\n        if _, ok := temp_map[v[0]]; ok {\n            temp_map[v[0]] += 1\n        } else {\n            temp_map[v[0]] = 1\n        }\n    }\n    for k, v := range temp_map {\n        if v > 1 {\n            temp = append(temp, k)\n        }\n    }\n    output = append(output, temp)\n    return output\n}\n",
    "    // Write your code here\n    var result [][]interface{}\n    var temp []interface{}\n    for i := 0; i < len(Input); i++ {\n        if i == 0 {\n            temp = append(temp, Input[i][0])\n            temp = append(temp, Input[i][1])\n        } else {\n            if Input[i][0] == Input[i-1][0] {\n                temp = append(temp, Input[i][1])\n            } else {\n                result = append(result, temp)\n                temp = nil\n                temp = append(temp, Input[i][0])\n                temp = append(temp, Input[i][1])\n            }\n        }\n    }\n    result = append(result, temp)\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    for _, tuple := range Input {\n        if len(temp) == 0 {\n            temp = append(temp, tuple[0])\n            result = append(result, temp)\n        } else {\n            var found bool\n            for _, t := range result {\n                if t[0] == tuple[0] {\n                    found = true\n                    break\n                }\n            }\n            if !found {\n                temp = append(temp, tuple[0])\n                result = append(result, temp)\n            }\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    for i := 0; i < len(Input); i++ {\n        if i == 0 {\n            temp = append(temp, Input[i][0])\n            temp = append(temp, Input[i][1])\n        } else {\n            if Input[i][0] == Input[i-1][0] {\n                temp = append(temp, Input[i][1])\n            } else {\n                result = append(result, temp)\n                temp = nil\n                temp = append(temp, Input[i][0])\n                temp = append(temp, Input[i][1])\n            }\n        }\n    }\n    result = append(result, temp)\n    return result\n}\n",
    "    var Output [][]interface{}\n    for _, tuple := range Input {\n        if len(tuple) > 0 {\n            Output = append(Output, []interface{}{tuple[0], []interface{}{tuple[1:]}})\n        }\n    }\n    return Output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, v := range Input {\n        flag = false\n        for _, v1 := range result {\n            if v[0] == v1[0] {\n                temp = append(v1, v[1])\n                result = append(result[:len(result)-1], temp)\n                flag = true\n                break\n            }\n        }\n        if !flag {\n            result = append(result, v)\n        }\n    }\n    return result\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, v := range Input {\n        flag = false\n        for _, v2 := range Output {\n            if v[0] == v2[0] {\n                flag = true\n                v2 = append(v2, v[1])\n            }\n        }\n        if !flag {\n            temp = append(temp, v[0])\n            temp = append(temp, v[1])\n            Output = append(Output, temp)\n            temp = []interface{}{}\n        }\n    }\n    return Output\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, v := range Input {\n        flag = false\n        for _, v2 := range Output {\n            if v2[0] == v[0] {\n                flag = true\n                temp = v2\n                break\n            }\n        }\n        if flag {\n            temp = append(temp, v[1])\n        } else {\n            temp = v\n            Output = append(Output, temp)\n        }\n    }\n    return Output\n}\n",
    "    var output [][]interface{}\n    var first_element interface{}\n    var temp []interface{}\n    var flag bool\n    for _, tuple := range Input {\n        first_element = tuple[0]\n        flag = false\n        for _, group := range output {\n            if group[0] == first_element {\n                flag = true\n                group = append(group, tuple[1])\n            }\n        }\n        if !flag {\n            temp = append(temp, first_element)\n            temp = append(temp, tuple[1])\n            output = append(output, temp)\n            temp = nil\n        }\n    }\n    return output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    for _, v := range Input {\n        if len(temp) == 0 {\n            temp = append(temp, v[0])\n            temp = append(temp, v[1])\n        } else {\n            if temp[0] == v[0] {\n                temp = append(temp, v[1])\n            } else {\n                result = append(result, temp)\n                temp = []interface{}{}\n                temp = append(temp, v[0])\n                temp = append(temp, v[1])\n            }\n        }\n    }\n    result = append(result, temp)\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, v := range Input {\n        flag = false\n        for i, v1 := range result {\n            if v[0] == v1[0] {\n                flag = true\n                result[i] = append(result[i], v[1])\n            }\n        }\n        if !flag {\n            temp = []interface{}{v[0]}\n            temp = append(temp, v[1])\n            result = append(result, temp)\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_list []interface{}\n    var temp_list_list [][]interface{}\n    var temp_list_list_list [][][]interface{}\n    var temp_list_list_list_list [][][][]interface{}\n    var temp_list_list_list_list_list [][][][][]interface{}\n    var temp_list_list_list_list_list_list [][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list [][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list [][][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list_list [][][][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list_list_list [][][][][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list_list_list_list [][][][][][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list_list_list_list_list [][][][][][][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list_list_list_list_list_list [][][][][][][][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list_list_list_list_list_list_list [][][][][][][][][][][][][][]interface{}\n    var temp_list_list_list_list_list_list_list_list_list_list_list_list_list_list_list [][][][][][][][][][][][][][][]interface{}\n    var temp_list_list_list_list_list_",
    "    var result [][]interface{}\n    var tmp []interface{}\n    for _, v := range Input {\n        if len(tmp) == 0 {\n            tmp = append(tmp, v[0])\n            result = append(result, tmp)\n        } else {\n            if tmp[0] == v[0] {\n                result = append(result, tmp)\n            } else {\n                tmp = append(tmp, v[0])\n                result = append(result, tmp)\n            }\n        }\n    }\n    return result\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var temp_index int\n    var temp_flag bool\n    for _, tuple := range Input {\n        temp_flag = false\n        for index, output_tuple := range Output {\n            if tuple[0] == output_tuple[0] {\n                temp_flag = true\n                temp_index = index\n                break\n            }\n        }\n        if temp_flag {\n            temp = Output[temp_index]\n            temp = append(temp, tuple[1])\n            Output[temp_index] = temp\n        } else {\n            temp = make([]interface{}, 0)\n            temp = append(temp, tuple[0])\n            temp = append(temp, tuple[1])\n            Output = append(Output, temp)\n        }\n    }\n    return Output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_slice []interface{}\n    var temp_slice_slice [][]interface{}\n    var temp_slice_slice_slice [][][]interface{}\n    var temp_slice_slice_slice_slice [][][][]interface{}\n    var temp_slice_slice_slice_slice_slice [][][][][]interface{}\n    var temp_slice_slice_slice_slice_slice_slice [][][][][][]interface{}\n    var temp_slice_slice_slice_slice_slice_slice_slice [][][][][][][]interface{}\n    var temp_slice_slice_slice_slice_slice_slice_slice_slice [][][][][][][][]interface{}\n    var temp_slice_slice_slice_slice_slice_slice_slice_slice_slice [][][][][][][][][]interface{}\n    var temp_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice [][][][][][][][][][]interface{}\n    var temp_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice [][][][][][][][][][][]interface{}\n    var temp_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice [][][][][][][][][][][][]interface{}\n    var temp_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice [][][][][][][][][][][][][]interface{}\n    var temp_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice [][][][][][][][][][][][][][]interface{}\n    var temp_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice_slice [][][][][][][][][][][][][][][]interface{}\n    var temp_slice_slice_slice_slice_slice_",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_map = make(map[interface{}][]interface{})\n    for _, v := range Input {\n        temp_map[v[0]] = append(temp_map[v[0]], v[1])\n    }\n    for k, v := range temp_map {\n        temp = append(temp, k)\n        temp = append(temp, v)\n        result = append(result, temp)\n        temp = nil\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_index int\n    var temp_count int\n    var temp_count_max int\n    var temp_count_max_index int\n    var temp_count_max_index_list []int\n    var temp_count_max_index_list_index int\n    var temp_count_max_index_list_index_count int\n    var temp_count_max_index_list_index_count_max int\n    var temp_count_max_index_list_index_count_max_index int\n    var temp_count_max_index_list_index_count_max_index_list []int\n    var temp_count_max_index_list_index_count_max_index_list_index int\n    var temp_count_max_index_list_index_count_max_index_list_index_count int\n    var temp_count_max_index_list_index_count_max_index_list_index_count_max int\n    var temp_count_max_index_list_index_count_max_index_list_index_count_max_index int\n    var temp_count_max_index_list_index_count_max_index_list_index_count_max_index_list []int\n    var temp_count_max_index_list_index_count_max_index_list_index_count_max_index_list_index int\n    var temp_count_max_index_list_index_count_max_index_list_index_count_max_index_list_index_count int\n    var temp_count_max_index_list_index_count_max_index_list_index_count_max_index_list_index_count_max int\n    var temp_count_max_index_list_index_count_max_index_list_index_count_max_index_list_index_count_max_index int\n    var temp_count_max_index_list_index_count_max_index_list_index_count_max_index_list_index_count_max_index_list []int\n    var temp_count_max",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var temp_map = make(map[interface{}][]interface{})\n    for _, tuple := range Input {\n        if _, ok := temp_map[tuple[0]]; ok {\n            temp_map[tuple[0]] = append(temp_map[tuple[0]], tuple[1])\n        } else {\n            temp_map[tuple[0]] = []interface{}{tuple[1]}\n        }\n    }\n    for key, value := range temp_map {\n        temp = append(temp, key)\n        temp = append(temp, value)\n        Output = append(Output, temp)\n        temp = nil\n    }\n    return Output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, v := range Input {\n        flag = false\n        for _, v2 := range result {\n            if v[0] == v2[0] {\n                v2 = append(v2, v[1])\n                flag = true\n            }\n        }\n        if flag == false {\n            temp = append(temp, v[0])\n            temp = append(temp, v[1])\n            result = append(result, temp)\n            temp = nil\n        }\n    }\n    return result\n}\n",
    "    var output [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, tuple := range Input {\n        if len(output) == 0 {\n            output = append(output, tuple)\n        } else {\n            flag = false\n            for i, group := range output {\n                if group[0] == tuple[0] {\n                    flag = true\n                    temp = append(temp, group[0])\n                    temp = append(temp, tuple[1])\n                    output[i] = temp\n                    temp = nil\n                }\n            }\n            if !flag {\n                output = append(output, tuple)\n            }\n        }\n    }\n    return output\n}\n",
    "    var output [][]interface{}\n    var temp []interface{}\n    var temp_map = make(map[interface{}][]interface{})\n    for _, value := range Input {\n        temp_map[value[0]] = append(temp_map[value[0]], value[1])\n    }\n    for key, value := range temp_map {\n        temp = append(temp, key)\n        temp = append(temp, value)\n        output = append(output, temp)\n        temp = nil\n    }\n    return output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    for _, v := range Input {\n        if len(temp) == 0 {\n            temp = append(temp, v[0])\n            result = append(result, temp)\n        } else {\n            if v[0] == temp[0] {\n                temp = append(temp, v[1])\n                result[len(result)-1] = temp\n            } else {\n                temp = []interface{}{}\n                temp = append(temp, v[0])\n                result = append(result, temp)\n            }\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    for _, v := range Input {\n        if len(temp) == 0 {\n            temp = append(temp, v[0])\n            result = append(result, temp)\n        } else {\n            if v[0] == temp[0] {\n                temp = append(temp, v[1])\n                result[len(result)-1] = temp\n            } else {\n                temp = []interface{}{}\n                temp = append(temp, v[0])\n                result = append(result, temp)\n            }\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_result []interface{}\n    var temp_result_1 []interface{}\n    var temp_result_2 []interface{}\n    var temp_result_3 []interface{}\n    var temp_result_4 []interface{}\n    var temp_result_5 []interface{}\n    var temp_result_6 []interface{}\n    var temp_result_7 []interface{}\n    var temp_result_8 []interface{}\n    var temp_result_9 []interface{}\n    var temp_result_10 []interface{}\n    var temp_result_11 []interface{}\n    var temp_result_12 []interface{}\n    var temp_result_13 []interface{}\n    var temp_result_14 []interface{}\n    var temp_result_15 []interface{}\n    var temp_result_16 []interface{}\n    var temp_result_17 []interface{}\n    var temp_result_18 []interface{}\n    var temp_result_19 []interface{}\n    var temp_result_20 []interface{}\n    var temp_result_21 []interface{}\n    var temp_result_22 []interface{}\n    var temp_result_23 []interface{}\n    var temp_result_24 []interface{}\n    var temp_result_25 []interface{}\n    var temp_result_26 []interface{}\n    var temp_result_27 []interface{}\n    var temp_result_28 []interface{}\n    var temp_result_29 []interface{}\n    var temp_result_30 []interface{}\n    var temp_result_31 []interface{}\n    var temp_result_32 []interface{}\n    var temp_result_33 []interface{}\n    var temp_result_34 []interface{}\n    var temp_result_35 []interface{}\n    var temp_result_36 []interface{}\n    var temp_result_37 []interface{}\n    var temp_result_38 []interface{}\n    var temp_result_39 []interface{}\n    var temp_result_40 []interface{}\n    var temp",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_map = make(map[interface{}][]interface{})\n    for _, v := range Input {\n        temp_map[v[0]] = append(temp_map[v[0]], v[1])\n    }\n    for k, v := range temp_map {\n        temp = append(temp, k)\n        temp = append(temp, v)\n        result = append(result, temp)\n        temp = temp[:0]\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_map map[interface{}]int\n    temp_map = make(map[interface{}]int)\n    for _, tuple := range Input {\n        temp_map[tuple[0]]++\n    }\n    for key, value := range temp_map {\n        temp = append(temp, key)\n        temp = append(temp, value)\n        result = append(result, temp)\n        temp = nil\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_map = make(map[interface{}]int)\n    for _, tuple := range Input {\n        if _, ok := temp_map[tuple[0]]; ok {\n            temp_map[tuple[0]] += 1\n        } else {\n            temp_map[tuple[0]] = 1\n        }\n    }\n    for key, value := range temp_map {\n        temp = append(temp, key, value)\n        result = append(result, temp)\n        temp = temp[:0]\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_map = make(map[interface{}][]interface{})\n    for _, tuple := range Input {\n        if _, ok := temp_map[tuple[0]]; ok {\n            temp_map[tuple[0]] = append(temp_map[tuple[0]], tuple[1])\n        } else {\n            temp_map[tuple[0]] = []interface{}{tuple[1]}\n        }\n    }\n    for key, value := range temp_map {\n        temp = []interface{}{key, value}\n        result = append(result, temp)\n    }\n    return result\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var flag bool\n    for _, tuple := range Input {\n        flag = false\n        for _, group := range Output {\n            if tuple[0] == group[0] {\n                flag = true\n                group = append(group, tuple[1])\n                break\n            }\n        }\n        if !flag {\n            temp = []interface{}{tuple[0]}\n            temp = append(temp, tuple[1])\n            Output = append(Output, temp)\n        }\n    }\n    return Output\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var temp_index int\n    var temp_count int\n    var temp_flag bool\n    for _, v := range Input {\n        temp_flag = false\n        for i, v2 := range Output {\n            if v[0] == v2[0] {\n                temp_flag = true\n                temp_index = i\n                break\n            }\n        }\n        if temp_flag {\n            temp_count = Output[temp_index][1].(int)\n            temp_count++\n            Output[temp_index][1] = temp_count\n        } else {\n            temp = []interface{}{v[0], 1}\n            Output = append(Output, temp)\n        }\n    }\n    return Output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_index int\n    var temp_flag bool\n    for _, value := range Input {\n        temp_flag = false\n        for index, value2 := range result {\n            if value[0] == value2[0] {\n                temp_flag = true\n                temp_index = index\n                break\n            }\n        }\n        if temp_flag {\n            temp = result[temp_index]\n            temp = append(temp, value[1])\n            result[temp_index] = temp\n        } else {\n            temp = []interface{}{value[0], value[1]}\n            result = append(result, temp)\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_result []interface{}\n    for i := 0; i < len(Input); i++ {\n        temp = Input[i]\n        for j := 0; j < len(Input); j++ {\n            if temp[0] == Input[j][0] {\n                temp_result = append(temp_result, Input[j][1])\n            }\n        }\n        if len(temp_result) > 0 {\n            result = append(result, []interface{}{temp[0], temp_result})\n            temp_result = []interface{}{}\n        }\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    for _, v := range Input {\n        if len(temp) == 0 {\n            temp = append(temp, v[0])\n            result = append(result, temp)\n        } else {\n            if temp[0] == v[0] {\n                temp = append(temp, v[1])\n                result[len(result)-1] = temp\n            } else {\n                temp = []interface{}{}\n                temp = append(temp, v[0])\n                result = append(result, temp)\n            }\n        }\n    }\n    return result\n}\n",
    "    var output [][]interface{}\n    for _, tuple := range Input {\n        var found bool\n        for _, group := range output {\n            if tuple[0] == group[0] {\n                found = true\n                group = append(group, tuple[1])\n                break\n            }\n        }\n        if !found {\n            output = append(output, tuple)\n        }\n    }\n    return output\n}\n",
    "    var Output [][]interface{}\n    var tmp []interface{}\n    var tmp_map = make(map[interface{}]bool)\n    for _, v := range Input {\n        if _, ok := tmp_map[v[0]]; !ok {\n            tmp_map[v[0]] = true\n            tmp = append(tmp, v[0])\n        }\n    }\n    for _, v := range tmp {\n        var tmp_slice []interface{}\n        for _, v1 := range Input {\n            if v == v1[0] {\n                tmp_slice = append(tmp_slice, v1)\n            }\n        }\n        Output = append(Output, tmp_slice)\n    }\n    return Output\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_key interface{}\n    var temp_value interface{}\n    var temp_value_list []interface{}\n    var temp_value_list_map map[interface{}]interface{}\n    temp_value_list_map = make(map[interface{}]interface{})\n    for _, v := range Input {\n        temp_key = v[0]\n        temp_value = v[1]\n        if _, ok := temp_value_list_map[temp_key]; ok {\n            temp_value_list = temp_value_list_map[temp_key].([]interface{})\n            temp_value_list = append(temp_value_list, temp_value)\n            temp_value_list_map[temp_key] = temp_value_list\n        } else {\n            temp_value_list = make([]interface{}, 0)\n            temp_value_list = append(temp_value_list, temp_value)\n            temp_value_list_map[temp_key] = temp_value_list\n        }\n    }\n    for k, v := range temp_value_list_map {\n        temp = make([]interface{}, 0)\n        temp = append(temp, k)\n        temp = append(temp, v)\n        result = append(result, temp)\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var first_element interface{}\n    for i := 0; i < len(Input); i++ {\n        first_element = Input[i][0]\n        temp = append(temp, first_element)\n        for j := i + 1; j < len(Input); j++ {\n            if first_element == Input[j][0] {\n                temp = append(temp, Input[j][1])\n            }\n        }\n        result = append(result, temp)\n        temp = nil\n    }\n    return result\n}\n",
    "    var result [][]interface{}\n    var temp []interface{}\n    var temp_map map[interface{}]bool\n\n    temp_map = make(map[interface{}]bool)\n    for _, v := range Input {\n        if _, ok := temp_map[v[0]]; !ok {\n            temp_map[v[0]] = true\n            temp = append(temp, v[0])\n        }\n    }\n\n    for _, v := range temp {\n        var temp_tuple []interface{}\n        for _, v1 := range Input {\n            if v == v1[0] {\n                temp_tuple = append(temp_tuple, v1)\n            }\n        }\n        result = append(result, temp_tuple)\n    }\n\n    return result\n}\n",
    "    var Output [][]interface{}\n    var temp []interface{}\n    var temp_map = make(map[interface{}][]interface{})\n\n    for _, v := range Input {\n        if _, ok := temp_map[v[0]]; !ok {\n            temp_map[v[0]] = []interface{}{v[1]}\n        } else {\n            temp_map[v[0]] = append(temp_map[v[0]], v[1])\n        }\n    }\n\n    for k, v := range temp_map {\n        temp = append(temp, k)\n        temp = append(temp, v)\n        Output = append(Output, temp)\n        temp = []interface{}{}\n    }\n    return Output\n}\n"
  ]
}