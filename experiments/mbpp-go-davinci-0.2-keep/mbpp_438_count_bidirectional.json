{
  "name": "mbpp_438_count_bidirectional",
  "language": "go_test.go",
  "prompt": "package count_bidirectional_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to count bidirectional tuple pairs.\nfunc count_bidirectional(test_list [][]interface{}) int {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_438_count_bidirectional.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestCount_Bidirectional(t *testing.T) {\n  candidate := count_bidirectional\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{5, 6}, []interface{}{1, 2}, []interface{}{6, 5}, []interface{}{9, 1}, []interface{}{6, 5}, []interface{}{2, 1}}), expected: 3 },\n     { actual: candidate([][]int{[]interface{}{5, 6}, []interface{}{1, 3}, []interface{}{6, 5}, []interface{}{9, 1}, []interface{}{6, 5}, []interface{}{2, 1}}), expected: 2 },\n     { actual: candidate([][]int{[]interface{}{5, 6}, []interface{}{1, 2}, []interface{}{6, 5}, []interface{}{9, 2}, []interface{}{6, 5}, []interface{}{2, 1}}), expected: 4 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    // Create a map to store the tuple pairs.\n    tuple_map := make(map[interface{}]map[interface{}]int)\n\n    // Iterate through the list and store the tuple pairs.\n    for _, tuple := range test_list {\n        if _, ok := tuple_map[tuple[0]]; !ok {\n            tuple_map[tuple[0]] = make(map[interface{}]int)\n        }\n        tuple_map[tuple[0]][tuple[1]] += 1\n    }\n\n    // Iterate through the map and count the bidirectional pairs.\n    count := 0\n    for _, v := range tuple_map {\n        for k, v2 := range v {\n            if _, ok := tuple_map[k]; ok {\n                if _, ok := tuple_map[k][tuple_map[k]]; ok {\n                    count += v2\n                }\n            }\n        }\n    }\n\n    return count\n}\n",
    "    var count int\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list); j++ {\n            if test_list[i][0] == test_list[j][1] && test_list[i][1] == test_list[j][0] {\n                count++\n            }\n        }\n    }\n    return count\n}\n",
    "    var count int = 0\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list); j++ {\n            if test_list[i][0] == test_list[j][1] && test_list[i][1] == test_list[j][0] {\n                count++\n            }\n        }\n    }\n    return count\n}\n",
    "    var count int\n    for _, v := range test_list {\n        if v[0] == v[1] {\n            count++\n        }\n    }\n    return count\n}\n",
    "    // Create a map to store the count of each tuple.\n    tuple_count := make(map[string]int)\n\n    // Iterate through the list of tuples.\n    for _, tuple := range test_list {\n        // Create a string representation of the tuple.\n        tuple_string := fmt.Sprintf(\"%v,%v\", tuple[0], tuple[1])\n\n        // Check if the tuple has been seen before.\n        if _, ok := tuple_count[tuple_string]; ok {\n            // Increment the count.\n            tuple_count[tuple_string]++\n        } else {\n            // Add the tuple to the map.\n            tuple_count[tuple_string] = 1\n        }\n    }\n\n    // Create a variable to store the count of bidirectional tuples.\n    bidirectional_count := 0\n\n    // Iterate through the map of tuples.\n    for tuple, count := range tuple_count {\n        // Check if the tuple is bidirectional.\n        if count > 1 {\n            // Increment the count of bidirectional tuples.\n            bidirectional_count++\n        }\n    }\n\n    // Return the count of bidirectional tuples.\n    return bidirectional_count\n}\n",
    "    // Initialize a map to store the counts.\n    counts := make(map[string]int)\n\n    // Iterate through the list.\n    for _, tuple := range test_list {\n        // Initialize a string to store the key.\n        key := \"\"\n\n        // Iterate through the tuple.\n        for _, item := range tuple {\n            // Append the item to the key.\n            key += fmt.Sprintf(\"%v\", item)\n        }\n\n        // Increment the count.\n        counts[key] += 1\n    }\n\n    // Initialize a count to store the number of bidirectional pairs.\n    count := 0\n\n    // Iterate through the counts.\n    for key, value := range counts {\n        // Check if the count is greater than 1.\n        if value > 1 {\n            // Increment the count.\n            count += 1\n        }\n    }\n\n    // Return the count.\n    return count\n}\n",
    "    var count int = 0\n    for _, test_tuple := range test_list {\n        for _, test_tuple_2 := range test_list {\n            if test_tuple[0] == test_tuple_2[1] && test_tuple[1] == test_tuple_2[0] {\n                count++\n            }\n        }\n    }\n    return count\n}\n",
    "    // Create a map to store the results.\n    result_map := make(map[interface{}]map[interface{}]int)\n    // Iterate through the list.\n    for _, tuple := range test_list {\n        // Check if the first element is in the map.\n        if _, ok := result_map[tuple[0]]; !ok {\n            // If not, create a new map for it.\n            result_map[tuple[0]] = make(map[interface{}]int)\n        }\n        // Check if the second element is in the map.\n        if _, ok := result_map[tuple[1]]; !ok {\n            // If not, create a new map for it.\n            result_map[tuple[1]] = make(map[interface{}]int)\n        }\n        // Increment the count for the first element.\n        result_map[tuple[0]][tuple[1]]++\n        // Increment the count for the second element.\n        result_map[tuple[1]][tuple[0]]++\n    }\n    // Create a variable to store the result.\n    result := 0\n    // Iterate through the map.\n    for _, value := range result_map {\n        // Iterate through the map.\n        for _, count := range value {\n            // Add the count to the result.\n            result += count\n        }\n    }\n    // Return the result.\n    return result\n}\n",
    "    var count int\n    for _, tuple := range test_list {\n        if tuple[0] == tuple[1] {\n            count++\n        }\n    }\n    return count\n}\n",
    "    count := 0\n    for _, tuple := range test_list {\n        if len(tuple) != 2 {\n            continue\n        }\n        for _, tuple2 := range test_list {\n            if len(tuple2) != 2 {\n                continue\n            }\n            if tuple[0] == tuple2[1] && tuple[1] == tuple2[0] {\n                count++\n            }\n        }\n    }\n    return count\n}\n",
    "    var count int\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list); j++ {\n            if i == j {\n                continue\n            }\n            if test_list[i][0] == test_list[j][1] && test_list[i][1] == test_list[j][0] {\n                count++\n            }\n        }\n    }\n    return count\n}\n",
    "    count := 0\n    for i := 0; i < len(test_list); i++ {\n        for j := 0; j < len(test_list); j++ {\n            if test_list[i][0] == test_list[j][1] && test_list[i][1] == test_list[j][0] {\n                count++\n            }\n        }\n    }\n    return count\n}\n",
    "    // Create a map to store the count of each tuple.\n    tuple_count := make(map[string]int)\n\n    // Iterate through the list of tuples.\n    for _, tuple := range test_list {\n        // Create a string representation of the tuple.\n        tuple_string := fmt.Sprintf(\"%v,%v\", tuple[0], tuple[1])\n        // Create a string representation of the reverse tuple.\n        reverse_tuple_string := fmt.Sprintf(\"%v,%v\", tuple[1], tuple[0])\n\n        // Check if the tuple is in the map.\n        if _, ok := tuple_count[tuple_string]; ok {\n            // Increment the count of the tuple.\n            tuple_count[tuple_string] += 1\n        } else {\n            // Check if the reverse tuple is in the map.\n            if _, ok := tuple_count[reverse_tuple_string]; ok {\n                // Increment the count of the reverse tuple.\n                tuple_count[reverse_tuple_string] += 1\n            } else {\n                // Add the tuple to the map.\n                tuple_count[tuple_string] = 1\n            }\n        }\n    }\n\n    // Initialize the count of bidirectional tuples.\n    bidirectional_count := 0\n\n    // Iterate through the map of tuples.\n    for _, count := range tuple_count {\n        // Check if the tuple is bidirectional.\n        if count > 1 {\n            // Increment the count of bidirectional tuples.\n            bidirectional_count += 1\n        }\n    }\n\n    // Return the count of bidirectional tuples.\n    return bidirectional_count\n}\n",
    "    // Create a map to store the count of each tuple.\n    tuple_count := make(map[string]int)\n    // Create a map to store the count of each tuple pair.\n    tuple_pair_count := make(map[string]int)\n    // Create a map to store the count of each tuple pair.\n    tuple_pair_count_bidirectional := make(map[string]int)\n\n    // Loop through the list of tuples.\n    for _, tuple := range test_list {\n        // Create a string to store the tuple.\n        tuple_string := fmt.Sprintf(\"%v\", tuple)\n        // Create a string to store the tuple in reverse order.\n        tuple_string_reverse := fmt.Sprintf(\"%v\", reverse_tuple(tuple))\n        // Increment the count of the tuple.\n        tuple_count[tuple_string]++\n        // Increment the count of the tuple in reverse order.\n        tuple_count[tuple_string_reverse]++\n        // Increment the count of the tuple pair.\n        tuple_pair_count[tuple_string + tuple_string_reverse]++\n        // Increment the count of the tuple pair in reverse order.\n        tuple_pair_count[tuple_string_reverse + tuple_string]++\n    }\n\n    // Loop through the map of tuple pairs.\n    for tuple_pair, count := range tuple_pair_count {\n        // If the tuple pair is bidirectional.\n        if count == 2 {\n            // Split the tuple pair into two tuples.\n            tuple_1, tuple_2 := tuple_pair[:len(tuple_pair)/2], tuple_pair[len(tuple_pair)/2:]\n            // If the tuple pair is bidirectional.\n            if tuple_count[tuple_1] == 2 && tuple_count[tuple_2] == 2 {\n                // Increment the count of the bidirectional tuple pair.\n                tuple_pair_count_bidirectional[tuple_pair]++\n            }\n        }\n    }\n\n    // Return the count of bidirectional tuple pairs.\n    return len(tuple_pair_count_bidirectional)\n}\n\n",
    "    // Create a map to store the counts of each tuple.\n    tuple_counts := make(map[string]int)\n\n    // Iterate over the list of tuples.\n    for _, tuple := range test_list {\n        // Create a string representation of the tuple.\n        tuple_string := fmt.Sprintf(\"%v,%v\", tuple[0], tuple[1])\n\n        // Increment the count of the tuple.\n        tuple_counts[tuple_string]++\n    }\n\n    // Create a variable to store the bidirectional count.\n    bidirectional_count := 0\n\n    // Iterate over the list of tuples.\n    for _, tuple := range test_list {\n        // Create a string representation of the tuple.\n        tuple_string := fmt.Sprintf(\"%v,%v\", tuple[0], tuple[1])\n\n        // Create a string representation of the reverse tuple.\n        reverse_tuple_string := fmt.Sprintf(\"%v,%v\", tuple[1], tuple[0])\n\n        // Increment the bidirectional count if the reverse tuple exists.\n        if tuple_counts[reverse_tuple_string] > 0 {\n            bidirectional_count++\n        }\n    }\n\n    // Return the bidirectional count.\n    return bidirectional_count\n}\n",
    "    var count int\n    for _, tuple := range test_list {\n        for _, tuple2 := range test_list {\n            if tuple[0] == tuple2[1] && tuple[1] == tuple2[0] {\n                count++\n            }\n        }\n    }\n    return count\n}\n",
    "    var count int\n    for _, test := range test_list {\n        if test[0] == test[1] {\n            count++\n        }\n    }\n    return count\n}\n",
    "    // Create a map to store the number of times a tuple has been seen.\n    tuple_counts := make(map[string]int)\n    // Create a map to store the number of times a tuple has been seen in reverse.\n    reverse_counts := make(map[string]int)\n    // Create a variable to store the number of bidirectional tuples.\n    bidirectional_count := 0\n\n    // Iterate through the list of tuples.\n    for _, tuple := range test_list {\n        // Create a string to store the tuple.\n        tuple_string := fmt.Sprintf(\"%v,%v\", tuple[0], tuple[1])\n        // Create a string to store the reverse tuple.\n        reverse_string := fmt.Sprintf(\"%v,%v\", tuple[1], tuple[0])\n\n        // If the tuple has been seen before, increment the tuple count.\n        if _, ok := tuple_counts[tuple_string]; ok {\n            tuple_counts[tuple_string] += 1\n        } else {\n            // If the tuple has not been seen before, set the tuple count to 1.\n            tuple_counts[tuple_string] = 1\n        }\n\n        // If the reverse tuple has been seen before, increment the reverse tuple count.\n        if _, ok := reverse_counts[reverse_string]; ok {\n            reverse_counts[reverse_string] += 1\n        } else {\n            // If the reverse tuple has not been seen before, set the reverse tuple count to 1.\n            reverse_counts[reverse_string] = 1\n        }\n\n        // If the tuple and reverse tuple have been seen before, increment the bidirectional count.\n        if tuple_counts[tuple_string] > 0 && reverse_counts[reverse_string] > 0 {\n            bidirectional_count += 1\n        }\n    }\n\n    return bidirectional_count\n}\n",
    "    // Create a map to store the count of each tuple.\n    tuple_map := make(map[interface{}]map[interface{}]int)\n    for _, tuple := range test_list {\n        // Check if the first element is in the map.\n        if _, ok := tuple_map[tuple[0]]; !ok {\n            // Create a new map for the first element.\n            tuple_map[tuple[0]] = make(map[interface{}]int)\n        }\n        // Check if the second element is in the map.\n        if _, ok := tuple_map[tuple[1]]; !ok {\n            // Create a new map for the second element.\n            tuple_map[tuple[1]] = make(map[interface{}]int)\n        }\n        // Increment the count of the first element.\n        tuple_map[tuple[0]][tuple[1]]++\n        // Increment the count of the second element.\n        tuple_map[tuple[1]][tuple[0]]++\n    }\n    // Create a variable to store the count of bidirectional pairs.\n    count := 0\n    // Iterate through the map.\n    for _, value := range tuple_map {\n        // Iterate through the map.\n        for _, count_value := range value {\n            // Check if the count is greater than 1.\n            if count_value > 1 {\n                // Increment the count.\n                count++\n            }\n        }\n    }\n    // Return the count.\n    return count\n}\n",
    "    // Create a map to store the tuples.\n    tuple_map := make(map[string]bool)\n    // Create a counter to store the number of bidirectional tuples.\n    bidirectional_counter := 0\n    // Loop through the list of tuples.\n    for _, tuple := range test_list {\n        // Create a key for the map.\n        key := fmt.Sprintf(\"%v,%v\", tuple[0], tuple[1])\n        // Check if the key is in the map.\n        if _, ok := tuple_map[key]; ok {\n            // Increment the bidirectional counter.\n            bidirectional_counter++\n        } else {\n            // Add the key to the map.\n            tuple_map[key] = true\n        }\n    }\n    // Return the bidirectional counter.\n    return bidirectional_counter\n}\n"
  ]
}