{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "go_test.go",
  "prompt": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    pairs := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            pairs = append(pairs, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(pairs); j++ {\n            if pairs[i][0] + pairs[i][1] > pairs[j][0] + pairs[j][1] {\n                pairs[i], pairs[j] = pairs[j], pairs[i]\n            }\n        }\n    }\n    return pairs[:k]\n}\n",
    "    var res [][]int\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return res\n    }\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n    heap_sort(heap)\n    for i := 0; i < k && i < len(heap); i++ {\n        res = append(res, heap[i])\n    }\n    return res\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        index := 0\n        for j := 0; j < len(nums1); j++ {\n            for m := 0; m < len(nums2); m++ {\n                if nums1[j] + nums2[m] < min {\n                    min = nums1[j] + nums2[m]\n                    index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[index], nums2[0]})\n        nums1 = append(nums1[:index], nums1[index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return result\n}\n",
    "    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return result\n    }\n\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    heap_sort(heap)\n\n    for i := 0; i < k; i++ {\n        result = append(result, heap[i])\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n    for len(result) < k && len(queue) > 0 {\n        pair := queue[0]\n        queue = queue[1:]\n        result = append(result, []int{nums1[pair[0]], nums2[pair[1]]})\n        if pair[0] + 1 < len(nums1) {\n            queue = append(queue, []int{pair[0] + 1, pair[1], nums1[pair[0] + 1] + nums2[pair[1]]})\n        }\n        if pair[1] + 1 < len(nums2) {\n            queue = append(queue, []int{pair[0], pair[1] + 1, nums1[pair[0]] + nums2[pair[1] + 1]})\n        }\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := -1\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if min == -1 {\n                    min = nums1[j] + nums2[l]\n                    result = append(result, []int{nums1[j], nums2[l]})\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        result = append(result, []int{nums1[j], nums2[l]})\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min = -1\n        var min_index = -1\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                var found = false\n                for _, v := range result {\n                    if v[0] == nums1[j] && v[1] == nums2[l] {\n                        found = true\n                        break\n                    }\n                }\n                if found {\n                    continue\n                }\n                if min == -1 || nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] + nums2[0] < min {\n                min = nums1[j] + nums2[0]\n                min_index = j\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    var queue [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            queue = append(queue, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        min := 0\n        for j := 0; j < len(queue); j++ {\n            if queue[j][0] + queue[j][1] < queue[min][0] + queue[min][1] {\n                min = j\n            }\n        }\n        result = append(result, queue[min])\n        queue = append(queue[:min], queue[min+1:]...)\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n    for len(result) < k && len(queue) > 0 {\n        var tmp []int\n        tmp, queue = queue[0], queue[1:]\n        result = append(result, []int{nums1[tmp[0]], nums2[tmp[1]]})\n\n        if tmp[0] + 1 < len(nums1) {\n            queue = append(queue, []int{tmp[0] + 1, tmp[1], nums1[tmp[0] + 1] + nums2[tmp[1]]})\n        }\n        if tmp[1] + 1 < len(nums2) {\n            queue = append(queue, []int{tmp[0], tmp[1] + 1, nums1[tmp[0]] + nums2[tmp[1] + 1]})\n        }\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        result = append(result, []int{nums1[0], nums2[0]})\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = []int{nums1[i], nums2[j]}\n                for m := k - 2; m >= 0; m-- {\n                    if result[m][0] + result[m][1] > result[m+1][0] + result[m+1][1] {\n                        result[m], result[m+1] = result[m+1], result[m]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n    return result[:k]\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if i < len(nums2) && nums1[j] + nums2[i] < nums1[min] + nums2[min_index] {\n                min = j\n                min_index = i\n            }\n            if i >= len(nums2) && nums1[j] + nums2[len(nums2) - 1] < nums1[min] + nums2[min_index] {\n                min = j\n                min_index = len(nums2) - 1\n            }\n        }\n        result = append(result, []int{nums1[min], nums2[min_index]})\n        nums1 = append(nums1[:min], nums1[min + 1:]...)\n        nums2 = append(nums2[:min_index], nums2[min_index + 1:]...)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n    for len(result) < k && len(queue) > 0 {\n        var tmp []int\n        tmp, queue = queue[0], queue[1:]\n        result = append(result, []int{nums1[tmp[0]], nums2[tmp[1]]})\n\n        if tmp[0] + 1 < len(nums1) {\n            queue = append(queue, []int{tmp[0] + 1, tmp[1], nums1[tmp[0] + 1] + nums2[tmp[1]]})\n        }\n        if tmp[1] + 1 < len(nums2) {\n            queue = append(queue, []int{tmp[0], tmp[1] + 1, nums1[tmp[0]] + nums2[tmp[1] + 1]})\n        }\n    }\n\n    return result\n}\n",
    "    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    if len(result) < k {\n        return result\n    }\n\n    return result[:k]\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    // init\n    var result [][]int\n    var heap [][]int\n    heap = append(heap, []int{nums1[0] + nums2[0], 0, 0})\n    visited := make([][]bool, len(nums1))\n    for i := 0; i < len(nums1); i++ {\n        visited[i] = make([]bool, len(nums2))\n    }\n    visited[0][0] = true\n\n    // heapify\n    for i := len(heap) / 2 - 1; i >= 0; i-- {\n        down(heap, i)\n    }\n\n    // pop\n    for i := 0; i < k && len(heap) > 0; i++ {\n        result = append(result, []int{heap[0][0], heap[0][1], heap[0][2]})\n        if heap[0][1] + 1 < len(nums1) && !visited[heap[0][1] + 1][heap[0][2]] {\n            heap = append(heap, []int{nums1[heap[0][1] + 1] + nums2[heap[0][2]], heap[0][1] + 1, heap[0][2]})\n            visited[heap[0][1] + 1][heap[0][2]] = true\n        }\n        if heap[0][2] + 1 < len(nums2) && !visited[heap[0][1]][heap[0][2] + 1] {\n            heap = append(heap, []int{nums1[heap[0][1]] + nums2[heap[0][2] + 1], heap[0][1], heap[0][2] + 1})\n            visited[heap[0][1]][heap[0][2] + 1] = true\n        }\n        heap[0], heap[len(heap) - 1] = heap[len(heap) -",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if i == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_index = j * len(nums2) + l\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        min_index = j * len(nums2) + l\n                    }\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index / len(nums2)], nums2[min_index % len(nums2)]})\n        nums1[min_index / len(nums2)] = nums1[min_index / len(nums2)] + nums2[min_index % len(nums2)] + 1\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue = make([]*pair, 0)\n    var visited = make(map[int]bool)\n\n    var p = &pair{\n        i: 0,\n        j: 0,\n        sum: nums1[0] + nums2[0],\n    }\n    queue = append(queue, p)\n    visited[p.i * len(nums2) + p.j] = true\n\n    for len(result) < k && len(queue) > 0 {\n        p = queue[0]\n        queue = queue[1:]\n\n        result = append(result, []int{nums1[p.i], nums2[p.j]})\n\n        if p.i + 1 < len(nums1) && !visited[(p.i + 1) * len(nums2) + p.j] {\n            var p1 = &pair{\n                i: p.i + 1,\n                j: p.j,\n                sum: nums1[p.i + 1] + nums2[p.j],\n            }\n            queue = append(queue, p1)\n            visited[p1.i * len(nums2) + p1.j] = true\n        }\n\n        if p.j + 1 < len(nums2) && !visited[p.i * len(nums2) + p.j + 1] {\n            var p2 = &pair{\n                i: p.i,\n                j: p.j + 1,\n                sum: nums1[p.i] + nums2[p.j + 1],\n            }\n            queue = append(queue, p2)\n            visited[p2.i * len(nums2) + p2.j] = true\n        }\n\n        queue = sort(queue)\n    }\n\n    return result\n}\n\ntype pair ",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_index := []int{0, 0}\n        for j := 0; j < len(nums1); j++ {\n            for m := 0; m < len(nums2); m++ {\n                if nums1[j] + nums2[m] < min {\n                    min = nums1[j] + nums2[m]\n                    min_index = []int{j, m}\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index[0]], nums2[min_index[1]]})\n        nums1 = append(nums1[:min_index[0]], nums1[min_index[0]+1:]...)\n        nums2 = append(nums2[:min_index[1]], nums2[min_index[1]+1:]...)\n    }\n    return result\n}\n",
    "    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        result = append(result, []int{nums1[0], nums2[0]})\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = []int{nums1[i], nums2[j]}\n                for l := k - 1; l > 0 && result[l][0]+result[l][1] < result[l-1][0]+result[l-1][1]; l-- {\n                    result[l], result[l-1] = result[l-1], result[l]\n                }\n            }\n        }\n    }\n\n    return result\n}\n"
  ]
}