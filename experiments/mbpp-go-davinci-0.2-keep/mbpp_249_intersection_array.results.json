{
  "name": "mbpp_249_intersection_array",
  "language": "go_test.go",
  "prompt": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_249_intersection_array.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_intersection []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_intersection = append(array_intersection, num1)\n            }\n        }\n    }\n    return array_intersection\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    var map_nums = make(map[int]int)\n    for _, num := range array_nums1 {\n        map_nums[num] = 1\n    }\n    for _, num := range array_nums2 {\n        if _, ok := map_nums[num]; ok {\n            result = append(result, num)\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510149,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for i := 0; i < len(array_nums1); i++ {\n        for j := 0; j < len(array_nums2); j++ {\n            if array_nums1[i] == array_nums2[j] {\n                result = append(result, array_nums1[i])\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_result = append(array_result, num1)\n            }\n        }\n    }\n    return array_result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num == num2 {\n                result = append(result, num)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num == num2 {\n                result = append(result, num)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    var map_nums = make(map[int]int)\n    for _, v := range array_nums1 {\n        map_nums[v] = 1\n    }\n    for _, v := range array_nums2 {\n        if _, ok := map_nums[v]; ok {\n            result = append(result, v)\n            map_nums[v] = 2\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_nums3 []int\n    for i := 0; i < len(array_nums1); i++ {\n        for j := 0; j < len(array_nums2); j++ {\n            if array_nums1[i] == array_nums2[j] {\n                array_nums3 = append(array_nums3, array_nums1[i])\n            }\n        }\n    }\n    return array_nums3\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num == num2 {\n                result = append(result, num)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    var map_nums = make(map[int]int)\n    for _, num := range array_nums1 {\n        map_nums[num] = 1\n    }\n    for _, num := range array_nums2 {\n        if _, ok := map_nums[num]; ok {\n            result = append(result, num)\n            delete(map_nums, num)\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, v := range array_nums1 {\n        for _, v2 := range array_nums2 {\n            if v == v2 {\n                result = append(result, v)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_nums []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_nums = append(array_nums, num1)\n            }\n        }\n    }\n    return array_nums\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_intersection []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_intersection = append(array_intersection, num1)\n            }\n        }\n    }\n    return array_intersection\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, v := range array_nums1 {\n        for _, v2 := range array_nums2 {\n            if v == v2 {\n                result = append(result, v)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_result []int\n    var map_nums1 = make(map[int]int)\n    var map_nums2 = make(map[int]int)\n\n    for _, num := range array_nums1 {\n        map_nums1[num] = 1\n    }\n\n    for _, num := range array_nums2 {\n        map_nums2[num] = 1\n    }\n\n    for key, _ := range map_nums1 {\n        if _, ok := map_nums2[key]; ok {\n            array_result = append(array_result, key)\n        }\n    }\n\n    return array_result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "--- FAIL: TestIntersection_Array (0.00s)\n    --- FAIL: TestIntersection_Array/test_num__1 (0.00s)\n        tmpby2u3944_test.go:46: expected '[%!s(int=3) %!s(int=5) %!s(int=7) %!s(int=9)]', got '[%!s(int=7) %!s(int=9) %!s(int=3) %!s(int=5)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var res []int\n    for i := 0; i < len(array_nums1); i++ {\n        for j := 0; j < len(array_nums2); j++ {\n            if array_nums1[i] == array_nums2[j] {\n                res = append(res, array_nums1[i])\n            }\n        }\n    }\n    return res\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.006s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_result = append(array_result, num1)\n            }\n        }\n    }\n    return array_result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_nums []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_nums = append(array_nums, num1)\n            }\n        }\n    }\n    return array_nums\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for i := 0; i < len(array_nums1); i++ {\n        for j := 0; j < len(array_nums2); j++ {\n            if array_nums1[i] == array_nums2[j] {\n                result = append(result, array_nums1[i])\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_result = append(array_result, num1)\n            }\n        }\n    }\n    return array_result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_nums3 []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_nums3 = append(array_nums3, num1)\n            }\n        }\n    }\n    return array_nums3\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var res []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                res = append(res, num1)\n            }\n        }\n    }\n    return res\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_nums []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_nums = append(array_nums, num1)\n            }\n        }\n    }\n    return array_nums\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num == num2 {\n                result = append(result, num)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_result = append(array_result, num1)\n            }\n        }\n    }\n    return array_result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_nums []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_nums = append(array_nums, num1)\n            }\n        }\n    }\n    return array_nums\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_result = append(array_result, num1)\n                break\n            }\n        }\n    }\n    return array_result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var intersection_array []int\n    for _, num := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num == num2 {\n                intersection_array = append(intersection_array, num)\n            }\n        }\n    }\n    return intersection_array\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_nums []int\n    for i := 0; i < len(array_nums1); i++ {\n        for j := 0; j < len(array_nums2); j++ {\n            if array_nums1[i] == array_nums2[j] {\n                array_nums = append(array_nums, array_nums1[i])\n            }\n        }\n    }\n    return array_nums\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var intersection_array []int\n    for _, num := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num == num2 {\n                intersection_array = append(intersection_array, num)\n            }\n        }\n    }\n    return intersection_array\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_intersection []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_intersection = append(array_intersection, num1)\n            }\n        }\n    }\n    return array_intersection\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for i := 0; i < len(array_nums1); i++ {\n        for j := 0; j < len(array_nums2); j++ {\n            if array_nums1[i] == array_nums2[j] {\n                result = append(result, array_nums1[i])\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_nums []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_nums = append(array_nums, num1)\n            }\n        }\n    }\n    return array_nums\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for i := 0; i < len(array_nums1); i++ {\n        for j := 0; j < len(array_nums2); j++ {\n            if array_nums1[i] == array_nums2[j] {\n                result = append(result, array_nums1[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num == num2 {\n                result = append(result, num)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num == num2 {\n                result = append(result, num)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var nums1_map = make(map[int]int)\n    var nums2_map = make(map[int]int)\n    var result []int\n\n    for _, num := range array_nums1 {\n        nums1_map[num]++\n    }\n\n    for _, num := range array_nums2 {\n        nums2_map[num]++\n    }\n\n    for num, _ := range nums1_map {\n        if _, ok := nums2_map[num]; ok {\n            result = append(result, num)\n        }\n    }\n\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "--- FAIL: TestIntersection_Array (0.00s)\n    --- FAIL: TestIntersection_Array/test_num__0 (0.00s)\n        tmpu6ta1sb8_test.go:46: expected '[%!s(int=1) %!s(int=2) %!s(int=8) %!s(int=9)]', got '[%!s(int=8) %!s(int=9) %!s(int=1) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num == num2 {\n                result = append(result, num)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_nums []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_nums = append(array_nums, num1)\n            }\n        }\n    }\n    return array_nums\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num == num2 {\n                result = append(result, num)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num == num2 {\n                result = append(result, num)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_intersection []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_intersection = append(array_intersection, num1)\n            }\n        }\n    }\n    return array_intersection\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num == num2 {\n                result = append(result, num)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_nums []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_nums = append(array_nums, num1)\n            }\n        }\n    }\n    return array_nums\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, v := range array_nums1 {\n        for _, v2 := range array_nums2 {\n            if v == v2 {\n                result = append(result, v)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var nums1 = make(map[int]int)\n    var nums2 = make(map[int]int)\n    var result = make(map[int]int)\n    for _, v := range array_nums1 {\n        nums1[v] = 1\n    }\n    for _, v := range array_nums2 {\n        nums2[v] = 1\n    }\n    for k, _ := range nums1 {\n        if _, ok := nums2[k]; ok {\n            result[k] = 1\n        }\n    }\n    var result_array = make([]int, 0)\n    for k, _ := range result {\n        result_array = append(result_array, k)\n    }\n    return result_array\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "--- FAIL: TestIntersection_Array (0.00s)\n    --- FAIL: TestIntersection_Array/test_num__0 (0.00s)\n        tmpw9survql_test.go:46: expected '[%!s(int=1) %!s(int=2) %!s(int=8) %!s(int=9)]', got '[%!s(int=8) %!s(int=9) %!s(int=1) %!s(int=2)]'\n    --- FAIL: TestIntersection_Array/test_num__1 (0.00s)\n        tmpw9survql_test.go:46: expected '[%!s(int=3) %!s(int=5) %!s(int=7) %!s(int=9)]', got '[%!s(int=7) %!s(int=9) %!s(int=3) %!s(int=5)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num == num2 {\n                result = append(result, num)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num == num2 {\n                result = append(result, num)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, v := range array_nums1 {\n        for _, v2 := range array_nums2 {\n            if v == v2 {\n                result = append(result, v)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num == num2 {\n                result = append(result, num)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_nums3 []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_nums3 = append(array_nums3, num1)\n            }\n        }\n    }\n    return array_nums3\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num == num2 {\n                result = append(result, num)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    var map_nums1 = make(map[int]int)\n    var map_nums2 = make(map[int]int)\n    for _, num := range array_nums1 {\n        map_nums1[num] = num\n    }\n    for _, num := range array_nums2 {\n        map_nums2[num] = num\n    }\n    for _, num := range array_nums1 {\n        if _, ok := map_nums2[num]; ok {\n            result = append(result, num)\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_nums []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_nums = append(array_nums, num1)\n            }\n        }\n    }\n    return array_nums\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_nums []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_nums = append(array_nums, num1)\n            }\n        }\n    }\n    return array_nums\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for i := 0; i < len(array_nums1); i++ {\n        for j := 0; j < len(array_nums2); j++ {\n            if array_nums1[i] == array_nums2[j] {\n                result = append(result, array_nums1[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_intersection []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_intersection = append(array_intersection, num1)\n            }\n        }\n    }\n    return array_intersection\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for i := 0; i < len(array_nums1); i++ {\n        for j := 0; j < len(array_nums2); j++ {\n            if array_nums1[i] == array_nums2[j] {\n                result = append(result, array_nums1[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var intersection_array []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                intersection_array = append(intersection_array, num1)\n            }\n        }\n    }\n    return intersection_array\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num == num2 {\n                result = append(result, num)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_nums []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_nums = append(array_nums, num1)\n            }\n        }\n    }\n    return array_nums\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for i := 0; i < len(array_nums1); i++ {\n        for j := 0; j < len(array_nums2); j++ {\n            if array_nums1[i] == array_nums2[j] {\n                result = append(result, array_nums1[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_intersection []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_intersection = append(array_intersection, num1)\n            }\n        }\n    }\n    return array_intersection\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var res []int\n    for _, num := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num == num2 {\n                res = append(res, num)\n            }\n        }\n    }\n    return res\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for i := 0; i < len(array_nums1); i++ {\n        for j := 0; j < len(array_nums2); j++ {\n            if array_nums1[i] == array_nums2[j] {\n                result = append(result, array_nums1[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for i := 0; i < len(array_nums1); i++ {\n        for j := 0; j < len(array_nums2); j++ {\n            if array_nums1[i] == array_nums2[j] {\n                result = append(result, array_nums1[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_intersection []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_intersection = append(array_intersection, num1)\n            }\n        }\n    }\n    return array_intersection\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_nums []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_nums = append(array_nums, num1)\n            }\n        }\n    }\n    return array_nums\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for i := 0; i < len(array_nums1); i++ {\n        for j := 0; j < len(array_nums2); j++ {\n            if array_nums1[i] == array_nums2[j] {\n                result = append(result, array_nums1[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_intersection []int\n    for _, num := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num == num2 {\n                array_intersection = append(array_intersection, num)\n                break\n            }\n        }\n    }\n    return array_intersection\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for i := 0; i < len(array_nums1); i++ {\n        for j := 0; j < len(array_nums2); j++ {\n            if array_nums1[i] == array_nums2[j] {\n                result = append(result, array_nums1[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, v := range array_nums1 {\n        for _, v2 := range array_nums2 {\n            if v == v2 {\n                result = append(result, v)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_nums []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_nums = append(array_nums, num1)\n            }\n        }\n    }\n    return array_nums\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_nums []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_nums = append(array_nums, num1)\n            }\n        }\n    }\n    return array_nums\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_nums3 []int\n    for _, v := range array_nums1 {\n        for _, v2 := range array_nums2 {\n            if v == v2 {\n                array_nums3 = append(array_nums3, v)\n            }\n        }\n    }\n    return array_nums3\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    var map_nums = make(map[int]int)\n    for _, num := range array_nums1 {\n        map_nums[num] = 1\n    }\n    for _, num := range array_nums2 {\n        if _, ok := map_nums[num]; ok {\n            result = append(result, num)\n            delete(map_nums, num)\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var intersection_array []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                intersection_array = append(intersection_array, num1)\n            }\n        }\n    }\n    return intersection_array\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    var map_nums = make(map[int]int)\n    for _, num := range array_nums1 {\n        map_nums[num] = 1\n    }\n    for _, num := range array_nums2 {\n        if map_nums[num] == 1 {\n            result = append(result, num)\n            map_nums[num] = 2\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for i := 0; i < len(array_nums1); i++ {\n        for j := 0; j < len(array_nums2); j++ {\n            if array_nums1[i] == array_nums2[j] {\n                result = append(result, array_nums1[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_intersection []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_intersection = append(array_intersection, num1)\n            }\n        }\n    }\n    return array_intersection\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_result = append(array_result, num1)\n            }\n        }\n    }\n    return array_result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for i := 0; i < len(array_nums1); i++ {\n        for j := 0; j < len(array_nums2); j++ {\n            if array_nums1[i] == array_nums2[j] {\n                result = append(result, array_nums1[i])\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_intersection []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_intersection = append(array_intersection, num1)\n            }\n        }\n    }\n    return array_intersection\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_intersection []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_intersection = append(array_intersection, num1)\n            }\n        }\n    }\n    return array_intersection\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_nums []int\n    for i := 0; i < len(array_nums1); i++ {\n        for j := 0; j < len(array_nums2); j++ {\n            if array_nums1[i] == array_nums2[j] {\n                array_nums = append(array_nums, array_nums1[i])\n            }\n        }\n    }\n    return array_nums\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_nums []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_nums = append(array_nums, num1)\n            }\n        }\n    }\n    return array_nums\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123251,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var array_result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                array_result = append(array_result, num1)\n            }\n        }\n    }\n    return array_result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num == num2 {\n                result = append(result, num)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num == num2 {\n                result = append(result, num)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num == num2 {\n                result = append(result, num)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package intersection_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1 []int, array_nums2 []int) []int {\n    var result []int\n    for _, num1 := range array_nums1 {\n        for _, num2 := range array_nums2 {\n            if num1 == num2 {\n                result = append(result, num1)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestIntersection_Array(t *testing.T) {\n  candidate := intersection_array\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{1, 2, 4, 8, 9}), expected: []int{1, 2, 8, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{3, 5, 7, 9}), expected: []int{3, 5, 7, 9} },\n     { actual: candidate([]int{1, 2, 3, 5, 7, 8, 9, 10}, []int{10, 20, 30, 40}), expected: []int{10} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510148,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    }
  ]
}