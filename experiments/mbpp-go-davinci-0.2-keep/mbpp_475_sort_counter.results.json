{
  "name": "mbpp_475_sort_counter",
  "language": "go_test.go",
  "prompt": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_475_sort_counter.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl0oh93l9_test.go:28:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl0oh93l9_test.go:29:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl0oh93l9_test.go:30:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var list [][]interface{}\n    for k, v := range dict1 {\n        list = append(list, []interface{}{k, v})\n    }\n    for i := 0; i < len(list); i++ {\n        for j := i + 1; j < len(list); j++ {\n            if list[i][1].(int) < list[j][1].(int) {\n                list[i], list[j] = list[j], list[i]\n            }\n        }\n    }\n    return list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp69stzawq_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp69stzawq_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp69stzawq_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                temp := sorted_dict[i]\n                sorted_dict[i] = sorted_dict[j]\n                sorted_dict[j] = temp\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoozpnt1x_test.go:33:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoozpnt1x_test.go:34:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoozpnt1x_test.go:35:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var dict2 [][]interface{}\n    for k, v := range dict1 {\n        dict2 = append(dict2, []interface{}{k, v})\n    }\n    for i := 0; i < len(dict2); i++ {\n        for j := i + 1; j < len(dict2); j++ {\n            if dict2[i][1].(int) < dict2[j][1].(int) {\n                dict2[i], dict2[j] = dict2[j], dict2[i]\n            }\n        }\n    }\n    return dict2\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa_ndkqm__test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa_ndkqm__test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa_ndkqm__test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    // Create a slice of tuples\n    var tuples [][]interface{}\n    for key, value := range dict1 {\n        tuple := []interface{}{key, value}\n        tuples = append(tuples, tuple)\n    }\n\n    // Sort the slice of tuples\n    for i := 0; i < len(tuples); i++ {\n        for j := i + 1; j < len(tuples); j++ {\n            if tuples[i][1].(int) > tuples[j][1].(int) {\n                temp := tuples[i]\n                tuples[i] = tuples[j]\n                tuples[j] = temp\n            }\n        }\n    }\n\n    return tuples\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpz1hqa367_test.go:38:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpz1hqa367_test.go:39:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpz1hqa367_test.go:40:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_dict [][]interface{}\n    for k, v := range dict1 {\n        sort_dict = append(sort_dict, []interface{}{k, v})\n    }\n\n    for i := 0; i < len(sort_dict); i++ {\n        for j := i + 1; j < len(sort_dict); j++ {\n            if sort_dict[i][1].(int) < sort_dict[j][1].(int) {\n                sort_dict[i], sort_dict[j] = sort_dict[j], sort_dict[i]\n            }\n        }\n    }\n    return sort_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl87vx61d_test.go:32:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl87vx61d_test.go:33:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl87vx61d_test.go:34:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var result [][]interface{}\n    for _, k := range keys {\n        result = append(result, []interface{}{k, dict1[k]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyg2r5qmj_test.go:28:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpyg2r5qmj_test.go:29:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpyg2r5qmj_test.go:30:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_list [][]interface{}\n    for k, v := range dict1 {\n        sort_list = append(sort_list, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_list); i++ {\n        for j := i + 1; j < len(sort_list); j++ {\n            if sort_list[i][1].(int) < sort_list[j][1].(int) {\n                sort_list[i], sort_list[j] = sort_list[j], sort_list[i]\n            }\n        }\n    }\n    return sort_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted [][]interface{}\n    for k, v := range dict1 {\n        sorted = append(sorted, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted); i++ {\n        for j := i + 1; j < len(sorted); j++ {\n            if sorted[i][1].(int) < sorted[j][1].(int) {\n                sorted[i], sorted[j] = sorted[j], sorted[i]\n            }\n        }\n    }\n    return sorted\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict) - 1; i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var result [][]interface{}\n    for k, v := range dict1 {\n        result = append(result, []interface{}{k, v})\n    }\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][1].(int) < result[j][1].(int) {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_dict [][]interface{}\n    for k, v := range dict1 {\n        sort_dict = append(sort_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_dict); i++ {\n        for j := i + 1; j < len(sort_dict); j++ {\n            if sort_dict[i][1].(int) < sort_dict[j][1].(int) {\n                sort_dict[i], sort_dict[j] = sort_dict[j], sort_dict[i]\n            }\n        }\n    }\n    return sort_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_list [][]interface{}\n    for k, v := range dict1 {\n        sort_list = append(sort_list, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_list); i++ {\n        for j := i + 1; j < len(sort_list); j++ {\n            if sort_list[i][1].(int) < sort_list[j][1].(int) {\n                sort_list[i], sort_list[j] = sort_list[j], sort_list[i]\n            }\n        }\n    }\n    return sort_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    // Create a slice of key-value pairs.\n    var kv_pairs [][]interface{}\n    for k, v := range dict1 {\n        kv_pairs = append(kv_pairs, []interface{}{k, v})\n    }\n    // Sort the slice of key-value pairs.\n    for i := 0; i < len(kv_pairs); i++ {\n        for j := i + 1; j < len(kv_pairs); j++ {\n            if kv_pairs[i][1].(int) < kv_pairs[j][1].(int) {\n                kv_pairs[i], kv_pairs[j] = kv_pairs[j], kv_pairs[i]\n            }\n        }\n    }\n    return kv_pairs\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_dict [][]interface{}\n    for k, v := range dict1 {\n        sort_dict = append(sort_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_dict); i++ {\n        for j := i + 1; j < len(sort_dict); j++ {\n            if sort_dict[i][1].(int) < sort_dict[j][1].(int) {\n                sort_dict[i], sort_dict[j] = sort_dict[j], sort_dict[i]\n            }\n        }\n    }\n    return sort_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[j][1].(int) < sorted_dict[i][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_list [][]interface{}\n    for k, v := range dict1 {\n        sort_list = append(sort_list, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_list); i++ {\n        for j := i + 1; j < len(sort_list); j++ {\n            if sort_list[i][1].(int) < sort_list[j][1].(int) {\n                sort_list[i], sort_list[j] = sort_list[j], sort_list[i]\n            }\n        }\n    }\n    return sort_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_list [][]interface{}\n    for k, v := range dict1 {\n        sorted_list = append(sorted_list, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_list); i++ {\n        for j := i + 1; j < len(sorted_list); j++ {\n            if sorted_list[i][1].(int) < sorted_list[j][1].(int) {\n                sorted_list[i], sorted_list[j] = sorted_list[j], sorted_list[i]\n            }\n        }\n    }\n    return sorted_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl0oh93l9_test.go:28:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl0oh93l9_test.go:29:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl0oh93l9_test.go:30:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_dict [][]interface{}\n    for key, value := range dict1 {\n        sort_dict = append(sort_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sort_dict); i++ {\n        for j := i + 1; j < len(sort_dict); j++ {\n            if sort_dict[i][1].(int) < sort_dict[j][1].(int) {\n                sort_dict[i], sort_dict[j] = sort_dict[j], sort_dict[i]\n            }\n        }\n    }\n    return sort_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    var sorted [][]interface{}\n    for _, k := range keys {\n        sorted = append(sorted, []interface{}{k, dict1[k]})\n    }\n    return sorted\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_list [][]interface{}\n    for key, value := range dict1 {\n        sorted_list = append(sorted_list, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_list); i++ {\n        for j := i + 1; j < len(sorted_list); j++ {\n            if sorted_list[i][1].(int) < sorted_list[j][1].(int) {\n                sorted_list[i], sorted_list[j] = sorted_list[j], sorted_list[i]\n            }\n        }\n    }\n    return sorted_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    // Create a slice of tuples.\n    var tuples [][]interface{}\n    for key, value := range dict1 {\n        tuples = append(tuples, []interface{}{key, value})\n    }\n    // Sort the slice of tuples.\n    for i := 0; i < len(tuples); i++ {\n        for j := i + 1; j < len(tuples); j++ {\n            if tuples[i][1].(int) < tuples[j][1].(int) {\n                tuples[i], tuples[j] = tuples[j], tuples[i]\n            }\n        }\n    }\n    return tuples\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    var result [][]interface{}\n    for _, k := range keys {\n        result = append(result, []interface{}{k, dict1[k]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    // Create a slice of the keys\n    keys := make([]string, len(dict1))\n    i := 0\n    for k := range dict1 {\n        keys[i] = k\n        i++\n    }\n    // Sort the keys\n    for i := 0; i < len(keys); i++ {\n        for j := i + 1; j < len(keys); j++ {\n            if dict1[keys[i]] < dict1[keys[j]] {\n                keys[i], keys[j] = keys[j], keys[i]\n            }\n        }\n    }\n    // Create a slice of the sorted keys\n    sorted_keys := make([]interface{}, len(keys))\n    for i := 0; i < len(keys); i++ {\n        sorted_keys[i] = keys[i]\n    }\n    // Create a slice of the sorted values\n    sorted_values := make([]interface{}, len(keys))\n    for i := 0; i < len(keys); i++ {\n        sorted_values[i] = dict1[keys[i]]\n    }\n    // Create a slice of the sorted keys and values\n    sorted_keys_values := make([][]interface{}, 2)\n    sorted_keys_values[0] = sorted_keys\n    sorted_keys_values[1] = sorted_values\n    return sorted_keys_values\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_list [][]interface{}\n    for k, v := range dict1 {\n        sorted_list = append(sorted_list, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_list) - 1; i++ {\n        for j := i + 1; j < len(sorted_list); j++ {\n            if sorted_list[i][1].(int) < sorted_list[j][1].(int) {\n                sorted_list[i], sorted_list[j] = sorted_list[j], sorted_list[i]\n            }\n        }\n    }\n    return sorted_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted [][]interface{}\n    for key, value := range dict1 {\n        sorted = append(sorted, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted); i++ {\n        for j := i + 1; j < len(sorted); j++ {\n            if sorted[i][1].(int) < sorted[j][1].(int) {\n                sorted[i], sorted[j] = sorted[j], sorted[i]\n            }\n        }\n    }\n    return sorted\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    // Create a slice of tuples.\n    var tuples [][]interface{}\n    // Iterate over the dictionary.\n    for key, value := range dict1 {\n        // Append the tuple to the slice.\n        tuples = append(tuples, []interface{}{key, value})\n    }\n    // Sort the slice of tuples.\n    for i := 0; i < len(tuples); i++ {\n        for j := i + 1; j < len(tuples); j++ {\n            if tuples[i][1].(int) < tuples[j][1].(int) {\n                tuples[i], tuples[j] = tuples[j], tuples[i]\n            }\n        }\n    }\n    // Return the slice of tuples.\n    return tuples\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_list [][]interface{}\n    for k, v := range dict1 {\n        sort_list = append(sort_list, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_list); i++ {\n        for j := i + 1; j < len(sort_list); j++ {\n            if sort_list[i][1].(int) < sort_list[j][1].(int) {\n                sort_list[i], sort_list[j] = sort_list[j], sort_list[i]\n            }\n        }\n    }\n    return sort_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    var dict2 [][]interface{}\n    for _, k := range keys {\n        dict2 = append(dict2, []interface{}{k, dict1[k]})\n    }\n    return dict2\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_list [][]interface{}\n    for k, v := range dict1 {\n        sort_list = append(sort_list, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_list); i++ {\n        for j := i + 1; j < len(sort_list); j++ {\n            if sort_list[i][1].(int) < sort_list[j][1].(int) {\n                sort_list[i], sort_list[j] = sort_list[j], sort_list[i]\n            }\n        }\n    }\n    return sort_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    // Create a slice of slice of interface{}\n    // Each element of the slice is a slice of interface{}\n    // The first element of the slice of interface{} is the key\n    // The second element of the slice of interface{} is the value\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    // Sort the slice of slice of interface{}\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl0oh93l9_test.go:28:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl0oh93l9_test.go:29:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl0oh93l9_test.go:30:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_list [][]interface{}\n    for k, v := range dict1 {\n        sort_list = append(sort_list, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_list); i++ {\n        for j := i + 1; j < len(sort_list); j++ {\n            if sort_list[i][1].(int) < sort_list[j][1].(int) {\n                sort_list[i], sort_list[j] = sort_list[j], sort_list[i]\n            }\n        }\n    }\n    return sort_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k, _ := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_dict [][]interface{}\n    for k, v := range dict1 {\n        sort_dict = append(sort_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_dict); i++ {\n        for j := i + 1; j < len(sort_dict); j++ {\n            if sort_dict[i][1].(int) < sort_dict[j][1].(int) {\n                sort_dict[i], sort_dict[j] = sort_dict[j], sort_dict[i]\n            }\n        }\n    }\n    return sort_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var list [][]interface{}\n    for key, value := range dict1 {\n        list = append(list, []interface{}{key, value})\n    }\n    for i := 0; i < len(list); i++ {\n        for j := i + 1; j < len(list); j++ {\n            if list[i][1].(int) < list[j][1].(int) {\n                list[i], list[j] = list[j], list[i]\n            }\n        }\n    }\n    return list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122527,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_list [][]interface{}\n    for key, value := range dict1 {\n        sort_list = append(sort_list, []interface{}{key, value})\n    }\n    for i := 0; i < len(sort_list); i++ {\n        for j := i + 1; j < len(sort_list); j++ {\n            if sort_list[i][1].(int) < sort_list[j][1].(int) {\n                sort_list[i], sort_list[j] = sort_list[j], sort_list[i]\n            }\n        }\n    }\n    return sort_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122527,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) > sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122527,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n\n    var result [][]interface{}\n    for _, k := range keys {\n        result = append(result, []interface{}{k, dict1[k]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122527,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    // Create a slice of tuples.\n    var tuples [][]interface{}\n    for key, value := range dict1 {\n        tuples = append(tuples, []interface{}{key, value})\n    }\n    // Sort the slice of tuples.\n    for i := 0; i < len(tuples); i++ {\n        for j := i + 1; j < len(tuples); j++ {\n            if tuples[i][1].(int) < tuples[j][1].(int) {\n                tuples[i], tuples[j] = tuples[j], tuples[i]\n            }\n        }\n    }\n    return tuples\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                temp := sorted_dict[i]\n                sorted_dict[i] = sorted_dict[j]\n                sorted_dict[j] = temp\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122527,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_dict [][]interface{}\n    for k, v := range dict1 {\n        sort_dict = append(sort_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_dict); i++ {\n        for j := i + 1; j < len(sort_dict); j++ {\n            if sort_dict[i][1].(int) < sort_dict[j][1].(int) {\n                sort_dict[i], sort_dict[j] = sort_dict[j], sort_dict[i]\n            }\n        }\n    }\n    return sort_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_dict [][]interface{}\n    for k, v := range dict1 {\n        sort_dict = append(sort_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_dict); i++ {\n        for j := i + 1; j < len(sort_dict); j++ {\n            if sort_dict[i][1].(int) < sort_dict[j][1].(int) {\n                sort_dict[i], sort_dict[j] = sort_dict[j], sort_dict[i]\n            }\n        }\n    }\n    return sort_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted [][]interface{}\n    for key, value := range dict1 {\n        sorted = append(sorted, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted); i++ {\n        for j := i + 1; j < len(sorted); j++ {\n            if sorted[i][1].(int) < sorted[j][1].(int) {\n                sorted[i], sorted[j] = sorted[j], sorted[i]\n            }\n        }\n    }\n    return sorted\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_dict [][]interface{}\n    for k, v := range dict1 {\n        sort_dict = append(sort_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_dict); i++ {\n        for j := i + 1; j < len(sort_dict); j++ {\n            if sort_dict[i][1].(int) < sort_dict[j][1].(int) {\n                sort_dict[i], sort_dict[j] = sort_dict[j], sort_dict[i]\n            }\n        }\n    }\n    return sort_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted [][]interface{}\n    for k, v := range dict1 {\n        sorted = append(sorted, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted); i++ {\n        for j := i + 1; j < len(sorted); j++ {\n            if sorted[i][1].(int) < sorted[j][1].(int) {\n                sorted[i], sorted[j] = sorted[j], sorted[i]\n            }\n        }\n    }\n    return sorted\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n\n    var result [][]interface{}\n    for _, k := range keys {\n        result = append(result, []interface{}{k, dict1[k]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122527,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    var values []int\n    for k, v := range dict1 {\n        keys = append(keys, k)\n        values = append(values, v)\n    }\n    for i := 0; i < len(values); i++ {\n        for j := i + 1; j < len(values); j++ {\n            if values[i] < values[j] {\n                values[i], values[j] = values[j], values[i]\n                keys[i], keys[j] = keys[j], keys[i]\n            }\n        }\n    }\n    var result [][]interface{}\n    for i := 0; i < len(values); i++ {\n        result = append(result, []interface{}{keys[i], values[i]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122527,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted [][]interface{}\n    for _, k := range keys {\n        sorted = append(sorted, []interface{}{k, dict1[k]})\n    }\n    for i := 0; i < len(sorted); i++ {\n        for j := i + 1; j < len(sorted); j++ {\n            if sorted[i][1].(int) < sorted[j][1].(int) {\n                sorted[i], sorted[j] = sorted[j], sorted[i]\n            }\n        }\n    }\n    return sorted\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122527,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122527,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    var values []int\n    for k, v := range dict1 {\n        keys = append(keys, k)\n        values = append(values, v)\n    }\n    for i := 0; i < len(values); i++ {\n        for j := i + 1; j < len(values); j++ {\n            if values[i] < values[j] {\n                values[i], values[j] = values[j], values[i]\n                keys[i], keys[j] = keys[j], keys[i]\n            }\n        }\n    }\n    var result [][]interface{}\n    for i := 0; i < len(values); i++ {\n        result = append(result, []interface{}{keys[i], values[i]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122527,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl0oh93l9_test.go:28:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl0oh93l9_test.go:29:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl0oh93l9_test.go:30:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    // Create a slice of tuples\n    var tuples [][]interface{}\n    for key, value := range dict1 {\n        tuples = append(tuples, []interface{}{key, value})\n    }\n\n    // Sort the slice of tuples\n    for i := 0; i < len(tuples); i++ {\n        for j := i + 1; j < len(tuples); j++ {\n            if tuples[i][1].(int) < tuples[j][1].(int) {\n                tuples[i], tuples[j] = tuples[j], tuples[i]\n            }\n        }\n    }\n\n    return tuples\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122527,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    var result [][]interface{}\n    for _, k := range keys {\n        result = append(result, []interface{}{k, dict1[k]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                temp := sorted_dict[i]\n                sorted_dict[i] = sorted_dict[j]\n                sorted_dict[j] = temp\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122527,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl0oh93l9_test.go:28:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl0oh93l9_test.go:29:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl0oh93l9_test.go:30:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl0oh93l9_test.go:28:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl0oh93l9_test.go:29:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl0oh93l9_test.go:30:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    var result [][]interface{}\n    for _, k := range keys {\n        result = append(result, []interface{}{k, dict1[k]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_dict [][]interface{}\n    for k, v := range dict1 {\n        sort_dict = append(sort_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_dict); i++ {\n        for j := i + 1; j < len(sort_dict); j++ {\n            if sort_dict[i][1].(int) < sort_dict[j][1].(int) {\n                sort_dict[i], sort_dict[j] = sort_dict[j], sort_dict[i]\n            }\n        }\n    }\n    return sort_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    // Create a slice of tuples.\n    var tuples [][]interface{}\n    for key, value := range dict1 {\n        tuples = append(tuples, []interface{}{key, value})\n    }\n    // Sort the tuples.\n    for i := 0; i < len(tuples); i++ {\n        for j := i + 1; j < len(tuples); j++ {\n            if tuples[i][1].(int) < tuples[j][1].(int) {\n                tuples[i], tuples[j] = tuples[j], tuples[i]\n            }\n        }\n    }\n    return tuples\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122527,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_list [][]interface{}\n    for k, v := range dict1 {\n        sort_list = append(sort_list, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_list); i++ {\n        for j := i + 1; j < len(sort_list); j++ {\n            if sort_list[i][1].(int) < sort_list[j][1].(int) {\n                sort_list[i], sort_list[j] = sort_list[j], sort_list[i]\n            }\n        }\n    }\n    return sort_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_list [][]interface{}\n    for k, v := range dict1 {\n        sort_list = append(sort_list, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_list); i++ {\n        for j := i + 1; j < len(sort_list); j++ {\n            if sort_list[i][1].(int) < sort_list[j][1].(int) {\n                sort_list[i], sort_list[j] = sort_list[j], sort_list[i]\n            }\n        }\n    }\n    return sort_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_dict [][]interface{}\n    for key, value := range dict1 {\n        sort_dict = append(sort_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sort_dict); i++ {\n        for j := i + 1; j < len(sort_dict); j++ {\n            if sort_dict[i][1].(int) < sort_dict[j][1].(int) {\n                sort_dict[i], sort_dict[j] = sort_dict[j], sort_dict[i]\n            }\n        }\n    }\n    return sort_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted [][]interface{}\n    for key, value := range dict1 {\n        sorted = append(sorted, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted); i++ {\n        for j := i + 1; j < len(sorted); j++ {\n            if sorted[i][1].(int) < sorted[j][1].(int) {\n                sorted[i], sorted[j] = sorted[j], sorted[i]\n            }\n        }\n    }\n    return sorted\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl0oh93l9_test.go:28:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl0oh93l9_test.go:29:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl0oh93l9_test.go:30:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := 0; j < len(sorted_dict)-1; j++ {\n            if sorted_dict[j][1].(int) < sorted_dict[j+1][1].(int) {\n                sorted_dict[j], sorted_dict[j+1] = sorted_dict[j+1], sorted_dict[j]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122527,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122527,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var result [][]interface{}\n    for _, k := range keys {\n        result = append(result, []interface{}{k, dict1[k]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyg2r5qmj_test.go:28:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpyg2r5qmj_test.go:29:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpyg2r5qmj_test.go:30:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    // Create a slice of tuples.\n    var tuples [][]interface{}\n    for key, value := range dict1 {\n        tuples = append(tuples, []interface{}{key, value})\n    }\n    // Sort the slice of tuples.\n    for i := 0; i < len(tuples); i++ {\n        for j := i + 1; j < len(tuples); j++ {\n            if tuples[i][1].(int) < tuples[j][1].(int) {\n                tuples[i], tuples[j] = tuples[j], tuples[i]\n            }\n        }\n    }\n    return tuples\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    // Create a slice of tuples to store the key/value pairs.\n    var tuples [][]interface{}\n    // Iterate over the map and append the key/value pairs to the slice.\n    for key, value := range dict1 {\n        tuples = append(tuples, []interface{}{key, value})\n    }\n    // Sort the slice of tuples by the second value in the tuple.\n    for i := 0; i < len(tuples); i++ {\n        for j := i + 1; j < len(tuples); j++ {\n            if tuples[i][1].(int) < tuples[j][1].(int) {\n                tuples[i], tuples[j] = tuples[j], tuples[i]\n            }\n        }\n    }\n    return tuples\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122527,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_dict [][]interface{}\n    for k, v := range dict1 {\n        sort_dict = append(sort_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_dict); i++ {\n        for j := i + 1; j < len(sort_dict); j++ {\n            if sort_dict[i][1].(int) < sort_dict[j][1].(int) {\n                sort_dict[i], sort_dict[j] = sort_dict[j], sort_dict[i]\n            }\n        }\n    }\n    return sort_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := 0; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) > sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122527,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122527,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_list [][]interface{}\n    for key, value := range dict1 {\n        sorted_list = append(sorted_list, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_list); i++ {\n        for j := i + 1; j < len(sorted_list); j++ {\n            if sorted_list[i][1].(int) < sorted_list[j][1].(int) {\n                sorted_list[i], sorted_list[j] = sorted_list[j], sorted_list[i]\n            }\n        }\n    }\n    return sorted_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_dict [][]interface{}\n    for key, value := range dict1 {\n        sort_dict = append(sort_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sort_dict); i++ {\n        for j := i + 1; j < len(sort_dict); j++ {\n            if sort_dict[i][1].(int) < sort_dict[j][1].(int) {\n                sort_dict[i], sort_dict[j] = sort_dict[j], sort_dict[i]\n            }\n        }\n    }\n    return sort_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_list [][]interface{}\n    for k, v := range dict1 {\n        sort_list = append(sort_list, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_list); i++ {\n        for j := i + 1; j < len(sort_list); j++ {\n            if sort_list[i][1].(int) < sort_list[j][1].(int) {\n                sort_list[i], sort_list[j] = sort_list[j], sort_list[i]\n            }\n        }\n    }\n    return sort_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    var values []int\n    var sorted_dict [][]interface{}\n\n    for k, v := range dict1 {\n        keys = append(keys, k)\n        values = append(values, v)\n    }\n\n    for i := 0; i < len(values); i++ {\n        for j := i + 1; j < len(values); j++ {\n            if values[i] < values[j] {\n                values[i], values[j] = values[j], values[i]\n                keys[i], keys[j] = keys[j], keys[i]\n            }\n        }\n    }\n\n    for i := 0; i < len(values); i++ {\n        sorted_dict = append(sorted_dict, []interface{}{keys[i], values[i]})\n    }\n\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122527,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted [][]interface{}\n    for k, v := range dict1 {\n        sorted = append(sorted, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted); i++ {\n        for j := i + 1; j < len(sorted); j++ {\n            if sorted[i][1].(int) < sorted[j][1].(int) {\n                sorted[i], sorted[j] = sorted[j], sorted[i]\n            }\n        }\n    }\n    return sorted\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_dict [][]interface{}\n    for k, v := range dict1 {\n        sort_dict = append(sort_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_dict); i++ {\n        for j := i + 1; j < len(sort_dict); j++ {\n            if sort_dict[i][1].(int) < sort_dict[j][1].(int) {\n                sort_dict[i], sort_dict[j] = sort_dict[j], sort_dict[i]\n            }\n        }\n    }\n    return sort_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    // Create a slice to store the sorted keys.\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    // Sort the keys.\n    sort.Strings(keys)\n    // Create a slice to store the sorted values.\n    var values [][]interface{}\n    for _, k := range keys {\n        values = append(values, []interface{}{k, dict1[k]})\n    }\n    return values\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122527,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl0oh93l9_test.go:28:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl0oh93l9_test.go:29:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl0oh93l9_test.go:30:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_dict [][]interface{}\n    for k, v := range dict1 {\n        sort_dict = append(sort_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_dict); i++ {\n        for j := i + 1; j < len(sort_dict); j++ {\n            if sort_dict[i][1].(int) < sort_dict[j][1].(int) {\n                sort_dict[i], sort_dict[j] = sort_dict[j], sort_dict[i]\n            }\n        }\n    }\n    return sort_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    // Create a slice of tuples\n    var tuples [][]interface{}\n    for key, value := range dict1 {\n        tuples = append(tuples, []interface{}{key, value})\n    }\n    // Sort the slice of tuples by the second element in each tuple\n    for i := 0; i < len(tuples); i++ {\n        for j := i + 1; j < len(tuples); j++ {\n            if tuples[i][1].(int) < tuples[j][1].(int) {\n                tuples[i], tuples[j] = tuples[j], tuples[i]\n            }\n        }\n    }\n    return tuples\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122527,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted [][]interface{}\n    for k, v := range dict1 {\n        sorted = append(sorted, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted); i++ {\n        for j := i + 1; j < len(sorted); j++ {\n            if sorted[i][1].(int) < sorted[j][1].(int) {\n                sorted[i], sorted[j] = sorted[j], sorted[i]\n            }\n        }\n    }\n    return sorted\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_dict [][]interface{}\n    for k, v := range dict1 {\n        sort_dict = append(sort_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_dict); i++ {\n        for j := i + 1; j < len(sort_dict); j++ {\n            if sort_dict[i][1].(int) < sort_dict[j][1].(int) {\n                sort_dict[i], sort_dict[j] = sort_dict[j], sort_dict[i]\n            }\n        }\n    }\n    return sort_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_dict [][]interface{}\n    for k, v := range dict1 {\n        sort_dict = append(sort_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_dict); i++ {\n        for j := i + 1; j < len(sort_dict); j++ {\n            if sort_dict[i][1].(int) < sort_dict[j][1].(int) {\n                sort_dict[i], sort_dict[j] = sort_dict[j], sort_dict[i]\n            }\n        }\n    }\n    return sort_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted [][]interface{}\n    for key, value := range dict1 {\n        sorted = append(sorted, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted); i++ {\n        for j := i + 1; j < len(sorted); j++ {\n            if sorted[i][1].(int) < sorted[j][1].(int) {\n                temp := sorted[i]\n                sorted[i] = sorted[j]\n                sorted[j] = temp\n            }\n        }\n    }\n    return sorted\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122527,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl0oh93l9_test.go:28:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl0oh93l9_test.go:29:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl0oh93l9_test.go:30:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var result [][]interface{}\n    for key, value := range dict1 {\n        result = append(result, []interface{}{key, value})\n    }\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][1].(int) < result[j][1].(int) {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122527,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_dict [][]interface{}\n    for k, v := range dict1 {\n        sort_dict = append(sort_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_dict); i++ {\n        for j := i + 1; j < len(sort_dict); j++ {\n            if sort_dict[i][1].(int) < sort_dict[j][1].(int) {\n                sort_dict[i], sort_dict[j] = sort_dict[j], sort_dict[i]\n            }\n        }\n    }\n    return sort_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    var values []int\n    var result [][]interface{}\n\n    for k, v := range dict1 {\n        keys = append(keys, k)\n        values = append(values, v)\n    }\n\n    for i := 0; i < len(values); i++ {\n        for j := i + 1; j < len(values); j++ {\n            if values[i] < values[j] {\n                values[i], values[j] = values[j], values[i]\n                keys[i], keys[j] = keys[j], keys[i]\n            }\n        }\n    }\n\n    for i := 0; i < len(values); i++ {\n        result = append(result, []interface{}{keys[i], values[i]})\n    }\n\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122527,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_dict [][]interface{}\n    for k, v := range dict1 {\n        sort_dict = append(sort_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_dict); i++ {\n        for j := i + 1; j < len(sort_dict); j++ {\n            if sort_dict[i][1].(int) < sort_dict[j][1].(int) {\n                sort_dict[i], sort_dict[j] = sort_dict[j], sort_dict[i]\n            }\n        }\n    }\n    return sort_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_list [][]interface{}\n    for key, value := range dict1 {\n        sorted_list = append(sorted_list, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_list); i++ {\n        for j := i + 1; j < len(sorted_list); j++ {\n            if sorted_list[i][1].(int) < sorted_list[j][1].(int) {\n                sorted_list[i], sorted_list[j] = sorted_list[j], sorted_list[i]\n            }\n        }\n    }\n    return sorted_list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122527,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var new_dict [][]interface{}\n    for k, v := range dict1 {\n        new_dict = append(new_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(new_dict); i++ {\n        for j := i + 1; j < len(new_dict); j++ {\n            if new_dict[i][1].(int) < new_dict[j][1].(int) {\n                new_dict[i], new_dict[j] = new_dict[j], new_dict[i]\n            }\n        }\n    }\n    return new_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122527,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted [][]interface{}\n    for k, v := range dict1 {\n        sorted = append(sorted, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted); i++ {\n        for j := i + 1; j < len(sorted); j++ {\n            if sorted[i][1].(int) < sorted[j][1].(int) {\n                sorted[i], sorted[j] = sorted[j], sorted[i]\n            }\n        }\n    }\n    return sorted\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sort_dict [][]interface{}\n    for k, v := range dict1 {\n        sort_dict = append(sort_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sort_dict); i++ {\n        for j := i + 1; j < len(sort_dict); j++ {\n            if sort_dict[i][1].(int) < sort_dict[j][1].(int) {\n                sort_dict[i], sort_dict[j] = sort_dict[j], sort_dict[i]\n            }\n        }\n    }\n    return sort_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted [][]interface{}\n    for k, v := range dict1 {\n        sorted = append(sorted, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted); i++ {\n        for j := i + 1; j < len(sorted); j++ {\n            if sorted[i][1].(int) < sorted[j][1].(int) {\n                sorted[i], sorted[j] = sorted[j], sorted[i]\n            }\n        }\n    }\n    return sorted\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl0oh93l9_test.go:28:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl0oh93l9_test.go:29:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl0oh93l9_test.go:30:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var result [][]interface{}\n    for key, value := range dict1 {\n        result = append(result, []interface{}{key, value})\n    }\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][1].(int) < result[j][1].(int) {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122527,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var dict2 [][]interface{}\n    for k, v := range dict1 {\n        dict2 = append(dict2, []interface{}{k, v})\n    }\n    for i := 0; i < len(dict2); i++ {\n        for j := i + 1; j < len(dict2); j++ {\n            if dict2[i][1].(int) < dict2[j][1].(int) {\n                dict2[i], dict2[j] = dict2[j], dict2[i]\n            }\n        }\n    }\n    return dict2\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa_ndkqm__test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa_ndkqm__test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa_ndkqm__test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    var sorted_dict [][]interface{}\n    for _, k := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{k, dict1[k]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl0oh93l9_test.go:28:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl0oh93l9_test.go:29:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpl0oh93l9_test.go:30:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                temp := sorted_dict[i]\n                sorted_dict[i] = sorted_dict[j]\n                sorted_dict[j] = temp\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoozpnt1x_test.go:33:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoozpnt1x_test.go:34:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpoozpnt1x_test.go:35:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var list [][]interface{}\n    for key, value := range dict1 {\n        list = append(list, []interface{}{key, value})\n    }\n    for i := 0; i < len(list); i++ {\n        for j := i + 1; j < len(list); j++ {\n            if list[i][1].(int) < list[j][1].(int) {\n                list[i], list[j] = list[j], list[i]\n            }\n        }\n    }\n    return list\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122527,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var dict2 [][]interface{}\n    for k, v := range dict1 {\n        dict2 = append(dict2, []interface{}{k, v})\n    }\n    for i := 0; i < len(dict2); i++ {\n        for j := i + 1; j < len(dict2); j++ {\n            if dict2[i][1].(int) < dict2[j][1].(int) {\n                dict2[i], dict2[j] = dict2[j], dict2[i]\n            }\n        }\n    }\n    return dict2\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa_ndkqm__test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa_ndkqm__test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa_ndkqm__test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted [][]interface{}\n    for k, v := range dict1 {\n        sorted = append(sorted, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted); i++ {\n        for j := i + 1; j < len(sorted); j++ {\n            if sorted[i][1].(int) < sorted[j][1].(int) {\n                sorted[i], sorted[j] = sorted[j], sorted[i]\n            }\n        }\n    }\n    return sorted\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for k := range dict1 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    var result [][]interface{}\n    for _, k := range keys {\n        result = append(result, []interface{}{k, dict1[k]})\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var dict2 [][]interface{}\n    for k, v := range dict1 {\n        dict2 = append(dict2, []interface{}{k, v})\n    }\n    for i := 0; i < len(dict2); i++ {\n        for j := i + 1; j < len(dict2); j++ {\n            if dict2[i][1].(int) < dict2[j][1].(int) {\n                dict2[i], dict2[j] = dict2[j], dict2[i]\n            }\n        }\n    }\n    return dict2\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa_ndkqm__test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa_ndkqm__test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpa_ndkqm__test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    // Create a slice of tuples.\n    var tuples [][]interface{}\n    // Iterate over the dictionary.\n    for key, value := range dict1 {\n        // Append the tuple to the slice.\n        tuples = append(tuples, []interface{}{key, value})\n    }\n    // Sort the slice of tuples.\n    for i := 0; i < len(tuples); i++ {\n        for j := i + 1; j < len(tuples); j++ {\n            if tuples[i][1].(int) < tuples[j][1].(int) {\n                tuples[i], tuples[j] = tuples[j], tuples[i]\n            }\n        }\n    }\n    // Return the slice of tuples.\n    return tuples\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122497,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var keys []string\n    for key := range dict1 {\n        keys = append(keys, key)\n    }\n    var sorted_dict [][]interface{}\n    for _, key := range keys {\n        sorted_dict = append(sorted_dict, []interface{}{key, dict1[key]})\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122543,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptwnqekos_test.go:28:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptwnqekos_test.go:29:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmptwnqekos_test.go:30:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for key, value := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{key, value})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi2l95szj_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmpi2l95szj_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var result [][]interface{}\n    for key, value := range dict1 {\n        result = append(result, []interface{}{key, value})\n    }\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][1].(int) < result[j][1].(int) {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122527,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package sort_counter_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1 map[string]int) [][]interface{} {\n    var sorted_dict [][]interface{}\n    for k, v := range dict1 {\n        sorted_dict = append(sorted_dict, []interface{}{k, v})\n    }\n    for i := 0; i < len(sorted_dict); i++ {\n        for j := i + 1; j < len(sorted_dict); j++ {\n            if sorted_dict[i][1].(int) < sorted_dict[j][1].(int) {\n                sorted_dict[i], sorted_dict[j] = sorted_dict[j], sorted_dict[i]\n            }\n        }\n    }\n    return sorted_dict\n}\n\nfunc TestSort_Counter(t *testing.T) {\n  candidate := sort_counter\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(map[string]int{\"Math\": 81, \"Physics\": 83, \"Chemistry\": 87}), expected: [][]int{[]interface{}{\"Chemistry\", 87}, []interface{}{\"Physics\", 83}, []interface{}{\"Math\", 81}} },\n     { actual: candidate(map[string]int{\"Math\": 400, \"Physics\": 300, \"Chemistry\": 250}), expected: [][]int{[]interface{}{\"Math\", 400}, []interface{}{\"Physics\", 300}, []interface{}{\"Chemistry\", 250}} },\n     { actual: candidate(map[string]int{\"Math\": 900, \"Physics\": 1000, \"Chemistry\": 1250}), expected: [][]int{[]interface{}{\"Chemistry\", 1250}, []interface{}{\"Physics\", 1000}, []interface{}{\"Math\", 900}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665509987,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2nnh3fkm_test.go:31:118: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:32:121: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n/tmp/tmp2nnh3fkm_test.go:33:123: cannot use []interface {}{...} (type []interface {}) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    }
  ]
}