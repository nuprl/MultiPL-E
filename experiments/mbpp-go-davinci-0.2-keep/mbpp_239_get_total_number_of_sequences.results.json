{
  "name": "mbpp_239_get_total_number_of_sequences",
  "language": "go_test.go",
  "prompt": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_239_get_total_number_of_sequences.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54625e, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x1, 0x0)\n\t/tmp/tmpvfj2qxsh_test.go:9 +0x9b fp=0xc020160390 sp=0xc020160388 pc=0x50a69b\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x2, 0xffffffffff55557e)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x58 fp=0xc0201603c0 sp=0xc020160390 pc=0x50a658\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557e, 0x2, 0xffffffffff55557f)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201603f0 sp=0xc0201603c0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557f, 0x2, 0xffffffffff555580)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160420 sp=0xc0201603f0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555580, 0x2, 0xffffffffff555581)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160450 sp=0xc020160420 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555581, 0x2, 0xffffffffff555582)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160480 sp=0xc020160450 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555582, 0x2, 0xffffffffff555583)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604b0 sp=0xc020160480 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555583, 0x2, 0xffffffffff555584)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604e0 sp=0xc0201604b0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555584, 0x2, 0xffffffffff555585)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 1, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=4)', got '%!s(int=6480)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m - 1, n) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp7ok5fxsa_test.go:34: expected '%!s(int=4)', got '%!s(int=362880)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp7ok5fxsa_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp7ok5fxsa_test.go:34: expected '%!s(int=84)', got '%!s(int=50400)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 1, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=4)', got '%!s(int=6480)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m-1, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmph23s941i_test.go:31: expected '%!s(int=4)', got '%!s(int=68)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmph23s941i_test.go:31: expected '%!s(int=6)', got '%!s(int=9)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmph23s941i_test.go:31: expected '%!s(int=84)', got '%!s(int=60)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54625e, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x1, 0x0)\n\t/tmp/tmpvfj2qxsh_test.go:9 +0x9b fp=0xc020160390 sp=0xc020160388 pc=0x50a69b\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x2, 0xffffffffff55557e)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x58 fp=0xc0201603c0 sp=0xc020160390 pc=0x50a658\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557e, 0x2, 0xffffffffff55557f)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201603f0 sp=0xc0201603c0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557f, 0x2, 0xffffffffff555580)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160420 sp=0xc0201603f0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555580, 0x2, 0xffffffffff555581)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160450 sp=0xc020160420 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555581, 0x2, 0xffffffffff555582)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160480 sp=0xc020160450 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555582, 0x2, 0xffffffffff555583)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604b0 sp=0xc020160480 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555583, 0x2, 0xffffffffff555584)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604e0 sp=0xc0201604b0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555584, 0x2, 0xffffffffff555585)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m + 1) / 2\n    }\n    if n == 3 {\n        return m * (m + 1) * (m + 2) / 6\n    }\n    return m * (m + 1) * (m + 2) / 6 * (m + 3) / 4\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_racspn1_test.go:37: expected '%!s(int=4)', got '%!s(int=715)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_racspn1_test.go:37: expected '%!s(int=6)', got '%!s(int=15)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_racspn1_test.go:37: expected '%!s(int=84)', got '%!s(int=816)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 1, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=4)', got '%!s(int=6480)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=4)', got '%!s(int=68)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=6)', got '%!s(int=9)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=84)', got '%!s(int=60)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return (m * (m + 1)) / 2\n    }\n    return (m * (m + 1) * (m + 2)) / 6\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122767,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmph5qsfg0k_test.go:37: expected '%!s(int=4)', got '%!s(int=220)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmph5qsfg0k_test.go:37: expected '%!s(int=6)', got '%!s(int=15)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmph5qsfg0k_test.go:37: expected '%!s(int=84)', got '%!s(int=816)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m - 1, n) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    // Write your code here\n    return 0\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=84)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122767,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpnnwcisc__test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpnnwcisc__test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpnnwcisc__test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m + 1) / 2\n    }\n    return m * (m + 1) / 2 * get_total_number_of_sequences(m, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpgeeshu73_test.go:34: expected '%!s(int=4)', got '%!s(int=166375)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpgeeshu73_test.go:34: expected '%!s(int=6)', got '%!s(int=15)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpgeeshu73_test.go:34: expected '%!s(int=84)', got '%!s(int=18496)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54625e, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x1, 0x0)\n\t/tmp/tmpvfj2qxsh_test.go:9 +0x9b fp=0xc020160390 sp=0xc020160388 pc=0x50a69b\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x2, 0xffffffffff55557e)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x58 fp=0xc0201603c0 sp=0xc020160390 pc=0x50a658\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557e, 0x2, 0xffffffffff55557f)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201603f0 sp=0xc0201603c0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557f, 0x2, 0xffffffffff555580)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160420 sp=0xc0201603f0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555580, 0x2, 0xffffffffff555581)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160450 sp=0xc020160420 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555581, 0x2, 0xffffffffff555582)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160480 sp=0xc020160450 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555582, 0x2, 0xffffffffff555583)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604b0 sp=0xc020160480 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555583, 0x2, 0xffffffffff555584)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604e0 sp=0xc0201604b0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555584, 0x2, 0xffffffffff555585)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp7ok5fxsa_test.go:34: expected '%!s(int=4)', got '%!s(int=362880)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp7ok5fxsa_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp7ok5fxsa_test.go:34: expected '%!s(int=84)', got '%!s(int=50400)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp409cn4dz_test.go:31: expected '%!s(int=4)', got '%!s(int=7290)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp409cn4dz_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp409cn4dz_test.go:31: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if m < 2 || n < 1 {\n        return 0\n    }\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1) / 2\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122767,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpll7t3rgv_test.go:37: expected '%!s(int=4)', got '%!s(int=3240)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpll7t3rgv_test.go:37: expected '%!s(int=6)', got '%!s(int=10)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpll7t3rgv_test.go:37: expected '%!s(int=84)', got '%!s(int=1800)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 2, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122763,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if m < 2 || n < 1 {\n        return 0\n    }\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpzr8z6163_test.go:34: expected '%!s(int=4)', got '%!s(int=31)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpzr8z6163_test.go:34: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpzr8z6163_test.go:34: expected '%!s(int=84)', got '%!s(int=36)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 1, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=4)', got '%!s(int=6480)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n\n    if m == 0 {\n        return 0\n    }\n\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122767,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp2t8tox16_test.go:36: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp2t8tox16_test.go:36: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp2t8tox16_test.go:36: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp409cn4dz_test.go:31: expected '%!s(int=4)', got '%!s(int=7290)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp409cn4dz_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp409cn4dz_test.go:31: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54625e, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x1, 0x0)\n\t/tmp/tmpvfj2qxsh_test.go:9 +0x9b fp=0xc020160390 sp=0xc020160388 pc=0x50a69b\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x2, 0xffffffffff55557e)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x58 fp=0xc0201603c0 sp=0xc020160390 pc=0x50a658\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557e, 0x2, 0xffffffffff55557f)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201603f0 sp=0xc0201603c0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557f, 0x2, 0xffffffffff555580)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160420 sp=0xc0201603f0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555580, 0x2, 0xffffffffff555581)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160450 sp=0xc020160420 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555581, 0x2, 0xffffffffff555582)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160480 sp=0xc020160450 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555582, 0x2, 0xffffffffff555583)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604b0 sp=0xc020160480 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555583, 0x2, 0xffffffffff555584)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604e0 sp=0xc0201604b0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555584, 0x2, 0xffffffffff555585)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m - 1, n) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if m <= 2 {\n        return 1\n    }\n    return get_total_number_of_sequences(m - 1, n - 1) + get_total_number_of_sequences(m - 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122767,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpp8gnuzmy_test.go:34: expected '%!s(int=4)', got '%!s(int=44)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpp8gnuzmy_test.go:34: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpp8gnuzmy_test.go:34: expected '%!s(int=84)', got '%!s(int=52)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m-1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122769,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54625e, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x1, 0x0)\n\t/tmp/tmp9k7ecjc9_test.go:9 +0x9b fp=0xc020160390 sp=0xc020160388 pc=0x50a69b\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x2, 0xffffffffff55557e)\n\t/tmp/tmp9k7ecjc9_test.go:13 +0x58 fp=0xc0201603c0 sp=0xc020160390 pc=0x50a658\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557e, 0x2, 0xffffffffff55557f)\n\t/tmp/tmp9k7ecjc9_test.go:13 +0x7d fp=0xc0201603f0 sp=0xc0201603c0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557f, 0x2, 0xffffffffff555580)\n\t/tmp/tmp9k7ecjc9_test.go:13 +0x7d fp=0xc020160420 sp=0xc0201603f0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555580, 0x2, 0xffffffffff555581)\n\t/tmp/tmp9k7ecjc9_test.go:13 +0x7d fp=0xc020160450 sp=0xc020160420 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555581, 0x2, 0xffffffffff555582)\n\t/tmp/tmp9k7ecjc9_test.go:13 +0x7d fp=0xc020160480 sp=0xc020160450 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555582, 0x2, 0xffffffffff555583)\n\t/tmp/tmp9k7ecjc9_test.go:13 +0x7d fp=0xc0201604b0 sp=0xc020160480 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555583, 0x2, 0xffffffffff555584)\n\t/tmp/tmp9k7ecjc9_test.go:13 +0x7d fp=0xc0201604e0 sp=0xc0201604b0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555584, 0x2, 0xffffffffff555585)\n\t/tmp/tmp9k7ecjc9_test.go:13 +0x7d fp=0x",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 1, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=4)', got '%!s(int=6480)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 1, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=4)', got '%!s(int=6480)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54625e, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x1, 0x0)\n\t/tmp/tmpvfj2qxsh_test.go:9 +0x9b fp=0xc020160390 sp=0xc020160388 pc=0x50a69b\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x2, 0xffffffffff55557e)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x58 fp=0xc0201603c0 sp=0xc020160390 pc=0x50a658\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557e, 0x2, 0xffffffffff55557f)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201603f0 sp=0xc0201603c0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557f, 0x2, 0xffffffffff555580)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160420 sp=0xc0201603f0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555580, 0x2, 0xffffffffff555581)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160450 sp=0xc020160420 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555581, 0x2, 0xffffffffff555582)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160480 sp=0xc020160450 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555582, 0x2, 0xffffffffff555583)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604b0 sp=0xc020160480 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555583, 0x2, 0xffffffffff555584)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604e0 sp=0xc0201604b0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555584, 0x2, 0xffffffffff555585)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m - n + 1\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122767,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpeeftxl9__test.go:31: expected '%!s(int=4)', got '%!s(int=7)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpeeftxl9__test.go:31: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpeeftxl9__test.go:31: expected '%!s(int=84)', got '%!s(int=14)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if m == 1 {\n        return 1\n    }\n    return get_total_number_of_sequences(m - 1, n) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_5jf7xwn_test.go:34: expected '%!s(int=4)', got '%!s(int=30)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_5jf7xwn_test.go:34: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_5jf7xwn_test.go:34: expected '%!s(int=84)', got '%!s(int=100)'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 1, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=4)', got '%!s(int=6480)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp409cn4dz_test.go:31: expected '%!s(int=4)', got '%!s(int=7290)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp409cn4dz_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp409cn4dz_test.go:31: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122767,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpev40mzqb_test.go:34: expected '%!s(int=4)', got '%!s(int=68)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpev40mzqb_test.go:34: expected '%!s(int=6)', got '%!s(int=9)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpev40mzqb_test.go:34: expected '%!s(int=84)', got '%!s(int=60)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54625e, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x1, 0x0)\n\t/tmp/tmpvfj2qxsh_test.go:9 +0x9b fp=0xc020160390 sp=0xc020160388 pc=0x50a69b\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x2, 0xffffffffff55557e)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x58 fp=0xc0201603c0 sp=0xc020160390 pc=0x50a658\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557e, 0x2, 0xffffffffff55557f)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201603f0 sp=0xc0201603c0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557f, 0x2, 0xffffffffff555580)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160420 sp=0xc0201603f0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555580, 0x2, 0xffffffffff555581)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160450 sp=0xc020160420 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555581, 0x2, 0xffffffffff555582)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160480 sp=0xc020160450 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555582, 0x2, 0xffffffffff555583)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604b0 sp=0xc020160480 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555583, 0x2, 0xffffffffff555584)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604e0 sp=0xc0201604b0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555584, 0x2, 0xffffffffff555585)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122764,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpe57m81z__test.go:34: expected '%!s(int=4)', got '%!s(int=715)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpe57m81z__test.go:34: expected '%!s(int=6)', got '%!s(int=15)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpe57m81z__test.go:34: expected '%!s(int=84)', got '%!s(int=816)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122764,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpe57m81z__test.go:34: expected '%!s(int=4)', got '%!s(int=715)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpe57m81z__test.go:34: expected '%!s(int=6)', got '%!s(int=15)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpe57m81z__test.go:34: expected '%!s(int=84)', got '%!s(int=816)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 2, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122763,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54625e, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x1, 0x0)\n\t/tmp/tmpvfj2qxsh_test.go:9 +0x9b fp=0xc020160390 sp=0xc020160388 pc=0x50a69b\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x2, 0xffffffffff55557e)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x58 fp=0xc0201603c0 sp=0xc020160390 pc=0x50a658\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557e, 0x2, 0xffffffffff55557f)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201603f0 sp=0xc0201603c0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557f, 0x2, 0xffffffffff555580)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160420 sp=0xc0201603f0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555580, 0x2, 0xffffffffff555581)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160450 sp=0xc020160420 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555581, 0x2, 0xffffffffff555582)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160480 sp=0xc020160450 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555582, 0x2, 0xffffffffff555583)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604b0 sp=0xc020160480 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555583, 0x2, 0xffffffffff555584)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604e0 sp=0xc0201604b0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555584, 0x2, 0xffffffffff555585)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m-1, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmph23s941i_test.go:31: expected '%!s(int=4)', got '%!s(int=68)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmph23s941i_test.go:31: expected '%!s(int=6)', got '%!s(int=9)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmph23s941i_test.go:31: expected '%!s(int=84)', got '%!s(int=60)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m - 1, n) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    result := 0\n    for i := 2; i <= m; i++ {\n        result += get_total_number_of_sequences(i, n - 1)\n    }\n    return result\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122767,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmptxnl5a_6_test.go:35: expected '%!s(int=4)', got '%!s(int=660)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmptxnl5a_6_test.go:35: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmptxnl5a_6_test.go:35: expected '%!s(int=84)', got '%!s(int=800)'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 1, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=4)', got '%!s(int=6480)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n\n    return get_total_number_of_sequences(m, n - 1) * (m - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp643x2ku2_test.go:32: expected '%!s(int=4)', got '%!s(int=7290)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp643x2ku2_test.go:32: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp643x2ku2_test.go:32: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m + 1) / 2\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m + n - 1) / n\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122767,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmptv6lac5k_test.go:34: expected '%!s(int=4)', got '%!s(int=715)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmptv6lac5k_test.go:34: expected '%!s(int=6)', got '%!s(int=15)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmptv6lac5k_test.go:34: expected '%!s(int=84)', got '%!s(int=816)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=4)', got '%!s(int=68)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=6)', got '%!s(int=9)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=84)', got '%!s(int=60)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m + 1) / 2\n    }\n    return m * (m + 1) / 2 * get_total_number_of_sequences(m, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpgeeshu73_test.go:34: expected '%!s(int=4)', got '%!s(int=166375)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpgeeshu73_test.go:34: expected '%!s(int=6)', got '%!s(int=15)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpgeeshu73_test.go:34: expected '%!s(int=84)', got '%!s(int=18496)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m - 1, n) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54625e, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x1, 0x0)\n\t/tmp/tmpvfj2qxsh_test.go:9 +0x9b fp=0xc020160390 sp=0xc020160388 pc=0x50a69b\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x2, 0xffffffffff55557e)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x58 fp=0xc0201603c0 sp=0xc020160390 pc=0x50a658\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557e, 0x2, 0xffffffffff55557f)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201603f0 sp=0xc0201603c0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557f, 0x2, 0xffffffffff555580)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160420 sp=0xc0201603f0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555580, 0x2, 0xffffffffff555581)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160450 sp=0xc020160420 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555581, 0x2, 0xffffffffff555582)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160480 sp=0xc020160450 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555582, 0x2, 0xffffffffff555583)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604b0 sp=0xc020160480 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555583, 0x2, 0xffffffffff555584)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604e0 sp=0xc0201604b0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555584, 0x2, 0xffffffffff555585)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=4)', got '%!s(int=68)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=6)', got '%!s(int=9)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=84)', got '%!s(int=60)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    // Write your code here\n    return 0\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=84)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp409cn4dz_test.go:31: expected '%!s(int=4)', got '%!s(int=7290)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp409cn4dz_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp409cn4dz_test.go:31: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n\n    if m == 0 {\n        return 0\n    }\n\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122767,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp2t8tox16_test.go:36: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp2t8tox16_test.go:36: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp2t8tox16_test.go:36: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m < 2 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmptt22a5e5_test.go:34: expected '%!s(int=4)', got '%!s(int=14)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmptt22a5e5_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmptt22a5e5_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1) / 2\n    }\n    return m * (m - 1) * (m - 2) / 6\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122767,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpo_bsfb6d_test.go:34: expected '%!s(int=4)', got '%!s(int=120)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpo_bsfb6d_test.go:34: expected '%!s(int=6)', got '%!s(int=10)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpo_bsfb6d_test.go:34: expected '%!s(int=84)', got '%!s(int=560)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n\n    if n == 2 {\n        return m * (m + 1) / 2\n    }\n\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122767,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpp5jh1_jl_test.go:36: expected '%!s(int=4)', got '%!s(int=120)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpp5jh1_jl_test.go:36: expected '%!s(int=6)', got '%!s(int=15)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpp5jh1_jl_test.go:36: expected '%!s(int=84)', got '%!s(int=152)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=4)', got '%!s(int=68)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=6)', got '%!s(int=9)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=84)', got '%!s(int=60)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122764,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp8pbx5fu0_test.go:32: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp8pbx5fu0_test.go:32: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp8pbx5fu0_test.go:32: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - 2 * n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122767,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpfb5lpgg5_test.go:34: expected '%!s(int=4)', got '%!s(int=2160)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpfb5lpgg5_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpfb5lpgg5_test.go:34: expected '%!s(int=84)', got '%!s(int=2880)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m - 1, n) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122764,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp8pbx5fu0_test.go:32: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp8pbx5fu0_test.go:32: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp8pbx5fu0_test.go:32: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122767,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp765bjt3q_test.go:31: expected '%!s(int=4)', got '%!s(int=32)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp765bjt3q_test.go:31: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp765bjt3q_test.go:31: expected '%!s(int=84)', got '%!s(int=36)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122767,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp765bjt3q_test.go:31: expected '%!s(int=4)', got '%!s(int=32)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp765bjt3q_test.go:31: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp765bjt3q_test.go:31: expected '%!s(int=84)', got '%!s(int=36)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122767,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp7oc52v2g_test.go:34: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp7oc52v2g_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp7oc52v2g_test.go:34: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return (m - 1) * get_total_number_of_sequences(m - 1, n - 1) + (m - 2) * get_total_number_of_sequences(m - 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122767,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp7c50p5l1_test.go:34: expected '%!s(int=4)', got '%!s(int=10470)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp7c50p5l1_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp7c50p5l1_test.go:34: expected '%!s(int=84)', got '%!s(int=5698)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    total := 0\n    for i := 2; i <= m; i++ {\n        total += get_total_number_of_sequences(i - 1, n - 1)\n    }\n    return total\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122767,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpqv5hcgow_test.go:35: expected '%!s(int=4)', got '%!s(int=210)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpqv5hcgow_test.go:35: expected '%!s(int=6)', got '%!s(int=10)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpqv5hcgow_test.go:35: expected '%!s(int=84)', got '%!s(int=560)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp7ok5fxsa_test.go:34: expected '%!s(int=4)', got '%!s(int=362880)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp7ok5fxsa_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp7ok5fxsa_test.go:34: expected '%!s(int=84)', got '%!s(int=50400)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - (n - 1))\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmprnjdopok_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmprnjdopok_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmprnjdopok_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=4)', got '%!s(int=68)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=6)', got '%!s(int=9)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=84)', got '%!s(int=60)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpb5d185el_test.go:32: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpb5d185el_test.go:32: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpb5d185el_test.go:32: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m-1, n) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122767,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=4)', got '%!s(int=68)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=6)', got '%!s(int=9)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=84)', got '%!s(int=60)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m-1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122769,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54625e, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x1, 0x0)\n\t/tmp/tmp9k7ecjc9_test.go:9 +0x9b fp=0xc020160390 sp=0xc020160388 pc=0x50a69b\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x2, 0xffffffffff55557e)\n\t/tmp/tmp9k7ecjc9_test.go:13 +0x58 fp=0xc0201603c0 sp=0xc020160390 pc=0x50a658\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557e, 0x2, 0xffffffffff55557f)\n\t/tmp/tmp9k7ecjc9_test.go:13 +0x7d fp=0xc0201603f0 sp=0xc0201603c0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557f, 0x2, 0xffffffffff555580)\n\t/tmp/tmp9k7ecjc9_test.go:13 +0x7d fp=0xc020160420 sp=0xc0201603f0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555580, 0x2, 0xffffffffff555581)\n\t/tmp/tmp9k7ecjc9_test.go:13 +0x7d fp=0xc020160450 sp=0xc020160420 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555581, 0x2, 0xffffffffff555582)\n\t/tmp/tmp9k7ecjc9_test.go:13 +0x7d fp=0xc020160480 sp=0xc020160450 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555582, 0x2, 0xffffffffff555583)\n\t/tmp/tmp9k7ecjc9_test.go:13 +0x7d fp=0xc0201604b0 sp=0xc020160480 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555583, 0x2, 0xffffffffff555584)\n\t/tmp/tmp9k7ecjc9_test.go:13 +0x7d fp=0xc0201604e0 sp=0xc0201604b0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555584, 0x2, 0xffffffffff555585)\n\t/tmp/tmp9k7ecjc9_test.go:13 +0x7d fp=0x",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122767,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpg1ujcsvw_test.go:34: expected '%!s(int=4)', got '%!s(int=68)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpg1ujcsvw_test.go:34: expected '%!s(int=6)', got '%!s(int=9)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpg1ujcsvw_test.go:34: expected '%!s(int=84)', got '%!s(int=60)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 1, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=4)', got '%!s(int=6480)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m + 1) / 2\n    }\n    return m * (m + 1) / 2 * get_total_number_of_sequences(m, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpgeeshu73_test.go:34: expected '%!s(int=4)', got '%!s(int=166375)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpgeeshu73_test.go:34: expected '%!s(int=6)', got '%!s(int=15)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpgeeshu73_test.go:34: expected '%!s(int=84)', got '%!s(int=18496)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54625e, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x1, 0x0)\n\t/tmp/tmpvfj2qxsh_test.go:9 +0x9b fp=0xc020160390 sp=0xc020160388 pc=0x50a69b\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x2, 0xffffffffff55557e)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x58 fp=0xc0201603c0 sp=0xc020160390 pc=0x50a658\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557e, 0x2, 0xffffffffff55557f)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201603f0 sp=0xc0201603c0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557f, 0x2, 0xffffffffff555580)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160420 sp=0xc0201603f0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555580, 0x2, 0xffffffffff555581)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160450 sp=0xc020160420 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555581, 0x2, 0xffffffffff555582)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160480 sp=0xc020160450 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555582, 0x2, 0xffffffffff555583)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604b0 sp=0xc020160480 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555583, 0x2, 0xffffffffff555584)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604e0 sp=0xc0201604b0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555584, 0x2, 0xffffffffff555585)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return (m - 1) * (get_total_number_of_sequences(m - 1, n - 1) + get_total_number_of_sequences(m - 2, n - 1))\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpt6j4pmgv_test.go:34: expected '%!s(int=4)', got '%!s(int=11592)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpt6j4pmgv_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpt6j4pmgv_test.go:34: expected '%!s(int=84)', got '%!s(int=5880)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n\n    return get_total_number_of_sequences(m, n - 1) * (m - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp643x2ku2_test.go:32: expected '%!s(int=4)', got '%!s(int=7290)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp643x2ku2_test.go:32: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp643x2ku2_test.go:32: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 2, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122763,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n\n    if m == 0 {\n        return 0\n    }\n\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122767,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpl4ijk3ng_test.go:36: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpl4ijk3ng_test.go:36: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpl4ijk3ng_test.go:36: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 2, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122763,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_qwv3oxo_test.go:34: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=4)', got '%!s(int=68)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=6)', got '%!s(int=9)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpi9fb6tjn_test.go:31: expected '%!s(int=84)', got '%!s(int=60)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m - 1, n) + get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122767,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpeghn7x1n_test.go:34: expected '%!s(int=4)', got '%!s(int=210)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpeghn7x1n_test.go:34: expected '%!s(int=6)', got '%!s(int=10)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpeghn7x1n_test.go:34: expected '%!s(int=84)', got '%!s(int=560)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122764,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpe57m81z__test.go:34: expected '%!s(int=4)', got '%!s(int=715)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpe57m81z__test.go:34: expected '%!s(int=6)', got '%!s(int=15)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpe57m81z__test.go:34: expected '%!s(int=84)', got '%!s(int=816)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n-1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122764,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpfpg53yzv_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpfpg53yzv_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpfpg53yzv_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    // Write your code here\n    return 0\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=84)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n\n    if m == 0 {\n        return 0\n    }\n\n    return get_total_number_of_sequences(m - 1, n) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122767,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpzan7op29_test.go:34: expected '%!s(int=4)', got '%!s(int=6480)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpzan7op29_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpzan7op29_test.go:34: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m - 1, n) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122767,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp765bjt3q_test.go:31: expected '%!s(int=4)', got '%!s(int=32)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp765bjt3q_test.go:31: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp765bjt3q_test.go:31: expected '%!s(int=84)', got '%!s(int=36)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m - 1, n) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m - 1, n) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return (m - 1) * (get_total_number_of_sequences(m - 1, n - 1) + get_total_number_of_sequences(m - 1, n - 2))\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122767,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx06hcxmo_test.go:34: expected '%!s(int=4)', got '%!s(int=5256)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx06hcxmo_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx06hcxmo_test.go:34: expected '%!s(int=84)', got '%!s(int=3375)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp7ok5fxsa_test.go:34: expected '%!s(int=4)', got '%!s(int=362880)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp7ok5fxsa_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp7ok5fxsa_test.go:34: expected '%!s(int=84)', got '%!s(int=50400)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    // Write your code here\n    return 0\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=84)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if m < 2 || n < 1 {\n        return 0\n    }\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpzr8z6163_test.go:34: expected '%!s(int=4)', got '%!s(int=31)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpzr8z6163_test.go:34: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpzr8z6163_test.go:34: expected '%!s(int=84)', got '%!s(int=36)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n-1) + get_total_number_of_sequences(m/2, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpy825a12r_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    // Write your code here\n    return 0\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp2c9rlis4_test.go:29: expected '%!s(int=84)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if m == 0 {\n        return 0\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m / 2, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=4)', got '%!s(int=16)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=6)', got '%!s(int=4)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpx7uk2kdw_test.go:34: expected '%!s(int=84)', got '%!s(int=8)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m + 1) / 2\n    }\n    return m * (m + 1) / 2 * get_total_number_of_sequences(m, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122762,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpgeeshu73_test.go:34: expected '%!s(int=4)', got '%!s(int=166375)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpgeeshu73_test.go:34: expected '%!s(int=6)', got '%!s(int=15)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpgeeshu73_test.go:34: expected '%!s(int=84)', got '%!s(int=18496)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122768,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpwiqyk88p_test.go:34: expected '%!s(int=4)', got '%!s(int=32)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpwiqyk88p_test.go:34: expected '%!s(int=84)', got '%!s(int=33)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=4)', got '%!s(int=7200)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=6)', got '%!s(int=25)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp_y02yath_test.go:31: expected '%!s(int=84)', got '%!s(int=3840)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m - 1, n)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510130,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160380 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54625e, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x1, 0x0)\n\t/tmp/tmpvfj2qxsh_test.go:9 +0x9b fp=0xc020160390 sp=0xc020160388 pc=0x50a69b\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557d, 0x2, 0xffffffffff55557e)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x58 fp=0xc0201603c0 sp=0xc020160390 pc=0x50a658\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557e, 0x2, 0xffffffffff55557f)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201603f0 sp=0xc0201603c0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff55557f, 0x2, 0xffffffffff555580)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160420 sp=0xc0201603f0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555580, 0x2, 0xffffffffff555581)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160450 sp=0xc020160420 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555581, 0x2, 0xffffffffff555582)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc020160480 sp=0xc020160450 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555582, 0x2, 0xffffffffff555583)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604b0 sp=0xc020160480 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555583, 0x2, 0xffffffffff555584)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc0201604e0 sp=0xc0201604b0 pc=0x50a67d\ncommand-line-arguments_test.get_total_number_of_sequences(0xffffffffff555584, 0x2, 0xffffffffff555585)\n\t/tmp/tmpvfj2qxsh_test.go:13 +0x7d fp=0xc",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m-1, n-1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122768,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpgymgrn7m_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpgymgrn7m_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpgymgrn7m_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    return m * get_total_number_of_sequences(m - 1, n - 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp9vhnm2pr_test.go:31: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return get_total_number_of_sequences(m, n - 1) * (m - n + 1)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122767,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmp7oc52v2g_test.go:34: expected '%!s(int=4)', got '%!s(int=5040)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmp7oc52v2g_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmp7oc52v2g_test.go:34: expected '%!s(int=84)', got '%!s(int=3360)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_total_number_of_sequences_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m int, n int) int {\n    if n == 1 {\n        return m\n    }\n    if n == 2 {\n        return m * (m - 1)\n    }\n    return m * (m - 1) * get_total_number_of_sequences(m - 1, n - 2)\n}\n\nfunc TestGet_Total_Number_Of_Sequences(t *testing.T) {\n  candidate := get_total_number_of_sequences\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(10, 4), expected: 4 },\n     { actual: candidate(5, 2), expected: 6 },\n     { actual: candidate(16, 3), expected: 84 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510129,
      "stdout": "--- FAIL: TestGet_Total_Number_Of_Sequences (0.00s)\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__0 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=4)', got '%!s(int=6480)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__1 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=6)', got '%!s(int=20)'\n    --- FAIL: TestGet_Total_Number_Of_Sequences/test_num__2 (0.00s)\n        tmpedlawvkq_test.go:34: expected '%!s(int=84)', got '%!s(int=3600)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}