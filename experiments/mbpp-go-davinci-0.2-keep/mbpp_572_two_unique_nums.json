{
  "name": "mbpp_572_two_unique_nums",
  "language": "go_test.go",
  "prompt": "package two_unique_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function to remove duplicate numbers from a given number of lists.\nfunc two_unique_nums(nums []int) []int {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_572_two_unique_nums.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestTwo_Unique_Nums(t *testing.T) {\n  candidate := two_unique_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 2, 3, 4, 5}), expected: []int{1, 4, 5} },\n     { actual: candidate([]int{1, 2, 3, 2, 4, 5}), expected: []int{1, 3, 4, 5} },\n     { actual: candidate([]int{1, 2, 3, 4, 5}), expected: []int{1, 2, 3, 4, 5} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    // Create a map to store the number of times a number appears in the list.\n    num_map := make(map[int]int)\n\n    // Iterate through the list and add the number to the map.\n    for _, num := range nums {\n        num_map[num]++\n    }\n\n    // Create a list to store the unique numbers.\n    unique_nums := make([]int, 0)\n\n    // Iterate through the map and add the unique numbers to the list.\n    for num, count := range num_map {\n        if count == 1 {\n            unique_nums = append(unique_nums, num)\n        }\n    }\n\n    return unique_nums\n}\n",
    "    var result []int\n    for _, num := range nums {\n        if len(result) == 0 {\n            result = append(result, num)\n        } else if num != result[len(result)-1] {\n            result = append(result, num)\n        }\n    }\n    return result\n}\n",
    "    // TODO: Implement me!\n    return []int{}\n}\n",
    "    var result []int\n    var seen = make(map[int]bool)\n\n    for _, num := range nums {\n        if _, ok := seen[num]; !ok {\n            seen[num] = true\n            result = append(result, num)\n        }\n    }\n\n    return result\n}\n",
    "    var unique_nums []int\n    for _, num := range nums {\n        if !contains(unique_nums, num) {\n            unique_nums = append(unique_nums, num)\n        }\n    }\n    return unique_nums\n}\n",
    "    // map to store the number of times each number appears\n    num_map := make(map[int]int)\n    for _, num := range nums {\n        num_map[num] += 1\n    }\n\n    // iterate through the map and add the unique numbers to a slice\n    unique_nums := make([]int, 0)\n    for num, count := range num_map {\n        if count == 1 {\n            unique_nums = append(unique_nums, num)\n        }\n    }\n\n    return unique_nums\n}\n",
    "    var unique_nums []int\n    for _, num := range nums {\n        if !contains(unique_nums, num) {\n            unique_nums = append(unique_nums, num)\n        }\n    }\n    return unique_nums\n}\n",
    "    // map to store the count of each number\n    num_counts := make(map[int]int)\n    for _, num := range nums {\n        num_counts[num]++\n    }\n\n    // get the unique numbers\n    unique_nums := []int{}\n    for num, count := range num_counts {\n        if count == 1 {\n            unique_nums = append(unique_nums, num)\n        }\n    }\n\n    return unique_nums\n}\n",
    "    var unique_nums []int\n    for _, num := range nums {\n        if !contains(unique_nums, num) {\n            unique_nums = append(unique_nums, num)\n        }\n    }\n    return unique_nums\n}\n",
    "    var result []int\n    var m = make(map[int]int)\n    for _, v := range nums {\n        m[v]++\n    }\n    for k, v := range m {\n        if v == 1 {\n            result = append(result, k)\n        }\n    }\n    return result\n}\n",
    "    var result []int\n    for _, num := range nums {\n        if len(result) == 0 {\n            result = append(result, num)\n        } else {\n            if result[0] == num {\n                result = result[1:]\n            } else {\n                result = result[:1]\n            }\n        }\n    }\n    return result\n}\n",
    "    if len(nums) == 0 {\n        return []int{}\n    }\n    unique_nums := make([]int, 0)\n    for _, num := range nums {\n        if len(unique_nums) == 0 {\n            unique_nums = append(unique_nums, num)\n        } else {\n            is_unique := true\n            for _, unique_num := range unique_nums {\n                if num == unique_num {\n                    is_unique = false\n                    break\n                }\n            }\n            if is_unique {\n                unique_nums = append(unique_nums, num)\n            }\n        }\n    }\n    return unique_nums\n}\n",
    "    // create a map to store the number of times each number appears\n    num_map := make(map[int]int)\n    for _, num := range nums {\n        num_map[num]++\n    }\n\n    // create a slice to store the unique numbers\n    unique_nums := make([]int, 0)\n    for num, count := range num_map {\n        if count == 1 {\n            unique_nums = append(unique_nums, num)\n        }\n    }\n\n    return unique_nums\n}\n",
    "    var result []int\n    for _, num := range nums {\n        if len(result) == 0 {\n            result = append(result, num)\n        } else {\n            if result[0] != num {\n                result = append(result, num)\n                break\n            }\n        }\n    }\n    return result\n}\n",
    "    var unique_nums []int\n    for _, num := range nums {\n        if len(unique_nums) == 0 {\n            unique_nums = append(unique_nums, num)\n        } else {\n            found := false\n            for i, unique_num := range unique_nums {\n                if unique_num == num {\n                    found = true\n                    break\n                }\n                if i == len(unique_nums) - 1 {\n                    unique_nums = append(unique_nums, num)\n                }\n            }\n            if found {\n                continue\n            }\n        }\n    }\n    return unique_nums\n}\n",
    "    var result []int\n    for _, num := range nums {\n        if len(result) == 0 {\n            result = append(result, num)\n        } else if result[0] == num {\n            result = result[1:]\n        } else {\n            result = append(result, num)\n        }\n    }\n    return result\n}\n",
    "    var result []int\n    for _, num := range nums {\n        if len(result) == 0 {\n            result = append(result, num)\n        } else if result[0] != num {\n            result = append(result, num)\n            break\n        }\n    }\n    return result\n}\n",
    "    nums_map := make(map[int]int)\n    for _, num := range nums {\n        nums_map[num]++\n    }\n    var result []int\n    for num, count := range nums_map {\n        if count == 1 {\n            result = append(result, num)\n        }\n    }\n    return result\n}\n",
    "    unique_nums := []int{}\n    for _, num := range nums {\n        if !contains(unique_nums, num) {\n            unique_nums = append(unique_nums, num)\n        }\n    }\n    return unique_nums\n}\n",
    "    if len(nums) == 0 {\n        return nums\n    }\n    var unique_nums []int\n    var unique_num int\n    for _, num := range nums {\n        if unique_num == num {\n            continue\n        }\n        unique_nums = append(unique_nums, num)\n        unique_num = num\n    }\n    return unique_nums\n}\n"
  ]
}