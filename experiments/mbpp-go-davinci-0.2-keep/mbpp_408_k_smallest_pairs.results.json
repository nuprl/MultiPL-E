{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "go_test.go",
  "prompt": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    pairs := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            pairs = append(pairs, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(pairs); j++ {\n            if pairs[i][0] + pairs[i][1] > pairs[j][0] + pairs[j][1] {\n                pairs[i], pairs[j] = pairs[j], pairs[i]\n            }\n        }\n    }\n    return pairs[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510125,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var res [][]int\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return res\n    }\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n    heap_sort(heap)\n    for i := 0; i < k && i < len(heap); i++ {\n        res = append(res, heap[i])\n    }\n    return res\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510125,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaxmj84ec_test.go:20:5: undefined: heap_sort\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        index := 0\n        for j := 0; j < len(nums1); j++ {\n            for m := 0; m < len(nums2); m++ {\n                if nums1[j] + nums2[m] < min {\n                    min = nums1[j] + nums2[m]\n                    index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[index], nums2[0]})\n        nums1 = append(nums1[:index], nums1[index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510125,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008c670, 0x0, 0x3, 0xc00008c668, 0x1, 0x1, 0x7, 0xc00000c048, 0x1, 0x1)\n\t/tmp/tmp30ft6krc_test.go:18 +0x4bd\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmp30ft6krc_test.go:44 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return result\n    }\n\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    heap_sort(heap)\n\n    for i := 0; i < k; i++ {\n        result = append(result, heap[i])\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510125,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc9qxchfr_test.go:22:5: undefined: heap_sort\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n    for len(result) < k && len(queue) > 0 {\n        pair := queue[0]\n        queue = queue[1:]\n        result = append(result, []int{nums1[pair[0]], nums2[pair[1]]})\n        if pair[0] + 1 < len(nums1) {\n            queue = append(queue, []int{pair[0] + 1, pair[1], nums1[pair[0] + 1] + nums2[pair[1]]})\n        }\n        if pair[1] + 1 < len(nums2) {\n            queue = append(queue, []int{pair[0], pair[1] + 1, nums1[pair[0]] + nums2[pair[1] + 1]})\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510125,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpn7pcikc5_test.go:46: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpn7pcikc5_test.go:46: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := -1\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if min == -1 {\n                    min = nums1[j] + nums2[l]\n                    result = append(result, []int{nums1[j], nums2[l]})\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        result = append(result, []int{nums1[j], nums2[l]})\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510125,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpj94hczp4_test.go:51: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpj94hczp4_test.go:51: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min = -1\n        var min_index = -1\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                var found = false\n                for _, v := range result {\n                    if v[0] == nums1[j] && v[1] == nums2[l] {\n                        found = true\n                        break\n                    }\n                }\n                if found {\n                    continue\n                }\n                if min == -1 || nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510125,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp7f1ba46w_test.go:60: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp7f1ba46w_test.go:60: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] + nums2[0] < min {\n                min = nums1[j] + nums2[0]\n                min_index = j\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510125,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000086670, 0x0, 0x3, 0xc000086668, 0x0, 0x0, 0x7, 0xc00013e048, 0x1, 0x1)\n\t/tmp/tmptbbhbkua_test.go:28 +0x43e\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000102600)\n\t/tmp/tmptbbhbkua_test.go:44 +0x2d2\ntesting.tRunner(0xc000102600, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    var queue [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            queue = append(queue, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        min := 0\n        for j := 0; j < len(queue); j++ {\n            if queue[j][0] + queue[j][1] < queue[min][0] + queue[min][1] {\n                min = j\n            }\n        }\n        result = append(result, queue[min])\n        queue = append(queue[:min], queue[min+1:]...)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510125,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n    for len(result) < k && len(queue) > 0 {\n        var tmp []int\n        tmp, queue = queue[0], queue[1:]\n        result = append(result, []int{nums1[tmp[0]], nums2[tmp[1]]})\n\n        if tmp[0] + 1 < len(nums1) {\n            queue = append(queue, []int{tmp[0] + 1, tmp[1], nums1[tmp[0] + 1] + nums2[tmp[1]]})\n        }\n        if tmp[1] + 1 < len(nums2) {\n            queue = append(queue, []int{tmp[0], tmp[1] + 1, nums1[tmp[0]] + nums2[tmp[1] + 1]})\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510125,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpjpd571ib_test.go:48: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpjpd571ib_test.go:48: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        result = append(result, []int{nums1[0], nums2[0]})\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = []int{nums1[i], nums2[j]}\n                for m := k - 2; m >= 0; m-- {\n                    if result[m][0] + result[m][1] > result[m+1][0] + result[m+1][1] {\n                        result[m], result[m+1] = result[m+1], result[m]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510125,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpwnlap78w_test.go:56: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpwnlap78w_test.go:56: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510125,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if i < len(nums2) && nums1[j] + nums2[i] < nums1[min] + nums2[min_index] {\n                min = j\n                min_index = i\n            }\n            if i >= len(nums2) && nums1[j] + nums2[len(nums2) - 1] < nums1[min] + nums2[min_index] {\n                min = j\n                min_index = len(nums2) - 1\n            }\n        }\n        result = append(result, []int{nums1[min], nums2[min_index]})\n        nums1 = append(nums1[:min], nums1[min + 1:]...)\n        nums2 = append(nums2[:min_index], nums2[min_index + 1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510125,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008c670, 0x0, 0x3, 0xc00008c658, 0x0, 0x3, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmp9upr84ah_test.go:33 +0x5e5\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmp9upr84ah_test.go:49 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n    for len(result) < k && len(queue) > 0 {\n        var tmp []int\n        tmp, queue = queue[0], queue[1:]\n        result = append(result, []int{nums1[tmp[0]], nums2[tmp[1]]})\n\n        if tmp[0] + 1 < len(nums1) {\n            queue = append(queue, []int{tmp[0] + 1, tmp[1], nums1[tmp[0] + 1] + nums2[tmp[1]]})\n        }\n        if tmp[1] + 1 < len(nums2) {\n            queue = append(queue, []int{tmp[0], tmp[1] + 1, nums1[tmp[0]] + nums2[tmp[1] + 1]})\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510125,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpjpd571ib_test.go:48: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpjpd571ib_test.go:48: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    if len(result) < k {\n        return result\n    }\n\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510125,
      "stdout": "ok  \tcommand-line-arguments\t0.007s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    // init\n    var result [][]int\n    var heap [][]int\n    heap = append(heap, []int{nums1[0] + nums2[0], 0, 0})\n    visited := make([][]bool, len(nums1))\n    for i := 0; i < len(nums1); i++ {\n        visited[i] = make([]bool, len(nums2))\n    }\n    visited[0][0] = true\n\n    // heapify\n    for i := len(heap) / 2 - 1; i >= 0; i-- {\n        down(heap, i)\n    }\n\n    // pop\n    for i := 0; i < k && len(heap) > 0; i++ {\n        result = append(result, []int{heap[0][0], heap[0][1], heap[0][2]})\n        if heap[0][1] + 1 < len(nums1) && !visited[heap[0][1] + 1][heap[0][2]] {\n            heap = append(heap, []int{nums1[heap[0][1] + 1] + nums2[heap[0][2]], heap[0][1] + 1, heap[0][2]})\n            visited[heap[0][1] + 1][heap[0][2]] = true\n        }\n        if heap[0][2] + 1 < len(nums2) && !visited[heap[0][1]][heap[0][2] + 1] {\n            heap = append(heap, []int{nums1[heap[0][1]] + nums2[heap[0][2] + 1], heap[0][1], heap[0][2] + 1})\n            visited[heap[0][1]][heap[0][2] + 1] = true\n        }\n        heap[0], heap[len(heap) - 1] = heap[len(heap) -\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510124,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpi987312t_test.go:41:6: expected '(', found TestK_Smallest_Pairs\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if i == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_index = j * len(nums2) + l\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        min_index = j * len(nums2) + l\n                    }\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index / len(nums2)], nums2[min_index % len(nums2)]})\n        nums1[min_index / len(nums2)] = nums1[min_index / len(nums2)] + nums2[min_index % len(nums2)] + 1\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510125,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpvb795sku_test.go:57: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=7) %!s(int=6)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__1 (0.00s)\n        tmpvb795sku_test.go:57: expected '[[%!s(int=1) %!s(int=2)]]', got '[[%!s(int=7) %!s(int=6)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpvb795sku_test.go:57: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=7) %!s(int=6)] [%!s(int=1) %!s(int=2)] [%!s(int=4) %!s(int=2)] [%!s(int=7) %!s(int=2)] [%!s(int=10) %!s(int=2)] [%!s(int=13) %!s(int=2)] [%!s(int=16) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue = make([]*pair, 0)\n    var visited = make(map[int]bool)\n\n    var p = &pair{\n        i: 0,\n        j: 0,\n        sum: nums1[0] + nums2[0],\n    }\n    queue = append(queue, p)\n    visited[p.i * len(nums2) + p.j] = true\n\n    for len(result) < k && len(queue) > 0 {\n        p = queue[0]\n        queue = queue[1:]\n\n        result = append(result, []int{nums1[p.i], nums2[p.j]})\n\n        if p.i + 1 < len(nums1) && !visited[(p.i + 1) * len(nums2) + p.j] {\n            var p1 = &pair{\n                i: p.i + 1,\n                j: p.j,\n                sum: nums1[p.i + 1] + nums2[p.j],\n            }\n            queue = append(queue, p1)\n            visited[p1.i * len(nums2) + p1.j] = true\n        }\n\n        if p.j + 1 < len(nums2) && !visited[p.i * len(nums2) + p.j + 1] {\n            var p2 = &pair{\n                i: p.i,\n                j: p.j + 1,\n                sum: nums1[p.i] + nums2[p.j + 1],\n            }\n            queue = append(queue, p2)\n            visited[p2.i * len(nums2) + p2.j] = true\n        }\n\n        queue = sort(queue)\n    }\n\n    return result\n}\n\ntype pair \nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510124,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjopji7pk_test.go:58:11: expected type, found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_index := []int{0, 0}\n        for j := 0; j < len(nums1); j++ {\n            for m := 0; m < len(nums2); m++ {\n                if nums1[j] + nums2[m] < min {\n                    min = nums1[j] + nums2[m]\n                    min_index = []int{j, m}\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index[0]], nums2[min_index[1]]})\n        nums1 = append(nums1[:min_index[0]], nums1[min_index[0]+1:]...)\n        nums2 = append(nums2[:min_index[1]], nums2[min_index[1]+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510125,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008c670, 0x0, 0x3, 0xc00008c658, 0x0, 0x3, 0x7, 0xc00000c048, 0x1, 0x1)\n\t/tmp/tmpcxb1t2i4_test.go:18 +0x725\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmpcxb1t2i4_test.go:44 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        result = append(result, []int{nums1[0], nums2[0]})\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = []int{nums1[i], nums2[j]}\n                for l := k - 1; l > 0 && result[l][0]+result[l][1] < result[l-1][0]+result[l-1][1]; l-- {\n                    result[l], result[l-1] = result[l-1], result[l]\n                }\n            }\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510125,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpn_my_vnt_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpn_my_vnt_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    res := make([][]int, k)\n    for i := 0; i < k; i++ {\n        res[i] = []int{}\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if len(res[0]) == 0 || nums1[i] + nums2[j] < res[0][0] + res[0][1] {\n                res[0] = []int{nums1[i], nums2[j]}\n                for m := 0; m < k - 1; m++ {\n                    if len(res[m]) == 0 || len(res[m + 1]) == 0 {\n                        break\n                    }\n                    if res[m][0] + res[m][1] > res[m + 1][0] + res[m + 1][1] {\n                        res[m], res[m + 1] = res[m + 1], res[m]\n                    }\n                }\n            }\n        }\n    }\n    return res\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122973,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpgf_j_5b9_test.go:53: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] []]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpgf_j_5b9_test.go:53: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [] [] [] [] [] []]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    for i := 0; i < k; i++ {\n        var min int = nums1[0] + nums2[0]\n        var min_index []int\n        for j := 0; j < len(nums1); j++ {\n            for m := 0; m < len(nums2); m++ {\n                if nums1[j] + nums2[m] < min {\n                    min = nums1[j] + nums2[m]\n                    min_index = []int{j, m}\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index[0]], nums2[min_index[1]]})\n        nums1 = append(nums1[:min_index[0]], nums1[min_index[0]+1:]...)\n        nums2 = append(nums2[:min_index[1]], nums2[min_index[1]+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122973,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000092640, 0x3, 0x3, 0xc000092628, 0x3, 0x3, 0x2, 0x5826e3, 0xf, 0x0)\n\t/tmp/tmpvyz9wtjp_test.go:28 +0x6ac\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmpvyz9wtjp_test.go:42 +0xfb\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_i int\n        var min_j int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if min_i == j && min_j == l {\n                    continue\n                }\n                if min_i == -1 || nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        min_i = -1\n        min_j = -1\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122973,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpcs3r_erf_test.go:55: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpcs3r_erf_test.go:55: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    // TODO:\n    return nil\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122973,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpyqgrvlal_test.go:29: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__1 (0.00s)\n        tmpyqgrvlal_test.go:29: expected '[[%!s(int=1) %!s(int=2)]]', got '[]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpyqgrvlal_test.go:29: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var tmp [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            tmp = append(tmp, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        min := tmp[0]\n        min_index := 0\n        for j := 1; j < len(tmp); j++ {\n            if tmp[j][0] + tmp[j][1] < min[0] + min[1] {\n                min = tmp[j]\n                min_index = j\n            }\n        }\n        result = append(result, min)\n        tmp = append(tmp[:min_index], tmp[min_index+1:]...)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122973,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    // heap\n    heap := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n    // heap sort\n    for i := len(heap) / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, len(heap))\n    }\n    for i := len(heap) - 1; i >= len(heap) - k; i-- {\n        heap[0], heap[i] = heap[i], heap[0]\n        heapify(heap, 0, i)\n    }\n    return heap[len(heap) - k:]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122973,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeyhp3_tl_test.go:25:9: undefined: heapify\n/tmp/tmpeyhp3_tl_test.go:29:9: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    res := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        res = append(res, []int{nums1[0], nums2[0]})\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < res[k-1][0] + res[k-1][1] {\n                res[k-1][0] = nums1[i]\n                res[k-1][1] = nums2[j]\n                for m := k - 1; m > 0; m-- {\n                    if res[m][0] + res[m][1] < res[m-1][0] + res[m-1][1] {\n                        res[m][0], res[m][1], res[m-1][0], res[m-1][1] = res[m-1][0], res[m-1][1], res[m][0], res[m][1]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return res\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122973,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpcqt4tofy_test.go:53: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpcqt4tofy_test.go:53: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n\n    if len(nums1) * len(nums2) < k {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for k := 0; k < len(nums2); k++ {\n                if nums1[j] + nums2[k] < min {\n                    min = nums1[j] + nums2[k]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[min_index]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = append(nums2[:min_index], nums2[min_index+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122973,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc0000c2e70, 0x0, 0x3, 0xc0000c2e58, 0x0, 0x3, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmp1slsjgo9_test.go:30 +0x554\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmp1slsjgo9_test.go:46 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[min_index]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = append(nums2[:min_index], nums2[min_index+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122973,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc0000c2e70, 0x0, 0x3, 0xc0000c2e58, 0x0, 0x3, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmp2g1j1e9k_test.go:28 +0x545\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmp2g1j1e9k_test.go:44 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n    for i := 0; i < k; i++ {\n        var tmp = queue[0]\n        queue = queue[1:]\n        result = append(result, []int{nums1[tmp[0]], nums2[tmp[1]]})\n        if tmp[0] + 1 < len(nums1) && tmp[1] == 0 {\n            queue = append(queue, []int{tmp[0] + 1, 0, nums1[tmp[0] + 1] + nums2[0]})\n        }\n        if tmp[1] + 1 < len(nums2) {\n            queue = append(queue, []int{tmp[0], tmp[1] + 1, nums1[tmp[0]] + nums2[tmp[1] + 1]})\n        }\n        for j := 1; j < len(queue); j++ {\n            if queue[j][2] < queue[j - 1][2] {\n                queue[j], queue[j - 1] = queue[j - 1], queue[j]\n            } else {\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122973,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpo24wjl7c_test.go:58: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpo24wjl7c_test.go:58: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    // init heap\n    heap := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        heap = append(heap, []int{nums1[i] + nums2[0], i, 0})\n    }\n    heapify(heap)\n\n    // pop k elements\n    result := make([][]int, 0)\n    for i := 0; i < k && len(heap) > 0; i++ {\n        result = append(result, []int{nums1[heap[0][1]], nums2[heap[0][2]]})\n        if heap[0][2] < len(nums2) - 1 {\n            heap[0][0] = nums1[heap[0][1]] + nums2[heap[0][2] + 1]\n            heap[0][2]++\n        } else {\n            heap[0] = heap[len(heap) - 1]\n            heap = heap[:len(heap) - 1]\n        }\n        heapify(heap)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122973,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6j33_inf_test.go:19:5: undefined: heapify\n/tmp/tmp6j33_inf_test.go:32:9: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < len(result) - 1; i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n    if k > len(result) {\n        return result\n    }\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122973,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n\n    var heap [][]int\n    var heap_size int\n    var heap_push = func(item []int) {\n        heap[heap_size] = item\n        heap_size++\n        var i = heap_size - 1\n        for ; i > 0; i = (i - 1) / 2 {\n            if heap[i][0] + heap[i][1] < heap[(i - 1) / 2][0] + heap[(i - 1) / 2][1] {\n                heap[i], heap[(i - 1) / 2] = heap[(i - 1) / 2], heap[i]\n            } else {\n                break\n            }\n        }\n    }\n    var heap_pop = func() []int {\n        var result = heap[0]\n        heap_size--\n        heap[0] = heap[heap_size]\n        heap[heap_size] = nil\n        var i = 0\n        for ; i * 2 + 1 < heap_size; {\n            var j = i * 2 + 1\n            if j + 1 < heap_size && heap[j + 1][0] + heap[j + 1][1] < heap[j][0] + heap[j][1] {\n                j++\n            }\n            if heap[j][0] + heap[j][1] < heap[i][0] + heap[i][1] {\n                heap[i], heap[j] = heap[j], heap[i]\n                i = j\n            } else {\n                break\n            }\n        }\n        return result\n    }\n\n    heap = make([][]int, len(nums1) * len(nums2))\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap_push([]int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k && i < len(\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122972,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpdiv9y5us_test.go:57:6: expected '(', found TestK_Smallest_Pairs\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{nums1[0], nums2[0]}\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k - 1][0] + result[k - 1][1] {\n                result[k - 1] = []int{nums1[i], nums2[j]}\n                for l := k - 1; l > 0; l-- {\n                    if result[l][0] + result[l][1] < result[l - 1][0] + result[l - 1][1] {\n                        result[l], result[l - 1] = result[l - 1], result[l]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122973,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp3riljhb1_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp3riljhb1_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var res [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            res = append(res, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(res); i++ {\n        for j := i + 1; j < len(res); j++ {\n            if res[i][0] + res[i][1] > res[j][0] + res[j][1] {\n                res[i], res[j] = res[j], res[i]\n            }\n        }\n    }\n\n    if len(res) < k {\n        return res\n    }\n    return res[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122973,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j * len(nums2) + l\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index / len(nums2)], nums2[min_index % len(nums2)]})\n        nums1[min_index / len(nums2)] = 0x7fffffff\n        nums2[min_index % len(nums2)] = 0x7fffffff\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122973,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpe7mlh2ta_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=2147483647) %!s(int=2147483647)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpe7mlh2ta_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=2147483647) %!s(int=2147483647)] [%!s(int=2147483647) %!s(int=2147483647)] [%!s(int=2147483647) %!s(int=2147483647)] [%!s(int=2147483647) %!s(int=2147483647)] [%!s(int=2147483647) %!s(int=2147483647)] [%!s(int=2147483647) %!s(int=2147483647)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n    for i := 0; i < k && len(queue) > 0; i++ {\n        var tmp = queue[0]\n        queue = queue[1:]\n        result = append(result, []int{nums1[tmp[0]], nums2[tmp[1]]})\n        if tmp[0] + 1 < len(nums1) {\n            queue = append(queue, []int{tmp[0] + 1, tmp[1], nums1[tmp[0] + 1] + nums2[tmp[1]]})\n        }\n        if tmp[0] == 0 && tmp[1] + 1 < len(nums2) {\n            queue = append(queue, []int{tmp[0], tmp[1] + 1, nums1[tmp[0]] + nums2[tmp[1] + 1]})\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122973,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpcnla6_ly_test.go:45: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpcnla6_ly_test.go:45: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=4)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    heap := make([]int, k)\n    for i := 0; i < k; i++ {\n        heap[i] = -1\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if len(result) < k {\n                result = append(result, []int{nums1[i], nums2[j]})\n                heap[len(result) - 1] = len(result) - 1\n                sift_up(result, heap, len(result) - 1)\n            } else {\n                if nums1[i] + nums2[j] < result[0][0] + result[0][1] {\n                    result[0] = []int{nums1[i], nums2[j]}\n                    sift_down(result, heap, 0)\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122973,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr550gc81_test.go:26:17: undefined: sift_up\n/tmp/tmpr550gc81_test.go:30:21: undefined: sift_down\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n    if k == 0 {\n        return result\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var heap = make([]int, k)\n    var heap_index = make([]int, k)\n    var heap_size = 0\n    var heap_index_size = 0\n    var heap_index_nums1 = make([]int, k)\n    var heap_index_nums2 = make([]int, k)\n    var heap_index_nums1_size = 0\n    var heap_index_nums2_size = 0\n    var heap_index_nums1_index = 0\n    var heap_index_nums2_index = 0\n    var heap_index_nums1_index_size = 0\n    var heap_index_nums2_index_size = 0\n    var heap_index_nums1_index_nums2_index = 0\n    var heap_index_nums1_index_nums2_index_size = 0\n    var heap_index_nums1_index_nums2_index_nums1 = make([]int, k)\n    var heap_index_nums1_index_nums2_index_nums2 = make([]int, k)\n    var heap_index_nums1_index_nums2_index_nums1_size = 0\n    var heap_index_nums1_index_nums2_index_nums2_size = 0\n    var heap_index_nums1_index_nums2_index_nums1_index = 0\n    var heap_index_nums1_index_nums2_index_nums2_index = 0\n    var heap_index_nums1_index_nums2_index_nums1_index_size = 0\n    var heap_index_nums1_index_nums2_index_nums\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122972,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpzv8rr3_x_test.go:41:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if j == 0 && l == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_index = j * len(nums2) + l\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        min_index = j * len(nums2) + l\n                    }\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index / len(nums2)], nums2[min_index % len(nums2)]})\n        nums1[min_index / len(nums2)] = 1000000\n        nums2[min_index % len(nums2)] = 1000000\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122973,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpxnxcwt9r_test.go:55: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpxnxcwt9r_test.go:55: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=7) %!s(int=6)] [%!s(int=1000000) %!s(int=1000000)] [%!s(int=1000000) %!s(int=1000000)] [%!s(int=1000000) %!s(int=1000000)] [%!s(int=1000000) %!s(int=1000000)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var heap [][]int\n    var result [][]int\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        if len(heap) == 0 {\n            break\n        }\n\n        min := heap[0]\n        min_index := 0\n\n        for j := 1; j < len(heap); j++ {\n            if heap[j][0] + heap[j][1] < min[0] + min[1] {\n                min = heap[j]\n                min_index = j\n            }\n        }\n\n        result = append(result, min)\n        heap = append(heap[:min_index], heap[min_index+1:]...)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122973,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{nums1[0], nums2[0]}\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = []int{nums1[i], nums2[j]}\n                for m := k - 1; m > 0; m-- {\n                    if result[m][0] + result[m][1] < result[m-1][0] + result[m-1][1] {\n                        tmp := result[m]\n                        result[m] = result[m-1]\n                        result[m-1] = tmp\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122973,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp_7dpa24e_test.go:54: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp_7dpa24e_test.go:54: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if i == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_index = j * len(nums2) + l\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        min_index = j * len(nums2) + l\n                    }\n                }\n            }\n        }\n\n        result = append(result, []int{nums1[min_index / len(nums2)], nums2[min_index % len(nums2)]})\n        nums1[min_index / len(nums2)] = -1\n        nums2[min_index % len(nums2)] = -1\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122973,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp50pk4hcc_test.go:59: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=7) %!s(int=6)] [%!s(int=-1) %!s(int=-1)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__1 (0.00s)\n        tmp50pk4hcc_test.go:59: expected '[[%!s(int=1) %!s(int=2)]]', got '[[%!s(int=7) %!s(int=6)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp50pk4hcc_test.go:59: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=7) %!s(int=6)] [%!s(int=-1) %!s(int=-1)] [%!s(int=-1) %!s(int=-1)] [%!s(int=-1) %!s(int=-1)] [%!s(int=-1) %!s(int=-1)] [%!s(int=-1) %!s(int=-1)] [%!s(int=-1) %!s(int=-1)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return result\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min || min == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122974,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008c670, 0x0, 0x3, 0xc00008c668, 0x0, 0x0, 0x7, 0xc00013e048, 0x1, 0x1)\n\t/tmp/tmprv9di0ra_test.go:28 +0x475\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000102600)\n\t/tmp/tmprv9di0ra_test.go:44 +0x2d2\ntesting.tRunner(0xc000102600, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n    for len(result) < k && len(queue) > 0 {\n        pair := queue[0]\n        queue = queue[1:]\n        result = append(result, []int{nums1[pair[0]], nums2[pair[1]]})\n        if pair[0] + 1 < len(nums1) {\n            queue = append(queue, []int{pair[0] + 1, pair[1], nums1[pair[0] + 1] + nums2[pair[1]]})\n        }\n        if pair[0] == 0 && pair[1] + 1 < len(nums2) {\n            queue = append(queue, []int{pair[0], pair[1] + 1, nums1[pair[0]] + nums2[pair[1] + 1]})\n        }\n        for i := 1; i < len(queue); i++ {\n            if queue[i][2] < queue[0][2] {\n                queue[i], queue[0] = queue[0], queue[i]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122974,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp8tg36z5d_test.go:51: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp8tg36z5d_test.go:51: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n\n    for len(result) < k && len(queue) > 0 {\n        var pair []int\n        pair, queue = queue[0], queue[1:]\n        result = append(result, []int{nums1[pair[0]], nums2[pair[1]]})\n\n        if pair[0] + 1 < len(nums1) {\n            queue = append(queue, []int{pair[0] + 1, pair[1], nums1[pair[0] + 1] + nums2[pair[1]]})\n        }\n\n        if pair[0] == 0 && pair[1] + 1 < len(nums2) {\n            queue = append(queue, []int{pair[0], pair[1] + 1, nums1[pair[0]] + nums2[pair[1] + 1]})\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122975,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp1x5qo6ec_test.go:50: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp1x5qo6ec_test.go:50: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=4)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    var index1, index2 int\n    for i := 0; i < k; i++ {\n        if index1 >= len(nums1) {\n            index2++\n        } else if index2 >= len(nums2) {\n            index1++\n        } else {\n            if nums1[index1] < nums2[index2] {\n                index1++\n            } else {\n                index2++\n            }\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        if index1 >= len(nums1) {\n            result = append(result, []int{nums1[index1 - 1], nums2[index2]})\n            index2++\n        } else if index2 >= len(nums2) {\n            result = append(result, []int{nums1[index1], nums2[index2 - 1]})\n            index1++\n        } else {\n            if nums1[index1] < nums2[index2] {\n                result = append(result, []int{nums1[index1], nums2[index2 - 1]})\n                index1++\n            } else {\n                result = append(result, []int{nums1[index1 - 1], nums2[index2]})\n                index2++\n            }\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122975,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [4] with length 3 [recovered]\n\tpanic: runtime error: index out of range [4] with length 3\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008c670, 0x3, 0x3, 0xc00008c658, 0x3, 0x3, 0x7, 0xc00013e048, 0x1, 0x1)\n\t/tmp/tmpyipoiodx_test.go:36 +0x750\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000102600)\n\t/tmp/tmpyipoiodx_test.go:64 +0x2d2\ntesting.tRunner(0xc000102600, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = make([]int, 2)\n    }\n    for i := 0; i < k; i++ {\n        result[i][0] = nums1[0]\n        result[i][1] = nums2[0]\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k - 1][0] + result[k - 1][1] {\n                result[k - 1][0] = nums1[i]\n                result[k - 1][1] = nums2[j]\n                for m := k - 1; m > 0; m-- {\n                    if result[m][0] + result[m][1] < result[m - 1][0] + result[m - 1][1] {\n                        result[m][0], result[m - 1][0] = result[m - 1][0], result[m][0]\n                        result[m][1], result[m - 1][1] = result[m - 1][1], result[m][1]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122975,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpk5sfu2ws_test.go:58: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpk5sfu2ws_test.go:58: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if len(heap) < k {\n                heap = append(heap, []int{nums1[i], nums2[j]})\n                if len(heap) == k {\n                    build_heap(heap)\n                }\n            } else {\n                if nums1[i] + nums2[j] < heap[0][0] + heap[0][1] {\n                    heap[0] = []int{nums1[i], nums2[j]}\n                    heapify(heap, 0)\n                }\n            }\n        }\n    }\n    return heap\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122975,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp79qygdae_test.go:22:21: undefined: build_heap\n/tmp/tmp79qygdae_test.go:27:21: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = make([]int, 2)\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1][0] = nums1[i]\n                result[k-1][1] = nums2[j]\n                for m := k - 1; m > 0; m-- {\n                    if result[m][0] + result[m][1] < result[m-1][0] + result[m-1][1] {\n                        result[m][0], result[m][1] = result[m-1][0], result[m-1][1]\n                        result[m-1][0], result[m-1][1] = nums1[i], nums2[j]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122975,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp9q986vgt_test.go:55: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=0) %!s(int=0)] [%!s(int=0) %!s(int=0)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__1 (0.00s)\n        tmp9q986vgt_test.go:55: expected '[[%!s(int=1) %!s(int=2)]]', got '[[%!s(int=0) %!s(int=0)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp9q986vgt_test.go:55: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=0) %!s(int=0)] [%!s(int=0) %!s(int=0)] [%!s(int=0) %!s(int=0)] [%!s(int=0) %!s(int=0)] [%!s(int=0) %!s(int=0)] [%!s(int=0) %!s(int=0)] [%!s(int=0) %!s(int=0)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_index := []int{0, 0}\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = []int{j, l}\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index[0]], nums2[min_index[1]]})\n        nums1 = append(nums1[:min_index[0]], nums1[min_index[0]+1:]...)\n        nums2 = append(nums2[:min_index[1]], nums2[min_index[1]+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122975,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00011ae70, 0x0, 0x3, 0xc00011ae58, 0x0, 0x3, 0x7, 0xc00013e048, 0x1, 0x1)\n\t/tmp/tmpmwa93ss8_test.go:18 +0x6f6\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000102600)\n\t/tmp/tmpmwa93ss8_test.go:44 +0x2d2\ntesting.tRunner(0xc000102600, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = make([]int, 2)\n    }\n\n    // init\n    for i := 0; i < len(nums1); i++ {\n        result[i][0] = nums1[i]\n        result[i][1] = nums2[0]\n    }\n\n    for i := 1; i < len(nums2); i++ {\n        for j := 0; j < k; j++ {\n            if result[j][1] > nums2[i] {\n                for l := k - 1; l > j; l-- {\n                    result[l][0] = result[l - 1][0]\n                    result[l][1] = result[l - 1][1]\n                }\n                result[j][0] = nums1[0]\n                result[j][1] = nums2[i]\n                break\n            }\n        }\n    }\n\n    for i := 1; i < len(nums1); i++ {\n        for j := 0; j < k; j++ {\n            if result[j][0] > nums1[i] {\n                for l := k - 1; l > j; l-- {\n                    result[l][0] = result[l - 1][0]\n                    result[l][1] = result[l - 1][1]\n                }\n                result[j][0] = nums1[i]\n                result[j][1] = nums2[0]\n                break\n            }\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122975,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2] with length 2\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008c640, 0x3, 0x3, 0xc00008c628, 0x3, 0x3, 0x2, 0x5826c3, 0xf, 0x0)\n\t/tmp/tmp5wzw46ug_test.go:25 +0x4d4\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000102600)\n\t/tmp/tmp5wzw46ug_test.go:67 +0xfb\ntesting.tRunner(0xc000102600, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if i % len(nums2) == 0 {\n                min = nums1[j] + nums2[0]\n                min_index = j\n            } else {\n                if nums1[j] + nums2[i % len(nums2)] < min {\n                    min = nums1[j] + nums2[i % len(nums2)]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[i % len(nums2)]})\n        nums1 = append(nums1[:min_index], nums1[min_index + 1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122975,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000092670, 0x0, 0x3, 0xc000092658, 0x3, 0x3, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmpmszjmb4b_test.go:31 +0x44d\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmpmszjmb4b_test.go:46 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        result = append(result, []int{nums1[0], nums2[0]})\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[0][0] + result[0][1] {\n                result[0] = []int{nums1[i], nums2[j]}\n                for p := 0; p < k; p++ {\n                    for q := p + 1; q < k; q++ {\n                        if result[p][0] + result[p][1] > result[q][0] + result[q][1] {\n                            result[p], result[q] = result[q], result[p]\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122975,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpc2f2h8ok_test.go:56: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpc2f2h8ok_test.go:56: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var res [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            res = append(res, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(res); j++ {\n            if res[i][0] + res[i][1] > res[j][0] + res[j][1] {\n                res[i], res[j] = res[j], res[i]\n            }\n        }\n    }\n    return res[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122975,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] + nums2[0] < min {\n                min = nums1[j] + nums2[0]\n                min_index = j\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122975,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000092670, 0x0, 0x3, 0xc000092668, 0x0, 0x0, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmp0yd8dsgo_test.go:28 +0x43e\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmp0yd8dsgo_test.go:45 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_index := []int{0, 0}\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = []int{j, l}\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index[0]], nums2[min_index[1]]})\n        nums1 = append(nums1[:min_index[0]], nums1[min_index[0]+1:]...)\n        nums2 = append(nums2[:min_index[1]], nums2[min_index[1]+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122975,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00011ae70, 0x0, 0x3, 0xc00011ae58, 0x0, 0x3, 0x7, 0xc00013e048, 0x1, 0x1)\n\t/tmp/tmpz6tjkx8n_test.go:20 +0x6f6\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000102600)\n\t/tmp/tmpz6tjkx8n_test.go:46 +0x2d2\ntesting.tRunner(0xc000102600, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[min_index]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = append(nums2[:min_index], nums2[min_index+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122973,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc0000c2e70, 0x0, 0x3, 0xc0000c2e58, 0x0, 0x3, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmp2g1j1e9k_test.go:28 +0x545\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmp2g1j1e9k_test.go:44 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0})\n\n    for len(result) < k && len(queue) > 0 {\n        var tmp []int\n        tmp, queue = queue[0], queue[1:]\n        result = append(result, []int{nums1[tmp[0]], nums2[tmp[1]]})\n\n        if tmp[0] + 1 < len(nums1) {\n            queue = append(queue, []int{tmp[0] + 1, tmp[1]})\n        }\n\n        if tmp[0] == 0 && tmp[1] + 1 < len(nums2) {\n            queue = append(queue, []int{tmp[0], tmp[1] + 1})\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122975,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpm0wls_vt_test.go:50: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpm0wls_vt_test.go:50: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=4)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_i int\n        var min_j int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if i == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        min_i = j\n                        min_j = l\n                    }\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122975,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc0000c2e70, 0x0, 0x3, 0xc0000c2e58, 0x0, 0x3, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmplsmw6wse_test.go:38 +0x5ad\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmplsmw6wse_test.go:55 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if len(result) < k {\n                result = append(result, []int{nums1[i], nums2[j]})\n            } else {\n                if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                    result[k-1] = []int{nums1[i], nums2[j]}\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122975,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmprn0_i37p_test.go:44: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var index1, index2 int\n    for i := 0; i < k; i++ {\n        if index1 >= len(nums1) || index2 >= len(nums2) {\n            break\n        }\n\n        if nums1[index1] + nums2[index2] <= nums1[0] + nums2[0] {\n            result = append(result, []int{nums1[index1], nums2[index2]})\n            index1++\n            if index1 >= len(nums1) {\n                index2++\n                index1 = 0\n            }\n        } else {\n            result = append(result, []int{nums1[0], nums2[0]})\n            index2++\n            if index2 >= len(nums2) {\n                index1++\n                index2 = 0\n            }\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122975,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp0kire7d6_test.go:56: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp0kire7d6_test.go:56: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_i, min_j int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if j == 0 && l == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        min_i = j\n                        min_j = l\n                    }\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122975,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00011ae70, 0x0, 0x3, 0xc00011ae58, 0x0, 0x3, 0x7, 0xc00013e048, 0x1, 0x1)\n\t/tmp/tmp3br3dyab_test.go:37 +0x5ad\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000102600)\n\t/tmp/tmp3br3dyab_test.go:54 +0x2d2\ntesting.tRunner(0xc000102600, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{}\n    }\n\n    // use heap to find k smallest pairs\n    // the heap is a min heap\n    heap := make([]int, k)\n    for i := 0; i < k; i++ {\n        heap[i] = nums1[0] + nums2[i]\n    }\n\n    // build heap\n    for i := k/2 - 1; i >= 0; i-- {\n        heapify(heap, i, k)\n    }\n\n    // find k smallest pairs\n    for i := 0; i < k; i++ {\n        // pop the smallest pair\n        result[i] = []int{nums1[0], nums2[0]}\n\n        // find the next smallest pair\n        if len(nums2) > 1 {\n            nums2 = nums2[1:]\n            heap[0] = nums1[0] + nums2[0]\n        } else {\n            nums1 = nums1[1:]\n            nums2 = nums2[:len(nums2)-1]\n            heap[0] = nums1[0] + nums2[0]\n        }\n\n        // heapify\n        heapify(heap, 0, k)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122975,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu7_aj804_test.go:32:9: undefined: heapify\n/tmp/tmpu7_aj804_test.go:51:9: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if i == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        min_index = j\n                    }\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], min - nums1[min_index]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122975,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000092670, 0x0, 0x3, 0xc000092658, 0x3, 0x3, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmpg3wnnnjl_test.go:33 +0x40a\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmpg3wnnnjl_test.go:48 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var min_sum = nums1[0] + nums2[0]\n    var min_sum_index = []int{0, 0}\n    for i := 0; i < k; i++ {\n        if min_sum_index[0] == len(nums1) - 1 && min_sum_index[1] == len(nums2) - 1 {\n            break\n        }\n        result = append(result, []int{nums1[min_sum_index[0]], nums2[min_sum_index[1]]})\n        if min_sum_index[0] == len(nums1) - 1 {\n            min_sum_index[1]++\n        } else if min_sum_index[1] == len(nums2) - 1 {\n            min_sum_index[0]++\n        } else {\n            if nums1[min_sum_index[0] + 1] + nums2[min_sum_index[1]] < nums1[min_sum_index[0]] + nums2[min_sum_index[1] + 1] {\n                min_sum_index[0]++\n            } else {\n                min_sum_index[1]++\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122975,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp13nesic0_test.go:15:9: min_sum declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] + nums2[0] < min {\n                min = nums1[j] + nums2[0]\n                min_index = j\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122975,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008ce70, 0x0, 0x3, 0xc00008ce68, 0x0, 0x0, 0x7, 0xc00019a048, 0x1, 0x1)\n\t/tmp/tmpzh5sfjej_test.go:26 +0x43e\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000186300)\n\t/tmp/tmpzh5sfjej_test.go:42 +0x2d2\ntesting.tRunner(0xc000186300, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var min_sum int = nums1[0] + nums2[0]\n    var min_index1 int = 0\n    var min_index2 int = 0\n\n    for i := 0; i < k; i++ {\n        min_sum = nums1[0] + nums2[0]\n        min_index1 = 0\n        min_index2 = 0\n\n        for j := 0; j < len(nums1); j++ {\n            for m := 0; m < len(nums2); m++ {\n                if nums1[j] + nums2[m] < min_sum {\n                    min_sum = nums1[j] + nums2[m]\n                    min_index1 = j\n                    min_index2 = m\n                }\n            }\n        }\n\n        result = append(result, []int{nums1[min_index1], nums2[min_index2]})\n        nums1 = append(nums1[:min_index1], nums1[min_index1+1:]...)\n        nums2 = append(nums2[:min_index2], nums2[min_index2+1:]...)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122976,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000092e70, 0x0, 0x3, 0xc000092e58, 0x0, 0x3, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmpj83nxzq0_test.go:20 +0x586\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmpj83nxzq0_test.go:51 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k <= 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    var queue [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            queue = append(queue, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        var min []int\n        for j := 0; j < len(queue); j++ {\n            if min == nil || queue[j][0] + queue[j][1] < min[0] + min[1] {\n                min = queue[j]\n            }\n        }\n        result = append(result, min)\n        for j := 0; j < len(queue); j++ {\n            if queue[j][0] == min[0] && queue[j][1] == min[1] {\n                queue = append(queue[:j], queue[j+1:]...)\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122976,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    pairs := make([][]int, 0, k)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            pairs = append(pairs, []int{nums1[i], nums2[j]})\n        }\n    }\n    quick_sort(pairs, 0, len(pairs) - 1)\n    return pairs[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122976,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjr05u61i_test.go:22:5: undefined: quick_sort\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    // use a min heap to store the pairs\n    heap := make([]int, k)\n    for i := 0; i < k; i++ {\n        heap[i] = nums1[0] + nums2[0]\n    }\n    for i := k / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, k)\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < heap[0] {\n                heap[0] = nums1[i] + nums2[j]\n                heapify(heap, 0, k)\n            }\n        }\n    }\n\n    // get the pairs from the heap\n    pairs := make([][]int, k)\n    for i := 0; i < k; i++ {\n        pairs[i] = make([]int, 2)\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] == heap[i] {\n                    pairs[i][0] = nums1[j]\n                    pairs[i][1] = nums2[l]\n                    break\n                }\n            }\n        }\n    }\n\n    return pairs\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122976,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0n05iwt4_test.go:23:9: undefined: heapify\n/tmp/tmp0n05iwt4_test.go:30:17: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n\n    // heap\n    h := make([]int, 0, len(nums1) * len(nums2))\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            h = append(h, nums1[i] + nums2[j])\n        }\n    }\n    heapify(h)\n    for i := 0; i < k - 1; i++ {\n        h = pop(h)\n    }\n    min := h[0]\n\n    // find pairs\n    pairs := make([][]int, 0, k)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] == min {\n                pairs = append(pairs, []int{nums1[i], nums2[j]})\n            }\n        }\n    }\n\n    return pairs\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122976,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxac_b1p5_test.go:21:5: undefined: heapify\n/tmp/tmpxac_b1p5_test.go:23:13: undefined: pop\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min || j == 0 && l == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_index = j * len(nums2) + l\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index / len(nums2)], nums2[min_index % len(nums2)]})\n        nums1[min_index / len(nums2)] = nums1[min_index / len(nums2)] + nums2[min_index % len(nums2)] + 1\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122977,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpu84kt800_test.go:49: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpu84kt800_test.go:49: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=4) %!s(int=2)] [%!s(int=6) %!s(int=2)] [%!s(int=7) %!s(int=2)] [%!s(int=7) %!s(int=2)] [%!s(int=9) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = make([]int, 2)\n    }\n\n    var i, j int\n    for i = 0; i < k; i++ {\n        result[i][0] = nums1[0]\n        result[i][1] = nums2[0]\n    }\n\n    for i = 0; i < k; i++ {\n        for j = 0; j < len(nums1); j++ {\n            if nums1[j] + nums2[0] < result[i][0] + result[i][1] {\n                result[i][0] = nums1[j]\n                result[i][1] = nums2[0]\n            }\n        }\n\n        for j = 0; j < len(nums2); j++ {\n            if nums1[0] + nums2[j] < result[i][0] + result[i][1] {\n                result[i][0] = nums1[0]\n                result[i][1] = nums2[j]\n            }\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122977,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp_1iky1qv_test.go:63: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp_1iky1qv_test.go:63: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = make([]int, 2)\n    }\n    // init heap\n    heap := make([]int, k)\n    for i := 0; i < k; i++ {\n        heap[i] = nums1[0] + nums2[i]\n    }\n    // build heap\n    for i := k / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, k)\n    }\n    // find k smallest pairs\n    for i := 0; i < k; i++ {\n        result[i][0] = heap[0] - nums2[0]\n        result[i][1] = nums2[0]\n        if i < k - 1 {\n            heap[0] = heap[0] - nums2[0] + nums2[i + 1]\n            heapify(heap, 0, k)\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122977,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpo9uqrd87_test.go:27:9: undefined: heapify\n/tmp/tmpo9uqrd87_test.go:35:13: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122977,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_i := 0\n        min_j := 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122977,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000092670, 0x0, 0x3, 0xc000092658, 0x0, 0x3, 0x7, 0xc00000c048, 0x1, 0x1)\n\t/tmp/tmp4m06kswr_test.go:20 +0x5e5\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmp4m06kswr_test.go:48 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var (\n        result [][]int\n        i, j int\n        heap = make([]int, k)\n        heapSize int\n        heapPush = func(n int) {\n            if heapSize < k {\n                heap[heapSize] = n\n                heapSize++\n                return\n            }\n\n            if n < heap[0] {\n                heap[0] = n\n            }\n        }\n        heapPop = func() int {\n            if heapSize == 0 {\n                return 0\n            }\n\n            var (\n                min = heap[0]\n                i = 0\n                j = 1\n            )\n\n            if j < heapSize && heap[j] < heap[i] {\n                i = j\n            }\n\n            if j + 1 < heapSize && heap[j + 1] < heap[i] {\n                i = j + 1\n            }\n\n            heap[i] = heap[heapSize - 1]\n            heapSize--\n\n            return min\n        }\n    )\n\n    for i < len(nums1) && j < len(nums2) {\n        heapPush(nums1[i] + nums2[j])\n        if i == len(nums1) - 1 {\n            j++\n        } else if j == len(nums2) - 1 {\n            i++\n        } else {\n            if nums1[i + 1] + nums2[j] < nums1[i] + nums2[j + 1] {\n                i++\n            } else {\n                j++\n            }\n        }\n    }\n\n    for heapSize > 0 {\n        result = append(result, []int{nums1[i], nums2[j]})\n        heapPop()\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122977,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [3] with length 3 [recovered]\n\tpanic: runtime error: index out of range [3] with length 3\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008c640, 0x3, 0x3, 0xc00008c628, 0x3, 0x3, 0x2, 0x582703, 0xf, 0x0)\n\t/tmp/tmp3e6tm8db_test.go:72 +0x474\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000102600)\n\t/tmp/tmp3e6tm8db_test.go:86 +0xfb\ntesting.tRunner(0xc000102600, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var heap [][]int\n    var heap_size int\n    var heap_capacity int = k\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if heap_size < heap_capacity {\n                heap = append(heap, []int{nums1[i], nums2[j]})\n                heap_size++\n                if heap_size == heap_capacity {\n                    heapify(heap, heap_size)\n                }\n            } else {\n                if nums1[i] + nums2[j] < heap[0][0] + heap[0][1] {\n                    heap[0] = []int{nums1[i], nums2[j]}\n                    heapify(heap, heap_size)\n                }\n            }\n        }\n    }\n\n    for i := 0; i < heap_size; i++ {\n        result = append(result, heap[i])\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122977,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9aaf1wip_test.go:25:21: undefined: heapify\n/tmp/tmp9aaf1wip_test.go:30:21: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k <= 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{nums1[0], nums2[0]}\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k - 1][0] + result[k - 1][1] {\n                result[k - 1] = []int{nums1[i], nums2[j]}\n                for m := k - 2; m >= 0; m-- {\n                    if result[m][0] + result[m][1] > result[m + 1][0] + result[m + 1][1] {\n                        result[m], result[m + 1] = result[m + 1], result[m]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122977,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp5oaywhd__test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp5oaywhd__test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_index := []int{0, 0}\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = []int{j, l}\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index[0]], nums2[min_index[1]]})\n        nums1 = append(nums1[:min_index[0]], nums1[min_index[0]+1:]...)\n        nums2 = append(nums2[:min_index[1]], nums2[min_index[1]+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122977,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000092670, 0x0, 0x3, 0xc000092658, 0x0, 0x3, 0x7, 0xc00000c048, 0x1, 0x1)\n\t/tmp/tmpappv3vxp_test.go:18 +0x725\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmpappv3vxp_test.go:44 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n\n    for len(result) < k && len(queue) > 0 {\n        var tmp []int\n        tmp, queue = queue[0], queue[1:]\n        result = append(result, []int{nums1[tmp[0]], nums2[tmp[1]]})\n\n        if tmp[0] + 1 < len(nums1) {\n            queue = append(queue, []int{tmp[0] + 1, tmp[1], nums1[tmp[0] + 1] + nums2[tmp[1]]})\n        }\n        if tmp[1] + 1 < len(nums2) {\n            queue = append(queue, []int{tmp[0], tmp[1] + 1, nums1[tmp[0]] + nums2[tmp[1] + 1]})\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122977,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp34mwuedc_test.go:49: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp34mwuedc_test.go:49: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var pairs []pair\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            pairs = append(pairs, pair{nums1[i], nums2[j]})\n        }\n    }\n\n    quick_sort(pairs, 0, len(pairs) - 1)\n\n    for i := 0; i < k && i < len(pairs); i++ {\n        result = append(result, []int{pairs[i].a, pairs[i].b})\n    }\n\n    return result\n}\n\ntype pair \nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122976,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmps_olluol_test.go:31:11: expected type, found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n    for len(result) < k && len(queue) > 0 {\n        var tmp []int\n        tmp, queue = queue[0], queue[1:]\n        result = append(result, []int{nums1[tmp[0]], nums2[tmp[1]]})\n\n        if tmp[0] + 1 < len(nums1) {\n            queue = append(queue, []int{tmp[0] + 1, tmp[1], nums1[tmp[0] + 1] + nums2[tmp[1]]})\n        }\n\n        if tmp[0] == 0 && tmp[1] + 1 < len(nums2) {\n            queue = append(queue, []int{tmp[0], tmp[1] + 1, nums1[tmp[0]] + nums2[tmp[1] + 1]})\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122977,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpyaagug5d_test.go:49: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpyaagug5d_test.go:49: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=4)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    heapify(heap)\n    for i := 0; i < k; i++ {\n        if i < len(heap) {\n            result = append(result, heap[0])\n            heap[0] = heap[len(heap) - 1]\n            heap = heap[:len(heap) - 1]\n            heapify(heap)\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122977,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp59ez51tn_test.go:22:5: undefined: heapify\n/tmp/tmp59ez51tn_test.go:28:13: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var heap [][]int\n    var heapSize int\n\n    heap = append(heap, []int{nums1[0] + nums2[0], 0, 0})\n    heapSize = 1\n\n    for i := 0; i < k && heapSize > 0; i++ {\n        sum, x, y := heap[0][0], heap[0][1], heap[0][2]\n        result = append(result, []int{nums1[x], nums2[y]})\n\n        if y + 1 < len(nums2) {\n            heap = append(heap, []int{nums1[x] + nums2[y + 1], x, y + 1})\n            heapSize++\n        }\n\n        if y == 0 && x + 1 < len(nums1) {\n            heap = append(heap, []int{nums1[x + 1] + nums2[y], x + 1, y})\n            heapSize++\n        }\n\n        heap = heap[1:]\n        heapSize--\n\n        heapify(heap, 0, heapSize)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122977,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpf71rxicj_test.go:38:9: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        result = append(result, []int{nums1[0], nums2[0]})\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = []int{nums1[i], nums2[j]}\n                for l := k - 1; l > 0; l-- {\n                    if result[l][0] + result[l][1] < result[l-1][0] + result[l-1][1] {\n                        result[l], result[l-1] = result[l-1], result[l]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122977,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp2a3y4fwt_test.go:56: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp2a3y4fwt_test.go:56: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{nums1[0], nums2[0]}\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            tmp := []int{nums1[i], nums2[j]}\n            if tmp[0] + tmp[1] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = tmp\n                for m := k - 1; m > 0; m-- {\n                    if result[m][0] + result[m][1] < result[m-1][0] + result[m-1][1] {\n                        result[m], result[m-1] = result[m-1], result[m]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122977,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp6ak98vbd_test.go:53: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp6ak98vbd_test.go:53: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var res [][]int\n    for i := 0; i < k; i++ {\n        var min = nums1[0] + nums2[0]\n        var min_i = 0\n        var min_j = 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        res = append(res, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return res\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122977,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008c670, 0x0, 0x3, 0xc00008c658, 0x0, 0x3, 0x7, 0xc00013e048, 0x1, 0x1)\n\t/tmp/tmpi757x8hb_test.go:18 +0x599\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000102600)\n\t/tmp/tmpi757x8hb_test.go:46 +0x2d2\ntesting.tRunner(0xc000102600, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    var queue []*pair\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            queue = append(queue, &pair{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        min := queue[0]\n        for j := 1; j < len(queue); j++ {\n            if queue[j].sum() < min.sum() {\n                min = queue[j]\n            }\n        }\n        result = append(result, []int{min.a, min.b})\n        queue = remove(queue, min)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122977,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpit15yhuu_test.go:23:18: undefined: pair\n/tmp/tmpit15yhuu_test.go:26:36: undefined: pair\n/tmp/tmpit15yhuu_test.go:38:17: undefined: remove\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n    quick_sort(result, 0, len(result) - 1)\n    if k > len(result) {\n        return result\n    }\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122978,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpue0oe3d1_test.go:19:5: undefined: quick_sort\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122978,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    ret := make([][]int, 0, k)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            ret = append(ret, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(ret); j++ {\n            if ret[i][0] + ret[i][1] > ret[j][0] + ret[j][1] {\n                ret[i], ret[j] = ret[j], ret[i]\n            }\n        }\n    }\n    return ret[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122978,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{nums1[0], nums2[0]}\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = []int{nums1[i], nums2[j]}\n                for l := k - 1; l > 0; l-- {\n                    if result[l][0] + result[l][1] < result[l-1][0] + result[l-1][1] {\n                        result[l], result[l-1] = result[l-1], result[l]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122978,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp2det1sl3_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp2det1sl3_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n\n    for len(result) < k && len(queue) > 0 {\n        pair := queue[0]\n        queue = queue[1:]\n\n        result = append(result, []int{nums1[pair[0]], nums2[pair[1]]})\n\n        if pair[0] + 1 < len(nums1) {\n            queue = append(queue, []int{pair[0] + 1, pair[1], nums1[pair[0] + 1] + nums2[pair[1]]})\n        }\n\n        if pair[0] == 0 && pair[1] + 1 < len(nums2) {\n            queue = append(queue, []int{pair[0], pair[1] + 1, nums1[pair[0]] + nums2[pair[1] + 1]})\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122978,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpmi4i864q_test.go:51: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpmi4i864q_test.go:51: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=4)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        var min_index []int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = []int{j, l}\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index[0]], nums2[min_index[1]]})\n        nums1 = append(nums1[:min_index[0]], nums1[min_index[0]+1:]...)\n        nums2 = append(nums2[:min_index[1]], nums2[min_index[1]+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122979,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008c640, 0x3, 0x3, 0xc00008c628, 0x3, 0x3, 0x2, 0x5826e3, 0xf, 0x0)\n\t/tmp/tmpoo8wufe0_test.go:28 +0x6ac\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000102600)\n\t/tmp/tmpoo8wufe0_test.go:42 +0xfb\ntesting.tRunner(0xc000102600, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n    if len(nums1) * len(nums2) <= k {\n        for _, v1 := range nums1 {\n            for _, v2 := range nums2 {\n                result = append(result, []int{v1, v2})\n            }\n        }\n        return result\n    }\n    var tmp []int\n    for _, v1 := range nums1 {\n        for _, v2 := range nums2 {\n            tmp = append(tmp, v1 + v2)\n        }\n    }\n    tmp = quick_sort(tmp)\n    for i := 0; i < k; i++ {\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] == tmp[i] {\n                    result = append(result, []int{nums1[j], nums2[l]})\n                    break\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122978,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqsfodrd7_test.go:28:11: undefined: quick_sort\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    if len(result) < k {\n        return result\n    }\n    return result[0:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122979,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    res := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        res = append(res, []int{nums1[0], nums2[0]})\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < res[k-1][0] + res[k-1][1] {\n                res[k-1] = []int{nums1[i], nums2[j]}\n                for m := k - 1; m > 0; m-- {\n                    if res[m][0] + res[m][1] < res[m-1][0] + res[m-1][1] {\n                        res[m], res[m-1] = res[m-1], res[m]\n                    }\n                }\n            }\n        }\n    }\n    return res\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122979,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpxk5qrgi7_test.go:53: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpxk5qrgi7_test.go:53: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    // TODO:\n    return nil\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122973,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpyqgrvlal_test.go:29: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__1 (0.00s)\n        tmpyqgrvlal_test.go:29: expected '[[%!s(int=1) %!s(int=2)]]', got '[]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpyqgrvlal_test.go:29: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        result = append(result, []int{nums1[0], nums2[0]})\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = []int{nums1[i], nums2[j]}\n                for l := k - 1; l > 0; l-- {\n                    if result[l][0] + result[l][1] < result[l-1][0] + result[l-1][1] {\n                        result[l], result[l-1] = result[l-1], result[l]\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122979,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpceerzgbn_test.go:50: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpceerzgbn_test.go:50: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    res := make([][]int, k)\n    for i := 0; i < k; i++ {\n        res[i] = make([]int, 2)\n    }\n    for i := 0; i < k; i++ {\n        min := int(^uint(0) >> 1)\n        var x, y int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    x = j\n                    y = l\n                }\n            }\n        }\n        res[i][0] = nums1[x]\n        res[i][1] = nums2[y]\n        nums1 = append(nums1[:x], nums1[x+1:]...)\n        nums2 = append(nums2[:y], nums2[y+1:]...)\n    }\n    return res\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122979,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008c670, 0x0, 0x3, 0xc00008c658, 0x0, 0x3, 0x7, 0xc00013e030, 0x1, 0x1)\n\t/tmp/tmp67jx98pl_test.go:32 +0x4a5\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000102600)\n\t/tmp/tmp67jx98pl_test.go:49 +0x2d2\ntesting.tRunner(0xc000102600, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    // init heap\n    heap := make([][]int, 0)\n    for i := 0; i < k; i++ {\n        heap = append(heap, []int{nums1[0] + nums2[i], 0, i})\n    }\n\n    // build heap\n    for i := k / 2 - 1; i >= 0; i-- {\n        heap = heapify(heap, i)\n    }\n\n    // pop k elements\n    result := make([][]int, 0)\n    for i := 0; i < k; i++ {\n        result = append(result, []int{heap[0][1], heap[0][2]})\n        if heap[0][1] < len(nums1) - 1 {\n            heap[0][1]++\n            heap[0][0] = nums1[heap[0][1]] + nums2[heap[0][2]]\n        } else {\n            heap[0] = heap[len(heap) - 1]\n            heap = heap[:len(heap) - 1]\n        }\n        heap = heapify(heap, 0)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122979,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0ruugmea_test.go:26:16: undefined: heapify\n/tmp/tmp0ruugmea_test.go:40:16: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] + nums2[0] < min || j == 0 {\n                min = nums1[j] + nums2[0]\n                min_index = j\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122979,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc0001c4000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc0001a0300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc0001c4000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008c670, 0x0, 0x3, 0xc00008c668, 0x0, 0x0, 0x7, 0xc0001ae048, 0x1, 0x1)\n\t/tmp/tmprgna64a2_test.go:29 +0x46d\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc0001a0300)\n\t/tmp/tmprgna64a2_test.go:45 +0x2d2\ntesting.tRunner(0xc0001a0300, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := len(heap) / 2; i >= 0; i-- {\n        heap = heapify(heap, i)\n    }\n\n    for i := 0; i < k; i++ {\n        if len(heap) == 0 {\n            break\n        }\n        result = append(result, heap[0])\n        heap[0] = heap[len(heap) - 1]\n        heap = heap[:len(heap) - 1]\n        heap = heapify(heap, 0)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122979,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpun1ij0u9_test.go:23:16: undefined: heapify\n/tmp/tmpun1ij0u9_test.go:33:16: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var minHeap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            minHeap = append(minHeap, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    heapify(minHeap)\n\n    for i := 0; i < k && i < len(minHeap); i++ {\n        result = append(result, minHeap[0])\n        minHeap[0] = minHeap[len(minHeap) - 1]\n        minHeap = minHeap[:len(minHeap) - 1]\n        heapify(minHeap)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122979,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuu46izpn_test.go:22:5: undefined: heapify\n/tmp/tmpuu46izpn_test.go:28:9: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        result = append(result, []int{nums1[0], nums2[0]})\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[0][0] + result[0][1] {\n                result[0] = []int{nums1[i], nums2[j]}\n                for m := 1; m < k; m++ {\n                    if result[m][0] + result[m][1] < result[m-1][0] + result[m-1][1] {\n                        result[m], result[m-1] = result[m-1], result[m]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122979,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpaee70xu8_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpaee70xu8_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 || k <= 0 {\n        return result\n    }\n\n    var pq PriorityQueue\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            pq.Push([]int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k && !pq.Empty(); i++ {\n        result = append(result, pq.Pop().([]int))\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122979,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4tyhzle2_test.go:15:12: undefined: PriorityQueue\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k <= 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = make([]int, 2)\n    }\n    heap := make([]int, k)\n    heap[0] = nums1[0] + nums2[0]\n    heap_size := 1\n    for i := 0; i < k; i++ {\n        result[i][0] = nums1[0]\n        result[i][1] = nums2[0]\n        if i + 1 < len(nums1) {\n            heap[heap_size] = nums1[i + 1] + nums2[0]\n            heap_size++\n        }\n        if i + 1 < len(nums2) {\n            heap[heap_size] = nums1[0] + nums2[i + 1]\n            heap_size++\n        }\n        if i + 1 < len(nums1) && i + 1 < len(nums2) {\n            heap[heap_size] = nums1[i + 1] + nums2[i + 1]\n            heap_size++\n        }\n        heap_size = build_heap(heap, heap_size)\n        result[i][0] = nums1[heap[0] / len(nums2)]\n        result[i][1] = nums2[heap[0] % len(nums2)]\n        heap[0] = heap[heap_size - 1]\n        heap_size--\n        heap_size = heapify(heap, heap_size, 0)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122979,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5xadqxwl_test.go:41:21: undefined: build_heap\n/tmp/tmp5xadqxwl_test.go:46:21: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue []int\n    var visited = make(map[int]bool)\n\n    queue = append(queue, 0)\n    visited[0] = true\n\n    for len(queue) > 0 && len(result) < k {\n        var idx = queue[0]\n        queue = queue[1:]\n\n        var i = idx / len(nums2)\n        var j = idx % len(nums2)\n\n        result = append(result, []int{nums1[i], nums2[j]})\n\n        if i + 1 < len(nums1) && !visited[(i + 1) * len(nums2) + j] {\n            queue = append(queue, (i + 1) * len(nums2) + j)\n            visited[(i + 1) * len(nums2) + j] = true\n        }\n\n        if j + 1 < len(nums2) && !visited[i * len(nums2) + j + 1] {\n            queue = append(queue, i * len(nums2) + j + 1)\n            visited[i * len(nums2) + j + 1] = true\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122979,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp48xgykyz_test.go:59: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp48xgykyz_test.go:59: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=4)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n\n    var minHeap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if len(minHeap) < k {\n                minHeap = append(minHeap, []int{nums1[i], nums2[j]})\n            } else {\n                if nums1[i] + nums2[j] < minHeap[0][0] + minHeap[0][1] {\n                    minHeap[0] = []int{nums1[i], nums2[j]}\n                }\n            }\n            minHeapify(minHeap, 0)\n        }\n    }\n\n    return minHeap\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122979,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr636e86g_test.go:25:13: undefined: minHeapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] + nums2[0] < min || j == 0 {\n                min = nums1[j] + nums2[0]\n                min_index = j\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122979,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008c670, 0x0, 0x3, 0xc00008c668, 0x0, 0x0, 0x7, 0xc00013e048, 0x1, 0x1)\n\t/tmp/tmpx8l_z6e4_test.go:28 +0x43e\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000102600)\n\t/tmp/tmpx8l_z6e4_test.go:45 +0x2d2\ntesting.tRunner(0xc000102600, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[min_index]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = append(nums2[:min_index], nums2[min_index+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122979,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc0000c2e70, 0x0, 0x3, 0xc0000c2e58, 0x0, 0x3, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmp2_oz2wl7_test.go:28 +0x539\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmp2_oz2wl7_test.go:44 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min = nums1[0] + nums2[0]\n        var min_i = 0\n        var min_j = 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122979,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008c670, 0x0, 0x3, 0xc00008c658, 0x0, 0x3, 0x7, 0xc00013e048, 0x1, 0x1)\n\t/tmp/tmp0hdb92ak_test.go:18 +0x599\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000102600)\n\t/tmp/tmp0hdb92ak_test.go:46 +0x2d2\ntesting.tRunner(0xc000102600, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        result = append(result, []int{nums1[0], nums2[0]})\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            sum := nums1[i] + nums2[j]\n            for k := 0; k < len(result); k++ {\n                if sum < result[k][0] + result[k][1] {\n                    result = append(result[:k], append([][]int{[]int{nums1[i], nums2[j]}}, result[k:]...)...)\n                    break\n                }\n            }\n        }\n    }\n\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122980,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpqy8hhljq_test.go:53: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpqy8hhljq_test.go:53: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n    visited := make(map[int]bool)\n    visited[0] = true\n\n    for len(result) < k && len(queue) > 0 {\n        pair := queue[0]\n        queue = queue[1:]\n\n        result = append(result, []int{nums1[pair[0]], nums2[pair[1]]})\n\n        if pair[0] + 1 < len(nums1) && !visited[pair[0] + 1 + pair[1] * len(nums1)] {\n            queue = append(queue, []int{pair[0] + 1, pair[1], nums1[pair[0] + 1] + nums2[pair[1]]})\n            visited[pair[0] + 1 + pair[1] * len(nums1)] = true\n        }\n\n        if pair[1] + 1 < len(nums2) && !visited[pair[0] + (pair[1] + 1) * len(nums1)] {\n            queue = append(queue, []int{pair[0], pair[1] + 1, nums1[pair[0]] + nums2[pair[1] + 1]})\n            visited[pair[0] + (pair[1] + 1) * len(nums1)] = true\n        }\n\n        for i := 1; i < len(queue); i++ {\n            if queue[i][2] < queue[0][2] {\n                queue[i], queue[0] = queue[0], queue[i]\n            }\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122980,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpx7s3ohvu_test.go:61: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpx7s3ohvu_test.go:61: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return nil\n    }\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n    if k > len(result) {\n        return result\n    }\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122980,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    heap := make([]int, k)\n    for i := 0; i < k; i++ {\n        heap[i] = nums1[0] + nums2[i / len(nums1)]\n    }\n    for i := k / len(nums1) - 1; i >= 0; i-- {\n        heapify(heap, i, k)\n    }\n    for i := k; i < len(nums1) * len(nums2); i++ {\n        if nums1[i / len(nums2)] + nums2[i % len(nums2)] < heap[0] {\n            heap[0] = nums1[i / len(nums2)] + nums2[i % len(nums2)]\n            heapify(heap, 0, k)\n        }\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{nums1[i / len(nums2)], nums2[i % len(nums2)]}\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122980,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy628w8bp_test.go:21:9: undefined: heapify\n/tmp/tmpy628w8bp_test.go:26:13: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if len(result) == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                    break\n                } else {\n                    if nums1[j] + nums2[l] > result[len(result) - 1][0] + result[len(result) - 1][1] {\n                        continue\n                    } else {\n                        if nums1[j] + nums2[l] < min {\n                            min = nums1[j] + nums2[l]\n                            min_index = j\n                        }\n                    }\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums2 = nums2[1:]\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122980,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000092670, 0x3, 0x3, 0xc000092668, 0x0, 0x0, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmpa3f80qmu_test.go:40 +0x33d\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmpa3f80qmu_test.go:55 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return result\n    }\n\n    // init heap\n    heap := make([]int, len(nums1) * len(nums2))\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap[i * len(nums2) + j] = nums1[i] + nums2[j]\n        }\n    }\n\n    // build heap\n    for i := len(heap) / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, len(heap))\n    }\n\n    // extract min\n    for i := 0; i < k; i++ {\n        if i < len(heap) {\n            result = append(result, []int{heap[0] / 10, heap[0] % 10})\n            heap[0] = heap[len(heap) - 1]\n            heap = heap[:len(heap) - 1]\n            heapify(heap, 0, len(heap))\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122980,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu9j_7sy1_test.go:25:9: undefined: heapify\n/tmp/tmpu9j_7sy1_test.go:34:13: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[min_index]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = append(nums2[:min_index], nums2[min_index+1:]...)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122981,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00011ae70, 0x0, 0x3, 0xc00011ae58, 0x0, 0x3, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmp9_vndy3x_test.go:30 +0x545\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmp9_vndy3x_test.go:47 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var index int\n    var tmp int\n    var tmp_index int\n    var tmp_index2 int\n    var tmp_index3 int\n    var tmp_index4 int\n    var tmp_index5 int\n    var tmp_index6 int\n    var tmp_index7 int\n    var tmp_index8 int\n    var tmp_index9 int\n    var tmp_index10 int\n    var tmp_index11 int\n    var tmp_index12 int\n    var tmp_index13 int\n    var tmp_index14 int\n    var tmp_index15 int\n    var tmp_index16 int\n    var tmp_index17 int\n    var tmp_index18 int\n    var tmp_index19 int\n    var tmp_index20 int\n    var tmp_index21 int\n    var tmp_index22 int\n    var tmp_index23 int\n    var tmp_index24 int\n    var tmp_index25 int\n    var tmp_index26 int\n    var tmp_index27 int\n    var tmp_index28 int\n    var tmp_index29 int\n    var tmp_index30 int\n    var tmp_index31 int\n    var tmp_index32 int\n    var tmp_index33 int\n    var tmp_index34 int\n    var tmp_index35 int\n    var tmp_index36 int\n    var tmp_index37 int\n    var tmp_index38 int\n    var tmp_index39 int\n    var tmp_index40 int\n    var tmp_index41 int\n    var tmp_index42 int\n    var tmp_index43 int\n    var tmp_index44 int\n    var tmp_index45 int\n    var tmp_index46 int\n    var tmp_index47 int\n    var tmp_index48 int\n    var tmp_index49 int\n    var tmp_index50 int\n    var tmp_index51 int\n    var tmp_index52 int\n    var tmp_index53 int\n    var tmp_index54 int\n    var tmp_index55 int\n    var tmp_index56 int\n    var tmp_index57 int\n    var tmp_index\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122980,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpg3av1mjr_test.go:74:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = make([]int, 2)\n    }\n    // heap\n    heap := make([]int, k)\n    heap_size := 0\n    // map\n    m := make(map[int]int)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if heap_size < k {\n                heap[heap_size] = nums1[i] + nums2[j]\n                m[heap[heap_size]] = i * len(nums2) + j\n                heap_size++\n                if heap_size == k {\n                    build_heap(heap, heap_size)\n                }\n            } else {\n                if nums1[i] + nums2[j] < heap[0] {\n                    heap[0] = nums1[i] + nums2[j]\n                    m[heap[0]] = i * len(nums2) + j\n                    heapify(heap, 0, heap_size)\n                }\n            }\n        }\n    }\n    for i := k - 1; i >= 0; i-- {\n        result[i][0] = nums1[m[heap[0]] / len(nums2)]\n        result[i][1] = nums2[m[heap[0]] % len(nums2)]\n        heap[0] = heap[heap_size - 1]\n        heap_size--\n        heapify(heap, 0, heap_size)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122981,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3a8ga1b5_test.go:32:21: undefined: build_heap\n/tmp/tmp3a8ga1b5_test.go:38:21: undefined: heapify\n/tmp/tmp3a8ga1b5_test.go:48:9: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var heap [][]int\n    heap = append(heap, []int{nums1[0] + nums2[0], 0, 0})\n    for i := 0; i < k && len(heap) > 0; i++ {\n        pair := heap[0]\n        heap = heap[1:]\n        result = append(result, []int{nums1[pair[1]], nums2[pair[2]]})\n\n        if pair[1] + 1 < len(nums1) {\n            heap = append(heap, []int{nums1[pair[1] + 1] + nums2[pair[2]], pair[1] + 1, pair[2]})\n        }\n        if pair[1] == 0 && pair[2] + 1 < len(nums2) {\n            heap = append(heap, []int{nums1[pair[1]] + nums2[pair[2] + 1], pair[1], pair[2] + 1})\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122981,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmplnykf2yg_test.go:48: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmplnykf2yg_test.go:48: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=4)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[min_index]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122981,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008c670, 0x0, 0x3, 0xc00008c658, 0x3, 0x3, 0x7, 0xc00013e048, 0x1, 0x1)\n\t/tmp/tmpf56lmtn3_test.go:28 +0x412\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000102600)\n\t/tmp/tmpf56lmtn3_test.go:43 +0x2d2\ntesting.tRunner(0xc000102600, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        result = append(result, []int{})\n    }\n\n    var i, j int\n    for i < len(nums1) && j < len(nums2) {\n        if nums1[i] + nums2[j] < nums1[i] + nums2[j+1] {\n            for k := 0; k < len(result); k++ {\n                if len(result[k]) == 0 {\n                    result[k] = []int{nums1[i], nums2[j]}\n                    break\n                }\n            }\n            j++\n        } else {\n            for k := 0; k < len(result); k++ {\n                if len(result[k]) == 0 {\n                    result[k] = []int{nums1[i], nums2[j+1]}\n                    break\n                }\n            }\n            i++\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122981,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [3] with length 3 [recovered]\n\tpanic: runtime error: index out of range [3] with length 3\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008ce40, 0x3, 0x3, 0xc00008ce28, 0x3, 0x3, 0x2, 0x5826e3, 0xf, 0x0)\n\t/tmp/tmp5yflbwpw_test.go:25 +0x42c\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000186300)\n\t/tmp/tmp5yflbwpw_test.go:54 +0xfb\ntesting.tRunner(0xc000186300, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    for i := 0; i < len(nums1) && i < k; i++ {\n        for j := 0; j < len(nums2) && j < k; j++ {\n            if len(result) < k {\n                result = append(result, []int{nums1[i], nums2[j]})\n            } else {\n                if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                    result[k-1] = []int{nums1[i], nums2[j]}\n                }\n            }\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122981,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpmxw4lwdg_test.go:45: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var min_heap []int\n    var heap_size int\n    var heap_capacity int = k\n    var heap_index int\n    var heap_value int\n    var heap_value_index int\n    var heap_value_array_index int\n    var heap_value_array_index_max int\n    var heap_value_array_index_min int\n\n    heap_size = 0\n    heap_index = 0\n    heap_value_array_index_max = len(nums1) - 1\n    heap_value_array_index_min = 0\n\n    for heap_index < k && heap_value_array_index_min <= heap_value_array_index_max {\n        heap_value_array_index = heap_value_array_index_min\n        heap_value = nums1[heap_value_array_index] + nums2[0]\n        if heap_size < heap_capacity {\n            min_heap = append(min_heap, heap_value)\n            heap_size++\n        } else {\n            if heap_value < min_heap[0] {\n                min_heap[0] = heap_value\n            }\n        }\n\n        heap_value_array_index_min++\n        heap_index++\n    }\n\n    for heap_index < k && heap_value_array_index_min <= heap_value_array_index_max {\n        heap_value_array_index = heap_value_array_index_max\n        heap_value = nums1[heap_value_array_index] + nums2[0]\n        if heap_size < heap_capacity {\n            min_heap = append(min_heap, heap_value)\n            heap_size++\n        } else {\n            if heap_value < min_heap[0] {\n                min_heap[0] = heap_value\n            }\n        }\n\n        heap_value_array_index_max--\n        heap_index++\n    }\n\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122980,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpy77eqzsm_test.go:63:6: expected '(', found TestK_Smallest_Pairs\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if i == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_index = j * len(nums2) + l\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        min_index = j * len(nums2) + l\n                    }\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index / len(nums2)], nums2[min_index % len(nums2)]})\n        nums1[min_index / len(nums2)] = nums1[min_index / len(nums2)] + nums2[min_index % len(nums2)] + 1\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122981,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpsecwit0n_test.go:57: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=7) %!s(int=6)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__1 (0.00s)\n        tmpsecwit0n_test.go:57: expected '[[%!s(int=1) %!s(int=2)]]', got '[[%!s(int=7) %!s(int=6)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpsecwit0n_test.go:57: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=7) %!s(int=6)] [%!s(int=1) %!s(int=2)] [%!s(int=4) %!s(int=2)] [%!s(int=7) %!s(int=2)] [%!s(int=10) %!s(int=2)] [%!s(int=13) %!s(int=2)] [%!s(int=16) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var heap [][]int\n    var heap_size int\n    var heap_capacity int = k\n    var heap_top []int\n\n    heap = make([][]int, k)\n    heap_size = 0\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if heap_size < heap_capacity {\n                heap[heap_size] = []int{nums1[i], nums2[j]}\n                heap_size++\n                if heap_size == heap_capacity {\n                    build_heap(heap, heap_size)\n                }\n            } else {\n                heap_top = heap[0]\n                if nums1[i] + nums2[j] < heap_top[0] + heap_top[1] {\n                    heap[0] = []int{nums1[i], nums2[j]}\n                    heapify(heap, 0, heap_size)\n                }\n            }\n        }\n    }\n\n    for i := 0; i < heap_size; i++ {\n        result = append(result, heap[i])\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122981,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7zl900hs_test.go:29:21: undefined: build_heap\n/tmp/tmp7zl900hs_test.go:35:21: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[min_index]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = append(nums2[:min_index], nums2[min_index+1:]...)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122981,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00011ae70, 0x0, 0x3, 0xc00011ae58, 0x0, 0x3, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmp9_vndy3x_test.go:30 +0x545\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmp9_vndy3x_test.go:47 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n\n    var res [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n    for len(res) < k && len(queue) > 0 {\n        var pair []int\n        pair, queue = queue[0], queue[1:]\n        res = append(res, []int{nums1[pair[0]], nums2[pair[1]]})\n        if pair[0] + 1 < len(nums1) {\n            queue = append(queue, []int{pair[0] + 1, pair[1], nums1[pair[0] + 1] + nums2[pair[1]]})\n        }\n        if pair[0] == 0 && pair[1] + 1 < len(nums2) {\n            queue = append(queue, []int{pair[0], pair[1] + 1, nums1[pair[0]] + nums2[pair[1] + 1]})\n        }\n    }\n    return res\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122981,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpa5o4lbxb_test.go:46: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpa5o4lbxb_test.go:46: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=4)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var min_heap [][]int\n    var heap_size int\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if heap_size < k {\n                min_heap = append(min_heap, []int{nums1[i], nums2[j]})\n                heap_size++\n                if heap_size == k {\n                    build_min_heap(min_heap)\n                }\n            } else {\n                if nums1[i] + nums2[j] < min_heap[0][0] + min_heap[0][1] {\n                    min_heap[0] = []int{nums1[i], nums2[j]}\n                    min_heapify(min_heap, 0)\n                }\n            }\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        result = append(result, min_heap[0])\n        min_heap[0] = min_heap[heap_size - 1]\n        heap_size--\n        min_heapify(min_heap, 0)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122981,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzgqh_ko5_test.go:24:21: undefined: build_min_heap\n/tmp/tmpzgqh_ko5_test.go:29:21: undefined: min_heapify\n/tmp/tmpzgqh_ko5_test.go:39:9: undefined: min_heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122982,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_i := 0\n        min_j := 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122977,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000092670, 0x0, 0x3, 0xc000092658, 0x0, 0x3, 0x7, 0xc00000c048, 0x1, 0x1)\n\t/tmp/tmp4m06kswr_test.go:20 +0x5e5\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmp4m06kswr_test.go:48 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var min_heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            min_heap = append(min_heap, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        if len(min_heap) == 0 {\n            break\n        }\n\n        min_index := 0\n        for j := 1; j < len(min_heap); j++ {\n            if min_heap[j][0] + min_heap[j][1] < min_heap[min_index][0] + min_heap[min_index][1] {\n                min_index = j\n            }\n        }\n\n        result = append(result, min_heap[min_index])\n        min_heap = append(min_heap[:min_index], min_heap[min_index+1:]...)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122982,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n    for len(result) < k && len(queue) > 0 {\n        var pair []int\n        pair, queue = queue[0], queue[1:]\n        result = append(result, []int{nums1[pair[0]], nums2[pair[1]]})\n\n        if pair[0] + 1 < len(nums1) {\n            queue = append(queue, []int{pair[0] + 1, pair[1], nums1[pair[0] + 1] + nums2[pair[1]]})\n        }\n        if pair[1] + 1 < len(nums2) {\n            queue = append(queue, []int{pair[0], pair[1] + 1, nums1[pair[0]] + nums2[pair[1] + 1]})\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122982,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpnagiii9d_test.go:48: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpnagiii9d_test.go:48: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    res := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            res = append(res, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(res); i++ {\n        for j := i + 1; j < len(res); j++ {\n            if res[i][0] + res[i][1] > res[j][0] + res[j][1] {\n                res[i], res[j] = res[j], res[i]\n            }\n        }\n    }\n\n    if k > len(res) {\n        return res\n    }\n    return res[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122982,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        if len(heap) == 0 {\n            break\n        }\n        result = append(result, heap[0])\n        heap = heap[1:]\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122982,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpk0hud21o_test.go:48: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_i int\n        var min_j int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if j == 0 && l == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        min_i = j\n                        min_j = l\n                    }\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122982,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00011ae70, 0x0, 0x3, 0xc00011ae58, 0x0, 0x3, 0x7, 0xc00013e048, 0x1, 0x1)\n\t/tmp/tmp7y24kqt9_test.go:36 +0x5ad\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000102600)\n\t/tmp/tmp7y24kqt9_test.go:52 +0x2d2\ntesting.tRunner(0xc000102600, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n\n    for len(result) < k && len(queue) > 0 {\n        pair := queue[0]\n        queue = queue[1:]\n\n        result = append(result, []int{nums1[pair[0]], nums2[pair[1]]})\n\n        if pair[0] + 1 < len(nums1) {\n            queue = append(queue, []int{pair[0] + 1, pair[1], nums1[pair[0] + 1] + nums2[pair[1]]})\n        }\n        if pair[1] + 1 < len(nums2) {\n            queue = append(queue, []int{pair[0], pair[1] + 1, nums1[pair[0]] + nums2[pair[1] + 1]})\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122982,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpn1k4nyg7_test.go:50: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpn1k4nyg7_test.go:50: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if len(nums1) * len(nums2) < k {\n        k = len(nums1) * len(nums2)\n    }\n    var ret [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_i, min_j int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if j == 0 && l == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        min_i = j\n                        min_j = l\n                    }\n                }\n            }\n        }\n        ret = append(ret, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return ret\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122982,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc0000c2e70, 0x0, 0x3, 0xc0000c2e58, 0x0, 0x3, 0x7, 0xc00019a048, 0x1, 0x1)\n\t/tmp/tmp7yh4sgm2_test.go:35 +0x5ad\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000186300)\n\t/tmp/tmp7yh4sgm2_test.go:51 +0x2d2\ntesting.tRunner(0xc000186300, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n\n    // init heap\n    heap := make([]int, len(nums1) * len(nums2))\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap[i * len(nums2) + j] = nums1[i] + nums2[j]\n        }\n    }\n\n    // build heap\n    for i := len(heap) / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, len(heap))\n    }\n\n    // pop k smallest\n    for i := 0; i < k; i++ {\n        if len(heap) == 0 {\n            break\n        }\n        pop_heap(heap)\n    }\n\n    // get result\n    for i := 0; i < len(heap); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if heap[i] == nums1[i / len(nums2)] + nums2[j] {\n                result = append(result, []int{nums1[i / len(nums2)], nums2[j]})\n                break\n            }\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122982,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3wkbnh7f_test.go:25:9: undefined: heapify\n/tmp/tmp3wkbnh7f_test.go:33:9: undefined: pop_heap\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[min_index]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = append(nums2[:min_index], nums2[min_index+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122973,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc0000c2e70, 0x0, 0x3, 0xc0000c2e58, 0x0, 0x3, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmp2g1j1e9k_test.go:28 +0x545\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmp2g1j1e9k_test.go:44 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    heap := make([]int, k)\n    for i := 0; i < k; i++ {\n        heap[i] = nums1[0] + nums2[i / len(nums1)]\n    }\n    for i := k / len(nums1) - 1; i >= 0; i-- {\n        heapify(heap, i, k)\n    }\n    for i := k; i < len(nums1) * len(nums2); i++ {\n        if nums1[i / len(nums2)] + nums2[i % len(nums2)] < heap[0] {\n            heap[0] = nums1[i / len(nums2)] + nums2[i % len(nums2)]\n            heapify(heap, 0, k)\n        }\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{heap[i] - nums2[i / len(nums1)], nums2[i / len(nums1)]}\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122982,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1povo6z3_test.go:21:9: undefined: heapify\n/tmp/tmp1povo6z3_test.go:26:13: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k <= 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if len(result) < k {\n                result = append(result, []int{nums1[i], nums2[j]})\n            } else {\n                max := result[0][0] + result[0][1]\n                max_index := 0\n                for index, val := range result {\n                    if val[0] + val[1] > max {\n                        max = val[0] + val[1]\n                        max_index = index\n                    }\n                }\n                if nums1[i] + nums2[j] < max {\n                    result[max_index] = []int{nums1[i], nums2[j]}\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122982,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpozkf3y06_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        result = append(result, []int{nums1[0], nums2[0]})\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = []int{nums1[i], nums2[j]}\n                for l := k - 1; l > 0; l-- {\n                    if result[l][0] + result[l][1] < result[l-1][0] + result[l-1][1] {\n                        result[l], result[l-1] = result[l-1], result[l]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122977,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp2a3y4fwt_test.go:56: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp2a3y4fwt_test.go:56: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_i int\n        var min_j int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if j == 0 && l == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        min_i = j\n                        min_j = l\n                    }\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122982,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00011ae70, 0x0, 0x3, 0xc00011ae58, 0x0, 0x3, 0x7, 0xc00013e048, 0x1, 0x1)\n\t/tmp/tmp7y24kqt9_test.go:36 +0x5ad\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000102600)\n\t/tmp/tmp7y24kqt9_test.go:52 +0x2d2\ntesting.tRunner(0xc000102600, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        result = append(result, []int{nums1[0], nums2[0]})\n    }\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = []int{nums1[i], nums2[j]}\n                for m := k - 1; m > 0; m-- {\n                    if result[m][0] + result[m][1] < result[m-1][0] + result[m-1][1] {\n                        result[m], result[m-1] = result[m-1], result[m]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122982,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpuxruhjhj_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpuxruhjhj_test.go:52: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    // create a heap\n    heap := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    // sort the heap\n    for i := len(heap) - 1; i >= 0; i-- {\n        for j := 0; j < i; j++ {\n            if heap[j][0] + heap[j][1] > heap[j + 1][0] + heap[j + 1][1] {\n                heap[j], heap[j + 1] = heap[j + 1], heap[j]\n            }\n        }\n    }\n\n    // return the first k elements\n    if k > len(heap) {\n        k = len(heap)\n    }\n    return heap[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122982,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k <= 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        var min_index []int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = []int{j, l}\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index[0]], nums2[min_index[1]]})\n        nums2 = append(nums2[:min_index[1]], nums2[min_index[1]+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122983,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000092640, 0x3, 0x3, 0xc000092628, 0x3, 0x3, 0x2, 0x5826e3, 0xf, 0x0)\n\t/tmp/tmpi3a7shhe_test.go:32 +0x56d\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmpi3a7shhe_test.go:45 +0xfb\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var res [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return res\n    }\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n    heap = build_heap(heap)\n    for i := 0; i < k; i++ {\n        if len(heap) == 0 {\n            break\n        }\n        res = append(res, heap[0])\n        heap[0] = heap[len(heap)-1]\n        heap = heap[:len(heap)-1]\n        heap = heapify(heap, 0)\n    }\n    return res\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122983,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4hgb07sj_test.go:20:12: undefined: build_heap\n/tmp/tmp4hgb07sj_test.go:28:16: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := -1\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if min == -1 {\n                    min = nums1[j] + nums2[l]\n                    result = append(result, []int{nums1[j], nums2[l]})\n                } else {\n                    if nums1[j] + nums2[l] < min {\n                        min = nums1[j] + nums2[l]\n                        result[i] = []int{nums1[j], nums2[l]}\n                    }\n                }\n            }\n        }\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] == min {\n                    nums1 = append(nums1[:j], nums1[j+1:]...)\n                    nums2 = append(nums2[:l], nums2[l+1:]...)\n                    break\n                }\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122983,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp146_ynex_test.go:60: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=4)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp146_ynex_test.go:60: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=7) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var min int\n    var min_index int\n    var min_index_2 int\n    var min_index_2_count int\n    var min_index_2_count_max int\n    var min_index_2_count_max_index int\n    var min_index_2_count_max_index_2 int\n    var min_index_2_count_max_index_2_count int\n    var min_index_2_count_max_index_2_count_max int\n    var min_index_2_count_max_index_2_count_max_index int\n    var min_index_2_count_max_index_2_count_max_index_2 int\n    var min_index_2_count_max_index_2_count_max_index_2_count int\n    var min_index_2_count_max_index_2_count_max_index_2_count_max int\n    var min_index_2_count_max_index_2_count_max_index_2_count_max_index int\n    var min_index_2_count_max_index_2_count_max_index_2_count_max_index_2 int\n    var min_index_2_count_max_index_2_count_max_index_2_count_max_index_2_count int\n    var min_index_2_count_max_index_2_count_max_index_2_count_max_index_2_count_max int\n    var min_index_2_count_max_index_2_count_max_index_2_count_max_index_2_count_max_index int\n    var min_index_2_count_max_index_2_count_max_index_2_count_max_index_2_count_max_index_2 int\n    var min_index_2_count_max_index_2_count_max_index_2_count_max_index_2_count\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122982,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmppdpib41b_test.go:34:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var res [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            res = append(res, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(res); i++ {\n        for j := i + 1; j < len(res); j++ {\n            if res[i][0] + res[i][1] > res[j][0] + res[j][1] {\n                res[i], res[j] = res[j], res[i]\n            }\n        }\n    }\n\n    if k > len(res) {\n        return res\n    }\n\n    return res[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122983,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    var i, j int\n    var heap [][]int\n    var heap_size int\n    var heap_top []int\n    var heap_top_i, heap_top_j int\n    var heap_top_next_i, heap_top_next_j int\n    var heap_top_next []int\n    var heap_top_next_value int\n    var heap_top_value int\n    var heap_top_next_value_i, heap_top_next_value_j int\n\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return result\n    }\n\n    heap_size = 0\n    for i = 0; i < len(nums1); i++ {\n        for j = 0; j < len(nums2); j++ {\n            if heap_size < k {\n                heap = append(heap, []int{nums1[i], nums2[j], i, j})\n                heap_size++\n            } else {\n                heap_top = heap[0]\n                heap_top_value = heap_top[0] + heap_top[1]\n                heap_top_i = heap_top[2]\n                heap_top_j = heap_top[3]\n                if nums1[i] + nums2[j] < heap_top_value {\n                    heap_top_next_i = i\n                    heap_top_next_j = j\n                    heap_top_next_value = nums1[i] + nums2[j]\n                    heap_top_next = []int{nums1[i], nums2[j], i, j}\n                    heap[0] = heap_top_next\n                    heap_top_next_value_i = heap_top_next_i\n                    heap_top_next_value_j = heap_top_next_j\n                    for heap_top_next_value < heap_top_value {\n                        heap_top_next_i = (heap_top_next_i - 1) / 2\n                        heap_top_next_j = (heap_top_next_j\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122982,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpf8mqsxl0_test.go:47:59: expected ')', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n    for i := 0; i < k; i++ {\n        var temp []int\n        temp, queue = queue[0], queue[1:]\n        result = append(result, []int{nums1[temp[0]], nums2[temp[1]]})\n        if temp[0] + 1 < len(nums1) {\n            queue = append(queue, []int{temp[0] + 1, temp[1], nums1[temp[0] + 1] + nums2[temp[1]]})\n        }\n        if temp[0] == 0 && temp[1] + 1 < len(nums2) {\n            queue = append(queue, []int{temp[0], temp[1] + 1, nums1[temp[0]] + nums2[temp[1] + 1]})\n        }\n        for j := 0; j < len(queue) - 1; j++ {\n            if queue[j][2] > queue[j + 1][2] {\n                queue[j], queue[j + 1] = queue[j + 1], queue[j]\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122983,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp6xv7oitm_test.go:56: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp6xv7oitm_test.go:56: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if min == 0 {\n                    min = nums1[j] + nums2[l]\n                    min_index = j * len(nums2) + l\n                } else if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j * len(nums2) + l\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_index / len(nums2)], nums2[min_index % len(nums2)]})\n        nums1[min_index / len(nums2)] = 0\n        nums2[min_index % len(nums2)] = 0\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122983,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpaowregdl_test.go:53: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=0)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpaowregdl_test.go:53: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=0)] [%!s(int=0) %!s(int=4)] [%!s(int=0) %!s(int=6)] [%!s(int=7) %!s(int=0)] [%!s(int=0) %!s(int=0)] [%!s(int=0) %!s(int=0)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n    for len(result) < k && len(queue) > 0 {\n        var tmp []int\n        tmp, queue = queue[0], queue[1:]\n        result = append(result, []int{nums1[tmp[0]], nums2[tmp[1]]})\n        if tmp[0] + 1 < len(nums1) {\n            queue = append(queue, []int{tmp[0] + 1, tmp[1], nums1[tmp[0] + 1] + nums2[tmp[1]]})\n        }\n        if tmp[0] == 0 && tmp[1] + 1 < len(nums2) {\n            queue = append(queue, []int{tmp[0], tmp[1] + 1, nums1[tmp[0]] + nums2[tmp[1] + 1]})\n        }\n        for i := 1; i < len(queue); i++ {\n            if queue[i][2] < queue[i - 1][2] {\n                queue[i], queue[i - 1] = queue[i - 1], queue[i]\n            } else {\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122983,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpcpj659hy_test.go:53: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpcpj659hy_test.go:53: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n    for i := 0; i < k && len(queue) > 0; i++ {\n        var tmp = queue[0]\n        queue = queue[1:]\n        result = append(result, []int{nums1[tmp[0]], nums2[tmp[1]]})\n        if tmp[0] < len(nums1) - 1 {\n            queue = append(queue, []int{tmp[0] + 1, tmp[1], nums1[tmp[0] + 1] + nums2[tmp[1]]})\n        }\n        if tmp[0] == 0 && tmp[1] < len(nums2) - 1 {\n            queue = append(queue, []int{tmp[0], tmp[1] + 1, nums1[tmp[0]] + nums2[tmp[1] + 1]})\n        }\n        for j := i + 1; j < len(queue); j++ {\n            if queue[j][2] < queue[j - 1][2] {\n                queue[j], queue[j - 1] = queue[j - 1], queue[j]\n            } else {\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122983,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp9lu4jmnr_test.go:53: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp9lu4jmnr_test.go:53: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=4)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n\n    var minHeap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if len(minHeap) < k {\n                minHeap = append(minHeap, []int{nums1[i], nums2[j]})\n                if len(minHeap) == k {\n                    buildMinHeap(minHeap)\n                }\n            } else if nums1[i] + nums2[j] < minHeap[0][0] + minHeap[0][1] {\n                minHeap[0] = []int{nums1[i], nums2[j]}\n                minHeapify(minHeap, 0)\n            }\n        }\n    }\n    return minHeap\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122983,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg14q0c4f_test.go:21:21: undefined: buildMinHeap\n/tmp/tmpg14q0c4f_test.go:25:17: undefined: minHeapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    result := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    if k > len(result) {\n        return result\n    } else {\n        return result[:k]\n    }\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122984,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_index := 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_index = j * len(nums2) + l\n                }\n            }\n        }\n\n        result = append(result, []int{nums1[min_index / len(nums2)], nums2[min_index % len(nums2)]})\n        nums1[min_index / len(nums2)] = nums1[len(nums1) - 1]\n        nums1 = nums1[:len(nums1) - 1]\n        nums2[min_index % len(nums2)] = nums2[len(nums2) - 1]\n        nums2 = nums2[:len(nums2) - 1]\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122984,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000092670, 0x1, 0x3, 0xc000092658, 0x1, 0x3, 0x7, 0xc00000c048, 0x1, 0x1)\n\t/tmp/tmpf_cpdhz5_test.go:20 +0x34f\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmpf_cpdhz5_test.go:50 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return nil\n    }\n    if k == 0 {\n        return nil\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122984,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122984,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n\n    var heap [][]int\n    var heap_size int\n    var heap_push = func(nums []int) {\n        heap = append(heap, nums)\n        heap_size++\n        var i = heap_size - 1\n        for i > 0 {\n            var parent = (i - 1) / 2\n            if nums[0] + nums[1] >= heap[parent][0] + heap[parent][1] {\n                break\n            }\n            heap[i] = heap[parent]\n            i = parent\n        }\n        heap[i] = nums\n    }\n    var heap_pop = func() []int {\n        var result = heap[0]\n        heap_size--\n        heap[0] = heap[heap_size]\n        heap = heap[:heap_size]\n        var i, child int\n        for i = 0; i * 2 + 1 < heap_size; i = child {\n            child = i * 2 + 1\n            if child + 1 < heap_size && heap[child + 1][0] + heap[child + 1][1] < heap[child][0] + heap[child][1] {\n                child++\n            }\n            if heap[i][0] + heap[i][1] <= heap[child][0] + heap[child][1] {\n                break\n            }\n            heap[child], heap[i] = heap[i], heap[child]\n        }\n        return result\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if len(result) < k {\n                heap_push([]int{nums1[i], nums2[j]})\n            } else if nums1[i] + nums2[j] < heap[0][0] + heap[0][1] {\n                heap_pop()\n                heap_push([]int{nums1[i], nums2[j\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122983,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3r1pydqk_test.go:56:50: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var i, j int\n    for i < len(nums1) && j < len(nums2) && k > 0 {\n        if nums1[i] < nums2[j] {\n            result = append(result, []int{nums1[i], nums2[j]})\n            i++\n        } else {\n            result = append(result, []int{nums1[i], nums2[j]})\n            j++\n        }\n        k--\n    }\n\n    for i < len(nums1) && k > 0 {\n        result = append(result, []int{nums1[i], nums2[j-1]})\n        i++\n        k--\n    }\n\n    for j < len(nums2) && k > 0 {\n        result = append(result, []int{nums1[i-1], nums2[j]})\n        j++\n        k--\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122984,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp3855bvvc_test.go:57: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp3855bvvc_test.go:57: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=7) %!s(int=4)] [%!s(int=7) %!s(int=6)] [%!s(int=7) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue []*pair\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            queue = append(queue, &pair{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k && i < len(queue); i++ {\n        min := queue[0]\n        for j := 1; j < len(queue); j++ {\n            if queue[j].sum() < min.sum() {\n                min = queue[j]\n            }\n        }\n        result = append(result, []int{min.a, min.b})\n        queue = remove(queue, min)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122984,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn5xlq5tm_test.go:15:18: undefined: pair\n/tmp/tmpn5xlq5tm_test.go:18:36: undefined: pair\n/tmp/tmpn5xlq5tm_test.go:30:17: undefined: remove\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_i := 0\n        min_j := 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122984,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000092670, 0x0, 0x3, 0xc000092658, 0x0, 0x3, 0x7, 0xc00000c048, 0x1, 0x1)\n\t/tmp/tmpzbjkrfpu_test.go:18 +0x5e5\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmpzbjkrfpu_test.go:46 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    var queue []*pair\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            queue = append(queue, &pair{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        min := queue[0]\n        for j := 1; j < len(queue); j++ {\n            if queue[j].sum() < min.sum() {\n                min = queue[j]\n            }\n        }\n        result = append(result, []int{min.a, min.b})\n        queue = remove(queue, min)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122984,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg8w7fhw4_test.go:19:18: undefined: pair\n/tmp/tmpg8w7fhw4_test.go:22:36: undefined: pair\n/tmp/tmpg8w7fhw4_test.go:34:17: undefined: remove\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue = make([][]int, 0)\n    var visited = make(map[int]bool)\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n    visited[0] = true\n\n    for len(result) < k && len(queue) > 0 {\n        var cur = queue[0]\n        queue = queue[1:]\n        result = append(result, []int{nums1[cur[0]], nums2[cur[1]]})\n\n        if cur[0] + 1 < len(nums1) && !visited[cur[0] + 1] {\n            visited[cur[0] + 1] = true\n            queue = append(queue, []int{cur[0] + 1, cur[1], nums1[cur[0] + 1] + nums2[cur[1]]})\n        }\n        if cur[1] + 1 < len(nums2) && !visited[cur[1] + 1] {\n            visited[cur[1] + 1] = true\n            queue = append(queue, []int{cur[0], cur[1] + 1, nums1[cur[0]] + nums2[cur[1] + 1]})\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122984,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpw2e30y0d_test.go:56: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpw2e30y0d_test.go:56: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=7) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue []int\n    var visited map[int]bool = make(map[int]bool)\n    var heapify func([]int, int)\n    var heap_pop func() int\n    var heap_push func(int)\n\n    heapify = func(a []int, i int) {\n        l := i * 2 + 1\n        r := i * 2 + 2\n        largest := i\n        if l < len(a) && a[l] > a[largest] {\n            largest = l\n        }\n        if r < len(a) && a[r] > a[largest] {\n            largest = r\n        }\n        if largest != i {\n            a[i], a[largest] = a[largest], a[i]\n            heapify(a, largest)\n        }\n    }\n\n    heap_pop = func() int {\n        if len(queue) == 0 {\n            return -1\n        }\n        result := queue[0]\n        queue[0] = queue[len(queue) - 1]\n        queue = queue[:len(queue) - 1]\n        heapify(queue, 0)\n        return result\n    }\n\n    heap_push = func(v int) {\n        queue = append(queue, v)\n        i := len(queue) - 1\n        for i > 0 {\n            p := (i - 1) / 2\n            if queue[p] < queue[i] {\n                queue[p], queue[i] = queue[i], queue[p]\n                i = p\n            } else {\n                break\n            }\n        }\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if len(result) < k {\n                result = append(result, []int{nums1[i], nums2[j]})\n            } else {\n                if nums1[i] + nums2[j] < result[0\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122984,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp43vd3af5_test.go:67:50: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k <= 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{nums1[0], nums2[0]}\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                result[k-1] = []int{nums1[i], nums2[j]}\n                for l := k - 1; l > 0; l-- {\n                    if result[l][0] + result[l][1] < result[l-1][0] + result[l-1][1] {\n                        result[l], result[l-1] = result[l-1], result[l]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122984,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpvqrhij8g_test.go:54: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpvqrhij8g_test.go:54: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, k)\n    for i := 0; i < k; i++ {\n        result[i] = []int{}\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if len(result[k-1]) == 0 || nums1[i] + nums2[j] < result[k-1][0] + result[k-1][1] {\n                for l := k - 2; l >= 0; l-- {\n                    if len(result[l]) == 0 || nums1[i] + nums2[j] > result[l][0] + result[l][1] {\n                        result[l+1] = []int{nums1[i], nums2[j]}\n                        break\n                    } else {\n                        result[l+1] = result[l]\n                    }\n                }\n                if len(result[0]) == 0 || nums1[i] + nums2[j] < result[0][0] + result[0][1] {\n                    result[0] = []int{nums1[i], nums2[j]}\n                }\n            }\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122984,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp095n0p6c_test.go:59: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp095n0p6c_test.go:59: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [] [] [] [] [] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        result = append(result, []int{nums1[0], nums2[0]})\n    }\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if nums1[i] + nums2[j] < result[k - 1][0] + result[k - 1][1] {\n                result[k - 1] = []int{nums1[i], nums2[j]}\n                for l := k - 1; l > 0; l-- {\n                    if result[l][0] + result[l][1] < result[l - 1][0] + result[l - 1][1] {\n                        result[l], result[l - 1] = result[l - 1], result[l]\n                    } else {\n                        break\n                    }\n                }\n            }\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122984,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpc4xj1wkc_test.go:56: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpc4xj1wkc_test.go:56: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var res [][]int\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return res\n    }\n\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    heap_sort(heap)\n    for i := 0; i < k && i < len(heap); i++ {\n        res = append(res, heap[i])\n    }\n    return res\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122984,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl3il475w_test.go:22:5: undefined: heap_sort\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    var result [][]int\n    var queue [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            queue = append(queue, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        if i >= len(queue) {\n            break\n        }\n        min := i\n        for j := i + 1; j < len(queue); j++ {\n            if queue[j][0] + queue[j][1] < queue[min][0] + queue[min][1] {\n                min = j\n            }\n        }\n        queue[i], queue[min] = queue[min], queue[i]\n        result = append(result, queue[i])\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122985,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122985,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpbs110xig_test.go:39: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)] [%!s(int=7) %!s(int=4)] [%!s(int=7) %!s(int=6)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__1 (0.00s)\n        tmpbs110xig_test.go:39: expected '[[%!s(int=1) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)] [%!s(int=7) %!s(int=4)] [%!s(int=7) %!s(int=6)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpbs110xig_test.go:39: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)] [%!s(int=7) %!s(int=4)] [%!s(int=7) %!s(int=6)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    var p1, p2 int\n    for i := 0; i < k; i++ {\n        if p1 == len(nums1) {\n            p2++\n        } else if p2 == len(nums2) {\n            p1++\n        } else {\n            if nums1[p1] < nums2[p2] {\n                p1++\n            } else {\n                p2++\n            }\n        }\n    }\n    for i := 0; i < p1; i++ {\n        for j := 0; j < p2; j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122985,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [3] with length 3 [recovered]\n\tpanic: runtime error: index out of range [3] with length 3\n\ngoroutine 33 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc0001c8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000182480)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc0001c8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc0001c4670, 0x3, 0x3, 0xc0001c4658, 0x3, 0x3, 0x7, 0x0, 0x0, 0x0)\n\t/tmp/tmp8l11p900_test.go:36 +0x30e\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000182480)\n\t/tmp/tmp8l11p900_test.go:51 +0x2d2\ntesting.tRunner(0xc000182480, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var pq = make(PriorityQueue, 0)\n    heap.Init(&pq)\n\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap.Push(&pq, &Item{\n                value: nums1[i] + nums2[j],\n                index: []int{i, j},\n            })\n        }\n    }\n\n    for i := 0; i < k && pq.Len() > 0; i++ {\n        item := heap.Pop(&pq).(*Item)\n        result = append(result, item.index)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122985,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa8tblutn_test.go:15:19: undefined: PriorityQueue\n/tmp/tmpa8tblutn_test.go:16:5: undefined: heap\n/tmp/tmpa8tblutn_test.go:20:13: undefined: heap\n/tmp/tmpa8tblutn_test.go:20:29: undefined: Item\n/tmp/tmpa8tblutn_test.go:28:17: undefined: heap\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return result\n    }\n\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        heap = append(heap, []int{nums1[i] + nums2[0], i, 0})\n    }\n\n    for i := 0; i < k && i < len(nums1) * len(nums2); i++ {\n        result = append(result, []int{heap[0][0] - heap[0][2], heap[0][1]})\n        if heap[0][2] == len(nums2) - 1 {\n            heap[0] = heap[len(heap) - 1]\n            heap = heap[:len(heap) - 1]\n        } else {\n            heap[0] = []int{heap[0][0] - heap[0][2] + 1, heap[0][1], heap[0][2] + 1}\n        }\n        adjust_heap(heap)\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122985,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwewlwe5__test.go:28:9: undefined: adjust_heap\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 || k == 0 {\n        return [][]int{}\n    }\n\n    result := [][]int{}\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    if k > len(result) {\n        return result\n    } else {\n        return result[:k]\n    }\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122985,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    var tmp []int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            tmp = []int{nums1[i], nums2[j]}\n            result = append(result, tmp)\n        }\n    }\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122985,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] + nums2[0] < min || j == 0 {\n                min = nums1[j] + nums2[0]\n                min_index = j\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122985,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000092670, 0x0, 0x3, 0xc000092668, 0x0, 0x0, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmps4bwc3cl_test.go:26 +0x43e\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmps4bwc3cl_test.go:42 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var queue [][]int\n    queue = append(queue, []int{0, 0, nums1[0] + nums2[0]})\n    for len(result) < k && len(queue) > 0 {\n        var pair []int\n        pair, queue = queue[0], queue[1:]\n        result = append(result, []int{nums1[pair[0]], nums2[pair[1]]})\n        if pair[0] + 1 < len(nums1) {\n            queue = append(queue, []int{pair[0] + 1, pair[1], nums1[pair[0] + 1] + nums2[pair[1]]})\n        }\n        if pair[0] == 0 && pair[1] + 1 < len(nums2) {\n            queue = append(queue, []int{pair[0], pair[1] + 1, nums1[pair[0]] + nums2[pair[1] + 1]})\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122985,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpyh787tba_test.go:46: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpyh787tba_test.go:46: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=4)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var res [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            res = append(res, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(res); i++ {\n        for j := i + 1; j < len(res); j++ {\n            if res[i][0] + res[i][1] > res[j][0] + res[j][1] {\n                res[i], res[j] = res[j], res[i]\n            }\n        }\n    }\n\n    if k > len(res) {\n        k = len(res)\n    }\n    return res[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122985,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var ret [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return ret\n    }\n\n    var heap = make([]int, 0)\n    var heap_index = make([]int, 0)\n    var heap_index_map = make(map[int]int)\n    var heap_index_map_reverse = make(map[int]int)\n    var heap_index_map_size = 0\n    var heap_size = 0\n\n    var push = func(index int) {\n        heap = append(heap, index)\n        heap_index = append(heap_index, index)\n        heap_index_map[index] = heap_index_map_size\n        heap_index_map_reverse[heap_index_map_size] = index\n        heap_index_map_size++\n        heap_size++\n        var i = heap_size - 1\n        for i > 0 {\n            var parent = (i - 1) / 2\n            if nums1[heap_index[i]] + nums2[heap_index[i]] < nums1[heap_index[parent]] + nums2[heap_index[parent]] {\n                heap_index[i], heap_index[parent] = heap_index[parent], heap_index[i]\n                heap_index_map[heap_index[i]], heap_index_map[heap_index[parent]] = heap_index_map[heap_index[parent]], heap_index_map[heap_index[i]]\n                heap_index_map_reverse[heap_index_map[heap_index[i]]], heap_index_map_reverse[heap_index_map[heap_index[parent]]] = heap_index_map_reverse[heap_index_map[heap_index[parent]]], heap_index_map_reverse[heap_index_map[heap_index[i]]]\n                i = parent\n            } else {\n                break\n            }\n        }\n    }\n\n    var pop = func() int {\n        var ret = heap_index[0]\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122985,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpvcofe7_p_test.go:46:6: expected '(', found TestK_Smallest_Pairs\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := nums1[0] + nums2[0]\n        min_i := 0\n        min_j := 0\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        result = append(result, []int{nums1[min_i], nums2[min_j]})\n        nums1 = append(nums1[:min_i], nums1[min_i+1:]...)\n        nums2 = append(nums2[:min_j], nums2[min_j+1:]...)\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122984,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000092670, 0x0, 0x3, 0xc000092658, 0x0, 0x3, 0x7, 0xc00000c048, 0x1, 0x1)\n\t/tmp/tmpzbjkrfpu_test.go:18 +0x5e5\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmpzbjkrfpu_test.go:46 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return result\n    }\n\n    var heap [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            heap = append(heap, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < k; i++ {\n        if len(heap) == 0 {\n            break\n        }\n        result = append(result, heap[0])\n        heap = heap[1:]\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122982,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpk0hud21o_test.go:48: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    // init heap\n    heap := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            if len(heap) < k {\n                heap = append(heap, []int{nums1[i], nums2[j]})\n                if len(heap) == k {\n                    heap = build_heap(heap)\n                }\n            } else {\n                if nums1[i] + nums2[j] < heap[0][0] + heap[0][1] {\n                    heap[0] = []int{nums1[i], nums2[j]}\n                    heap = heapify(heap, 0)\n                }\n            }\n        }\n    }\n\n    return heap\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122985,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprxezpvlk_test.go:25:28: undefined: build_heap\n/tmp/tmprxezpvlk_test.go:30:28: undefined: heapify\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n\n    if len(result) < k {\n        return result\n    }\n\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122985,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var result [][]int\n    var heap [][]int\n    heap = append(heap, []int{nums1[0] + nums2[0], 0, 0})\n    for i := 0; i < k && len(heap) > 0; i++ {\n        pair := heap[0]\n        heap = heap[1:]\n        result = append(result, []int{nums1[pair[1]], nums2[pair[2]]})\n        if pair[1] + 1 < len(nums1) {\n            heap = append(heap, []int{nums1[pair[1] + 1] + nums2[pair[2]], pair[1] + 1, pair[2]})\n        }\n        if pair[1] == 0 && pair[2] + 1 < len(nums2) {\n            heap = append(heap, []int{nums1[pair[1]] + nums2[pair[2] + 1], pair[1], pair[2] + 1})\n        }\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122985,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmp1kxqjrls_test.go:46: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmp1kxqjrls_test.go:46: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=7) %!s(int=2)] [%!s(int=3) %!s(int=4)] [%!s(int=1) %!s(int=6)] [%!s(int=7) %!s(int=4)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < k; i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510125,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    result := make([][]int, 0)\n    for i := 0; i < len(nums1); i++ {\n        for j := 0; j < len(nums2); j++ {\n            result = append(result, []int{nums1[i], nums2[j]})\n        }\n    }\n    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0] + result[i][1] > result[j][0] + result[j][1] {\n                result[i], result[j] = result[j], result[i]\n            }\n        }\n    }\n    return result[:k]\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122977,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n\n    var result [][]int\n    var indexs []int\n    for i := 0; i < len(nums1); i++ {\n        indexs = append(indexs, 0)\n    }\n\n    for i := 0; i < k; i++ {\n        var min = nums1[0] + nums2[0]\n        var min_index = 0\n        for j := 0; j < len(nums1); j++ {\n            if indexs[j] < len(nums2) && nums1[j] + nums2[indexs[j]] < min {\n                min = nums1[j] + nums2[indexs[j]]\n                min_index = j\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[indexs[min_index]]})\n        indexs[min_index]++\n    }\n\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122985,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [3] with length 3 [recovered]\n\tpanic: runtime error: index out of range [3] with length 3\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000158000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000158000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00011ae70, 0x3, 0x3, 0xc00011ae58, 0x3, 0x3, 0x7, 0xc00013e048, 0x1, 0x1)\n\t/tmp/tmp3wxah57u_test.go:33 +0x3b6\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000102600)\n\t/tmp/tmp3wxah57u_test.go:49 +0x2d2\ntesting.tRunner(0xc000102600, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    res := make([][]int, 0, k)\n    for i := 0; i < k; i++ {\n        min := int(^uint(0) >> 1)\n        var min_i, min_j int\n        for j := 0; j < len(nums1); j++ {\n            for l := 0; l < len(nums2); l++ {\n                if nums1[j] + nums2[l] < min {\n                    min = nums1[j] + nums2[l]\n                    min_i = j\n                    min_j = l\n                }\n            }\n        }\n        res = append(res, []int{nums1[min_i], nums2[min_j]})\n        nums1[min_i] = int(^uint(0) >> 1)\n        nums2[min_j] = int(^uint(0) >> 1)\n    }\n    return res\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122985,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\n    --- FAIL: TestK_Smallest_Pairs/test_num__0 (0.00s)\n        tmpkaj7mz7__test.go:51: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=9223372036854775807)]]'\n    --- FAIL: TestK_Smallest_Pairs/test_num__2 (0.00s)\n        tmpkaj7mz7__test.go:51: expected '[[%!s(int=1) %!s(int=2)] [%!s(int=1) %!s(int=4)] [%!s(int=3) %!s(int=2)] [%!s(int=1) %!s(int=6)] [%!s(int=3) %!s(int=4)] [%!s(int=3) %!s(int=6)] [%!s(int=7) %!s(int=2)]]', got '[[%!s(int=1) %!s(int=2)] [%!s(int=3) %!s(int=9223372036854775807)] [%!s(int=9223372036854775807) %!s(int=4)] [%!s(int=9223372036854775807) %!s(int=6)] [%!s(int=7) %!s(int=9223372036854775807)] [%!s(int=9223372036854775807) %!s(int=9223372036854775807)] [%!s(int=9223372036854775807) %!s(int=9223372036854775807)]]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var res [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] + nums2[0] < min {\n                min = nums1[j] + nums2[0]\n                min_index = j\n            }\n        }\n        res = append(res, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return res\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122985,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc000016468)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc000092670, 0x0, 0x3, 0xc000092668, 0x0, 0x0, 0x7, 0xc00000c060, 0x1, 0x1)\n\t/tmp/tmp4jkw9u2i_test.go:29 +0x46d\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000001380)\n\t/tmp/tmp4jkw9u2i_test.go:45 +0x2d2\ntesting.tRunner(0xc000001380, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    var result [][]int\n    var min int\n    var min_index int\n    var min_index_2 int\n    var min_index_2_set bool\n    var min_index_2_set_count int\n    var min_index_2_set_count_max int\n    var min_index_2_set_count_max_index int\n    var min_index_2_set_count_max_index_2 int\n    var min_index_2_set_count_max_index_2_set bool\n    var min_index_2_set_count_max_index_2_set_count int\n    var min_index_2_set_count_max_index_2_set_count_max int\n    var min_index_2_set_count_max_index_2_set_count_max_index int\n    var min_index_2_set_count_max_index_2_set_count_max_index_2 int\n    var min_index_2_set_count_max_index_2_set_count_max_index_2_set bool\n    var min_index_2_set_count_max_index_2_set_count_max_index_2_set_count int\n    var min_index_2_set_count_max_index_2_set_count_max_index_2_set_count_max int\n    var min_index_2_set_count_max_index_2_set_count_max_index_2_set_count_max_index int\n    var min_index_2_set_count_max_index_2_set_count_max_index_2_set_count_max_index_2 int\n    var min_index_2_set_count_max_index_2_set_count_max_index_2_set_count_max_index_2_set bool\n    var min_index_2_set_count_max_index_2_set_count_max_index_2_set_count_max_index_2_set_count int\n    var min_index_2_set_count_max_index_2_set_count_max\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122985,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpzejygadi_test.go:31:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n    if k == 0 {\n        return [][]int{}\n    }\n    if k > len(nums1) * len(nums2) {\n        k = len(nums1) * len(nums2)\n    }\n    var result [][]int\n    for i := 0; i < k; i++ {\n        var min int\n        var min_index int\n        for j := 0; j < len(nums1); j++ {\n            if nums1[j] + nums2[0] < min || j == 0 {\n                min = nums1[j] + nums2[0]\n                min_index = j\n            }\n        }\n        result = append(result, []int{nums1[min_index], nums2[0]})\n        nums1 = append(nums1[:min_index], nums1[min_index+1:]...)\n        nums2 = nums2[1:]\n    }\n    return result\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122979,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc0001c4000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc0001a0300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc0001c4000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00008c670, 0x0, 0x3, 0xc00008c668, 0x0, 0x0, 0x7, 0xc0001ae048, 0x1, 0x1)\n\t/tmp/tmprgna64a2_test.go:29 +0x46d\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc0001a0300)\n\t/tmp/tmprgna64a2_test.go:45 +0x2d2\ntesting.tRunner(0xc0001a0300, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package k_smallest_pairs_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1 []int, nums2 []int, k int) [][]int {\n    if len(nums1) == 0 || len(nums2) == 0 {\n        return [][]int{}\n    }\n\n    var res [][]int\n    var i, j int\n    for i < len(nums1) && j < len(nums2) && k > 0 {\n        if nums1[i] < nums2[j] {\n            res = append(res, []int{nums1[i], nums2[j]})\n            i++\n        } else {\n            res = append(res, []int{nums1[i], nums2[j]})\n            j++\n        }\n        k--\n    }\n\n    for i < len(nums1) && k > 0 {\n        res = append(res, []int{nums1[i], nums2[j]})\n        i++\n        k--\n    }\n\n    for j < len(nums2) && k > 0 {\n        res = append(res, []int{nums1[i], nums2[j]})\n        j++\n        k--\n    }\n\n    return res\n}\n\nfunc TestK_Smallest_Pairs(t *testing.T) {\n  candidate := k_smallest_pairs\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 2), expected: [][]int{[]int{1, 2}, []int{1, 4}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 1), expected: [][]int{[]int{1, 2}} },\n     { actual: candidate([]int{1, 3, 7}, []int{2, 4, 6}, 7), expected: [][]int{[]int{1, 2}, []int{1, 4}, []int{3, 2}, []int{1, 6}, []int{3, 4}, []int{3, 6}, []int{7, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122985,
      "stdout": "--- FAIL: TestK_Smallest_Pairs (0.00s)\npanic: runtime error: index out of range [3] with length 3 [recovered]\n\tpanic: runtime error: index out of range [3] with length 3\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536520, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536520, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.k_smallest_pairs(0xc00011ae70, 0x3, 0x3, 0xc00011ae58, 0x3, 0x3, 0x7, 0xc00019a048, 0x1, 0x1)\n\t/tmp/tmptefwpe2y_test.go:28 +0x6d0\ncommand-line-arguments_test.TestK_Smallest_Pairs(0xc000186300)\n\t/tmp/tmptefwpe2y_test.go:51 +0x2d2\ntesting.tRunner(0xc000186300, 0x54f3e8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}