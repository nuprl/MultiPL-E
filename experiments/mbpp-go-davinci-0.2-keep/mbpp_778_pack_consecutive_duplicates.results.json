{
  "name": "mbpp_778_pack_consecutive_duplicates",
  "language": "go_test.go",
  "prompt": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_778_pack_consecutive_duplicates.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return []interface{}{}\n        }\n        if len(list) == 1 {\n            return []interface{}{list}\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpf7fa0g3s_test.go:47:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var last interface{}\n        for _, item := range list {\n            if last == nil {\n                sublist = append(sublist, item)\n                last = item\n            } else if item == last {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n                last = item\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case string:\n        list := list1.(string)\n        if len(list) == 0 {\n            return list\n        }\n        var result string\n        var sublist string\n        var last rune\n        for _, item := range list {\n            if last == 0 {\n                sublist = sublist + string(item)\n                last = item\n            } else if item == last {\n                sublist = sublist + string(item)\n            } else {\n                result = result + sublist\n                sublist = string(item)\n                last = item\n            }\n        }\n        result = result + sublist\n        return result\n    }\n    return list1\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsx34z9jo_test.go:68:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        result := []interface{}{}\n        for i := 0; i < len(list); i++ {\n            sublist := []string{}\n            for j := i; j < len(list); j++ {\n                if list[i] == list[j] {\n                    sublist = append(sublist, list[j])\n                } else {\n                    break\n                }\n            }\n            result = append(result, sublist)\n            i += len(sublist) - 1\n        }\n        return result\n    case []int:\n        list := list1.([]int)\n        result := []interface{}{}\n        for i := 0; i < len(list); i++ {\n            sublist := []int{}\n            for j := i; j < len(list); j++ {\n                if list[i] == list[j] {\n                    sublist = append(sublist, list[j])\n                } else {\n                    break\n                }\n            }\n            result = append(result, sublist)\n            i += len(sublist) - 1\n        }\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1kt18znf_test.go:57:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpch3laa9k_test.go:57:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        var list2 []interface{}\n        var sublist []interface{}\n        for _, v := range list1.([]interface{}) {\n            if len(sublist) == 0 || sublist[0] == v {\n                sublist = append(sublist, v)\n            } else {\n                list2 = append(list2, sublist)\n                sublist = []interface{}{v}\n            }\n        }\n        list2 = append(list2, sublist)\n        return list2\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxbe3p9yd_test.go:38:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var temp []interface{}\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = nil\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprloy0uy0_test.go:44:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := []interface{}{}\n        current := list[0]\n        count := 1\n        for i := 1; i < len(list); i++ {\n            if list[i] == current {\n                count++\n            } else {\n                result = append(result, []interface{}{current, count})\n                current = list[i]\n                count = 1\n            }\n        }\n        result = append(result, []interface{}{current, count})\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpokaa707f_test.go:44:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case string:\n        list := list1.(string)\n        if len(list) == 0 {\n            return list\n        }\n        var result string\n        var sublist string\n        for i, v := range list {\n            if i == 0 {\n                sublist = string(v)\n            } else {\n                if v == rune(list[i-1]) {\n                    sublist = sublist + string(v)\n                } else {\n                    result = result + sublist\n                    sublist = string(v)\n                }\n            }\n        }\n        result = result + sublist\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1y7vml85_test.go:67:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return nil\n        }\n        result := make([][]int, 0)\n        temp := make([]int, 0)\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 || temp[0] == list[i] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]int, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return nil\n        }\n        result := make([][]string, 0)\n        temp := make([]string, 0)\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 || temp[0] == list[i] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]string, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2wc0fntk_test.go:61:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510449,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu3hj4pyu_test.go:61:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    var list2 []interface{}\n    var list3 []interface{}\n    var list4 []interface{}\n    var list5 []interface{}\n    var list6 []interface{}\n    var list7 []interface{}\n    var list8 []interface{}\n    var list9 []interface{}\n    var list10 []interface{}\n    var list11 []interface{}\n    var list12 []interface{}\n    var list13 []interface{}\n    var list14 []interface{}\n    var list15 []interface{}\n    var list16 []interface{}\n    var list17 []interface{}\n    var list18 []interface{}\n    var list19 []interface{}\n    var list20 []interface{}\n    var list21 []interface{}\n    var list22 []interface{}\n    var list23 []interface{}\n    var list24 []interface{}\n    var list25 []interface{}\n    var list26 []interface{}\n    var list27 []interface{}\n    var list28 []interface{}\n    var list29 []interface{}\n    var list30 []interface{}\n    var list31 []interface{}\n    var list32 []interface{}\n    var list33 []interface{}\n    var list34 []interface{}\n    var list35 []interface{}\n    var list36 []interface{}\n    var list37 []interface{}\n    var list38 []interface{}\n    var list39 []interface{}\n    var list40 []interface{}\n    var list41 []interface{}\n    var list42 []interface{}\n    var list43 []interface{}\n    var list44 []interface{}\n    var list45 []interface{}\n    var list46 []interface{}\n    var list47 []interface{}\n    var list48 []interface{}\n    var list49 []interface{}\n    var list50 []interface{}\n    var list51 []interface{}\n    var list52 []interface{}\n    var list53 []interface{}\n    var list54 []interface{}\n    var list55 []interface{}\n    var list56 []interface{}\n    var list57 []interface{}\n    var list58 []interface{\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510448,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptq1imtvt_test.go:67:1: expected '}', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return []interface{}{}\n        }\n        result := []interface{}{}\n        sublist := []interface{}{list[0]}\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case string:\n        list := list1.(string)\n        if len(list) == 0 {\n            return \"\"\n        }\n        result := \"\"\n        sublist := string(list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist += string(list[i])\n            } else {\n                result += sublist\n                sublist = string(list[i])\n            }\n        }\n        result += sublist\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnd50nrpm_test.go:59:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        temp := make([]string, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]string, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        temp := make([]int, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]int, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpm3s5ww6h_test.go:63:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        result := []interface{}{}\n        for i := 0; i < len(list); i++ {\n            sublist := []string{}\n            sublist = append(sublist, list[i])\n            for j := i + 1; j < len(list); j++ {\n                if list[i] == list[j] {\n                    sublist = append(sublist, list[j])\n                    i++\n                } else {\n                    break\n                }\n            }\n            result = append(result, sublist)\n        }\n        return result\n    case []int:\n        list := list1.([]int)\n        result := []interface{}{}\n        for i := 0; i < len(list); i++ {\n            sublist := []int{}\n            sublist = append(sublist, list[i])\n            for j := i + 1; j < len(list); j++ {\n                if list[i] == list[j] {\n                    sublist = append(sublist, list[j])\n                    i++\n                } else {\n                    break\n                }\n            }\n            result = append(result, sublist)\n        }\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6v5lfd2e_test.go:59:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        var list2 []interface{}\n        var list3 []interface{}\n        for _, v := range list1.([]interface{}) {\n            if len(list3) == 0 || list3[0] == v {\n                list3 = append(list3, v)\n            } else {\n                list2 = append(list2, list3)\n                list3 = []interface{}{v}\n            }\n        }\n        if len(list3) > 0 {\n            list2 = append(list2, list3)\n        }\n        return list2\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510449,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpw2mdau1m_test.go:40:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var prev interface{}\n        for _, item := range list {\n            if prev == nil {\n                sublist = append(sublist, item)\n            } else if prev == item {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n            }\n            prev = item\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppjm2tyl2_test.go:46:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        var list2 []interface{}\n        var sublist []interface{}\n        for _, v := range list1.([]interface{}) {\n            if len(sublist) == 0 || sublist[0] == v {\n                sublist = append(sublist, v)\n            } else {\n                list2 = append(list2, sublist)\n                sublist = []interface{}{v}\n            }\n        }\n        if len(sublist) > 0 {\n            list2 = append(list2, sublist)\n        }\n        return list2\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4i2l2vb5_test.go:40:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpedef3bdi_test.go:44:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := []interface{}{}\n        current := list[0]\n        count := 1\n        for i := 1; i < len(list); i++ {\n            if list[i] == current {\n                count++\n            } else {\n                result = append(result, []interface{}{current, count})\n                current = list[i]\n                count = 1\n            }\n        }\n        result = append(result, []interface{}{current, count})\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpokaa707f_test.go:44:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        result := make([][]string, 0)\n        for i := 0; i < len(list); i++ {\n            sublist := make([]string, 0)\n            sublist = append(sublist, list[i])\n            for j := i + 1; j < len(list); j++ {\n                if list[i] == list[j] {\n                    sublist = append(sublist, list[j])\n                    i++\n                } else {\n                    break\n                }\n            }\n            result = append(result, sublist)\n        }\n        return result\n    case []int:\n        list := list1.([]int)\n        result := make([][]int, 0)\n        for i := 0; i < len(list); i++ {\n            sublist := make([]int, 0)\n            sublist = append(sublist, list[i])\n            for j := i + 1; j < len(list); j++ {\n                if list[i] == list[j] {\n                    sublist = append(sublist, list[j])\n                    i++\n                } else {\n                    break\n                }\n            }\n            result = append(result, sublist)\n        }\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph7_usor0_test.go:59:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpedef3bdi_test.go:44:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{}\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{}\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123486,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqt5fqvn1_test.go:63:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := []interface{}{}\n        sublist := []interface{}{list[0]}\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123473,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4i7dns3i_test.go:42:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        temp := make([]interface{}, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]interface{}, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123480,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpns09wzij_test.go:44:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i, v := range list {\n            if i == 0 {\n                temp = append(temp, v)\n            } else if v == list[i-1] {\n                temp = append(temp, v)\n            } else {\n                result = append(result, temp)\n                temp = []string{v}\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i, v := range list {\n            if i == 0 {\n                temp = append(temp, v)\n            } else if v == list[i-1] {\n                temp = append(temp, v)\n            } else {\n                result = append(result, temp)\n                temp = []int{v}\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123486,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprniuwk7d_test.go:57:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        var sublist []interface{}\n        var prev interface{}\n        for _, v := range list {\n            if prev == nil {\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, v)\n                prev = v\n            } else if prev == v {\n                sublist = append(sublist, v)\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, v)\n                prev = v\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123486,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphiax7do8_test.go:49:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        current := make([]interface{}, 0)\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]interface{}, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123475,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpll0a3z0t_test.go:44:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123473,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_eaqp4et_test.go:47:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == sublist[0] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123486,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvyurkiyu_test.go:47:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123486,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphfn_pk6o_test.go:61:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123478,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5he1b071_test.go:61:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        temp := make([]interface{}, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]interface{}, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123480,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpns09wzij_test.go:44:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        temp := make([]interface{}, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]interface{}, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case string:\n        list := list1.(string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([]string, 0)\n        temp := \"\"\n        temp = string(list[0])\n        for i := 1; i < len(list); i++ {\n            if string(list[i]) == string(list[i-1]) {\n                temp = temp + string(list[i])\n            } else {\n                result = append(result, temp)\n                temp = \"\"\n                temp = string(list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123486,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb_d6fvbb_test.go:63:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        temp := make([]string, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]string, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        temp := make([]int, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]int, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpm3s5ww6h_test.go:63:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        temp := make([]int, 0)\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = make([]int, 0)\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        temp := make([]string, 0)\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = make([]string, 0)\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123486,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3u800erm_test.go:69:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var temp []string\n        for i, v := range list {\n            if i == 0 {\n                temp = append(temp, v)\n            } else {\n                if v == list[i-1] {\n                    temp = append(temp, v)\n                } else {\n                    result = append(result, temp)\n                    temp = []string{v}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var temp []int\n        for i, v := range list {\n            if i == 0 {\n                temp = append(temp, v)\n            } else {\n                if v == list[i-1] {\n                    temp = append(temp, v)\n                } else {\n                    result = append(result, temp)\n                    temp = []int{v}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510449,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpref18um4_test.go:61:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]int\n        var temp []int\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = nil\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]string\n        var temp []string\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = nil\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123486,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt1j3u9r3_test.go:63:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123480,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt7ctldi2_test.go:61:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, v)\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case string:\n        str := list1.(string)\n        if len(str) == 0 {\n            return str\n        }\n        result := \"\"\n        sublist := \"\"\n        for i, v := range str {\n            if i == 0 {\n                sublist = string(v)\n            } else {\n                if v == rune(str[i-1]) {\n                    sublist = sublist + string(v)\n                } else {\n                    result = result + sublist\n                    sublist = string(v)\n                }\n            }\n        }\n        result = result + sublist\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123486,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpm8arl7uf_test.go:68:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        current := make([]string, 0)\n        for i := 0; i < len(list); i++ {\n            if len(current) == 0 {\n                current = append(current, list[i])\n            } else if current[0] == list[i] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]string, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        current := make([]int, 0)\n        for i := 0; i < len(list); i++ {\n            if len(current) == 0 {\n                current = append(current, list[i])\n            } else if current[0] == list[i] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]int, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123486,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdo96ol6k_test.go:65:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        result := make([][]int, 0)\n        for i := 0; i < len(list); i++ {\n            if i == 0 || list[i] != list[i-1] {\n                result = append(result, []int{list[i]})\n            } else {\n                result[len(result)-1] = append(result[len(result)-1], list[i])\n            }\n        }\n        return result\n    case []string:\n        list := list1.([]string)\n        result := make([][]string, 0)\n        for i := 0; i < len(list); i++ {\n            if i == 0 || list[i] != list[i-1] {\n                result = append(result, []string{list[i]})\n            } else {\n                result[len(result)-1] = append(result[len(result)-1], list[i])\n            }\n        }\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123486,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx0x_xji3_test.go:47:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    var list2 interface{}\n    var list3 interface{}\n    var list4 interface{}\n    var list5 interface{}\n    var list6 interface{}\n    var list7 interface{}\n    var list8 interface{}\n    var list9 interface{}\n    var list10 interface{}\n    var list11 interface{}\n    var list12 interface{}\n    var list13 interface{}\n    var list14 interface{}\n    var list15 interface{}\n    var list16 interface{}\n    var list17 interface{}\n    var list18 interface{}\n    var list19 interface{}\n    var list20 interface{}\n    var list21 interface{}\n    var list22 interface{}\n    var list23 interface{}\n    var list24 interface{}\n    var list25 interface{}\n    var list26 interface{}\n    var list27 interface{}\n    var list28 interface{}\n    var list29 interface{}\n    var list30 interface{}\n    var list31 interface{}\n    var list32 interface{}\n    var list33 interface{}\n    var list34 interface{}\n    var list35 interface{}\n    var list36 interface{}\n    var list37 interface{}\n    var list38 interface{}\n    var list39 interface{}\n    var list40 interface{}\n    var list41 interface{}\n    var list42 interface{}\n    var list43 interface{}\n    var list44 interface{}\n    var list45 interface{}\n    var list46 interface{}\n    var list47 interface{}\n    var list48 interface{}\n    var list49 interface{}\n    var list50 interface{}\n    var list51 interface{}\n    var list52 interface{}\n    var list53 interface{}\n    var list54 interface{}\n    var list55 interface{}\n    var list56 interface{}\n    var list57 interface{}\n    var list58 interface{}\n    var list59 interface{}\n    var list60 interface{}\n    var list61 interface{}\n    var list62 interface{}\n    var list63 interface{}\n    var list64 interface{}\n    var list65 interface{}\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123479,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpwi_fw9ah_test.go:74:6: expected '(', found TestPack_Consecutive_Duplicates\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123480,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqlxjwqf7_test.go:61:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := []interface{}{}\n        sublist := []interface{}{}\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{}\n                    sublist = append(sublist, v)\n                }\n            }\n            if i == len(list)-1 {\n                result = append(result, sublist)\n            }\n        }\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123486,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoft3h254_test.go:49:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        temp := make([]interface{}, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]interface{}, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123480,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpns09wzij_test.go:44:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        temp := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == temp[0] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]interface{}, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123486,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe3rg4vbj_test.go:45:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var prev interface{}\n        for _, v := range list {\n            if prev == nil {\n                sublist = append(sublist, v)\n            } else if prev == v {\n                sublist = append(sublist, v)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{v}\n            }\n            prev = v\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123486,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4ltnq74d_test.go:46:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var last interface{}\n        for _, v := range list {\n            if last == nil {\n                last = v\n                sublist = append(sublist, v)\n            } else if last == v {\n                sublist = append(sublist, v)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{v}\n                last = v\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123486,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_8o9aap2_test.go:47:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        current := make([]interface{}, 0)\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]interface{}, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123475,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpll0a3z0t_test.go:44:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        for i := 0; i < len(list); i++ {\n            sublist := make([]string, 0)\n            sublist = append(sublist, list[i])\n            for j := i + 1; j < len(list); j++ {\n                if list[j] == list[i] {\n                    sublist = append(sublist, list[j])\n                    i++\n                } else {\n                    break\n                }\n            }\n            result = append(result, sublist)\n        }\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        for i := 0; i < len(list); i++ {\n            sublist := make([]int, 0)\n            sublist = append(sublist, list[i])\n            for j := i + 1; j < len(list); j++ {\n                if list[j] == list[i] {\n                    sublist = append(sublist, list[j])\n                    i++\n                } else {\n                    break\n                }\n            }\n            result = append(result, sublist)\n        }\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123486,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp18v954bz_test.go:65:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    var list2 []interface{}\n    var list3 []interface{}\n    var list4 []interface{}\n    var list5 []interface{}\n    var list6 []interface{}\n    var list7 []interface{}\n    var list8 []interface{}\n    var list9 []interface{}\n    var list10 []interface{}\n    var list11 []interface{}\n    var list12 []interface{}\n    var list13 []interface{}\n    var list14 []interface{}\n    var list15 []interface{}\n    var list16 []interface{}\n    var list17 []interface{}\n    var list18 []interface{}\n    var list19 []interface{}\n    var list20 []interface{}\n    var list21 []interface{}\n    var list22 []interface{}\n    var list23 []interface{}\n    var list24 []interface{}\n    var list25 []interface{}\n    var list26 []interface{}\n    var list27 []interface{}\n    var list28 []interface{}\n    var list29 []interface{}\n    var list30 []interface{}\n    var list31 []interface{}\n    var list32 []interface{}\n    var list33 []interface{}\n    var list34 []interface{}\n    var list35 []interface{}\n    var list36 []interface{}\n    var list37 []interface{}\n    var list38 []interface{}\n    var list39 []interface{}\n    var list40 []interface{}\n    var list41 []interface{}\n    var list42 []interface{}\n    var list43 []interface{}\n    var list44 []interface{}\n    var list45 []interface{}\n    var list46 []interface{}\n    var list47 []interface{}\n    var list48 []interface{}\n    var list49 []interface{}\n    var list50 []interface{}\n    var list51 []interface{}\n    var list52 []interface{}\n    var list53 []interface{}\n    var list54 []interface{}\n    var list55 []interface{}\n    var list56 []interface{}\n    var list57 []interface{}\n    var list58 []interface{\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510448,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptq1imtvt_test.go:67:1: expected '}', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510449,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptxodo9wr_test.go:61:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 || list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 || list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123486,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqfzetzey_test.go:53:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123480,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt7ctldi2_test.go:61:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123473,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_eaqp4et_test.go:47:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        temp := make([]int, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]int, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        temp := make([]string, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]string, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123486,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoofkbkov_test.go:63:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        var list2 []interface{}\n        var list3 []interface{}\n        for _, v := range list1.([]interface{}) {\n            if len(list3) == 0 || list3[0] == v {\n                list3 = append(list3, v)\n            } else {\n                list2 = append(list2, list3)\n                list3 = []interface{}{v}\n            }\n        }\n        if len(list3) > 0 {\n            list2 = append(list2, list3)\n        }\n        return list2\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510449,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpw2mdau1m_test.go:40:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i:=0; i<len(list); i++ {\n            if i==0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i:=0; i<len(list); i++ {\n            if i==0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123486,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6zd0tdhr_test.go:61:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var prev interface{}\n        for _, item := range list {\n            if prev == nil || item == prev {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n            }\n            prev = item\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123486,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy2oaolqv_test.go:44:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510449,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppveyvofj_test.go:61:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123473,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptqf35lyy_test.go:46:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        result = append(result, []interface{}{list[0]})\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                result[len(result)-1] = append(result[len(result)-1], list[i])\n            } else {\n                result = append(result, []interface{}{list[i]})\n            }\n        }\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123486,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9p4ohw22_test.go:40:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []string{}\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []int{}\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123486,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpp17ah0jy_test.go:59:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        current := make([]interface{}, 0)\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]interface{}, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123475,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpll0a3z0t_test.go:44:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    list2 := []interface{}{}\n    list3 := []interface{}{}\n    for _, v := range list1.([]interface{}) {\n        if len(list3) == 0 || list3[0] == v {\n            list3 = append(list3, v)\n        } else {\n            list2 = append(list2, list3)\n            list3 = []interface{}{v}\n        }\n    }\n    if len(list3) > 0 {\n        list2 = append(list2, list3)\n    }\n    return list2\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123486,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2wcp0621_test.go:35:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpedef3bdi_test.go:44:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if sublist[0] == list[i] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510449,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpri6_abdo_test.go:47:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if sublist[0] == list[i] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case string:\n        list := list1.(string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if sublist[0] == list[i] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        panic(\"Unsupported type\")\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123488,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9ptbpb4s_test.go:69:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 || sublist[0] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123483,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmponhz6om9_test.go:43:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123478,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5he1b071_test.go:61:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        sublist := make([]int, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]int, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        sublist := make([]string, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]string, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123483,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbjcpc202_test.go:63:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        var result []interface{}\n        var temp []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []interface{}{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123488,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpng3dze2w_test.go:41:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var last interface{}\n        for _, item := range list {\n            if last == nil {\n                last = item\n                sublist = append(sublist, item)\n            } else if last == item {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n                last = item\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123478,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8_1j1_5o_test.go:47:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        temp := make([]string, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]string, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        temp := make([]int, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]int, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    }\n    return nil\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123488,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmcocjbp__test.go:62:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    list := list1.([]interface{})\n    var result []interface{}\n    var sublist []interface{}\n    for i := 0; i < len(list); i++ {\n        if i == 0 {\n            sublist = append(sublist, list[i])\n        } else {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{list[i]}\n            }\n        }\n    }\n    result = append(result, sublist)\n    return result\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123488,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplelieta6_test.go:38:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if sublist[0] == list[i] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510449,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpri6_abdo_test.go:47:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123478,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5he1b071_test.go:61:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == temp[0] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []string{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == temp[0] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []int{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123488,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphm_3wlg5_test.go:57:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{}\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123488,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn2karcpy_test.go:44:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        current := make([]interface{}, 0)\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]interface{}, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    case string:\n        str := list1.(string)\n        if len(str) == 0 {\n            return str\n        }\n        result := make([]string, 0)\n        current := make([]rune, 0)\n        current = append(current, []rune(str)[0])\n        for i := 1; i < len(str); i++ {\n            if []rune(str)[i] == []rune(str)[i-1] {\n                current = append(current, []rune(str)[i])\n            } else {\n                result = append(result, string(current))\n                current = make([]rune, 0)\n                current = append(current, []rune(str)[i])\n            }\n        }\n        result = append(result, string(current))\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123488,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn_twz862_test.go:63:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{}\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123488,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplfrashv2_test.go:47:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        temp := make([]int, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i - 1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]int, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        temp := make([]string, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i - 1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]string, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123488,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9ojehepo_test.go:63:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []string{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []int{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123475,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3flskjl0_test.go:57:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        result := make([][]int, 0)\n        for i := 0; i < len(list); {\n            j := i + 1\n            for ; j < len(list) && list[j] == list[i]; j++ {}\n            result = append(result, list[i:j])\n            i = j\n        }\n        return result\n    case []string:\n        list := list1.([]string)\n        result := make([][]string, 0)\n        for i := 0; i < len(list); {\n            j := i + 1\n            for ; j < len(list) && list[j] == list[i]; j++ {}\n            result = append(result, list[i:j])\n            i = j\n        }\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123488,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjch5we5b_test.go:45:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    var list2 []interface{}\n    var sublist []interface{}\n    var prev interface{}\n    for _, item := range list1.([]interface{}) {\n        if prev == nil {\n            sublist = append(sublist, item)\n        } else if item == prev {\n            sublist = append(sublist, item)\n        } else {\n            list2 = append(list2, sublist)\n            sublist = []interface{}{item}\n        }\n        prev = item\n    }\n    list2 = append(list2, sublist)\n    return list2\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123488,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmkrixd7__test.go:37:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case string:\n        s := list1.(string)\n        if len(s) == 0 {\n            return s\n        }\n        var result string\n        var sublist string\n        for i, v := range s {\n            if i == 0 {\n                sublist = string(v)\n            } else {\n                if v == rune(s[i-1]) {\n                    sublist = sublist + string(v)\n                } else {\n                    result = result + sublist\n                    sublist = string(v)\n                }\n            }\n        }\n        result = result + sublist\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123488,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcg_knvyw_test.go:67:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpedef3bdi_test.go:44:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123480,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqlxjwqf7_test.go:61:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        temp := make([]interface{}, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]interface{}, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123480,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpns09wzij_test.go:44:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]string\n        var sublist []string\n        var last string\n        for _, v := range list {\n            if len(sublist) == 0 {\n                sublist = append(sublist, v)\n                last = v\n            } else if v == last {\n                sublist = append(sublist, v)\n            } else {\n                result = append(result, sublist)\n                sublist = []string{v}\n                last = v\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]int\n        var sublist []int\n        var last int\n        for _, v := range list {\n            if len(sublist) == 0 {\n                sublist = append(sublist, v)\n                last = v\n            } else if v == last {\n                sublist = append(sublist, v)\n            } else {\n                result = append(result, sublist)\n                sublist = []int{v}\n                last = v\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123488,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9o83h7c4_test.go:69:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123473,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptqf35lyy_test.go:46:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]string\n        var sublist []string\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = nil\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]int\n        var sublist []int\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = nil\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []float64:\n        list := list1.([]float64)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]float64\n        var sublist []float64\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = nil\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123487,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpu6jvc5t7_test.go:70:6: expected '(', found TestPack_Consecutive_Duplicates\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123475,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpckb4ze_9_test.go:61:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123478,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5he1b071_test.go:61:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        return pack_consecutive_duplicates_string(list1.([]string))\n    case []int:\n        return pack_consecutive_duplicates_int(list1.([]int))\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123488,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp236jlv2__test.go:12:16: undefined: pack_consecutive_duplicates_string\n/tmp/tmp236jlv2__test.go:14:16: undefined: pack_consecutive_duplicates_int\n/tmp/tmp236jlv2__test.go:29:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var prev interface{}\n        for _, item := range list {\n            if prev == nil {\n                prev = item\n                sublist = append(sublist, item)\n            } else if prev == item {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n                prev = item\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123473,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp80lwp6ob_test.go:47:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        sublist := make([]string, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else if sublist[0] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]string, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        sublist := make([]int, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else if sublist[0] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]int, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123488,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_tmevu83_test.go:65:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var prev interface{}\n        for _, v := range list {\n            if prev == nil {\n                prev = v\n                sublist = append(sublist, v)\n            } else if prev == v {\n                sublist = append(sublist, v)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{v}\n                prev = v\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123488,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpor_58njc_test.go:47:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        var list2 []interface{}\n        var sublist []interface{}\n        for i, v := range list1.([]interface{}) {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list1.([]interface{})[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    list2 = append(list2, sublist)\n                    sublist = []interface{}{v}\n                }\n            }\n        }\n        list2 = append(list2, sublist)\n        return list2\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123488,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6burmpk5_test.go:42:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        temp := make([]string, 0)\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 {\n                temp = append(temp, list[i])\n            } else if temp[0] == list[i] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]string, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        temp := make([]int, 0)\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 {\n                temp = append(temp, list[i])\n            } else if temp[0] == list[i] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]int, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123488,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi9ma9g_i_test.go:65:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        temp := make([]interface{}, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]interface{}, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123480,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpns09wzij_test.go:44:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpch3laa9k_test.go:57:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        var result []interface{}\n        var sublist []interface{}\n        var last interface{}\n        for _, v := range list1.([]interface{}) {\n            if last == nil {\n                last = v\n                sublist = append(sublist, v)\n            } else if last == v {\n                sublist = append(sublist, v)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{v}\n                last = v\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123488,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv80fr80x_test.go:43:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    list2 := []interface{}{}\n    list3 := []interface{}{}\n    for _, v := range list1.([]interface{}) {\n        if len(list3) == 0 {\n            list3 = append(list3, v)\n        } else if v == list3[0] {\n            list3 = append(list3, v)\n        } else {\n            list2 = append(list2, list3)\n            list3 = []interface{}{v}\n        }\n    }\n    if len(list3) > 0 {\n        list2 = append(list2, list3)\n    }\n    return list2\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123488,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyprsm4rb_test.go:37:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        var result []interface{}\n        var temp []interface{}\n        for i, v := range list {\n            if i == 0 {\n                temp = append(temp, v)\n            } else if v == list[i-1] {\n                temp = append(temp, v)\n            } else {\n                result = append(result, temp)\n                temp = []interface{}{v}\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123488,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp029nhces_test.go:41:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        var list2 [][]string\n        var sublist []string\n        for i, v := range list1.([]string) {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else if v == list1.([]string)[i-1] {\n                sublist = append(sublist, v)\n            } else {\n                list2 = append(list2, sublist)\n                sublist = []string{v}\n            }\n        }\n        list2 = append(list2, sublist)\n        return list2\n    case []int:\n        var list2 [][]int\n        var sublist []int\n        for i, v := range list1.([]int) {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else if v == list1.([]int)[i-1] {\n                sublist = append(sublist, v)\n            } else {\n                list2 = append(list2, sublist)\n                sublist = []int{v}\n            }\n        }\n        list2 = append(list2, sublist)\n        return list2\n    }\n    return nil\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123488,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp95u6oxo3_test.go:54:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var temp []interface{}\n        for i, v := range list {\n            if i == 0 {\n                temp = append(temp, v)\n            } else {\n                if list[i-1] == v {\n                    temp = append(temp, v)\n                } else {\n                    result = append(result, temp)\n                    temp = []interface{}{v}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123490,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqx9almss_test.go:46:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i, v := range list {\n            if i == 0 {\n                temp = append(temp, v)\n            } else {\n                if v == list[i-1] {\n                    temp = append(temp, v)\n                } else {\n                    result = append(result, temp)\n                    temp = []string{v}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i, v := range list {\n            if i == 0 {\n                temp = append(temp, v)\n            } else {\n                if v == list[i-1] {\n                    temp = append(temp, v)\n                } else {\n                    result = append(result, temp)\n                    temp = []int{v}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123482,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjrxbgbrm_test.go:61:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        temp := make([]string, 0)\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if temp[0] == list[i] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = make([]string, 0)\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        temp := make([]int, 0)\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if temp[0] == list[i] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = make([]int, 0)\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123490,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0rf_uo85_test.go:69:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpch3laa9k_test.go:57:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123480,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqlxjwqf7_test.go:61:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return nil\n        }\n        if len(list) == 1 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{}\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123490,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpip5lkaog_test.go:50:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var last interface{}\n        for _, item := range list {\n            if last == nil {\n                last = item\n                sublist = append(sublist, item)\n            } else if last == item {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n                last = item\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123478,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8_1j1_5o_test.go:47:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{}\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{}\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123490,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbydledwg_test.go:63:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var last interface{}\n        for _, item := range list {\n            if last == nil {\n                sublist = append(sublist, item)\n                last = item\n            } else if last == item {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n                last = item\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123490,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptd26c5sf_test.go:47:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if sublist[0] == list[i] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510449,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpri6_abdo_test.go:47:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        var list2 []interface{}\n        var list3 []interface{}\n        for _, v := range list1.([]interface{}) {\n            if len(list3) == 0 || list3[0] == v {\n                list3 = append(list3, v)\n            } else {\n                list2 = append(list2, list3)\n                list3 = []interface{}{v}\n            }\n        }\n        if len(list3) != 0 {\n            list2 = append(list2, list3)\n        }\n        return list2\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123490,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwj64_3nz_test.go:40:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123482,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpm50hsqb6_test.go:57:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var last interface{}\n        for i, v := range list {\n            if i == 0 {\n                last = v\n                sublist = append(sublist, v)\n            } else {\n                if v == last {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{v}\n                }\n                last = v\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123490,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3fqb_v05_test.go:49:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    var list2 []interface{}\n    var list3 []interface{}\n    var list4 interface{}\n    var list5 interface{}\n    var list6 interface{}\n    var list7 interface{}\n    var list8 interface{}\n    var list9 interface{}\n    var list10 interface{}\n    var list11 interface{}\n    var list12 interface{}\n    var list13 interface{}\n    var list14 interface{}\n    var list15 interface{}\n    var list16 interface{}\n    var list17 interface{}\n    var list18 interface{}\n    var list19 interface{}\n    var list20 interface{}\n    var list21 interface{}\n    var list22 interface{}\n    var list23 interface{}\n    var list24 interface{}\n    var list25 interface{}\n    var list26 interface{}\n    var list27 interface{}\n    var list28 interface{}\n    var list29 interface{}\n    var list30 interface{}\n    var list31 interface{}\n    var list32 interface{}\n    var list33 interface{}\n    var list34 interface{}\n    var list35 interface{}\n    var list36 interface{}\n    var list37 interface{}\n    var list38 interface{}\n    var list39 interface{}\n    var list40 interface{}\n    var list41 interface{}\n    var list42 interface{}\n    var list43 interface{}\n    var list44 interface{}\n    var list45 interface{}\n    var list46 interface{}\n    var list47 interface{}\n    var list48 interface{}\n    var list49 interface{}\n    var list50 interface{}\n    var list51 interface{}\n    var list52 interface{}\n    var list53 interface{}\n    var list54 interface{}\n    var list55 interface{}\n    var list56 interface{}\n    var list57 interface{}\n    var list58 interface{}\n    var list59 interface{}\n    var list60 interface{}\n    var list61 interface{}\n    var list62 interface{}\n    var list63 interface{}\n    var list64 interface{}\n    var list65 interface\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123475,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5589501__test.go:74:1: expected '{', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return []interface{}{}\n        }\n        if len(list) == 1 {\n            return []interface{}{list}\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{v}\n                }\n            }\n            if i == len(list)-1 {\n                result = append(result, sublist)\n            }\n        }\n        return result\n    default:\n        return []interface{}{}\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123490,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcsj14wl6_test.go:51:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list2 := make([]interface{}, 0)\n        for i := 0; i < len(list1.([]interface{})); i++ {\n            if i == 0 {\n                list2 = append(list2, make([]interface{}, 0))\n            }\n            if i > 0 && list1.([]interface{})[i] == list1.([]interface{})[i-1] {\n                list2[len(list2)-1] = append(list2[len(list2)-1].([]interface{}), list1.([]interface{})[i])\n            } else {\n                list2 = append(list2, make([]interface{}, 0))\n                list2[len(list2)-1] = append(list2[len(list2)-1].([]interface{}), list1.([]interface{})[i])\n            }\n        }\n        return list2\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123490,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpshz5k21d_test.go:39:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else if sublist[0] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510449,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaeradqfu_test.go:45:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]string, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]int, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123490,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv6qm4ga__test.go:69:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123478,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5he1b071_test.go:61:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := []interface{}{}\n        current := []interface{}{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                current = append(current, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    current = append(current, list[i])\n                } else {\n                    result = append(result, current)\n                    current = []interface{}{}\n                    current = append(current, list[i])\n                }\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123490,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjl29wddr_test.go:47:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        packed := make([][]interface{}, 0)\n        var last interface{}\n        var last_index int\n        for i, v := range list {\n            if i == 0 {\n                last = v\n                last_index = 0\n            } else {\n                if v == last {\n                    packed[last_index] = append(packed[last_index], v)\n                } else {\n                    packed = append(packed, []interface{}{v})\n                    last = v\n                    last_index++\n                }\n            }\n        }\n        return packed\n    case string:\n        str := list1.(string)\n        if len(str) == 0 {\n            return str\n        }\n        packed := make([][]interface{}, 0)\n        var last rune\n        var last_index int\n        for i, v := range str {\n            if i == 0 {\n                last = v\n                last_index = 0\n            } else {\n                if v == last {\n                    packed[last_index] = append(packed[last_index], v)\n                } else {\n                    packed = append(packed, []interface{}{v})\n                    last = v\n                    last_index++\n                }\n            }\n        }\n        return packed\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123490,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplshw_eg7_test.go:71:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123473,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_eaqp4et_test.go:47:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123482,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpm50hsqb6_test.go:57:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    var list2 []interface{}\n    var list3 []interface{}\n    var list4 []interface{}\n    var list5 []interface{}\n    var list6 []interface{}\n    var list7 []interface{}\n    var list8 []interface{}\n    var list9 []interface{}\n    var list10 []interface{}\n    var list11 []interface{}\n    var list12 []interface{}\n    var list13 []interface{}\n    var list14 []interface{}\n    var list15 []interface{}\n    var list16 []interface{}\n    var list17 []interface{}\n    var list18 []interface{}\n    var list19 []interface{}\n    var list20 []interface{}\n    var list21 []interface{}\n    var list22 []interface{}\n    var list23 []interface{}\n    var list24 []interface{}\n    var list25 []interface{}\n    var list26 []interface{}\n    var list27 []interface{}\n    var list28 []interface{}\n    var list29 []interface{}\n    var list30 []interface{}\n    var list31 []interface{}\n    var list32 []interface{}\n    var list33 []interface{}\n    var list34 []interface{}\n    var list35 []interface{}\n    var list36 []interface{}\n    var list37 []interface{}\n    var list38 []interface{}\n    var list39 []interface{}\n    var list40 []interface{}\n    var list41 []interface{}\n    var list42 []interface{}\n    var list43 []interface{}\n    var list44 []interface{}\n    var list45 []interface{}\n    var list46 []interface{}\n    var list47 []interface{}\n    var list48 []interface{}\n    var list49 []interface{}\n    var list50 []interface{}\n    var list51 []interface{}\n    var list52 []interface{}\n    var list53 []interface{}\n    var list54 []interface{}\n    var list55 []interface{}\n    var list56 []interface{}\n    var list57 []interface{}\n    var list58 []interface{\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510448,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptq1imtvt_test.go:67:1: expected '}', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510449,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu3hj4pyu_test.go:61:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    var list2 []interface{}\n    var list3 []interface{}\n    var list4 []interface{}\n    var list5 []interface{}\n    var list6 []interface{}\n    var list7 []interface{}\n    var list8 []interface{}\n    var list9 []interface{}\n    var list10 []interface{}\n    var list11 []interface{}\n    var list12 []interface{}\n    var list13 []interface{}\n    var list14 []interface{}\n    var list15 []interface{}\n    var list16 []interface{}\n    var list17 []interface{}\n    var list18 []interface{}\n    var list19 []interface{}\n    var list20 []interface{}\n    var list21 []interface{}\n    var list22 []interface{}\n    var list23 []interface{}\n    var list24 []interface{}\n    var list25 []interface{}\n    var list26 []interface{}\n    var list27 []interface{}\n    var list28 []interface{}\n    var list29 []interface{}\n    var list30 []interface{}\n    var list31 []interface{}\n    var list32 []interface{}\n    var list33 []interface{}\n    var list34 []interface{}\n    var list35 []interface{}\n    var list36 []interface{}\n    var list37 []interface{}\n    var list38 []interface{}\n    var list39 []interface{}\n    var list40 []interface{}\n    var list41 []interface{}\n    var list42 []interface{}\n    var list43 []interface{}\n    var list44 []interface{}\n    var list45 []interface{}\n    var list46 []interface{}\n    var list47 []interface{}\n    var list48 []interface{}\n    var list49 []interface{}\n    var list50 []interface{}\n    var list51 []interface{}\n    var list52 []interface{}\n    var list53 []interface{}\n    var list54 []interface{}\n    var list55 []interface{}\n    var list56 []interface{}\n    var list57 []interface{}\n    var list58 []interface{\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510448,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptq1imtvt_test.go:67:1: expected '}', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return []interface{}{}\n        }\n        if len(list) == 1 {\n            return []interface{}{list}\n        }\n        result := []interface{}{}\n        temp := []interface{}{list[0]}\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []interface{}{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123490,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0zrxmv_s_test.go:45:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        var result [][]string\n        var temp []string\n        for i, v := range list1.([]string) {\n            if i == 0 {\n                temp = append(temp, v)\n            } else {\n                if v == list1.([]string)[i-1] {\n                    temp = append(temp, v)\n                } else {\n                    result = append(result, temp)\n                    temp = []string{v}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        var result [][]int\n        var temp []int\n        for i, v := range list1.([]int) {\n            if i == 0 {\n                temp = append(temp, v)\n            } else {\n                if v == list1.([]int)[i-1] {\n                    temp = append(temp, v)\n                } else {\n                    result = append(result, temp)\n                    temp = []int{v}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123490,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpm3vk68zk_test.go:59:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]string, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]int, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123490,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv6qm4ga__test.go:69:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        current := make([]string, 0)\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]string, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        current := make([]int, 0)\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]int, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123482,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplyv7yr7f_test.go:63:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 || temp[len(temp)-1] == list[i] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []string{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 || temp[len(temp)-1] == list[i] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []int{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123490,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg0uvhb31_test.go:53:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list2 := list1.([]interface{})\n        if len(list2) == 0 {\n            return list2\n        }\n        list3 := make([]interface{}, 0)\n        list4 := make([]interface{}, 0)\n        for i := 0; i < len(list2); i++ {\n            if i == 0 {\n                list4 = append(list4, list2[i])\n            } else if list2[i] == list2[i-1] {\n                list4 = append(list4, list2[i])\n            } else {\n                list3 = append(list3, list4)\n                list4 = make([]interface{}, 0)\n                list4 = append(list4, list2[i])\n            }\n        }\n        list3 = append(list3, list4)\n        return list3\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123490,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn94by9f6_test.go:45:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    var list2 []interface{}\n    var sublist []interface{}\n    var prev interface{}\n    for _, v := range list1.([]interface{}) {\n        if v != prev {\n            if len(sublist) > 0 {\n                list2 = append(list2, sublist)\n            }\n            sublist = []interface{}{v}\n        } else {\n            sublist = append(sublist, v)\n        }\n        prev = v\n    }\n    if len(sublist) > 0 {\n        list2 = append(list2, sublist)\n    }\n    return list2\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123478,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt20xdl76_test.go:39:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        sublist := make([]string, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i - 1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]string, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        sublist := make([]int, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i - 1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]int, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123490,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0qyo0bdp_test.go:63:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []string{}\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []int{}\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123490,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3fayjmsx_test.go:63:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        temp := make([]int, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]int, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        temp := make([]string, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]string, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123486,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoofkbkov_test.go:63:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return []interface{}{}\n        }\n        result := []interface{}{}\n        temp := []interface{}{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []interface{}{}\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123490,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp80f8j2uv_test.go:47:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        current := make([]interface{}, 0)\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]interface{}, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123475,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpll0a3z0t_test.go:44:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123473,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptqf35lyy_test.go:46:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else if sublist[0] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510449,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaeradqfu_test.go:45:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        result := make([][]string, 0)\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]string, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        result := make([][]int, 0)\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]int, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123490,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg_7q3ssj_test.go:63:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return []interface{}{}\n        }\n        if len(list) == 1 {\n            return []interface{}{list}\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123490,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9b47rocy_test.go:49:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    var list2 []interface{}\n    var list3 []interface{}\n    var list4 interface{}\n    var list5 interface{}\n    var list6 interface{}\n    var list7 interface{}\n    var list8 interface{}\n    var list9 interface{}\n    var list10 interface{}\n    var list11 interface{}\n    var list12 interface{}\n    var list13 interface{}\n    var list14 interface{}\n    var list15 interface{}\n    var list16 interface{}\n    var list17 interface{}\n    var list18 interface{}\n    var list19 interface{}\n    var list20 interface{}\n    var list21 interface{}\n    var list22 interface{}\n    var list23 interface{}\n    var list24 interface{}\n    var list25 interface{}\n    var list26 interface{}\n    var list27 interface{}\n    var list28 interface{}\n    var list29 interface{}\n    var list30 interface{}\n    var list31 interface{}\n    var list32 interface{}\n    var list33 interface{}\n    var list34 interface{}\n    var list35 interface{}\n    var list36 interface{}\n    var list37 interface{}\n    var list38 interface{}\n    var list39 interface{}\n    var list40 interface{}\n    var list41 interface{}\n    var list42 interface{}\n    var list43 interface{}\n    var list44 interface{}\n    var list45 interface{}\n    var list46 interface{}\n    var list47 interface{}\n    var list48 interface{}\n    var list49 interface{}\n    var list50 interface{}\n    var list51 interface{}\n    var list52 interface{}\n    var list53 interface{}\n    var list54 interface{}\n    var list55 interface{}\n    var list56 interface{}\n    var list57 interface{}\n    var list58 interface{}\n    var list59 interface{}\n    var list60 interface{}\n    var list61 interface{}\n    var list62 interface{}\n    var list63 interface{}\n    var list64 interface{}\n    var list65 interface\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123475,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5589501__test.go:74:1: expected '{', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123480,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9rskbfpa_test.go:44:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := []interface{}{}\n        current := list[0]\n        current_list := []interface{}{current}\n        for _, item := range list[1:] {\n            if item == current {\n                current_list = append(current_list, item)\n            } else {\n                result = append(result, current_list)\n                current_list = []interface{}{item}\n                current = item\n            }\n        }\n        result = append(result, current_list)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123490,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps8ly41xw_test.go:44:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{}\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123488,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplfrashv2_test.go:47:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123478,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5he1b071_test.go:61:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := []interface{}{}\n        current := list[0]\n        count := 1\n        for i := 1; i < len(list); i++ {\n            if list[i] == current {\n                count++\n            } else {\n                result = append(result, []interface{}{current, count})\n                current = list[i]\n                count = 1\n            }\n        }\n        result = append(result, []interface{}{current, count})\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpokaa707f_test.go:44:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        current := make([]interface{}, 0)\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]interface{}, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123475,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpll0a3z0t_test.go:44:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]string\n        var tmp []string\n        tmp = append(tmp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                tmp = append(tmp, list[i])\n            } else {\n                result = append(result, tmp)\n                tmp = []string{}\n                tmp = append(tmp, list[i])\n            }\n        }\n        result = append(result, tmp)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]int\n        var tmp []int\n        tmp = append(tmp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                tmp = append(tmp, list[i])\n            } else {\n                result = append(result, tmp)\n                tmp = []int{}\n                tmp = append(tmp, list[i])\n            }\n        }\n        result = append(result, tmp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123490,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0a3nrm9u_test.go:63:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if temp[0] == list[i] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{}\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if len(temp) == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if temp[0] == list[i] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{}\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123492,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgeq4f1o3_test.go:63:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        var result []interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123492,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7imexefi_test.go:43:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if sublist[0] == list[i] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510449,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpri6_abdo_test.go:47:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 || list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 || list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123492,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph2mfrxa9_test.go:53:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123478,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwot7db4j_test.go:57:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n        case []interface{}:\n            list := list1.([]interface{})\n            if len(list) == 0 {\n                return list\n            }\n            var result []interface{}\n            var sublist []interface{}\n            var prev interface{}\n            for _, v := range list {\n                if prev == nil || prev == v {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{v}\n                }\n                prev = v\n            }\n            result = append(result, sublist)\n            return result\n        default:\n            return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123492,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpukw5vk6m_test.go:44:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123475,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnzdlu22r_test.go:46:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = nil\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = nil\n                    temp = append(temp, list[i])\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    }\n    return nil\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123480,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpypybl_be_test.go:62:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{}\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{}\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123492,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp69f2soqe_test.go:59:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpedef3bdi_test.go:44:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n        case []string:\n            list := list1.([]string)\n            result := []interface{}{}\n            for i := 0; i < len(list); i++ {\n                sublist := []string{}\n                for j := i; j < len(list); j++ {\n                    if list[i] == list[j] {\n                        sublist = append(sublist, list[j])\n                    } else {\n                        break\n                    }\n                }\n                result = append(result, sublist)\n                i += len(sublist) - 1\n            }\n            return result\n        case []int:\n            list := list1.([]int)\n            result := []interface{}{}\n            for i := 0; i < len(list); i++ {\n                sublist := []int{}\n                for j := i; j < len(list); j++ {\n                    if list[i] == list[j] {\n                        sublist = append(sublist, list[j])\n                    } else {\n                        break\n                    }\n                }\n                result = append(result, sublist)\n                i += len(sublist) - 1\n            }\n            return result\n        case []float64:\n            list := list1.([]float64)\n            result := []interface{}{}\n            for i := 0; i < len(list); i++ {\n                sublist := []float64{}\n                for j := i; j < len(list); j++ {\n                    if list[i] == list[j] {\n                        sublist = append(sublist, list[j])\n                    } else {\n                        break\n                    }\n                }\n                result = append(result, sublist)\n                i += len(sublist) - 1\n            }\n            return result\n        case []bool:\n            list := list1.([]bool)\n            result := []interface{}{}\n            for i := 0; i < len(list); i++ {\n                sublist := []bool{}\n                for j := i; j < len(list); j++ {\n                    if list[i] == list[j] {\n                        sublist = append(sublist, list[j\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123492,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp231se1dv_test.go:66:57: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123482,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpm50hsqb6_test.go:57:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n                continue\n            }\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123492,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8m9ix31s_test.go:46:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpch3laa9k_test.go:57:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        current := make([]interface{}, 0)\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]interface{}, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123475,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpll0a3z0t_test.go:44:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var last interface{}\n        for _, item := range list {\n            if last == nil {\n                last = item\n                sublist = append(sublist, item)\n            } else if last == item {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n                last = item\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123478,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8_1j1_5o_test.go:47:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123482,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpm50hsqb6_test.go:57:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        current := make([]interface{}, 0)\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = make([]interface{}, 0)\n                current = append(current, list[i])\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123475,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpll0a3z0t_test.go:44:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    var list2 interface{}\n    var list3 interface{}\n    var list4 interface{}\n    var list5 interface{}\n    var list6 interface{}\n    var list7 interface{}\n    var list8 interface{}\n    var list9 interface{}\n    var list10 interface{}\n    var list11 interface{}\n    var list12 interface{}\n    var list13 interface{}\n    var list14 interface{}\n    var list15 interface{}\n    var list16 interface{}\n    var list17 interface{}\n    var list18 interface{}\n    var list19 interface{}\n    var list20 interface{}\n    var list21 interface{}\n    var list22 interface{}\n    var list23 interface{}\n    var list24 interface{}\n    var list25 interface{}\n    var list26 interface{}\n    var list27 interface{}\n    var list28 interface{}\n    var list29 interface{}\n    var list30 interface{}\n    var list31 interface{}\n    var list32 interface{}\n    var list33 interface{}\n    var list34 interface{}\n    var list35 interface{}\n    var list36 interface{}\n    var list37 interface{}\n    var list38 interface{}\n    var list39 interface{}\n    var list40 interface{}\n    var list41 interface{}\n    var list42 interface{}\n    var list43 interface{}\n    var list44 interface{}\n    var list45 interface{}\n    var list46 interface{}\n    var list47 interface{}\n    var list48 interface{}\n    var list49 interface{}\n    var list50 interface{}\n    var list51 interface{}\n    var list52 interface{}\n    var list53 interface{}\n    var list54 interface{}\n    var list55 interface{}\n    var list56 interface{}\n    var list57 interface{}\n    var list58 interface{}\n    var list59 interface{}\n    var list60 interface{}\n    var list61 interface{}\n    var list62 interface{}\n    var list63 interface{}\n    var list64 interface{}\n    var list65 interface{}\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123479,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpwi_fw9ah_test.go:74:6: expected '(', found TestPack_Consecutive_Duplicates\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else if sublist[0] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510449,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaeradqfu_test.go:45:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        if len(list) == 1 {\n            return []interface{}{list}\n        }\n        var result []interface{}\n        var temp []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []interface{}{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123492,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpha0murbw_test.go:49:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpedef3bdi_test.go:44:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpedef3bdi_test.go:44:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []string{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    temp = append(temp, list[i])\n                } else {\n                    result = append(result, temp)\n                    temp = []int{list[i]}\n                }\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123478,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5he1b071_test.go:61:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        temp := make([]string, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]string, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        temp := make([]int, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]int, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpm3s5ww6h_test.go:63:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return []interface{}{}\n        }\n        result := []interface{}{}\n        sublist := []interface{}{}\n        for i, v := range list {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{v}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123492,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkv5h33nw_test.go:46:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        var temp []string\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]string, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        var temp []int\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]int, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123492,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdln7tra0_test.go:63:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result []interface{}\n        var current []string\n        for i, v := range list {\n            if i == 0 {\n                current = append(current, v)\n            } else {\n                if v == list[i-1] {\n                    current = append(current, v)\n                } else {\n                    result = append(result, current)\n                    current = []string{v}\n                }\n            }\n        }\n        result = append(result, current)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result []interface{}\n        var current []int\n        for i, v := range list {\n            if i == 0 {\n                current = append(current, v)\n            } else {\n                if v == list[i-1] {\n                    current = append(current, v)\n                } else {\n                    result = append(result, current)\n                    current = []int{v}\n                }\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123492,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphx1bu4fa_test.go:61:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123475,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnzdlu22r_test.go:46:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        sublist = append(sublist, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510450,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpedef3bdi_test.go:44:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var sublist []string\n        for i, v := range list {\n            if i == 0 || v == list[i-1] {\n                sublist = append(sublist, v)\n            } else {\n                result = append(result, sublist)\n                sublist = []string{v}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var sublist []int\n        for i, v := range list {\n            if i == 0 || v == list[i-1] {\n                sublist = append(sublist, v)\n            } else {\n                result = append(result, sublist)\n                sublist = []int{v}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123492,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb8mfhu7g_test.go:53:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]string\n        var sublist []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []string{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]int\n        var sublist []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else if list[i] == list[i-1] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = []int{list[i]}\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123492,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp70s2_ujz_test.go:63:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]int, 0)\n        temp := make([]int, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]int, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]string, 0)\n        temp := make([]string, 0)\n        temp = append(temp, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = make([]string, 0)\n                temp = append(temp, list[i])\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123486,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoofkbkov_test.go:63:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = make([]interface{}, 0)\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123473,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_eaqp4et_test.go:47:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []string:\n        var list2 [][]string\n        var sublist []string\n        for i, v := range list1.([]string) {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list1.([]string)[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    list2 = append(list2, sublist)\n                    sublist = []string{v}\n                }\n            }\n        }\n        list2 = append(list2, sublist)\n        return list2\n    case []int:\n        var list2 [][]int\n        var sublist []int\n        for i, v := range list1.([]int) {\n            if i == 0 {\n                sublist = append(sublist, v)\n            } else {\n                if v == list1.([]int)[i-1] {\n                    sublist = append(sublist, v)\n                } else {\n                    list2 = append(list2, sublist)\n                    sublist = []int{v}\n                }\n            }\n        }\n        list2 = append(list2, sublist)\n        return list2\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123492,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpldhyk_e__test.go:59:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        var result [][]int\n        var temp []int\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []int{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    case []string:\n        list := list1.([]string)\n        var result [][]string\n        var temp []string\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                temp = append(temp, list[i])\n            } else if list[i] == list[i-1] {\n                temp = append(temp, list[i])\n            } else {\n                result = append(result, temp)\n                temp = []string{list[i]}\n            }\n        }\n        result = append(result, temp)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123492,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_tg00tev_test.go:57:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    var list2 []interface{}\n    var sublist []interface{}\n    var last interface{}\n    for _, v := range list1.([]interface{}) {\n        if v != last {\n            if sublist != nil {\n                list2 = append(list2, sublist)\n            }\n            sublist = []interface{}{v}\n        } else {\n            sublist = append(sublist, v)\n        }\n        last = v\n    }\n    if sublist != nil {\n        list2 = append(list2, sublist)\n    }\n    return list2\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123492,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpj1cjgktn_test.go:39:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == sublist[0] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{}\n                    sublist = append(sublist, list[i])\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123492,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5ex28xa9_test.go:47:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]interface{}\n        var sublist []interface{}\n        for i := 0; i < len(list); i++ {\n            if i == 0 {\n                sublist = append(sublist, list[i])\n            } else {\n                if list[i] == list[i-1] {\n                    sublist = append(sublist, list[i])\n                } else {\n                    result = append(result, sublist)\n                    sublist = []interface{}{list[i]}\n                }\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123492,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpobzg47ly_test.go:46:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        var result []interface{}\n        var sublist []interface{}\n        var prev interface{}\n        for _, item := range list {\n            if prev == nil {\n                prev = item\n                sublist = append(sublist, item)\n            } else if prev == item {\n                sublist = append(sublist, item)\n            } else {\n                result = append(result, sublist)\n                sublist = []interface{}{item}\n                prev = item\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123473,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp80lwp6ob_test.go:47:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    list2 := []interface{}{}\n    for _, v := range list1.([]interface{}) {\n        if len(list2) == 0 || list2[len(list2)-1] != v {\n            list2 = append(list2, []interface{}{v})\n        } else {\n            list2[len(list2)-1] = append(list2[len(list2)-1].([]interface{}), v)\n        }\n    }\n    return list2\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123492,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprff8rtzw_test.go:30:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n        case []interface{}:\n            list := list1.([]interface{})\n            if len(list) == 0 {\n                return []interface{}{}\n            } else {\n                var result []interface{}\n                var sublist []interface{}\n                var prev interface{}\n                for _, v := range list {\n                    if prev == nil {\n                        prev = v\n                        sublist = append(sublist, v)\n                    } else {\n                        if v == prev {\n                            sublist = append(sublist, v)\n                        } else {\n                            result = append(result, sublist)\n                            sublist = []interface{}{v}\n                            prev = v\n                        }\n                    }\n                }\n                result = append(result, sublist)\n                return result\n            }\n        default:\n            return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123492,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpo8s30t1k_test.go:50:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []interface{}:\n        list := list1.([]interface{})\n        if len(list) == 0 {\n            return list\n        }\n        result := make([][]interface{}, 0)\n        sublist := make([]interface{}, 0)\n        for i := 0; i < len(list); i++ {\n            if len(sublist) == 0 {\n                sublist = append(sublist, list[i])\n            } else if sublist[0] == list[i] {\n                sublist = append(sublist, list[i])\n            } else {\n                result = append(result, sublist)\n                sublist = make([]interface{}, 0)\n                sublist = append(sublist, list[i])\n            }\n        }\n        result = append(result, sublist)\n        return result\n    default:\n        return list1\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510449,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaeradqfu_test.go:45:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package pack_consecutive_duplicates_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1 interface{}) interface{} {\n    switch list1.(type) {\n    case []int:\n        list := list1.([]int)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]int\n        var current []int\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = []int{list[i]}\n            }\n        }\n        result = append(result, current)\n        return result\n    case []string:\n        list := list1.([]string)\n        if len(list) == 0 {\n            return list\n        }\n        var result [][]string\n        var current []string\n        current = append(current, list[0])\n        for i := 1; i < len(list); i++ {\n            if list[i] == list[i-1] {\n                current = append(current, list[i])\n            } else {\n                result = append(result, current)\n                current = []string{list[i]}\n            }\n        }\n        result = append(result, current)\n        return result\n    default:\n        return nil\n    }\n}\n\nfunc TestPack_Consecutive_Duplicates(t *testing.T) {\n  candidate := pack_consecutive_duplicates\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4}), expected: [][]int{[]int{0, 0}, []int{1}, []int{2}, []int{3}, []int{4, 4}, []int{5}, []int{6, 6, 6}, []int{7}, []int{8}, []int{9}, []int{4, 4}} },\n     { actual: candidate([]int{10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10}), expected: [][]int{[]int{10, 10}, []int{15}, []int{19}, []int{18, 18}, []int{17}, []int{26, 26}, []int{17}, []int{18}, []int{10}} },\n     { actual: candidate([]string{\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"}), expected: [][]int{[]string{\"a\", \"a\"}, []string{\"b\"}, []string{\"c\"}, []string{\"d\", \"d\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666123492,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp__t_3qee_test.go:61:93: cannot use []string{...} (type []string) as type []int in slice literal\n",
      "exit_code": 2,
      "status": "SyntaxError"
    }
  ]
}