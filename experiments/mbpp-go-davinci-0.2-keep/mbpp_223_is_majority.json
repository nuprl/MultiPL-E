{
  "name": "mbpp_223_is_majority",
  "language": "go_test.go",
  "prompt": "package is_majority_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function that takes in a sorted array, its length (n), and an element and returns whether the element is the majority element in the given sorted array. (The majority element is the element that occurs more than n/2 times.)\nfunc is_majority(arr []int, n int, x int) bool {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_223_is_majority.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestIs_Majority(t *testing.T) {\n  candidate := is_majority\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 3, 3, 3, 10}, 7, 3), expected: true },\n     { actual: candidate([]int{1, 1, 2, 4, 4, 4, 6, 6}, 8, 4), expected: false },\n     { actual: candidate([]int{1, 1, 1, 2, 2}, 5, 1), expected: true },\n     { actual: candidate([]int{1, 1, 2, 2}, 5, 1), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    var count int = 0\n    for _, v := range arr {\n        if v == x {\n            count++\n        }\n    }\n    return count > n/2\n}\n",
    "    if n == 0 {\n        return false\n    }\n    if n == 1 {\n        return arr[0] == x\n    }\n    if n == 2 {\n        return arr[0] == x && arr[1] == x\n    }\n    mid := n / 2\n    if arr[mid] == x {\n        return is_majority(arr[:mid], mid, x)\n    } else if arr[mid] > x {\n        return is_majority(arr[:mid], mid, x)\n    } else {\n        return is_majority(arr[mid:], n - mid, x)\n    }\n}\n",
    "    var count int\n    for _, v := range arr {\n        if v == x {\n            count++\n        }\n    }\n    return count > n/2\n}\n",
    "    var count int\n    for i := 0; i < n; i++ {\n        if arr[i] == x {\n            count++\n        }\n    }\n    if count > n/2 {\n        return true\n    }\n    return false\n}\n",
    "    count := 0\n    for _, v := range arr {\n        if v == x {\n            count++\n        }\n    }\n    return count > n/2\n}\n",
    "    var count int = 0\n    for _, v := range arr {\n        if v == x {\n            count++\n        }\n    }\n    if count > n/2 {\n        return true\n    }\n    return false\n}\n",
    "    var count int = 0\n    for i := 0; i < n; i++ {\n        if arr[i] == x {\n            count++\n        }\n    }\n    if count > n/2 {\n        return true\n    }\n    return false\n}\n",
    "    count := 0\n    for _, v := range arr {\n        if v == x {\n            count++\n        }\n    }\n    return count > n/2\n}\n",
    "    // find the first occurance of x\n    first := find_first(arr, n, x)\n    // if x is not present in the array\n    if first == -1 {\n        return false\n    }\n    // if x is present in the array\n    // find the last occurance of x\n    last := find_last(arr, n, x)\n    // if x occurs more than n/2 times\n    if last - first + 1 > n/2 {\n        return true\n    }\n    return false\n}\n",
    "    // find the first occurence of x\n    first := find_first(arr, n, x)\n    if first == -1 {\n        return false\n    }\n    if (first + n/2) <= (n - 1) && arr[first + n/2] == x {\n        return true\n    }\n    return false\n}\n",
    "    var count int = 0\n    for _, v := range arr {\n        if v == x {\n            count++\n        }\n    }\n    return count > n/2\n}\n",
    "    // find the first occurence of x\n    first := -1\n    for i := 0; i < n; i++ {\n        if arr[i] == x {\n            first = i\n            break\n        }\n    }\n    if first == -1 {\n        return false\n    }\n    // find the last occurence of x\n    last := -1\n    for i := n - 1; i >= 0; i-- {\n        if arr[i] == x {\n            last = i\n            break\n        }\n    }\n    if last == -1 {\n        return false\n    }\n    // check if the number of occurences is greater than n/2\n    if last - first + 1 > n/2 {\n        return true\n    }\n    return false\n}\n",
    "    var count int = 0\n    for _, v := range arr {\n        if v == x {\n            count++\n        }\n    }\n    if count > n/2 {\n        return true\n    }\n    return false\n}\n",
    "    if n == 0 {\n        return false\n    }\n\n    if n == 1 {\n        return arr[0] == x\n    }\n\n    mid := n / 2\n\n    if arr[mid] == x {\n        return is_majority(arr[mid:], n - mid, x)\n    } else if arr[mid] < x {\n        return is_majority(arr[mid+1:], n - mid - 1, x)\n    } else {\n        return is_majority(arr[:mid], mid, x)\n    }\n}\n",
    "    var count int\n    for _, v := range arr {\n        if v == x {\n            count++\n        }\n    }\n    return count > n/2\n}\n",
    "    var count int = 0\n    for i := 0; i < n; i++ {\n        if arr[i] == x {\n            count++\n        }\n    }\n    if count > n/2 {\n        return true\n    }\n    return false\n}\n",
    "    if n == 0 {\n        return false\n    }\n    if x == arr[n/2] {\n        return true\n    }\n    if x > arr[n/2] {\n        return is_majority(arr[n/2+1:], n/2, x)\n    }\n    return is_majority(arr[:n/2], n/2, x)\n}\n",
    "    var count int\n    for _, val := range arr {\n        if val == x {\n            count++\n        }\n    }\n    if count > n/2 {\n        return true\n    }\n    return false\n}\n",
    "    // find the first occurence of x\n    first := find_first(arr, n, x)\n    // find the last occurence of x\n    last := find_last(arr, n, x)\n    // return true if the number of occurences of x is greater than n/2\n    return (last - first + 1) > n/2\n}\n",
    "    // find the first occurrence of x\n    first := -1\n    low := 0\n    high := n - 1\n    for low <= high {\n        mid := (low + high) / 2\n        if arr[mid] == x {\n            first = mid\n            high = mid - 1\n        } else if arr[mid] < x {\n            low = mid + 1\n        } else {\n            high = mid - 1\n        }\n    }\n    if first == -1 {\n        return false\n    }\n    // find the last occurrence of x\n    last := -1\n    low = 0\n    high = n - 1\n    for low <= high {\n        mid := (low + high) / 2\n        if arr[mid] == x {\n            last = mid\n            low = mid + 1\n        } else if arr[mid] < x {\n            low = mid + 1\n        } else {\n            high = mid - 1\n        }\n    }\n    if last == -1 {\n        return false\n    }\n    if last - first + 1 > n / 2 {\n        return true\n    }\n    return false\n}\n"
  ]
}