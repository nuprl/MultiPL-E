{
  "name": "mbpp_612_merge",
  "language": "go_test.go",
  "prompt": "package merge_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function which takes a list of lists, where each sublist has two elements, and returns a list of two lists where the first list has the first element of each sublist and the second one has the second.\nfunc merge(lst interface{}) interface{} {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_612_merge.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestMerge(t *testing.T) {\n  candidate := merge\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]string{\"x\", \"y\"}, []string{\"a\", \"b\"}, []string{\"m\", \"n\"}}), expected: [][]int{[]string{\"x\", \"a\", \"m\"}, []string{\"y\", \"b\", \"n\"}} },\n     { actual: candidate([][]int{[]int{1, 2}, []int{3, 4}, []int{5, 6}, []int{7, 8}}), expected: [][]int{[]int{1, 3, 5, 7}, []int{2, 4, 6, 8}} },\n     { actual: candidate([][]int{[]string{\"x\", \"y\", \"z\"}, []string{\"a\", \"b\", \"c\"}, []string{\"m\", \"n\", \"o\"}}), expected: [][]int{[]string{\"x\", \"a\", \"m\"}, []string{\"y\", \"b\", \"n\"}, []string{\"z\", \"c\", \"o\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return nil\n    }\n}\n",
    "    if lst == nil {\n        return nil\n    }\n    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{}\n        }\n        if len(l) == 1 {\n            return merge(l[0])\n        }\n        return merge([]interface{}{merge(l[0]), merge(l[1:])})\n    case []string:\n        l := lst.([]string)\n        if len(l) == 0 {\n            return []string{}\n        }\n        if len(l) == 1 {\n            return merge(l[0])\n        }\n        return merge([]string{merge(l[0]), merge(l[1:])})\n    case string:\n        return lst.(string)\n    }\n    return nil\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(\"Not a list\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var lst1 []interface{}\n        var lst2 []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                lst1 = append(lst1, v.([]interface{})[0])\n                lst2 = append(lst2, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{lst1, lst2}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                if len(v.([]interface{})) != 2 {\n                    panic(\"Invalid input\")\n                }\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            default:\n                panic(\"Invalid input\")\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        panic(\"Invalid input\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0]}, []interface{}{}}\n        }\n        return []interface{}{[]interface{}{l[0]}, []interface{}{l[1]}}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            first := merge(lst[0]).([]interface{})\n            rest := merge(lst[1:]).([]interface{})\n            return []interface{}{append(first[0].([]interface{}), rest[0].([]interface{})...), append(first[1].([]interface{}), rest[1].([]interface{})...)}\n        }\n    case []int:\n        lst := lst.([]int)\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            first := merge(lst[0]).([]interface{})\n            rest := merge(lst[1:]).([]interface{})\n            return []interface{}{append(first[0].([]interface{}), rest[0].([]interface{})...), append(first[1].([]interface{}), rest[1].([]interface{})...)}\n        }\n    case int:\n        return []interface{}{[]interface{}{lst}, []interface{}{}}\n    default:\n        panic(\"Unsupported type\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var a, b []interface{}\n        for _, v := range lst.([]interface{}) {\n            if v.([]interface{})[0] != nil {\n                a = append(a, v.([]interface{})[0])\n            }\n            if v.([]interface{})[1] != nil {\n                b = append(b, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{a, b}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return [][]interface{}{\n                []interface{}{lst[0].([]interface{})[0], lst[1].([]interface{})[0]},\n                []interface{}{lst[0].([]interface{})[1], lst[1].([]interface{})[1]},\n            }\n        }\n        return [][]interface{}{\n            []interface{}{lst[0].([]interface{})[0], merge(lst[1:]).([]interface{})[0]},\n            []interface{}{lst[0].([]interface{})[1], merge(lst[1:]).([]interface{})[1]},\n        }\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sub := range lst.([]interface{}) {\n            switch sub.(type) {\n            case []interface{}:\n                first = append(first, sub.([]interface{})[0])\n                second = append(second, sub.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            var first []interface{}\n            var second []interface{}\n            for _, v := range lst.([]interface{}) {\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            }\n            return []interface{}{first, second}\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        return []interface{}{\n            append(lst[0].([]interface{})[0].([]interface{}), merge(lst[1:])[0].([]interface{})...),\n            append(lst[0].([]interface{})[1].([]interface{}), merge(lst[1:])[1].([]interface{})...),\n        }\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            var first []interface{}\n            var second []interface{}\n            for _, v := range lst.([]interface{}) {\n                switch v.(type) {\n                    case []interface{}:\n                        first = append(first, v.([]interface{})[0])\n                        second = append(second, v.([]interface{})[1])\n                }\n            }\n            return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return nil\n    }\n}\n"
  ]
}