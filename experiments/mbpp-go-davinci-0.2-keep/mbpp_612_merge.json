{
  "name": "mbpp_612_merge",
  "language": "go_test.go",
  "prompt": "package merge_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a python function which takes a list of lists, where each sublist has two elements, and returns a list of two lists where the first list has the first element of each sublist and the second one has the second.\nfunc merge(lst interface{}) interface{} {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_612_merge.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestMerge(t *testing.T) {\n  candidate := merge\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]string{\"x\", \"y\"}, []string{\"a\", \"b\"}, []string{\"m\", \"n\"}}), expected: [][]int{[]string{\"x\", \"a\", \"m\"}, []string{\"y\", \"b\", \"n\"}} },\n     { actual: candidate([][]int{[]int{1, 2}, []int{3, 4}, []int{5, 6}, []int{7, 8}}), expected: [][]int{[]int{1, 3, 5, 7}, []int{2, 4, 6, 8}} },\n     { actual: candidate([][]int{[]string{\"x\", \"y\", \"z\"}, []string{\"a\", \"b\", \"c\"}, []string{\"m\", \"n\", \"o\"}}), expected: [][]int{[]string{\"x\", \"a\", \"m\"}, []string{\"y\", \"b\", \"n\"}, []string{\"z\", \"c\", \"o\"}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return nil\n    }\n}\n",
    "    if lst == nil {\n        return nil\n    }\n    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{}\n        }\n        if len(l) == 1 {\n            return merge(l[0])\n        }\n        return merge([]interface{}{merge(l[0]), merge(l[1:])})\n    case []string:\n        l := lst.([]string)\n        if len(l) == 0 {\n            return []string{}\n        }\n        if len(l) == 1 {\n            return merge(l[0])\n        }\n        return merge([]string{merge(l[0]), merge(l[1:])})\n    case string:\n        return lst.(string)\n    }\n    return nil\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(\"Not a list\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var lst1 []interface{}\n        var lst2 []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                lst1 = append(lst1, v.([]interface{})[0])\n                lst2 = append(lst2, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{lst1, lst2}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                if len(v.([]interface{})) != 2 {\n                    panic(\"Invalid input\")\n                }\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            default:\n                panic(\"Invalid input\")\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        panic(\"Invalid input\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0]}, []interface{}{}}\n        }\n        return []interface{}{[]interface{}{l[0]}, []interface{}{l[1]}}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            first := merge(lst[0]).([]interface{})\n            rest := merge(lst[1:]).([]interface{})\n            return []interface{}{append(first[0].([]interface{}), rest[0].([]interface{})...), append(first[1].([]interface{}), rest[1].([]interface{})...)}\n        }\n    case []int:\n        lst := lst.([]int)\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            first := merge(lst[0]).([]interface{})\n            rest := merge(lst[1:]).([]interface{})\n            return []interface{}{append(first[0].([]interface{}), rest[0].([]interface{})...), append(first[1].([]interface{}), rest[1].([]interface{})...)}\n        }\n    case int:\n        return []interface{}{[]interface{}{lst}, []interface{}{}}\n    default:\n        panic(\"Unsupported type\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var a, b []interface{}\n        for _, v := range lst.([]interface{}) {\n            if v.([]interface{})[0] != nil {\n                a = append(a, v.([]interface{})[0])\n            }\n            if v.([]interface{})[1] != nil {\n                b = append(b, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{a, b}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return nil\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return [][]interface{}{\n                []interface{}{lst[0].([]interface{})[0], lst[1].([]interface{})[0]},\n                []interface{}{lst[0].([]interface{})[1], lst[1].([]interface{})[1]},\n            }\n        }\n        return [][]interface{}{\n            []interface{}{lst[0].([]interface{})[0], merge(lst[1:]).([]interface{})[0]},\n            []interface{}{lst[0].([]interface{})[1], merge(lst[1:]).([]interface{})[1]},\n        }\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sub := range lst.([]interface{}) {\n            switch sub.(type) {\n            case []interface{}:\n                first = append(first, sub.([]interface{})[0])\n                second = append(second, sub.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            var first []interface{}\n            var second []interface{}\n            for _, v := range lst.([]interface{}) {\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            }\n            return []interface{}{first, second}\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        return []interface{}{\n            append(lst[0].([]interface{})[0].([]interface{}), merge(lst[1:])[0].([]interface{})...),\n            append(lst[0].([]interface{})[1].([]interface{}), merge(lst[1:])[1].([]interface{})...),\n        }\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            var first []interface{}\n            var second []interface{}\n            for _, v := range lst.([]interface{}) {\n                switch v.(type) {\n                    case []interface{}:\n                        first = append(first, v.([]interface{})[0])\n                        second = append(second, v.([]interface{})[1])\n                }\n            }\n            return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case [][]interface{}:\n        var lst1 []interface{}\n        var lst2 []interface{}\n        for _, sublist := range lst.([][]interface{}) {\n            lst1 = append(lst1, sublist[0])\n            lst2 = append(lst2, sublist[1])\n        }\n        return [][]interface{}{lst1, lst2}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        if len(lst) > 1 {\n            return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n        }\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        first := make([]interface{}, 0)\n        second := make([]interface{}, 0)\n        for _, sub := range lst.([]interface{}) {\n            switch sub.(type) {\n            case []interface{}:\n                first = append(first, sub.([]interface{})[0])\n                second = append(second, sub.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var l1 []interface{}\n        var l2 []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                l1 = append(l1, v.([]interface{})[0])\n                l2 = append(l2, v.([]interface{})[1])\n            default:\n                panic(\"Invalid input\")\n            }\n        }\n        return []interface{}{l1, l2}\n    default:\n        panic(\"Invalid input\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                if len(v.([]interface{})) != 2 {\n                    panic(\"Sublist must have two elements\")\n                }\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            default:\n                panic(\"Sublist must be a list\")\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        panic(\"List must be a list\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: %v is not a list\", lst))\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var res1, res2 []interface{}\n        for _, v := range lst.([]interface{}) {\n            if v1, ok := v.([]interface{}); ok {\n                res1 = append(res1, v1[0])\n                res2 = append(res2, v1[1])\n            }\n        }\n        return []interface{}{res1, res2}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        return mergeLst(lst.([]interface{}))\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{}\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        return merge([]interface{}{merge(lst[0]), merge(lst[1:])})\n    case []int:\n        lst := lst.([]int)\n        if len(lst) == 0 {\n            return []int{}\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        return merge([]int{merge(lst[0]), merge(lst[1:])})\n    case []string:\n        lst := lst.([]string)\n        if len(lst) == 0 {\n            return []string{}\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        return merge([]string{merge(lst[0]), merge(lst[1:])})\n    case int:\n        return lst\n    case string:\n        return lst\n    default:\n        panic(\"merge: unknown type\")\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var lst1 []interface{}\n        var lst2 []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                lst1 = append(lst1, v.([]interface{})[0])\n                lst2 = append(lst2, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{lst1, lst2}\n    }\n    return nil\n}\n",
    "    if lst == nil {\n        return nil\n    }\n    switch lst.(type) {\n    case []interface{}:\n        var l1, l2 []interface{}\n        for _, v := range lst.([]interface{}) {\n            if v == nil {\n                continue\n            }\n            switch v.(type) {\n            case []interface{}:\n                if len(v.([]interface{})) != 2 {\n                    panic(\"invalid input\")\n                }\n                l1 = append(l1, v.([]interface{})[0])\n                l2 = append(l2, v.([]interface{})[1])\n            default:\n                panic(\"invalid input\")\n            }\n        }\n        return []interface{}{l1, l2}\n    default:\n        panic(\"invalid input\")\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                if len(v.([]interface{})) != 2 {\n                    return nil\n                }\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            default:\n                return nil\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sublist := range lst.([]interface{}) {\n            if sublist.([]interface{})[0] != nil {\n                first = append(first, sublist.([]interface{})[0])\n            }\n            if sublist.([]interface{})[1] != nil {\n                second = append(second, sublist.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var l1, l2 []interface{}\n        for _, sub := range lst.([]interface{}) {\n            switch sub.(type) {\n            case []interface{}:\n                if len(sub.([]interface{})) == 2 {\n                    l1 = append(l1, sub.([]interface{})[0])\n                    l2 = append(l2, sub.([]interface{})[1])\n                }\n            }\n        }\n        return []interface{}{l1, l2}\n    }\n    return nil\n}\n",
    "    var result [][]int\n    var first []int\n    var second []int\n    for _, v := range lst.([][]int) {\n        first = append(first, v[0])\n        second = append(second, v[1])\n    }\n    result = append(result, first)\n    result = append(result, second)\n    return result\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sublist := range lst.([]interface{}) {\n            switch sublist.(type) {\n            case []interface{}:\n                if len(sublist.([]interface{})) == 2 {\n                    first = append(first, sublist.([]interface{})[0])\n                    second = append(second, sublist.([]interface{})[1])\n                }\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append(lst[0].([]interface{})[0].([]interface{}), lst[1].([]interface{})[0].([]interface{})...), append(lst[0].([]interface{})[1].([]interface{}), lst[1].([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var l1, l2 []interface{}\n        for _, sub := range lst.([]interface{}) {\n            switch sub.(type) {\n            case []interface{}:\n                if len(sub.([]interface{})) != 2 {\n                    return nil\n                }\n                l1 = append(l1, sub.([]interface{})[0])\n                l2 = append(l2, sub.([]interface{})[1])\n            default:\n                return nil\n            }\n        }\n        return []interface{}{l1, l2}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                if len(v.([]interface{})) != 2 {\n                    return nil\n                }\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            default:\n                return nil\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append(lst[0].([]interface{})[0].([]interface{}), merge(lst[1:]).([]interface{})[0].([]interface{})...), append(lst[0].([]interface{})[1].([]interface{}), merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{}\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        return merge([]interface{}{merge(lst[0]), merge(lst[1:])})\n    case []int:\n        lst := lst.([]int)\n        if len(lst) == 0 {\n            return []int{}\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        return merge([]int{merge(lst[0]), merge(lst[1:])})\n    case []string:\n        lst := lst.([]string)\n        if len(lst) == 0 {\n            return []string{}\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        return merge([]string{merge(lst[0]), merge(lst[1:])})\n    case int:\n        return lst.(int)\n    case string:\n        return lst.(string)\n    default:\n        panic(\"unexpected type\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var lst1 []interface{}\n        var lst2 []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                lst1 = append(lst1, v.([]interface{})[0])\n                lst2 = append(lst2, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{lst1, lst2}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            first := merge(lst[0])\n            rest := merge(lst[1:])\n            return []interface{}{append(first.([]interface{})[0].([]interface{}), rest.([]interface{})[0].([]interface{})...), append(first.([]interface{})[1].([]interface{}), rest.([]interface{})[1].([]interface{})...)}\n        }\n    case []int:\n        lst := lst.([]int)\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            first := merge(lst[0])\n            rest := merge(lst[1:])\n            return []interface{}{append(first.([]interface{})[0].([]interface{}), rest.([]interface{})[0].([]interface{})...), append(first.([]interface{})[1].([]interface{}), rest.([]interface{})[1].([]interface{})...)}\n        }\n    case int:\n        return []interface{}{[]interface{}{lst}, []interface{}{}}\n    default:\n        panic(fmt.Sprintf(\"%v\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sub := range lst.([]interface{}) {\n            switch sub.(type) {\n            case []interface{}:\n                first = append(first, sub.([]interface{})[0])\n                second = append(second, sub.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: %v is not a list\", lst))\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return nil\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        return merge(lst[0]).([]interface{})\n    case []int:\n        return lst\n    case []string:\n        return lst\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{}\n        }\n        if len(lst) == 1 {\n            return lst\n        }\n        if len(lst) == 2 {\n            return []interface{}{\n                []interface{}{lst[0].([]interface{})[0], lst[1].([]interface{})[0]},\n                []interface{}{lst[0].([]interface{})[1], lst[1].([]interface{})[1]},\n            }\n        }\n        return []interface{}{\n            append(lst[0].([]interface{})[0].([]interface{}), lst[1].([]interface{})[0].([]interface{})...),\n            append(lst[0].([]interface{})[1].([]interface{}), lst[1].([]interface{})[1].([]interface{})...),\n        }\n    default:\n        return nil\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{}\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        return merge([]interface{}{merge(lst[0]), merge(lst[1:])})\n    case []int:\n        lst := lst.([]int)\n        if len(lst) == 0 {\n            return []int{}\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        return merge([]int{merge(lst[0]), merge(lst[1:])})\n    case []string:\n        lst := lst.([]string)\n        if len(lst) == 0 {\n            return []string{}\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        return merge([]string{merge(lst[0]), merge(lst[1:])})\n    case [][]int:\n        lst := lst.([][]int)\n        if len(lst) == 0 {\n            return [][]int{}\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        return merge([][]int{merge(lst[0]), merge(lst[1:])})\n    case [][]string:\n        lst := lst.([][]string)\n        if len(lst) == 0 {\n            return [][]string{}\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        return merge([][]string{merge(lst[0]), merge(lst[1:])})\n    case [][]interface{}:\n        lst := lst.([][]interface{})\n        if len(lst) == 0 {\n            return [][]interface{}{}\n        }\n        if len(lst) == 1 {\n           ",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, v := range lst.([]interface{}) {\n            if v.([]interface{})[0] != nil {\n                first = append(first, v.([]interface{})[0])\n            }\n            if v.([]interface{})[1] != nil {\n                second = append(second, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        return nil\n    }\n}\n",
    "    var result [][]int\n    switch lst.(type) {\n    case []interface{}:\n        for _, v := range lst.([]interface{}) {\n            result = append(result, merge(v).([]int))\n        }\n    case []int:\n        result = append(result, lst.([]int))\n    }\n    return result\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return nil\n        }\n        if len(lst) == 1 {\n            return lst\n        }\n        if len(lst) == 2 {\n            return []interface{}{lst[0], lst[1]}\n        }\n        return []interface{}{merge(lst[:len(lst)/2]), merge(lst[len(lst)/2:])}\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case [][]int:\n        lst := lst.([][]int)\n        res := make([][]int, 2)\n        for i := 0; i < len(lst); i++ {\n            res[0] = append(res[0], lst[i][0])\n            res[1] = append(res[1], lst[i][1])\n        }\n        return res\n    case [][]string:\n        lst := lst.([][]string)\n        res := make([][]string, 2)\n        for i := 0; i < len(lst); i++ {\n            res[0] = append(res[0], lst[i][0])\n            res[1] = append(res[1], lst[i][1])\n        }\n        return res\n    }\n    return nil\n}\n",
    "    var result [][]interface{}\n    switch lst.(type) {\n    case []interface{}:\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                if len(v.([]interface{})) == 2 {\n                    result = append(result, v.([]interface{}))\n                }\n            }\n        }\n    }\n    return result\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return lst\n        }\n        return merge(lst[1:])\n    case [][]interface{}:\n        if len(lst) == 0 {\n            return lst\n        }\n        return merge(lst[1:])\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            first := merge(lst[1:])\n            first[0] = append(first[0].([]interface{}), lst[0].([]interface{})[0])\n            first[1] = append(first[1].([]interface{}), lst[0].([]interface{})[1])\n            return first\n        }\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{}\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        return merge([]interface{}{merge(lst[0]), merge(lst[1:])})\n    case []int:\n        lst := lst.([]int)\n        if len(lst) == 0 {\n            return []int{}\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        return merge([]int{merge(lst[0]), merge(lst[1:])})\n    case []string:\n        lst := lst.([]string)\n        if len(lst) == 0 {\n            return []string{}\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        return merge([]string{merge(lst[0]), merge(lst[1:])})\n    case [][]int:\n        lst := lst.([][]int)\n        if len(lst) == 0 {\n            return [][]int{}\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        return merge([][]int{merge(lst[0]), merge(lst[1:])})\n    case [][]string:\n        lst := lst.([][]string)\n        if len(lst) == 0 {\n            return [][]string{}\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        return merge([][]string{merge(lst[0]), merge(lst[1:])})\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{}\n        }\n        if len(lst) == 1 {\n            return lst[0]",
    "    switch lst.(type) {\n    case []interface{}:\n        var lst1, lst2 []interface{}\n        for _, sublist := range lst.([]interface{}) {\n            switch sublist.(type) {\n            case []interface{}:\n                lst1 = append(lst1, sublist.([]interface{})[0])\n                lst2 = append(lst2, sublist.([]interface{})[1])\n            default:\n                return nil\n            }\n        }\n        return []interface{}{lst1, lst2}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                if len(v.([]interface{})) != 2 {\n                    return nil\n                }\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            default:\n                return nil\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sublist := range lst.([]interface{}) {\n            switch sublist.(type) {\n            case []interface{}:\n                if len(sublist.([]interface{})) == 2 {\n                    first = append(first, sublist.([]interface{})[0])\n                    second = append(second, sublist.([]interface{})[1])\n                }\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    if lst == nil {\n        return nil\n    }\n    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return nil\n        }\n        if len(l) == 1 {\n            return merge(l[0])\n        }\n        return []interface{}{merge(l[0]), merge(l[1:])}\n    case []int:\n        l := lst.([]int)\n        if len(l) == 0 {\n            return nil\n        }\n        if len(l) == 1 {\n            return l[0]\n        }\n        return []int{l[0], merge(l[1:])}\n    case int:\n        return lst\n    default:\n        return nil\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected []interface{}, got %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append(lst[0].([]interface{})[0].([]interface{}), merge(lst[1:]).([]interface{})[0].([]interface{})...), append(lst[0].([]interface{})[1].([]interface{}), merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        if len(lst) > 1 {\n            return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n        }\n    }\n    return nil\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return lst\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return merge2(lst[0], lst[1])\n        }\n        return merge2(merge(lst[:len(lst)/2]), merge(lst[len(lst)/2:]))\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sublist := range lst.([]interface{}) {\n            if sublist.([]interface{})[0] != nil {\n                first = append(first, sublist.([]interface{})[0])\n            }\n            if sublist.([]interface{})[1] != nil {\n                second = append(second, sublist.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var l1, l2 []interface{}\n        for _, sublst := range lst.([]interface{}) {\n            l1 = append(l1, sublst.([]interface{})[0])\n            l2 = append(l2, sublst.([]interface{})[1])\n        }\n        return []interface{}{l1, l2}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var l1, l2 []interface{}\n        for _, sub := range lst.([]interface{}) {\n            switch sub.(type) {\n            case []interface{}:\n                if len(sub.([]interface{})) != 2 {\n                    return nil\n                }\n                l1 = append(l1, sub.([]interface{})[0])\n                l2 = append(l2, sub.([]interface{})[1])\n            default:\n                return nil\n            }\n        }\n        return []interface{}{l1, l2}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(\"Not a list\")\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: expected []interface{}, got %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return nil\n    }\n}\n",
    "    lst1 := lst.([]interface{})\n    lst2 := make([]interface{}, len(lst1))\n    lst3 := make([]interface{}, len(lst1))\n    for i, v := range lst1 {\n        lst2[i] = v.([]interface{})[0]\n        lst3[i] = v.([]interface{})[1]\n    }\n    return []interface{}{lst2, lst3}\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var l1, l2 []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                l1 = append(l1, v.([]interface{})[0])\n                l2 = append(l2, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{l1, l2}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append(lst[0].([]interface{}), merge(lst[1:]).([]interface{})[0].([]interface{})...), append(lst[0].([]interface{}), merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var l1, l2 []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                l1 = append(l1, v.([]interface{})[0])\n                l2 = append(l2, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{l1, l2}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sub := range lst.([]interface{}) {\n            if sub.([]interface{})[0] != nil {\n                first = append(first, sub.([]interface{})[0])\n            }\n            if sub.([]interface{})[1] != nil {\n                second = append(second, sub.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            return []interface{}{append(l[0].([]interface{})[0].([]interface{}), l[1].([]interface{})[0].([]interface{})...), append(l[0].([]interface{})[1].([]interface{}), l[1].([]interface{})[1].([]interface{})...)}\n        }\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{}\n        }\n        if len(l) == 1 {\n            return l[0]\n        }\n        return merge([]interface{}{merge(l[0]), merge(l[1:])})\n    case []int:\n        l := lst.([]int)\n        if len(l) == 0 {\n            return []int{}\n        }\n        if len(l) == 1 {\n            return l[0]\n        }\n        return merge([]int{merge(l[0]), merge(l[1:])})\n    case []string:\n        l := lst.([]string)\n        if len(l) == 0 {\n            return []string{}\n        }\n        if len(l) == 1 {\n            return l[0]\n        }\n        return merge([]string{merge(l[0]), merge(l[1:])})\n    case int:\n        return lst.(int)\n    case string:\n        return lst.(string)\n    }\n    return nil\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            return merge(l[1:]).([]interface{})\n        }\n    case [][]interface{}:\n        l := lst.([][]interface{})\n        if len(l) == 0 {\n            return [][]interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            return merge(l[1:]).([][]interface{})\n        }\n    default:\n        return nil\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            return merge(lst[1:]).([]interface{})\n        }\n    case [][]interface{}:\n        if len(lst) == 0 {\n            return [][]interface{}{[]interface{}{}, []interface{}{}}\n        } else {\n            return [][]interface{}{append(lst[0][:1], merge(lst[1:]).([]interface{})[0]...), append(lst[0][1:], merge(lst[1:]).([]interface{})[1]...)}\n        }\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sublist := range lst.([]interface{}) {\n            switch sublist.(type) {\n            case []interface{}:\n                if len(sublist.([]interface{})) != 2 {\n                    panic(\"Sublist must have two elements\")\n                }\n                first = append(first, sublist.([]interface{})[0])\n                second = append(second, sublist.([]interface{})[1])\n            default:\n                panic(\"Sublist must be a list\")\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        panic(\"List must be a list\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var lst1 []interface{}\n        var lst2 []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                lst1 = append(lst1, v.([]interface{})[0])\n                lst2 = append(lst2, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{lst1, lst2}\n    }\n    return nil\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{}\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return merge2(lst[0], lst[1])\n        }\n        return merge2(lst[0], merge(lst[1:]))\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{}\n        }\n        if len(l) == 1 {\n            return l\n        }\n        return merge([]interface{}{merge(l[0]), merge(l[1])})\n    case []int:\n        l := lst.([]int)\n        if len(l) == 0 {\n            return []int{}\n        }\n        if len(l) == 1 {\n            return l\n        }\n        return merge([]int{merge(l[0]), merge(l[1])})\n    case []string:\n        l := lst.([]string)\n        if len(l) == 0 {\n            return []string{}\n        }\n        if len(l) == 1 {\n            return l\n        }\n        return merge([]string{merge(l[0]), merge(l[1])})\n    case [][]int:\n        l := lst.([][]int)\n        if len(l) == 0 {\n            return [][]int{}\n        }\n        if len(l) == 1 {\n            return l\n        }\n        return merge([][]int{merge(l[0]), merge(l[1])})\n    case [][]string:\n        l := lst.([][]string)\n        if len(l) == 0 {\n            return [][]string{}\n        }\n        if len(l) == 1 {\n            return l\n        }\n        return merge([][]string{merge(l[0]), merge(l[1])})\n    case [][][]int:\n        l := lst.([][][]int)\n        if len(l) == 0 {\n            return [][][]int{}\n        }\n        if len(l) == 1 {\n            return l\n        }\n        return merge([][][]int{merge(l[0]), merge(l[1])})\n    case [][][]string:\n        l := lst.([][][]string)\n       ",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, v := range lst.([]interface{}) {\n            first = append(first, v.([]interface{})[0])\n            second = append(second, v.([]interface{})[1])\n        }\n        return []interface{}{first, second}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"%v is not a list\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{}\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        return merge([]interface{}{merge(lst[0]), merge(lst[1:])})\n    case []int:\n        lst := lst.([]int)\n        if len(lst) == 0 {\n            return []int{}\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        return merge([]int{merge(lst[0]), merge(lst[1:])})\n    case []string:\n        lst := lst.([]string)\n        if len(lst) == 0 {\n            return []string{}\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        return merge([]string{merge(lst[0]), merge(lst[1:])})\n    case [][]interface{}:\n        lst := lst.([][]interface{})\n        if len(lst) == 0 {\n            return [][]interface{}{}\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        return merge([][]interface{}{merge(lst[0]), merge(lst[1:])})\n    case [][]int:\n        lst := lst.([][]int)\n        if len(lst) == 0 {\n            return [][]int{}\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        return merge([][]int{merge(lst[0]), merge(lst[1:])})\n    case [][]string:\n        lst := lst.([][]string)\n        if len(lst) == 0 {\n            return [][]string{}\n        }\n        if len(lst) == 1 {\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: %v is not a list\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{}\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return merge2(lst[0], lst[1])\n        }\n        return merge2(merge(lst[:len(lst)/2]), merge(lst[len(lst)/2:]))\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{}\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return []interface{}{\n                append(lst[0].([]interface{}), lst[1].([]interface{})[0]),\n                append(lst[0].([]interface{})[1:], lst[1].([]interface{})[1]),\n            }\n        }\n        return merge([]interface{}{\n            merge(lst[:len(lst)/2]),\n            merge(lst[len(lst)/2:]),\n        })\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, e := range lst.([]interface{}) {\n            if e.([]interface{})[0] != nil {\n                first = append(first, e.([]interface{})[0])\n            }\n            if e.([]interface{})[1] != nil {\n                second = append(second, e.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case [][]int:\n        lst := lst.([][]int)\n        var res [][]int\n        res = append(res, []int{})\n        res = append(res, []int{})\n        for _, v := range lst {\n            res[0] = append(res[0], v[0])\n            res[1] = append(res[1], v[1])\n        }\n        return res\n    case [][]string:\n        lst := lst.([][]string)\n        var res [][]string\n        res = append(res, []string{})\n        res = append(res, []string{})\n        for _, v := range lst {\n            res[0] = append(res[0], v[0])\n            res[1] = append(res[1], v[1])\n        }\n        return res\n    }\n    return nil\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, item := range lst.([]interface{}) {\n            switch item.(type) {\n            case []interface{}:\n                if len(item.([]interface{})) != 2 {\n                    panic(\"Invalid input\")\n                }\n                first = append(first, item.([]interface{})[0])\n                second = append(second, item.([]interface{})[1])\n            default:\n                panic(\"Invalid input\")\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        panic(\"Invalid input\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n        }\n        return []interface{}{\n            append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...),\n            append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...),\n        }\n    default:\n        return nil\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append(lst[0].([]interface{}), merge(lst[1:]).([]interface{})[0].([]interface{})...), append(lst[0].([]interface{}), merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var lst1 []interface{}\n        var lst2 []interface{}\n        for _, v := range lst.([]interface{}) {\n            if v.([]interface{})[0] != nil {\n                lst1 = append(lst1, v.([]interface{})[0])\n            }\n            if v.([]interface{})[1] != nil {\n                lst2 = append(lst2, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{lst1, lst2}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sublist := range lst.([]interface{}) {\n            switch sublist.(type) {\n            case []interface{}:\n                if len(sublist.([]interface{})) != 2 {\n                    return nil\n                }\n                first = append(first, sublist.([]interface{})[0])\n                second = append(second, sublist.([]interface{})[1])\n            default:\n                return nil\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var res [][]interface{}\n        for _, v := range lst.([]interface{}) {\n            res = append(res, merge(v).([]interface{}))\n        }\n        return res\n    case [][]interface{}:\n        var res [][]interface{}\n        for _, v := range lst.([][]interface{}) {\n            res = append(res, merge(v).([]interface{}))\n        }\n        return res\n    case []int:\n        var res [][]int\n        for _, v := range lst.([]int) {\n            res = append(res, merge(v).([]int))\n        }\n        return res\n    case [][]int:\n        var res [][]int\n        for _, v := range lst.([][]int) {\n            res = append(res, merge(v).([]int))\n        }\n        return res\n    case int:\n        return []int{lst.(int)}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    var result [][]int\n    switch lst.(type) {\n    case [][]int:\n        for _, v := range lst.([][]int) {\n            if len(result) == 0 {\n                result = append(result, []int{v[0]})\n                result = append(result, []int{v[1]})\n            } else {\n                result[0] = append(result[0], v[0])\n                result[1] = append(result[1], v[1])\n            }\n        }\n    }\n    return result\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                if len(v.([]interface{})) != 2 {\n                    panic(\"Invalid input\")\n                }\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            default:\n                panic(\"Invalid input\")\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        panic(\"Invalid input\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(fmt.Sprintf(\"merge: invalid type %T\", lst))\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var a, b []interface{}\n        for _, v := range lst.([]interface{}) {\n            if v.([]interface{})[0].(int) % 2 == 0 {\n                a = append(a, v.([]interface{})[0])\n                b = append(b, v.([]interface{})[1])\n            } else {\n                a = append(a, v.([]interface{})[1])\n                b = append(b, v.([]interface{})[0])\n            }\n        }\n        return []interface{}{a, b}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    var result [][]interface{}\n    switch lst.(type) {\n    case []interface{}:\n        for _, item := range lst.([]interface{}) {\n            switch item.(type) {\n            case []interface{}:\n                if len(item.([]interface{})) == 2 {\n                    result = append(result, item.([]interface{}))\n                }\n            }\n        }\n    }\n    return result\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var l1, l2 []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                if len(v.([]interface{})) != 2 {\n                    return nil\n                }\n                l1 = append(l1, v.([]interface{})[0])\n                l2 = append(l2, v.([]interface{})[1])\n            default:\n                return nil\n            }\n        }\n        return []interface{}{l1, l2}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{}\n        }\n        if len(lst) == 1 {\n            return merge(lst[0])\n        }\n        return merge([]interface{}{merge(lst[0]), merge(lst[1:])})\n    case []int:\n        lst := lst.([]int)\n        if len(lst) == 0 {\n            return []int{}\n        }\n        if len(lst) == 1 {\n            return merge(lst[0])\n        }\n        return merge([]int{merge(lst[0]), merge(lst[1:])})\n    case [][]int:\n        lst := lst.([][]int)\n        if len(lst) == 0 {\n            return [][]int{}\n        }\n        if len(lst) == 1 {\n            return merge(lst[0])\n        }\n        return merge([][]int{merge(lst[0]), merge(lst[1:])})\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{}\n        }\n        if len(lst) == 1 {\n            return merge(lst[0])\n        }\n        return merge([]interface{}{merge(lst[0]), merge(lst[1:])})\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{}\n        }\n        if len(lst) == 1 {\n            return merge(lst[0])\n        }\n        return merge([]interface{}{merge(lst[0]), merge(lst[1:])})\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{}\n        }\n        if len(lst)",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sublst := range lst.([]interface{}) {\n            switch sublst.(type) {\n            case []interface{}:\n                if len(sublst.([]interface{})) != 2 {\n                    panic(\"Sublist must have exactly two elements\")\n                }\n                first = append(first, sublst.([]interface{})[0])\n                second = append(second, sublst.([]interface{})[1])\n            default:\n                panic(\"Sublist must be a list\")\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        panic(\"List must be a list\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sublist := range lst.([]interface{}) {\n            if sublist.([]interface{})[0] != nil {\n                first = append(first, sublist.([]interface{})[0])\n            }\n            if sublist.([]interface{})[1] != nil {\n                second = append(second, sublist.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        panic(\"Invalid input\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, e := range lst.([]interface{}) {\n            if e.([]interface{})[0] != nil {\n                first = append(first, e.([]interface{})[0])\n            }\n            if e.([]interface{})[1] != nil {\n                second = append(second, e.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(l) == 1 {\n            return []interface{}{[]interface{}{l[0].([]interface{})[0]}, []interface{}{l[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{l[0].([]interface{})[0]}, merge(l[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{l[0].([]interface{})[1]}, merge(l[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return lst\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return merge2(lst[0], lst[1])\n        }\n        return merge2(merge(lst[:len(lst)/2]), merge(lst[len(lst)/2:]))\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                if len(v.([]interface{})) == 2 {\n                    first = append(first, v.([]interface{})[0])\n                    second = append(second, v.([]interface{})[1])\n                }\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sub := range lst.([]interface{}) {\n            switch sub.(type) {\n            case []interface{}:\n                if len(sub.([]interface{})) != 2 {\n                    panic(\"sublist must have two elements\")\n                }\n                first = append(first, sub.([]interface{})[0])\n                second = append(second, sub.([]interface{})[1])\n            default:\n                panic(\"list elements must be sublists\")\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        panic(\"list must be a list of lists\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first, second []interface{}\n        for _, sub := range lst.([]interface{}) {\n            switch sub.(type) {\n            case []interface{}:\n                first = append(first, sub.([]interface{})[0])\n                second = append(second, sub.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            var first []interface{}\n            var second []interface{}\n            for _, v := range lst.([]interface{}) {\n                switch v.(type) {\n                    case []interface{}:\n                        if len(v.([]interface{})) != 2 {\n                            return nil\n                        }\n                        first = append(first, v.([]interface{})[0])\n                        second = append(second, v.([]interface{})[1])\n                    default:\n                        return nil\n                }\n            }\n            return []interface{}{first, second}\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, v := range lst.([]interface{}) {\n            if v.([]interface{})[0] != nil {\n                first = append(first, v.([]interface{})[0])\n            }\n            if v.([]interface{})[1] != nil {\n                second = append(second, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        return nil\n    }\n}\n",
    "    switch v := lst.(type) {\n    case []interface{}:\n        if len(v) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(v) == 1 {\n            return []interface{}{[]interface{}{v[0].([]interface{})[0]}, []interface{}{v[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{v[0].([]interface{})[0]}, merge(v[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{v[0].([]interface{})[1]}, merge(v[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return nil\n    }\n}\n",
    "    var result [][]int\n    switch lst := lst.(type) {\n    case [][]int:\n        result = make([][]int, 2)\n        for _, sublist := range lst {\n            result[0] = append(result[0], sublist[0])\n            result[1] = append(result[1], sublist[1])\n        }\n    }\n    return result\n}\n",
    "    switch lst := lst.(type) {\n        case []interface{}:\n            if len(lst) == 0 {\n                return lst\n            }\n            switch lst[0].(type) {\n                case []interface{}:\n                    return merge(lst)\n                case int:\n                    return lst\n            }\n        case [][]interface{}:\n            if len(lst) == 0 {\n                return lst\n            }\n            if len(lst[0]) != 2 {\n                panic(\"Invalid input\")\n            }\n            var result [][]interface{}\n            for _, v := range lst {\n                result = append(result, []interface{}{v[0]})\n                result = append(result, []interface{}{v[1]})\n            }\n            return result\n    }\n    return nil\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0]}, []interface{}{}}\n        }\n        if len(lst) == 2 {\n            return []interface{}{[]interface{}{lst[0]}, []interface{}{lst[1]}}\n        }\n        if len(lst) > 2 {\n            return []interface{}{[]interface{}{lst[0]}, []interface{}{lst[1:]}}\n        }\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{}\n        }\n        switch lst[0].(type) {\n        case []interface{}:\n            lst := lst.([]interface{})\n            if len(lst) == 0 {\n                return []interface{}{}\n            }\n            switch lst[0].(type) {\n            case []interface{}:\n                lst := lst.([]interface{})\n                if len(lst) == 0 {\n                    return []interface{}{}\n                }\n                switch lst[0].(type) {\n                case []interface{}:\n                    lst := lst.([]interface{})\n                    if len(lst) == 0 {\n                        return []interface{}{}\n                    }\n                    switch lst[0].(type) {\n                    case []interface{}:\n                        lst := lst.([]interface{})\n                        if len(lst) == 0 {\n                            return []interface{}{}\n                        }\n                        switch lst[0].(type) {\n                        case []interface{}:\n                            lst := lst.([]interface{})\n                            if len(lst) == 0 {\n                                return []interface{}{}\n                            }\n                            switch lst[0].(type) {\n                            case []interface{}:\n                                lst := lst.([]interface{})\n                                if len(lst) == 0 {\n                                    return []interface{}{}\n                                }\n                                switch lst[0].(type) {\n                                case []interface{}:\n                                    lst := lst.([]interface{})\n                                    if len(lst) == 0 {\n                                        return []interface{}{}\n                                    }\n                                    switch lst[0].(type) {\n                                    case []interface{}:\n                                        lst := lst.([]interface{})\n                                        if len(lst) == 0 {\n                                            return []interface{}{}\n                                        }\n                                        switch lst[0].(type) {\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return lst\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    var result []interface{}\n    var result1 []interface{}\n    var result2 []interface{}\n    switch lst.(type) {\n    case []interface{}:\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                result1 = append(result1, v.([]interface{})[0])\n                result2 = append(result2, v.([]interface{})[1])\n            }\n        }\n    }\n    result = append(result, result1)\n    result = append(result, result2)\n    return result\n}\n",
    "    if lst == nil {\n        return nil\n    }\n    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return nil\n        }\n        if len(l) == 1 {\n            return merge(l[0])\n        }\n        return []interface{}{merge(l[0]), merge(l[1:])}\n    case []int:\n        l := lst.([]int)\n        if len(l) == 0 {\n            return nil\n        }\n        if len(l) == 1 {\n            return merge(l[0])\n        }\n        return []interface{}{merge(l[0]), merge(l[1:])}\n    case int:\n        return lst\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            var first []interface{}\n            var second []interface{}\n            for _, v := range lst.([]interface{}) {\n                if v.([]interface{})[0] != nil {\n                    first = append(first, v.([]interface{})[0])\n                }\n                if v.([]interface{})[1] != nil {\n                    second = append(second, v.([]interface{})[1])\n                }\n            }\n            return []interface{}{first, second}\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                if len(v.([]interface{})) != 2 {\n                    panic(\"Invalid input\")\n                }\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            default:\n                panic(\"Invalid input\")\n            }\n        }\n        return []interface{}{first, second}\n    default:\n        panic(\"Invalid input\")\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, item := range lst.([]interface{}) {\n            switch item.(type) {\n            case []interface{}:\n                first = append(first, item.([]interface{})[0])\n                second = append(second, item.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        var first []interface{}\n        var second []interface{}\n        for _, v := range lst.([]interface{}) {\n            switch v.(type) {\n            case []interface{}:\n                first = append(first, v.([]interface{})[0])\n                second = append(second, v.([]interface{})[1])\n            }\n        }\n        return []interface{}{first, second}\n    }\n    return nil\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst := lst.(type) {\n    case []interface{}:\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{}\n        }\n        if len(lst) == 1 {\n            return lst[0]\n        }\n        if len(lst) == 2 {\n            return merge2(lst[0], lst[1])\n        }\n        return merge2(merge(lst[:len(lst)/2]), merge(lst[len(lst)/2:]))\n    default:\n        return lst\n    }\n}\n",
    "    // TODO: implement\n    return nil\n}\n",
    "    switch lst.(type) {\n        case []interface{}:\n            first := make([]interface{}, 0)\n            second := make([]interface{}, 0)\n            for _, v := range lst.([]interface{}) {\n                switch v.(type) {\n                    case []interface{}:\n                        first = append(first, v.([]interface{})[0])\n                        second = append(second, v.([]interface{})[1])\n                    default:\n                        return nil\n                }\n            }\n            return []interface{}{first, second}\n        default:\n            return nil\n    }\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        l := lst.([]interface{})\n        if len(l) == 0 {\n            return l\n        }\n        if len(l) == 1 {\n            return merge(l[0])\n        }\n        return []interface{}{merge(l[0]), merge(l[1:])}\n    case [][]interface{}:\n        l := lst.([][]interface{})\n        if len(l) == 0 {\n            return l\n        }\n        if len(l) == 1 {\n            return merge(l[0])\n        }\n        return []interface{}{merge(l[0]), merge(l[1:])}\n    case []int:\n        l := lst.([]int)\n        if len(l) == 0 {\n            return l\n        }\n        if len(l) == 1 {\n            return merge(l[0])\n        }\n        return []interface{}{merge(l[0]), merge(l[1:])}\n    case [][]int:\n        l := lst.([][]int)\n        if len(l) == 0 {\n            return l\n        }\n        if len(l) == 1 {\n            return merge(l[0])\n        }\n        return []interface{}{merge(l[0]), merge(l[1:])}\n    case []string:\n        l := lst.([]string)\n        if len(l) == 0 {\n            return l\n        }\n        if len(l) == 1 {\n            return merge(l[0])\n        }\n        return []interface{}{merge(l[0]), merge(l[1:])}\n    case [][]string:\n        l := lst.([][]string)\n        if len(l) == 0 {\n            return l\n        }\n        if len(l) == 1 {\n            return merge(l[0])\n        }\n        return []interface{}{merge(l[0]), merge(l[1:])}\n    default:\n        return lst\n    }\n}\n",
    "    var result [][]interface{}\n    for _, sublist := range lst.([][]interface{}) {\n        result = append(result, []interface{}{sublist[0], sublist[1]})\n    }\n    return result\n}\n",
    "    switch lst.(type) {\n    case []interface{}:\n        lst := lst.([]interface{})\n        if len(lst) == 0 {\n            return []interface{}{[]interface{}{}, []interface{}{}}\n        }\n        if len(lst) == 1 {\n            return []interface{}{[]interface{}{lst[0].([]interface{})[0]}, []interface{}{lst[0].([]interface{})[1]}}\n        }\n        return []interface{}{append([]interface{}{lst[0].([]interface{})[0]}, merge(lst[1:]).([]interface{})[0].([]interface{})...), append([]interface{}{lst[0].([]interface{})[1]}, merge(lst[1:]).([]interface{})[1].([]interface{})...)}\n    default:\n        return []interface{}{[]interface{}{}, []interface{}{}}\n    }\n}\n"
  ]
}