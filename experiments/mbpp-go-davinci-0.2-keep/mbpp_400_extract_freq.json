{
  "name": "mbpp_400_extract_freq",
  "language": "go_test.go",
  "prompt": "package extract_freq_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to extract the number of unique tuples in the given list.\nfunc extract_freq(test_list [][]interface{}) int {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_400_extract_freq.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestExtract_Freq(t *testing.T) {\n  candidate := extract_freq\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]interface{}{3, 4}, []interface{}{1, 2}, []interface{}{4, 3}, []interface{}{5, 6}}), expected: 3 },\n     { actual: candidate([][]int{[]interface{}{4, 15}, []interface{}{2, 3}, []interface{}{5, 4}, []interface{}{6, 7}}), expected: 4 },\n     { actual: candidate([][]int{[]interface{}{5, 16}, []interface{}{2, 3}, []interface{}{6, 5}, []interface{}{6, 9}}), expected: 4 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "completions": [
    "    // Create a map to store the unique tuples.\n    unique_tuples := make(map[string]bool)\n\n    // Iterate through the list of tuples.\n    for _, tuple := range test_list {\n        // Create a string to store the tuple.\n        tuple_string := \"\"\n\n        // Iterate through the tuple.\n        for _, element := range tuple {\n            // Convert the element to a string and append it to the tuple string.\n            tuple_string += fmt.Sprintf(\"%v\", element)\n        }\n\n        // Add the tuple to the map.\n        unique_tuples[tuple_string] = true\n    }\n\n    // Return the number of unique tuples.\n    return len(unique_tuples)\n}\n",
    "    // Create a map to store the unique tuples.\n    unique_tuples := make(map[string]bool)\n\n    // Iterate through the list of tuples.\n    for _, tuple := range test_list {\n        // Create a string representation of the tuple.\n        tuple_str := fmt.Sprintf(\"%v\", tuple)\n\n        // Check if the tuple is already in the map.\n        if _, ok := unique_tuples[tuple_str]; !ok {\n            // Add the tuple to the map.\n            unique_tuples[tuple_str] = true\n        }\n    }\n\n    // Return the number of unique tuples.\n    return len(unique_tuples)\n}\n",
    "    var count int\n    var seen = make(map[string]bool)\n    for _, item := range test_list {\n        key := fmt.Sprintf(\"%v\", item)\n        if !seen[key] {\n            seen[key] = true\n            count++\n        }\n    }\n    return count\n}\n",
    "    // Create a map to store the unique tuples.\n    unique_tuples := make(map[string]bool)\n\n    // Iterate through the list and store the unique tuples.\n    for _, tuple := range test_list {\n        // Create a string representation of the tuple.\n        tuple_string := fmt.Sprintf(\"%v\", tuple)\n\n        // Check if the tuple is already in the map.\n        _, exists := unique_tuples[tuple_string]\n\n        // If the tuple is not in the map, add it.\n        if !exists {\n            unique_tuples[tuple_string] = true\n        }\n    }\n\n    // Return the number of unique tuples.\n    return len(unique_tuples)\n}\n",
    "    var unique_tuples = make(map[string]int)\n    for _, tuple := range test_list {\n        unique_tuples[fmt.Sprintf(\"%v\", tuple)] += 1\n    }\n    return len(unique_tuples)\n}\n",
    "    // Create a map to store the unique tuples.\n    unique_tuples := make(map[string]bool)\n\n    // Loop through the list of tuples.\n    for _, tuple := range test_list {\n        // Create a string to store the tuple.\n        tuple_string := \"\"\n\n        // Loop through the tuple.\n        for _, element := range tuple {\n            // Add the element to the string.\n            tuple_string += fmt.Sprintf(\"%v\", element)\n        }\n\n        // Add the tuple to the map.\n        unique_tuples[tuple_string] = true\n    }\n\n    // Return the length of the map.\n    return len(unique_tuples)\n}\n",
    "    var unique_tuples = make(map[string]int)\n    for _, tuple := range test_list {\n        unique_tuples[fmt.Sprint(tuple)]++\n    }\n    return len(unique_tuples)\n}\n",
    "    // Create a map to store the unique tuples.\n    unique_tuples := make(map[string]bool)\n\n    // Iterate through the list and add the tuples to the map.\n    for _, tuple := range test_list {\n        // Convert the tuple to a string.\n        tuple_string := fmt.Sprintf(\"%v\", tuple)\n\n        // Add the tuple to the map.\n        unique_tuples[tuple_string] = true\n    }\n\n    // Return the length of the map.\n    return len(unique_tuples)\n}\n",
    "    var unique_tuples = make(map[string]bool)\n    for _, tuple := range test_list {\n        unique_tuples[fmt.Sprintf(\"%v\", tuple)] = true\n    }\n    return len(unique_tuples)\n}\n",
    "    // Create a map to store the unique tuples.\n    unique_tuples := make(map[string]bool)\n\n    // Iterate through the list and add the unique tuples to the map.\n    for _, tuple := range test_list {\n        // Convert the tuple to a string.\n        tuple_string := fmt.Sprint(tuple)\n\n        // Add the tuple to the map.\n        unique_tuples[tuple_string] = true\n    }\n\n    // Return the length of the map.\n    return len(unique_tuples)\n}\n",
    "    // Create a map to store the unique tuples.\n    unique_tuples := make(map[string]bool)\n\n    // Iterate through the list and add the tuples to the map.\n    for _, tuple := range test_list {\n        // Convert the tuple to a string.\n        tuple_string := fmt.Sprintf(\"%v\", tuple)\n\n        // Add the tuple to the map.\n        unique_tuples[tuple_string] = true\n    }\n\n    // Return the number of unique tuples.\n    return len(unique_tuples)\n}\n",
    "    // Create a map to store the unique tuples.\n    unique_tuples := make(map[string]int)\n\n    // Iterate through the list of tuples.\n    for _, tuple := range test_list {\n        // Convert the tuple to a string.\n        tuple_string := fmt.Sprintf(\"%v\", tuple)\n\n        // Check if the tuple is already in the map.\n        if _, ok := unique_tuples[tuple_string]; ok {\n            // If it is, increment the count.\n            unique_tuples[tuple_string] += 1\n        } else {\n            // If it isn't, add it to the map.\n            unique_tuples[tuple_string] = 1\n        }\n    }\n\n    // Return the length of the map.\n    return len(unique_tuples)\n}\n",
    "    // Create a map to hold the unique tuples.\n    unique_tuples := make(map[string]int)\n\n    // Iterate through the list of tuples.\n    for _, tuple := range test_list {\n        // Create a string to hold the tuple.\n        tuple_string := \"\"\n\n        // Iterate through the tuple.\n        for _, item := range tuple {\n            // Add the item to the tuple string.\n            tuple_string += fmt.Sprintf(\"%v\", item)\n        }\n\n        // Add the tuple to the map.\n        unique_tuples[tuple_string] = 1\n    }\n\n    // Return the number of unique tuples.\n    return len(unique_tuples)\n}\n",
    "    // Create a map to store the unique tuples.\n    unique_tuples := make(map[string]bool)\n    // Loop through the list and add the tuples to the map.\n    for _, tuple := range test_list {\n        unique_tuples[fmt.Sprint(tuple)] = true\n    }\n    // Return the length of the map.\n    return len(unique_tuples)\n}\n",
    "    var unique_tuples = make(map[string]int)\n    for _, tuple := range test_list {\n        unique_tuples[fmt.Sprintf(\"%v\", tuple)] += 1\n    }\n    return len(unique_tuples)\n}\n",
    "    // Create a map to store the unique tuples\n    unique_tuples := make(map[string]int)\n\n    // Iterate through the list and add the tuples to the map\n    for _, tuple := range test_list {\n        // Convert the tuple to a string\n        tuple_string := fmt.Sprintf(\"%v\", tuple)\n\n        // Add the tuple to the map\n        unique_tuples[tuple_string] = 1\n    }\n\n    // Return the length of the map\n    return len(unique_tuples)\n}\n",
    "    // Create a map to store the unique tuples.\n    unique_tuples := make(map[string]bool)\n    // Iterate through the list and add the tuples to the map.\n    for _, tuple := range test_list {\n        // Convert the tuple to a string.\n        tuple_string := fmt.Sprintf(\"%v\", tuple)\n        // Add the tuple to the map.\n        unique_tuples[tuple_string] = true\n    }\n    // Return the number of unique tuples.\n    return len(unique_tuples)\n}\n",
    "    // Create a map to store the unique tuples.\n    unique_tuples := make(map[string]bool)\n\n    // Iterate through the list and store the unique tuples.\n    for _, tuple := range test_list {\n        // Convert the tuple to a string.\n        tuple_str := fmt.Sprintf(\"%v\", tuple)\n\n        // Check if the tuple is already in the map.\n        if _, ok := unique_tuples[tuple_str]; !ok {\n            // Add the tuple to the map.\n            unique_tuples[tuple_str] = true\n        }\n    }\n\n    // Return the number of unique tuples.\n    return len(unique_tuples)\n}\n",
    "    // Create a map to store the unique tuples.\n    unique_tuples := make(map[string]int)\n\n    // Iterate through the list.\n    for _, tuple := range test_list {\n        // Convert the tuple to a string.\n        tuple_string := fmt.Sprintf(\"%v\", tuple)\n\n        // Check if the tuple is already in the map.\n        _, ok := unique_tuples[tuple_string]\n\n        // If the tuple is not in the map, add it.\n        if !ok {\n            unique_tuples[tuple_string] = 1\n        }\n    }\n\n    // Return the length of the map.\n    return len(unique_tuples)\n}\n",
    "    var count int\n    for i := 0; i < len(test_list); i++ {\n        for j := i + 1; j < len(test_list); j++ {\n            if test_list[i][0] == test_list[j][0] && test_list[i][1] == test_list[j][1] {\n                count++\n            }\n        }\n    }\n    return count\n}\n"
  ]
}