{
  "name": "mbpp_132_tup_string",
  "language": "go_test.go",
  "prompt": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_132_tup_string.py",
  "prompt_terminology": "verbatim",
  "tests": "func TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = fmt.Sprintf(\"%v\", tup1)\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'exercises', got '[e x e r c i s e s]'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'python', got '[p y t h o n]'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'program', got '[p r o g r a m]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for i := 0; i < len(tup1); i++ {\n        str += fmt.Sprintf(\"%v\", tup1[i])\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    str := \"\"\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = \"(\"\n    for i := 0; i < len(tup1); i++ {\n        if i == len(tup1) - 1 {\n            str += fmt.Sprintf(\"%v\", tup1[i])\n        } else {\n            str += fmt.Sprintf(\"%v, \", tup1[i])\n        }\n    }\n    str += \")\"\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmp7m4w0754_test.go:38: expected 'exercises', got '(e, x, e, r, c, i, s, e, s)'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmp7m4w0754_test.go:38: expected 'python', got '(p, y, t, h, o, n)'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmp7m4w0754_test.go:38: expected 'program', got '(p, r, o, g, r, a, m)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var tup_str string\n    for _, v := range tup1 {\n        tup_str += fmt.Sprintf(\"%v\", v)\n    }\n    return tup_str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for i, v := range tup1 {\n        if i == 0 {\n            str = fmt.Sprintf(\"%v\", v)\n        } else {\n            str = fmt.Sprintf(\"%s, %v\", str, v)\n        }\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmppk3h9s_7_test.go:36: expected 'exercises', got 'e, x, e, r, c, i, s, e, s'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmppk3h9s_7_test.go:36: expected 'python', got 'p, y, t, h, o, n'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmppk3h9s_7_test.go:36: expected 'program', got 'p, r, o, g, r, a, m'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = fmt.Sprintf(\"%v\", tup1)\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'exercises', got '[e x e r c i s e s]'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'python', got '[p y t h o n]'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'program', got '[p r o g r a m]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = \"(\"\n    for i, v := range tup1 {\n        if i == len(tup1) - 1 {\n            str += fmt.Sprintf(\"%v\", v)\n        } else {\n            str += fmt.Sprintf(\"%v, \", v)\n        }\n    }\n    str += \")\"\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpmyy90ph3_test.go:38: expected 'exercises', got '(e, x, e, r, c, i, s, e, s)'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpmyy90ph3_test.go:38: expected 'python', got '(p, y, t, h, o, n)'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpmyy90ph3_test.go:38: expected 'program', got '(p, r, o, g, r, a, m)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = fmt.Sprintf(\"%v\", tup1)\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'exercises', got '[e x e r c i s e s]'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'python', got '[p y t h o n]'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'program', got '[p r o g r a m]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for i := 0; i < len(tup1); i++ {\n        str += fmt.Sprintf(\"%v\", tup1[i])\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    str := \"(\"\n    for i, v := range tup1 {\n        if i == len(tup1) - 1 {\n            str += fmt.Sprintf(\"%v\", v)\n        } else {\n            str += fmt.Sprintf(\"%v, \", v)\n        }\n    }\n    str += \")\"\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpgxqzxgee_test.go:37: expected 'exercises', got '(e, x, e, r, c, i, s, e, s)'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpgxqzxgee_test.go:37: expected 'python', got '(p, y, t, h, o, n)'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpgxqzxgee_test.go:37: expected 'program', got '(p, r, o, g, r, a, m)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var tup_str string\n    for _, val := range tup1 {\n        tup_str += fmt.Sprintf(\"%v\", val)\n    }\n    return tup_str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for i := 0; i < len(tup1); i++ {\n        str += fmt.Sprintf(\"%v\", tup1[i])\n        if i != len(tup1) - 1 {\n            str += \",\"\n        }\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpe8s5toet_test.go:35: expected 'exercises', got 'e,x,e,r,c,i,s,e,s'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpe8s5toet_test.go:35: expected 'python', got 'p,y,t,h,o,n'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpe8s5toet_test.go:35: expected 'program', got 'p,r,o,g,r,a,m'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var s string\n    for i, v := range tup1 {\n        if i == 0 {\n            s = fmt.Sprintf(\"%v\", v)\n        } else {\n            s = fmt.Sprintf(\"%s, %v\", s, v)\n        }\n    }\n    return s\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpm2qltj62_test.go:36: expected 'exercises', got 'e, x, e, r, c, i, s, e, s'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpm2qltj62_test.go:36: expected 'python', got 'p, y, t, h, o, n'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpm2qltj62_test.go:36: expected 'program', got 'p, r, o, g, r, a, m'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for i, v := range tup1 {\n        if i == 0 {\n            str = fmt.Sprintf(\"%v\", v)\n        } else {\n            str = fmt.Sprintf(\"%s, %v\", str, v)\n        }\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmppk3h9s_7_test.go:36: expected 'exercises', got 'e, x, e, r, c, i, s, e, s'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmppk3h9s_7_test.go:36: expected 'python', got 'p, y, t, h, o, n'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmppk3h9s_7_test.go:36: expected 'program', got 'p, r, o, g, r, a, m'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = \"(\"\n    for i, v := range tup1 {\n        if i == 0 {\n            str += fmt.Sprintf(\"%v\", v)\n        } else {\n            str += fmt.Sprintf(\", %v\", v)\n        }\n    }\n    str += \")\"\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmplesx5ofc_test.go:38: expected 'exercises', got '(e, x, e, r, c, i, s, e, s)'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmplesx5ofc_test.go:38: expected 'python', got '(p, y, t, h, o, n)'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmplesx5ofc_test.go:38: expected 'program', got '(p, r, o, g, r, a, m)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = \"(\"\n    for i, v := range tup1 {\n        if i == len(tup1) - 1 {\n            str += fmt.Sprintf(\"%v\", v)\n        } else {\n            str += fmt.Sprintf(\"%v, \", v)\n        }\n    }\n    str += \")\"\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpmyy90ph3_test.go:38: expected 'exercises', got '(e, x, e, r, c, i, s, e, s)'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpmyy90ph3_test.go:38: expected 'python', got '(p, y, t, h, o, n)'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpmyy90ph3_test.go:38: expected 'program', got '(p, r, o, g, r, a, m)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, val := range tup1 {\n        str += fmt.Sprintf(\"%v\", val)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var result string\n    for _, v := range tup1 {\n        result += fmt.Sprintf(\"%v\", v)\n    }\n    return result\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = fmt.Sprintf(\"%v\", tup1)\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'exercises', got '[e x e r c i s e s]'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'python', got '[p y t h o n]'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'program', got '[p r o g r a m]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var tup_str string\n    for _, v := range tup1 {\n        tup_str += fmt.Sprintf(\"%v\", v)\n    }\n    return tup_str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    return fmt.Sprint(tup1)\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpmi15k1t9_test.go:28: expected 'exercises', got '[e x e r c i s e s]'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpmi15k1t9_test.go:28: expected 'python', got '[p y t h o n]'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpmi15k1t9_test.go:28: expected 'program', got '[p r o g r a m]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = fmt.Sprintf(\"%v\", tup1)\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'exercises', got '[e x e r c i s e s]'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'python', got '[p y t h o n]'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'program', got '[p r o g r a m]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = fmt.Sprintf(\"%v\", tup1)\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'exercises', got '[e x e r c i s e s]'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'python', got '[p y t h o n]'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'program', got '[p r o g r a m]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = \"(\"\n    for i, v := range tup1 {\n        if i == len(tup1) - 1 {\n            str += fmt.Sprintf(\"%v\", v)\n        } else {\n            str += fmt.Sprintf(\"%v, \", v)\n        }\n    }\n    str += \")\"\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpmyy90ph3_test.go:38: expected 'exercises', got '(e, x, e, r, c, i, s, e, s)'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpmyy90ph3_test.go:38: expected 'python', got '(p, y, t, h, o, n)'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpmyy90ph3_test.go:38: expected 'program', got '(p, r, o, g, r, a, m)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = \"(\"\n    for i, v := range tup1 {\n        if i == len(tup1) - 1 {\n            str += fmt.Sprintf(\"%v\", v)\n        } else {\n            str += fmt.Sprintf(\"%v, \", v)\n        }\n    }\n    str += \")\"\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpmyy90ph3_test.go:38: expected 'exercises', got '(e, x, e, r, c, i, s, e, s)'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpmyy90ph3_test.go:38: expected 'python', got '(p, y, t, h, o, n)'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpmyy90ph3_test.go:38: expected 'program', got '(p, r, o, g, r, a, m)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        switch v.(type) {\n        case string:\n            str += fmt.Sprintf(\"%q\", v)\n        case int:\n            str += fmt.Sprintf(\"%d\", v)\n        case float64:\n            str += fmt.Sprintf(\"%f\", v)\n        default:\n            str += fmt.Sprintf(\"%v\", v)\n        }\n        str += \", \"\n    }\n    return str[:len(str)-2]\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmp7mkimdsd_test.go:42: expected 'exercises', got '\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmp7mkimdsd_test.go:42: expected 'python', got '\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmp7mkimdsd_test.go:42: expected 'program', got '\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var tup_str string\n    for _, val := range tup1 {\n        tup_str += fmt.Sprintf(\"%v\", val)\n    }\n    return tup_str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for i := 0; i < len(tup1); i++ {\n        str += fmt.Sprintf(\"%v\", tup1[i])\n        if i != len(tup1) - 1 {\n            str += \" \"\n        }\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpvojbt73v_test.go:35: expected 'exercises', got 'e x e r c i s e s'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpvojbt73v_test.go:35: expected 'python', got 'p y t h o n'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpvojbt73v_test.go:35: expected 'program', got 'p r o g r a m'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v \", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpjrwiwo73_test.go:32: expected 'exercises', got 'e x e r c i s e s '\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpjrwiwo73_test.go:32: expected 'python', got 'p y t h o n '\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpjrwiwo73_test.go:32: expected 'program', got 'p r o g r a m '\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for i := 0; i < len(tup1); i++ {\n        str += fmt.Sprintf(\"%v\", tup1[i])\n        if i != len(tup1) - 1 {\n            str += \", \"\n        }\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpctyfxsgg_test.go:35: expected 'exercises', got 'e, x, e, r, c, i, s, e, s'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpctyfxsgg_test.go:35: expected 'python', got 'p, y, t, h, o, n'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpctyfxsgg_test.go:35: expected 'program', got 'p, r, o, g, r, a, m'\nFAIL\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = fmt.Sprintf(\"%v\", tup1)\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'exercises', got '[e x e r c i s e s]'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'python', got '[p y t h o n]'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'program', got '[p r o g r a m]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v \", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpjrwiwo73_test.go:32: expected 'exercises', got 'e x e r c i s e s '\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpjrwiwo73_test.go:32: expected 'python', got 'p y t h o n '\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpjrwiwo73_test.go:32: expected 'program', got 'p r o g r a m '\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    str := \"\"\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    str := \"(\"\n    for i, v := range tup1 {\n        if i == len(tup1) - 1 {\n            str += fmt.Sprintf(\"%v\", v)\n        } else {\n            str += fmt.Sprintf(\"%v, \", v)\n        }\n    }\n    str += \")\"\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpgxqzxgee_test.go:37: expected 'exercises', got '(e, x, e, r, c, i, s, e, s)'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpgxqzxgee_test.go:37: expected 'python', got '(p, y, t, h, o, n)'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpgxqzxgee_test.go:37: expected 'program', got '(p, r, o, g, r, a, m)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for i, v := range tup1 {\n        if i == 0 {\n            str = fmt.Sprintf(\"%v\", v)\n        } else {\n            str = fmt.Sprintf(\"%s, %v\", str, v)\n        }\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmppk3h9s_7_test.go:36: expected 'exercises', got 'e, x, e, r, c, i, s, e, s'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmppk3h9s_7_test.go:36: expected 'python', got 'p, y, t, h, o, n'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmppk3h9s_7_test.go:36: expected 'program', got 'p, r, o, g, r, a, m'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for i, v := range tup1 {\n        if i == 0 {\n            str = fmt.Sprintf(\"%v\", v)\n        } else {\n            str = fmt.Sprintf(\"%v, %v\", str, v)\n        }\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpulqboxdm_test.go:36: expected 'exercises', got 'e, x, e, r, c, i, s, e, s'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpulqboxdm_test.go:36: expected 'python', got 'p, y, t, h, o, n'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpulqboxdm_test.go:36: expected 'program', got 'p, r, o, g, r, a, m'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for i := 0; i < len(tup1); i++ {\n        str += fmt.Sprintf(\"%v\", tup1[i])\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    str := \"\"\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var tup_str string\n    for _, v := range tup1 {\n        tup_str += fmt.Sprintf(\"%v\", v)\n    }\n    return tup_str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = fmt.Sprintf(\"%v\", tup1)\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'exercises', got '[e x e r c i s e s]'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'python', got '[p y t h o n]'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'program', got '[p r o g r a m]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = fmt.Sprintf(\"%v\", tup1)\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'exercises', got '[e x e r c i s e s]'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'python', got '[p y t h o n]'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'program', got '[p r o g r a m]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = fmt.Sprintf(\"%v\", tup1)\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'exercises', got '[e x e r c i s e s]'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'python', got '[p y t h o n]'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'program', got '[p r o g r a m]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var tup_str string\n    for _, v := range tup1 {\n        tup_str += fmt.Sprintf(\"%v\", v)\n    }\n    return tup_str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for i := 0; i < len(tup1); i++ {\n        str += fmt.Sprintf(\"%v\", tup1[i])\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        switch v.(type) {\n        case int:\n            str += fmt.Sprintf(\"%d\", v)\n        case string:\n            str += fmt.Sprintf(\"%s\", v)\n        }\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for i, v := range tup1 {\n        if i == 0 {\n            str = fmt.Sprintf(\"%v\", v)\n        } else {\n            str = fmt.Sprintf(\"%s, %v\", str, v)\n        }\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmppk3h9s_7_test.go:36: expected 'exercises', got 'e, x, e, r, c, i, s, e, s'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmppk3h9s_7_test.go:36: expected 'python', got 'p, y, t, h, o, n'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmppk3h9s_7_test.go:36: expected 'program', got 'p, r, o, g, r, a, m'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = \"(\"\n    for i, v := range tup1 {\n        if i == len(tup1) - 1 {\n            str += fmt.Sprintf(\"%v\", v)\n        } else {\n            str += fmt.Sprintf(\"%v, \", v)\n        }\n    }\n    str += \")\"\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpmyy90ph3_test.go:38: expected 'exercises', got '(e, x, e, r, c, i, s, e, s)'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpmyy90ph3_test.go:38: expected 'python', got '(p, y, t, h, o, n)'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpmyy90ph3_test.go:38: expected 'program', got '(p, r, o, g, r, a, m)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = fmt.Sprintf(\"%v\", tup1)\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'exercises', got '[e x e r c i s e s]'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'python', got '[p y t h o n]'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'program', got '[p r o g r a m]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    return fmt.Sprintf(\"%v\", tup1)\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpubwcg8j6_test.go:28: expected 'exercises', got '[e x e r c i s e s]'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpubwcg8j6_test.go:28: expected 'python', got '[p y t h o n]'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpubwcg8j6_test.go:28: expected 'program', got '[p r o g r a m]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for i := 0; i < len(tup1); i++ {\n        str += fmt.Sprintf(\"%v\", tup1[i])\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for i := 0; i < len(tup1); i++ {\n        str += fmt.Sprintf(\"%v\", tup1[i])\n        if i < len(tup1) - 1 {\n            str += \" \"\n        }\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpb9il6288_test.go:35: expected 'exercises', got 'e x e r c i s e s'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpb9il6288_test.go:35: expected 'python', got 'p y t h o n'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpb9il6288_test.go:35: expected 'program', got 'p r o g r a m'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = fmt.Sprintf(\"%v\", tup1)\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'exercises', got '[e x e r c i s e s]'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'python', got '[p y t h o n]'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'program', got '[p r o g r a m]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = \"(\"\n    for i := 0; i < len(tup1); i++ {\n        str += fmt.Sprintf(\"%v\", tup1[i])\n        if i != len(tup1) - 1 {\n            str += \", \"\n        }\n    }\n    str += \")\"\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpw0kv6p9__test.go:37: expected 'exercises', got '(e, x, e, r, c, i, s, e, s)'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpw0kv6p9__test.go:37: expected 'python', got '(p, y, t, h, o, n)'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpw0kv6p9__test.go:37: expected 'program', got '(p, r, o, g, r, a, m)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    str := \"\"\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = \"(\"\n    for i, v := range tup1 {\n        if i == 0 {\n            str += fmt.Sprintf(\"%v\", v)\n        } else {\n            str += fmt.Sprintf(\", %v\", v)\n        }\n    }\n    str += \")\"\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmplesx5ofc_test.go:38: expected 'exercises', got '(e, x, e, r, c, i, s, e, s)'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmplesx5ofc_test.go:38: expected 'python', got '(p, y, t, h, o, n)'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmplesx5ofc_test.go:38: expected 'program', got '(p, r, o, g, r, a, m)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    str := \"\"\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = \"(\"\n    for i, v := range tup1 {\n        if i == 0 {\n            str = str + fmt.Sprintf(\"%v\", v)\n        } else {\n            str = str + fmt.Sprintf(\", %v\", v)\n        }\n    }\n    str = str + \")\"\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmp28quzwar_test.go:38: expected 'exercises', got '(e, x, e, r, c, i, s, e, s)'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmp28quzwar_test.go:38: expected 'python', got '(p, y, t, h, o, n)'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmp28quzwar_test.go:38: expected 'program', got '(p, r, o, g, r, a, m)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for i := 0; i < len(tup1); i++ {\n        str += fmt.Sprintf(\"%v\", tup1[i])\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = \"(\"\n    for i, v := range tup1 {\n        if i == len(tup1) - 1 {\n            str += fmt.Sprintf(\"%v\", v)\n        } else {\n            str += fmt.Sprintf(\"%v, \", v)\n        }\n    }\n    str += \")\"\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpmyy90ph3_test.go:38: expected 'exercises', got '(e, x, e, r, c, i, s, e, s)'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpmyy90ph3_test.go:38: expected 'python', got '(p, y, t, h, o, n)'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpmyy90ph3_test.go:38: expected 'program', got '(p, r, o, g, r, a, m)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = \"(\"\n    for i := 0; i < len(tup1); i++ {\n        if i == len(tup1) - 1 {\n            str += fmt.Sprintf(\"%v\", tup1[i])\n        } else {\n            str += fmt.Sprintf(\"%v, \", tup1[i])\n        }\n    }\n    str += \")\"\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmp7m4w0754_test.go:38: expected 'exercises', got '(e, x, e, r, c, i, s, e, s)'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmp7m4w0754_test.go:38: expected 'python', got '(p, y, t, h, o, n)'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmp7m4w0754_test.go:38: expected 'program', got '(p, r, o, g, r, a, m)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        switch v.(type) {\n        case int:\n            str += fmt.Sprintf(\"%d\", v)\n        case string:\n            str += fmt.Sprintf(\"%s\", v)\n        case float64:\n            str += fmt.Sprintf(\"%f\", v)\n        }\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    str := \"\"\n    for _, val := range tup1 {\n        switch val.(type) {\n        case int:\n            str += fmt.Sprintf(\"%d\", val)\n        case string:\n            str += fmt.Sprintf(\"%s\", val)\n        case float64:\n            str += fmt.Sprintf(\"%f\", val)\n        }\n        str += \" \"\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpx7lmxwpp_test.go:40: expected 'exercises', got 'e x e r c i s e s '\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpx7lmxwpp_test.go:40: expected 'python', got 'p y t h o n '\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpx7lmxwpp_test.go:40: expected 'program', got 'p r o g r a m '\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = \"(\"\n    for i, v := range tup1 {\n        if i == len(tup1) - 1 {\n            str += fmt.Sprintf(\"%v\", v)\n        } else {\n            str += fmt.Sprintf(\"%v, \", v)\n        }\n    }\n    str += \")\"\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpmyy90ph3_test.go:38: expected 'exercises', got '(e, x, e, r, c, i, s, e, s)'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpmyy90ph3_test.go:38: expected 'python', got '(p, y, t, h, o, n)'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpmyy90ph3_test.go:38: expected 'program', got '(p, r, o, g, r, a, m)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    str := \"\"\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v \", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpjrwiwo73_test.go:32: expected 'exercises', got 'e x e r c i s e s '\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpjrwiwo73_test.go:32: expected 'python', got 'p y t h o n '\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpjrwiwo73_test.go:32: expected 'program', got 'p r o g r a m '\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    str := \"\"\n    for _, v := range tup1 {\n        switch v.(type) {\n        case string:\n            str += fmt.Sprintf(\"%q\", v)\n        default:\n            str += fmt.Sprintf(\"%v\", v)\n        }\n        str += \", \"\n    }\n    return str[:len(str)-2]\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmplfcsplv4_test.go:38: expected 'exercises', got '\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmplfcsplv4_test.go:38: expected 'python', got '\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmplfcsplv4_test.go:38: expected 'program', got '\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = \"(\"\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n        str += \",\"\n    }\n    str = str[:len(str)-1]\n    str += \")\"\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpeldfsjqz_test.go:36: expected 'exercises', got '(e,x,e,r,c,i,s,e,s)'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpeldfsjqz_test.go:36: expected 'python', got '(p,y,t,h,o,n)'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpeldfsjqz_test.go:36: expected 'program', got '(p,r,o,g,r,a,m)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, val := range tup1 {\n        switch val.(type) {\n        case string:\n            str += fmt.Sprintf(\"%s\", val)\n        case int:\n            str += fmt.Sprintf(\"%d\", val)\n        case float64:\n            str += fmt.Sprintf(\"%f\", val)\n        }\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, t := range tup1 {\n        switch t.(type) {\n        case int:\n            str += fmt.Sprintf(\"%d\", t)\n        case string:\n            str += fmt.Sprintf(\"%s\", t)\n        case float64:\n            str += fmt.Sprintf(\"%f\", t)\n        }\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str1 string\n    for _, v := range tup1 {\n        str1 += fmt.Sprintf(\"%v\", v)\n    }\n    return str1\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var tup_str string\n    for _, v := range tup1 {\n        tup_str += fmt.Sprintf(\"%v\", v)\n    }\n    return tup_str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        switch v.(type) {\n        case int:\n            str += fmt.Sprintf(\"%d\", v)\n        case string:\n            str += fmt.Sprintf(\"%s\", v)\n        }\n        str += \" \"\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpkcg0espk_test.go:38: expected 'exercises', got 'e x e r c i s e s '\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpkcg0espk_test.go:38: expected 'python', got 'p y t h o n '\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpkcg0espk_test.go:38: expected 'program', got 'p r o g r a m '\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v \", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpjrwiwo73_test.go:32: expected 'exercises', got 'e x e r c i s e s '\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpjrwiwo73_test.go:32: expected 'python', got 'p y t h o n '\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpjrwiwo73_test.go:32: expected 'program', got 'p r o g r a m '\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for i := 0; i < len(tup1); i++ {\n        str += fmt.Sprintf(\"%v\", tup1[i])\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for i := 0; i < len(tup1); i++ {\n        str += fmt.Sprintf(\"%v\", tup1[i])\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var result string\n    for _, v := range tup1 {\n        result += fmt.Sprintf(\"%v\", v)\n    }\n    return result\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    str := \"\"\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = fmt.Sprintf(\"%v\", tup1)\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'exercises', got '[e x e r c i s e s]'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'python', got '[p y t h o n]'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'program', got '[p r o g r a m]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for i := 0; i < len(tup1); i++ {\n        str += fmt.Sprintf(\"%v\", tup1[i])\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for i := 0; i < len(tup1); i++ {\n        str += fmt.Sprintf(\"%v\", tup1[i])\n        if i < len(tup1)-1 {\n            str += \" \"\n        }\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmplgf7z1oa_test.go:35: expected 'exercises', got 'e x e r c i s e s'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmplgf7z1oa_test.go:35: expected 'python', got 'p y t h o n'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmplgf7z1oa_test.go:35: expected 'program', got 'p r o g r a m'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = \"(\"\n    for _, v := range tup1 {\n        switch v.(type) {\n        case int:\n            str += fmt.Sprintf(\"%d\", v)\n        case string:\n            str += fmt.Sprintf(\"%s\", v)\n        case float64:\n            str += fmt.Sprintf(\"%f\", v)\n        }\n        str += \", \"\n    }\n    str = str[:len(str)-2]\n    str += \")\"\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpsbdujfhm_test.go:43: expected 'exercises', got '(e, x, e, r, c, i, s, e, s)'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpsbdujfhm_test.go:43: expected 'python', got '(p, y, t, h, o, n)'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpsbdujfhm_test.go:43: expected 'program', got '(p, r, o, g, r, a, m)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = fmt.Sprintf(\"%v\", tup1)\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'exercises', got '[e x e r c i s e s]'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'python', got '[p y t h o n]'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'program', got '[p r o g r a m]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, val := range tup1 {\n        str += fmt.Sprintf(\"%v \", val)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpb0d4za_d_test.go:32: expected 'exercises', got 'e x e r c i s e s '\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpb0d4za_d_test.go:32: expected 'python', got 'p y t h o n '\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpb0d4za_d_test.go:32: expected 'program', got 'p r o g r a m '\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var tup_str string\n    for _, v := range tup1 {\n        tup_str += fmt.Sprintf(\"%v\", v)\n    }\n    return tup_str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = \"(\"\n    for i := 0; i < len(tup1); i++ {\n        if i == len(tup1) - 1 {\n            str += fmt.Sprintf(\"%v\", tup1[i])\n        } else {\n            str += fmt.Sprintf(\"%v, \", tup1[i])\n        }\n    }\n    str += \")\"\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmp7m4w0754_test.go:38: expected 'exercises', got '(e, x, e, r, c, i, s, e, s)'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmp7m4w0754_test.go:38: expected 'python', got '(p, y, t, h, o, n)'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmp7m4w0754_test.go:38: expected 'program', got '(p, r, o, g, r, a, m)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    str = fmt.Sprintf(\"%v\", tup1)\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'exercises', got '[e x e r c i s e s]'\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'python', got '[p y t h o n]'\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmpnmjp_xuf_test.go:30: expected 'program', got '[p r o g r a m]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, val := range tup1 {\n        str += fmt.Sprintf(\"%v\", val)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var tup_str string\n    for _, v := range tup1 {\n        tup_str += fmt.Sprintf(\"%v\", v)\n    }\n    return tup_str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var tup_string string\n    for _, v := range tup1 {\n        tup_string += fmt.Sprintf(\"%v\", v)\n    }\n    return tup_string\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    str := \"\"\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        switch v.(type) {\n        case string:\n            str += fmt.Sprintf(\"'%s'\", v)\n        default:\n            str += fmt.Sprintf(\"%v\", v)\n        }\n        str += \", \"\n    }\n    return str[:len(str)-2]\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1666122831,
      "stdout": "--- FAIL: TestTup_String (0.00s)\n    --- FAIL: TestTup_String/test_num__0 (0.00s)\n        tmplz1riy84_test.go:38: expected 'exercises', got ''e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's''\n    --- FAIL: TestTup_String/test_num__1 (0.00s)\n        tmplz1riy84_test.go:38: expected 'python', got ''p', 'y', 't', 'h', 'o', 'n''\n    --- FAIL: TestTup_String/test_num__2 (0.00s)\n        tmplz1riy84_test.go:38: expected 'program', got ''p', 'r', 'o', 'g', 'r', 'a', 'm''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package tup_string_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function to convert a tuple to a string.\nfunc tup_string(tup1 []interface{}) string {\n    var str string\n    for _, v := range tup1 {\n        str += fmt.Sprintf(\"%v\", v)\n    }\n    return str\n}\n\nfunc TestTup_String(t *testing.T) {\n  candidate := tup_string\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"}), expected: \"exercises\" },\n     { actual: candidate([]interface{}{\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"}), expected: \"python\" },\n     { actual: candidate([]interface{}{\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"}), expected: \"program\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1665510116,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    }
  ]
}